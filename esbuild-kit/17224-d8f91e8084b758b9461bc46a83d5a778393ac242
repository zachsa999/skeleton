{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});let{SourceMapConsumer,SourceMapGenerator}=require(\"source-map-js\");let{existsSync,readFileSync}=require(\"fs\");let{dirname,join}=require(\"path\");function fromBase64(str){if(Buffer){return Buffer.from(str,\"base64\").toString()}else{return window.atob(str)}}__name(fromBase64,\"fromBase64\");class PreviousMap{constructor(css,opts){if(opts.map===false)return;this.loadAnnotation(css);this.inline=this.startWith(this.annotation,\"data:\");let prev=opts.map?opts.map.prev:void 0;let text=this.loadMap(opts.from,prev);if(!this.mapFile&&opts.from){this.mapFile=opts.from}if(this.mapFile)this.root=dirname(this.mapFile);if(text)this.text=text}consumer(){if(!this.consumerCache){this.consumerCache=new SourceMapConsumer(this.text)}return this.consumerCache}withContent(){return!!(this.consumer().sourcesContent&&this.consumer().sourcesContent.length>0)}startWith(string,start){if(!string)return false;return string.substr(0,start.length)===start}getAnnotationURL(sourceMapString){return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/,\"\").trim()}loadAnnotation(css){let comments=css.match(/\\/\\*\\s*# sourceMappingURL=/gm);if(!comments)return;let start=css.lastIndexOf(comments.pop());let end=css.indexOf(\"*/\",start);if(start>-1&&end>-1){this.annotation=this.getAnnotationURL(css.substring(start,end))}}decodeInline(text){let baseCharsetUri=/^data:application\\/json;charset=utf-?8;base64,/;let baseUri=/^data:application\\/json;base64,/;let charsetUri=/^data:application\\/json;charset=utf-?8,/;let uri=/^data:application\\/json,/;if(charsetUri.test(text)||uri.test(text)){return decodeURIComponent(text.substr(RegExp.lastMatch.length))}if(baseCharsetUri.test(text)||baseUri.test(text)){return fromBase64(text.substr(RegExp.lastMatch.length))}let encoding=text.match(/data:application\\/json;([^,]+),/)[1];throw new Error(\"Unsupported source map encoding \"+encoding)}loadFile(path){this.root=dirname(path);if(existsSync(path)){this.mapFile=path;return readFileSync(path,\"utf-8\").toString().trim()}}loadMap(file,prev){if(prev===false)return false;if(prev){if(typeof prev===\"string\"){return prev}else if(typeof prev===\"function\"){let prevPath=prev(file);if(prevPath){let map=this.loadFile(prevPath);if(!map){throw new Error(\"Unable to load previous source map: \"+prevPath.toString())}return map}}else if(prev instanceof SourceMapConsumer){return SourceMapGenerator.fromSourceMap(prev).toString()}else if(prev instanceof SourceMapGenerator){return prev.toString()}else if(this.isMap(prev)){return JSON.stringify(prev)}else{throw new Error(\"Unsupported previous source map format: \"+prev.toString())}}else if(this.inline){return this.decodeInline(this.annotation)}else if(this.annotation){let map=this.annotation;if(file)map=join(dirname(file),map);return this.loadFile(map)}}isMap(map){if(typeof map!==\"object\")return false;return typeof map.mappings===\"string\"||typeof map._mappings===\"string\"||Array.isArray(map.sections)}}__name(PreviousMap,\"PreviousMap\");module.exports=PreviousMap;PreviousMap.default=PreviousMap;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/postcss@8.4.24/node_modules/postcss/lib/previous-map.js"],"sourcesContent":["'use strict'\n\nlet { SourceMapConsumer, SourceMapGenerator } = require('source-map-js')\nlet { existsSync, readFileSync } = require('fs')\nlet { dirname, join } = require('path')\n\nfunction fromBase64(str) {\n  if (Buffer) {\n    return Buffer.from(str, 'base64').toString()\n  } else {\n    /* c8 ignore next 2 */\n    return window.atob(str)\n  }\n}\n\nclass PreviousMap {\n  constructor(css, opts) {\n    if (opts.map === false) return\n    this.loadAnnotation(css)\n    this.inline = this.startWith(this.annotation, 'data:')\n\n    let prev = opts.map ? opts.map.prev : undefined\n    let text = this.loadMap(opts.from, prev)\n    if (!this.mapFile && opts.from) {\n      this.mapFile = opts.from\n    }\n    if (this.mapFile) this.root = dirname(this.mapFile)\n    if (text) this.text = text\n  }\n\n  consumer() {\n    if (!this.consumerCache) {\n      this.consumerCache = new SourceMapConsumer(this.text)\n    }\n    return this.consumerCache\n  }\n\n  withContent() {\n    return !!(\n      this.consumer().sourcesContent &&\n      this.consumer().sourcesContent.length > 0\n    )\n  }\n\n  startWith(string, start) {\n    if (!string) return false\n    return string.substr(0, start.length) === start\n  }\n\n  getAnnotationURL(sourceMapString) {\n    return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, '').trim()\n  }\n\n  loadAnnotation(css) {\n    let comments = css.match(/\\/\\*\\s*# sourceMappingURL=/gm)\n    if (!comments) return\n\n    // sourceMappingURLs from comments, strings, etc.\n    let start = css.lastIndexOf(comments.pop())\n    let end = css.indexOf('*/', start)\n\n    if (start > -1 && end > -1) {\n      // Locate the last sourceMappingURL to avoid pickin\n      this.annotation = this.getAnnotationURL(css.substring(start, end))\n    }\n  }\n\n  decodeInline(text) {\n    let baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/\n    let baseUri = /^data:application\\/json;base64,/\n    let charsetUri = /^data:application\\/json;charset=utf-?8,/\n    let uri = /^data:application\\/json,/\n\n    if (charsetUri.test(text) || uri.test(text)) {\n      return decodeURIComponent(text.substr(RegExp.lastMatch.length))\n    }\n\n    if (baseCharsetUri.test(text) || baseUri.test(text)) {\n      return fromBase64(text.substr(RegExp.lastMatch.length))\n    }\n\n    let encoding = text.match(/data:application\\/json;([^,]+),/)[1]\n    throw new Error('Unsupported source map encoding ' + encoding)\n  }\n\n  loadFile(path) {\n    this.root = dirname(path)\n    if (existsSync(path)) {\n      this.mapFile = path\n      return readFileSync(path, 'utf-8').toString().trim()\n    }\n  }\n\n  loadMap(file, prev) {\n    if (prev === false) return false\n\n    if (prev) {\n      if (typeof prev === 'string') {\n        return prev\n      } else if (typeof prev === 'function') {\n        let prevPath = prev(file)\n        if (prevPath) {\n          let map = this.loadFile(prevPath)\n          if (!map) {\n            throw new Error(\n              'Unable to load previous source map: ' + prevPath.toString()\n            )\n          }\n          return map\n        }\n      } else if (prev instanceof SourceMapConsumer) {\n        return SourceMapGenerator.fromSourceMap(prev).toString()\n      } else if (prev instanceof SourceMapGenerator) {\n        return prev.toString()\n      } else if (this.isMap(prev)) {\n        return JSON.stringify(prev)\n      } else {\n        throw new Error(\n          'Unsupported previous source map format: ' + prev.toString()\n        )\n      }\n    } else if (this.inline) {\n      return this.decodeInline(this.annotation)\n    } else if (this.annotation) {\n      let map = this.annotation\n      if (file) map = join(dirname(file), map)\n      return this.loadFile(map)\n    }\n  }\n\n  isMap(map) {\n    if (typeof map !== 'object') return false\n    return (\n      typeof map.mappings === 'string' ||\n      typeof map._mappings === 'string' ||\n      Array.isArray(map.sections)\n    )\n  }\n}\n\nmodule.exports = PreviousMap\nPreviousMap.default = PreviousMap\n"]}}