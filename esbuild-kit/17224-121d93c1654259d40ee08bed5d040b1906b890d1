{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interopRequireDefault,\"_interopRequireDefault\");var _linesandcolumns=require(\"lines-and-columns\");var _linesandcolumns2=_interopRequireDefault(_linesandcolumns);var _types=require(\"../parser/tokenizer/types\");function formatTokens(code,tokens){if(tokens.length===0){return\"\"}const tokenKeys=Object.keys(tokens[0]).filter(k=>k!==\"type\"&&k!==\"value\"&&k!==\"start\"&&k!==\"end\"&&k!==\"loc\");const typeKeys=Object.keys(tokens[0].type).filter(k=>k!==\"label\"&&k!==\"keyword\");const headings=[\"Location\",\"Label\",\"Raw\",...tokenKeys,...typeKeys];const lines=new(0,_linesandcolumns2.default)(code);const rows=[headings,...tokens.map(getTokenComponents)];const padding=headings.map(()=>0);for(const components of rows){for(let i=0;i<components.length;i++){padding[i]=Math.max(padding[i],components[i].length)}}return rows.map(components=>components.map((component,i)=>component.padEnd(padding[i])).join(\" \")).join(\"\\n\");function getTokenComponents(token){const raw=code.slice(token.start,token.end);return[formatRange(token.start,token.end),_types.formatTokenType.call(void 0,token.type),truncate(String(raw),14),...tokenKeys.map(key=>formatValue(token[key],key)),...typeKeys.map(key=>formatValue(token.type[key],key))]}__name(getTokenComponents,\"getTokenComponents\");function formatValue(value,key){if(value===true){return key}else if(value===false||value===null){return\"\"}else{return String(value)}}__name(formatValue,\"formatValue\");function formatRange(start,end){return`${formatPos(start)}-${formatPos(end)}`}__name(formatRange,\"formatRange\");function formatPos(pos){const location=lines.locationForIndex(pos);if(!location){return\"Unknown\"}else{return`${location.line+1}:${location.column+1}`}}__name(formatPos,\"formatPos\")}__name(formatTokens,\"formatTokens\");exports.default=formatTokens;function truncate(s,length){if(s.length>length){return`${s.slice(0,length-3)}...`}else{return s}}__name(truncate,\"truncate\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAG,SAAS,uBAAuB,IAAK,CAAE,OAAO,KAAO,IAAI,WAAa,IAAM,CAAE,QAAS,GAAI,CAAG,CAArF,wDAAsF,IAAI,iBAAmB,QAAQ,mBAAmB,EAAG,IAAI,kBAAoB,uBAAuB,gBAAgB,EAG7R,IAAI,OAAS,QAAQ,2BAA2B,EAE/C,SAAS,aAAa,KAAM,OAAQ,CACnC,GAAI,OAAO,SAAW,EAAG,CACvB,MAAO,EACT,CAEA,MAAM,UAAY,OAAO,KAAK,OAAO,CAAC,CAAC,EAAE,OACtC,GAAM,IAAM,QAAU,IAAM,SAAW,IAAM,SAAW,IAAM,OAAS,IAAM,KAChF,EACA,MAAM,SAAW,OAAO,KAAK,OAAO,CAAC,EAAE,IAAI,EAAE,OAAQ,GAAM,IAAM,SAAW,IAAM,SAAS,EAE3F,MAAM,SAAW,CAAC,WAAY,QAAS,MAAO,GAAG,UAAW,GAAG,QAAQ,EAEvE,MAAM,MAAQ,IAAK,EAAG,kBAAkB,SAAS,IAAI,EACrD,MAAM,KAAO,CAAC,SAAU,GAAG,OAAO,IAAI,kBAAkB,CAAC,EACzD,MAAM,QAAU,SAAS,IAAI,IAAM,CAAC,EACpC,UAAW,cAAc,KAAM,CAC7B,QAAS,EAAI,EAAG,EAAI,WAAW,OAAQ,IAAK,CAC1C,QAAQ,CAAC,EAAI,KAAK,IAAI,QAAQ,CAAC,EAAG,WAAW,CAAC,EAAE,MAAM,CACxD,CACF,CACA,OAAO,KACJ,IAAK,YAAe,WAAW,IAAI,CAAC,UAAW,IAAM,UAAU,OAAO,QAAQ,CAAC,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,EAC5F,KAAK,IAAI,EAEZ,SAAS,mBAAmB,MAAO,CACjC,MAAM,IAAM,KAAK,MAAM,MAAM,MAAO,MAAM,GAAG,EAC7C,MAAO,CACL,YAAY,MAAM,MAAO,MAAM,GAAG,EAClC,OAAO,gBAAgB,KAAK,OAAQ,MAAM,IAAI,EAC9C,SAAS,OAAO,GAAG,EAAG,EAAE,EAExB,GAAG,UAAU,IAAK,KAAQ,YAAY,MAAM,GAAG,EAAG,GAAG,CAAC,EAEtD,GAAG,SAAS,IAAK,KAAQ,YAAY,MAAM,KAAK,GAAG,EAAG,GAAG,CAAC,CAC5D,CACF,CAXS,gDAcT,SAAS,YAAY,MAAO,IAAK,CAC/B,GAAI,QAAU,KAAM,CAClB,OAAO,GACT,SAAW,QAAU,OAAS,QAAU,KAAM,CAC5C,MAAO,EACT,KAAO,CACL,OAAO,OAAO,KAAK,CACrB,CACF,CARS,kCAUT,SAAS,YAAY,MAAO,IAAK,CAC/B,MAAO,GAAG,UAAU,KAAK,KAAK,UAAU,GAAG,GAC7C,CAFS,kCAIT,SAAS,UAAU,IAAK,CACtB,MAAM,SAAW,MAAM,iBAAiB,GAAG,EAC3C,GAAI,CAAC,SAAU,CACb,MAAO,SACT,KAAO,CACL,MAAO,GAAG,SAAS,KAAO,KAAK,SAAS,OAAS,GACnD,CACF,CAPS,6BAQX,CA5DU,oCA4DR,QAAQ,QAAU,aAEpB,SAAS,SAAS,EAAG,OAAQ,CAC3B,GAAI,EAAE,OAAS,OAAQ,CACrB,MAAO,GAAG,EAAE,MAAM,EAAG,OAAS,CAAC,MACjC,KAAO,CACL,OAAO,CACT,CACF,CANS","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/util/formatTokens.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var _linesandcolumns = require('lines-and-columns'); var _linesandcolumns2 = _interopRequireDefault(_linesandcolumns);\n\n\nvar _types = require('../parser/tokenizer/types');\n\n function formatTokens(code, tokens) {\n  if (tokens.length === 0) {\n    return \"\";\n  }\n\n  const tokenKeys = Object.keys(tokens[0]).filter(\n    (k) => k !== \"type\" && k !== \"value\" && k !== \"start\" && k !== \"end\" && k !== \"loc\",\n  );\n  const typeKeys = Object.keys(tokens[0].type).filter((k) => k !== \"label\" && k !== \"keyword\");\n\n  const headings = [\"Location\", \"Label\", \"Raw\", ...tokenKeys, ...typeKeys];\n\n  const lines = new (0, _linesandcolumns2.default)(code);\n  const rows = [headings, ...tokens.map(getTokenComponents)];\n  const padding = headings.map(() => 0);\n  for (const components of rows) {\n    for (let i = 0; i < components.length; i++) {\n      padding[i] = Math.max(padding[i], components[i].length);\n    }\n  }\n  return rows\n    .map((components) => components.map((component, i) => component.padEnd(padding[i])).join(\" \"))\n    .join(\"\\n\");\n\n  function getTokenComponents(token) {\n    const raw = code.slice(token.start, token.end);\n    return [\n      formatRange(token.start, token.end),\n      _types.formatTokenType.call(void 0, token.type),\n      truncate(String(raw), 14),\n      // @ts-ignore: Intentional dynamic access by key.\n      ...tokenKeys.map((key) => formatValue(token[key], key)),\n      // @ts-ignore: Intentional dynamic access by key.\n      ...typeKeys.map((key) => formatValue(token.type[key], key)),\n    ];\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function formatValue(value, key) {\n    if (value === true) {\n      return key;\n    } else if (value === false || value === null) {\n      return \"\";\n    } else {\n      return String(value);\n    }\n  }\n\n  function formatRange(start, end) {\n    return `${formatPos(start)}-${formatPos(end)}`;\n  }\n\n  function formatPos(pos) {\n    const location = lines.locationForIndex(pos);\n    if (!location) {\n      return \"Unknown\";\n    } else {\n      return `${location.line + 1}:${location.column + 1}`;\n    }\n  }\n} exports.default = formatTokens;\n\nfunction truncate(s, length) {\n  if (s.length > length) {\n    return `${s.slice(0, length - 3)}...`;\n  } else {\n    return s;\n  }\n}\n"]}}