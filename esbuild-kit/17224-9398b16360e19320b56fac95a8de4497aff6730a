{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const stringify=require(\"./lib/stringify\");const compile=require(\"./lib/compile\");const expand=require(\"./lib/expand\");const parse=require(\"./lib/parse\");const braces=__name((input,options={})=>{let output=[];if(Array.isArray(input)){for(let pattern of input){let result=braces.create(pattern,options);if(Array.isArray(result)){output.push(...result)}else{output.push(result)}}}else{output=[].concat(braces.create(input,options))}if(options&&options.expand===true&&options.nodupes===true){output=[...new Set(output)]}return output},\"braces\");braces.parse=(input,options={})=>parse(input,options);braces.stringify=(input,options={})=>{if(typeof input===\"string\"){return stringify(braces.parse(input,options),options)}return stringify(input,options)};braces.compile=(input,options={})=>{if(typeof input===\"string\"){input=braces.parse(input,options)}return compile(input,options)};braces.expand=(input,options={})=>{if(typeof input===\"string\"){input=braces.parse(input,options)}let result=expand(input,options);if(options.noempty===true){result=result.filter(Boolean)}if(options.nodupes===true){result=[...new Set(result)]}return result};braces.create=(input,options={})=>{if(input===\"\"||input.length<3){return[input]}return options.expand!==true?braces.compile(input,options):braces.expand(input,options)};module.exports=braces;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAEA,MAAM,UAAY,QAAQ,iBAAiB,EAC3C,MAAM,QAAU,QAAQ,eAAe,EACvC,MAAM,OAAS,QAAQ,cAAc,EACrC,MAAM,MAAQ,QAAQ,aAAa,EAgBnC,MAAM,OAAS,QAAC,MAAO,QAAU,CAAC,IAAM,CACtC,IAAI,OAAS,CAAC,EAEd,GAAI,MAAM,QAAQ,KAAK,EAAG,CACxB,QAAS,WAAW,MAAO,CACzB,IAAI,OAAS,OAAO,OAAO,QAAS,OAAO,EAC3C,GAAI,MAAM,QAAQ,MAAM,EAAG,CACzB,OAAO,KAAK,GAAG,MAAM,CACvB,KAAO,CACL,OAAO,KAAK,MAAM,CACpB,CACF,CACF,KAAO,CACL,OAAS,CAAC,EAAE,OAAO,OAAO,OAAO,MAAO,OAAO,CAAC,CAClD,CAEA,GAAI,SAAW,QAAQ,SAAW,MAAQ,QAAQ,UAAY,KAAM,CAClE,OAAS,CAAC,GAAG,IAAI,IAAI,MAAM,CAAC,CAC9B,CACA,OAAO,MACT,EApBe,UAoCf,OAAO,MAAQ,CAAC,MAAO,QAAU,CAAC,IAAM,MAAM,MAAO,OAAO,EAgB5D,OAAO,UAAY,CAAC,MAAO,QAAU,CAAC,IAAM,CAC1C,GAAI,OAAO,QAAU,SAAU,CAC7B,OAAO,UAAU,OAAO,MAAM,MAAO,OAAO,EAAG,OAAO,CACxD,CACA,OAAO,UAAU,MAAO,OAAO,CACjC,EAiBA,OAAO,QAAU,CAAC,MAAO,QAAU,CAAC,IAAM,CACxC,GAAI,OAAO,QAAU,SAAU,CAC7B,MAAQ,OAAO,MAAM,MAAO,OAAO,CACrC,CACA,OAAO,QAAQ,MAAO,OAAO,CAC/B,EAmBA,OAAO,OAAS,CAAC,MAAO,QAAU,CAAC,IAAM,CACvC,GAAI,OAAO,QAAU,SAAU,CAC7B,MAAQ,OAAO,MAAM,MAAO,OAAO,CACrC,CAEA,IAAI,OAAS,OAAO,MAAO,OAAO,EAGlC,GAAI,QAAQ,UAAY,KAAM,CAC5B,OAAS,OAAO,OAAO,OAAO,CAChC,CAGA,GAAI,QAAQ,UAAY,KAAM,CAC5B,OAAS,CAAC,GAAG,IAAI,IAAI,MAAM,CAAC,CAC9B,CAEA,OAAO,MACT,EAkBA,OAAO,OAAS,CAAC,MAAO,QAAU,CAAC,IAAM,CACvC,GAAI,QAAU,IAAM,MAAM,OAAS,EAAG,CACpC,MAAO,CAAC,KAAK,CACf,CAED,OAAO,QAAQ,SAAW,KACrB,OAAO,QAAQ,MAAO,OAAO,EAC7B,OAAO,OAAO,MAAO,OAAO,CAClC,EAMA,OAAO,QAAU","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js"],"sourcesContent":["'use strict';\n\nconst stringify = require('./lib/stringify');\nconst compile = require('./lib/compile');\nconst expand = require('./lib/expand');\nconst parse = require('./lib/parse');\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n return options.expand !== true\n    ? braces.compile(input, options)\n    : braces.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nmodule.exports = braces;\n"]}}