{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interopRequireDefault,\"_interopRequireDefault\");var _tokenizer=require(\"../parser/tokenizer\");var _types=require(\"../parser/tokenizer/types\");var _JSXTransformer=require(\"../transformers/JSXTransformer\");var _getJSXPragmaInfo=require(\"./getJSXPragmaInfo\");var _getJSXPragmaInfo2=_interopRequireDefault(_getJSXPragmaInfo);function getNonTypeIdentifiers(tokens,options){const jsxPragmaInfo=_getJSXPragmaInfo2.default.call(void 0,options);const nonTypeIdentifiers=new Set;for(let i=0;i<tokens.tokens.length;i++){const token=tokens.tokens[i];if(token.type===_types.TokenType.name&&!token.isType&&(token.identifierRole===_tokenizer.IdentifierRole.Access||token.identifierRole===_tokenizer.IdentifierRole.ObjectShorthand||token.identifierRole===_tokenizer.IdentifierRole.ExportAccess)&&!token.shadowsGlobal){nonTypeIdentifiers.add(tokens.identifierNameForToken(token))}if(token.type===_types.TokenType.jsxTagStart){nonTypeIdentifiers.add(jsxPragmaInfo.base)}if(token.type===_types.TokenType.jsxTagStart&&i+1<tokens.tokens.length&&tokens.tokens[i+1].type===_types.TokenType.jsxTagEnd){nonTypeIdentifiers.add(jsxPragmaInfo.base);nonTypeIdentifiers.add(jsxPragmaInfo.fragmentBase)}if(token.type===_types.TokenType.jsxName&&token.identifierRole===_tokenizer.IdentifierRole.Access){const identifierName=tokens.identifierNameForToken(token);if(!_JSXTransformer.startsWithLowerCase.call(void 0,identifierName)||tokens.tokens[i+1].type===_types.TokenType.dot){nonTypeIdentifiers.add(tokens.identifierNameForToken(token))}}}return nonTypeIdentifiers}__name(getNonTypeIdentifiers,\"getNonTypeIdentifiers\");exports.getNonTypeIdentifiers=getNonTypeIdentifiers;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAG,SAAS,uBAAuB,IAAK,CAAE,OAAO,KAAO,IAAI,WAAa,IAAM,CAAE,QAAS,GAAI,CAAG,CAArF,wDACnF,IAAI,WAAa,QAAQ,qBAAqB,EAC9C,IAAI,OAAS,QAAQ,2BAA2B,EAEhD,IAAI,gBAAkB,QAAQ,gCAAgC,EAC9D,IAAI,kBAAoB,QAAQ,oBAAoB,EAAG,IAAI,mBAAqB,uBAAuB,iBAAiB,EAEvH,SAAS,sBAAsB,OAAQ,QAAS,CAC/C,MAAM,cAAgB,mBAAmB,QAAQ,KAAK,OAAQ,OAAO,EACrE,MAAM,mBAAqB,IAAI,IAC/B,QAAS,EAAI,EAAG,EAAI,OAAO,OAAO,OAAQ,IAAK,CAC7C,MAAM,MAAQ,OAAO,OAAO,CAAC,EAC7B,GACE,MAAM,OAAS,OAAO,UAAU,MAChC,CAAC,MAAM,SACN,MAAM,iBAAmB,WAAW,eAAe,QAClD,MAAM,iBAAmB,WAAW,eAAe,iBACnD,MAAM,iBAAmB,WAAW,eAAe,eACrD,CAAC,MAAM,cACP,CACA,mBAAmB,IAAI,OAAO,uBAAuB,KAAK,CAAC,CAC7D,CACA,GAAI,MAAM,OAAS,OAAO,UAAU,YAAa,CAC/C,mBAAmB,IAAI,cAAc,IAAI,CAC3C,CACA,GACE,MAAM,OAAS,OAAO,UAAU,aAChC,EAAI,EAAI,OAAO,OAAO,QACtB,OAAO,OAAO,EAAI,CAAC,EAAE,OAAS,OAAO,UAAU,UAC/C,CACA,mBAAmB,IAAI,cAAc,IAAI,EACzC,mBAAmB,IAAI,cAAc,YAAY,CACnD,CACA,GAAI,MAAM,OAAS,OAAO,UAAU,SAAW,MAAM,iBAAmB,WAAW,eAAe,OAAQ,CACxG,MAAM,eAAiB,OAAO,uBAAuB,KAAK,EAE1D,GAAI,CAAC,gBAAgB,oBAAoB,KAAK,OAAQ,cAAc,GAAK,OAAO,OAAO,EAAI,CAAC,EAAE,OAAS,OAAO,UAAU,IAAK,CAC3H,mBAAmB,IAAI,OAAO,uBAAuB,KAAK,CAAC,CAC7D,CACF,CACF,CACA,OAAO,kBACT,CAnCU,sDAmCR,QAAQ,sBAAwB","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/util/getNonTypeIdentifiers.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar _tokenizer = require('../parser/tokenizer');\nvar _types = require('../parser/tokenizer/types');\n\nvar _JSXTransformer = require('../transformers/JSXTransformer');\nvar _getJSXPragmaInfo = require('./getJSXPragmaInfo'); var _getJSXPragmaInfo2 = _interopRequireDefault(_getJSXPragmaInfo);\n\n function getNonTypeIdentifiers(tokens, options) {\n  const jsxPragmaInfo = _getJSXPragmaInfo2.default.call(void 0, options);\n  const nonTypeIdentifiers = new Set();\n  for (let i = 0; i < tokens.tokens.length; i++) {\n    const token = tokens.tokens[i];\n    if (\n      token.type === _types.TokenType.name &&\n      !token.isType &&\n      (token.identifierRole === _tokenizer.IdentifierRole.Access ||\n        token.identifierRole === _tokenizer.IdentifierRole.ObjectShorthand ||\n        token.identifierRole === _tokenizer.IdentifierRole.ExportAccess) &&\n      !token.shadowsGlobal\n    ) {\n      nonTypeIdentifiers.add(tokens.identifierNameForToken(token));\n    }\n    if (token.type === _types.TokenType.jsxTagStart) {\n      nonTypeIdentifiers.add(jsxPragmaInfo.base);\n    }\n    if (\n      token.type === _types.TokenType.jsxTagStart &&\n      i + 1 < tokens.tokens.length &&\n      tokens.tokens[i + 1].type === _types.TokenType.jsxTagEnd\n    ) {\n      nonTypeIdentifiers.add(jsxPragmaInfo.base);\n      nonTypeIdentifiers.add(jsxPragmaInfo.fragmentBase);\n    }\n    if (token.type === _types.TokenType.jsxName && token.identifierRole === _tokenizer.IdentifierRole.Access) {\n      const identifierName = tokens.identifierNameForToken(token);\n      // Lower-case single-component tag names like \"div\" don't count.\n      if (!_JSXTransformer.startsWithLowerCase.call(void 0, identifierName) || tokens.tokens[i + 1].type === _types.TokenType.dot) {\n        nonTypeIdentifiers.add(tokens.identifierNameForToken(token));\n      }\n    }\n  }\n  return nonTypeIdentifiers;\n} exports.getNonTypeIdentifiers = getNonTypeIdentifiers;\n"]}}