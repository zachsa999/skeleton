{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _index=require(\"../../tokenizer/index\");var _types=require(\"../../tokenizer/types\");var _base=require(\"../../traverser/base\");var _expression=require(\"../../traverser/expression\");var _util=require(\"../../traverser/util\");var _charcodes=require(\"../../util/charcodes\");var _identifier=require(\"../../util/identifier\");var _typescript=require(\"../typescript\");function jsxReadToken(){let sawNewline=false;let sawNonWhitespace=false;while(true){if(_base.state.pos>=_base.input.length){_util.unexpected.call(void 0,\"Unterminated JSX contents\");return}const ch=_base.input.charCodeAt(_base.state.pos);if(ch===_charcodes.charCodes.lessThan||ch===_charcodes.charCodes.leftCurlyBrace){if(_base.state.pos===_base.state.start){if(ch===_charcodes.charCodes.lessThan){_base.state.pos++;_index.finishToken.call(void 0,_types.TokenType.jsxTagStart);return}_index.getTokenFromCode.call(void 0,ch);return}if(sawNewline&&!sawNonWhitespace){_index.finishToken.call(void 0,_types.TokenType.jsxEmptyText)}else{_index.finishToken.call(void 0,_types.TokenType.jsxText)}return}if(ch===_charcodes.charCodes.lineFeed){sawNewline=true}else if(ch!==_charcodes.charCodes.space&&ch!==_charcodes.charCodes.carriageReturn&&ch!==_charcodes.charCodes.tab){sawNonWhitespace=true}_base.state.pos++}}__name(jsxReadToken,\"jsxReadToken\");function jsxReadString(quote){_base.state.pos++;for(;;){if(_base.state.pos>=_base.input.length){_util.unexpected.call(void 0,\"Unterminated string constant\");return}const ch=_base.input.charCodeAt(_base.state.pos);if(ch===quote){_base.state.pos++;break}_base.state.pos++}_index.finishToken.call(void 0,_types.TokenType.string)}__name(jsxReadString,\"jsxReadString\");function jsxReadWord(){let ch;do{if(_base.state.pos>_base.input.length){_util.unexpected.call(void 0,\"Unexpectedly reached the end of input.\");return}ch=_base.input.charCodeAt(++_base.state.pos)}while(_identifier.IS_IDENTIFIER_CHAR[ch]||ch===_charcodes.charCodes.dash);_index.finishToken.call(void 0,_types.TokenType.jsxName)}__name(jsxReadWord,\"jsxReadWord\");function jsxParseIdentifier(){nextJSXTagToken()}__name(jsxParseIdentifier,\"jsxParseIdentifier\");function jsxParseNamespacedName(identifierRole){jsxParseIdentifier();if(!_index.eat.call(void 0,_types.TokenType.colon)){_base.state.tokens[_base.state.tokens.length-1].identifierRole=identifierRole;return}jsxParseIdentifier()}__name(jsxParseNamespacedName,\"jsxParseNamespacedName\");function jsxParseElementName(){const firstTokenIndex=_base.state.tokens.length;jsxParseNamespacedName(_index.IdentifierRole.Access);let hadDot=false;while(_index.match.call(void 0,_types.TokenType.dot)){hadDot=true;nextJSXTagToken();jsxParseIdentifier()}if(!hadDot){const firstToken=_base.state.tokens[firstTokenIndex];const firstChar=_base.input.charCodeAt(firstToken.start);if(firstChar>=_charcodes.charCodes.lowercaseA&&firstChar<=_charcodes.charCodes.lowercaseZ){firstToken.identifierRole=null}}}__name(jsxParseElementName,\"jsxParseElementName\");function jsxParseAttributeValue(){switch(_base.state.type){case _types.TokenType.braceL:_index.next.call(void 0);_expression.parseExpression.call(void 0);nextJSXTagToken();return;case _types.TokenType.jsxTagStart:jsxParseElement();nextJSXTagToken();return;case _types.TokenType.string:nextJSXTagToken();return;default:_util.unexpected.call(void 0,\"JSX value should be either an expression or a quoted JSX text\")}}__name(jsxParseAttributeValue,\"jsxParseAttributeValue\");function jsxParseSpreadChild(){_util.expect.call(void 0,_types.TokenType.ellipsis);_expression.parseExpression.call(void 0)}__name(jsxParseSpreadChild,\"jsxParseSpreadChild\");function jsxParseOpeningElement(initialTokenIndex){if(_index.match.call(void 0,_types.TokenType.jsxTagEnd)){return false}jsxParseElementName();if(_base.isTypeScriptEnabled){_typescript.tsTryParseJSXTypeArgument.call(void 0)}let hasSeenPropSpread=false;while(!_index.match.call(void 0,_types.TokenType.slash)&&!_index.match.call(void 0,_types.TokenType.jsxTagEnd)&&!_base.state.error){if(_index.eat.call(void 0,_types.TokenType.braceL)){hasSeenPropSpread=true;_util.expect.call(void 0,_types.TokenType.ellipsis);_expression.parseMaybeAssign.call(void 0);nextJSXTagToken();continue}if(hasSeenPropSpread&&_base.state.end-_base.state.start===3&&_base.input.charCodeAt(_base.state.start)===_charcodes.charCodes.lowercaseK&&_base.input.charCodeAt(_base.state.start+1)===_charcodes.charCodes.lowercaseE&&_base.input.charCodeAt(_base.state.start+2)===_charcodes.charCodes.lowercaseY){_base.state.tokens[initialTokenIndex].jsxRole=_index.JSXRole.KeyAfterPropSpread}jsxParseNamespacedName(_index.IdentifierRole.ObjectKey);if(_index.match.call(void 0,_types.TokenType.eq)){nextJSXTagToken();jsxParseAttributeValue()}}const isSelfClosing=_index.match.call(void 0,_types.TokenType.slash);if(isSelfClosing){nextJSXTagToken()}return isSelfClosing}__name(jsxParseOpeningElement,\"jsxParseOpeningElement\");function jsxParseClosingElement(){if(_index.match.call(void 0,_types.TokenType.jsxTagEnd)){return}jsxParseElementName()}__name(jsxParseClosingElement,\"jsxParseClosingElement\");function jsxParseElementAt(){const initialTokenIndex=_base.state.tokens.length-1;_base.state.tokens[initialTokenIndex].jsxRole=_index.JSXRole.NoChildren;let numExplicitChildren=0;const isSelfClosing=jsxParseOpeningElement(initialTokenIndex);if(!isSelfClosing){nextJSXExprToken();while(true){switch(_base.state.type){case _types.TokenType.jsxTagStart:nextJSXTagToken();if(_index.match.call(void 0,_types.TokenType.slash)){nextJSXTagToken();jsxParseClosingElement();if(_base.state.tokens[initialTokenIndex].jsxRole!==_index.JSXRole.KeyAfterPropSpread){if(numExplicitChildren===1){_base.state.tokens[initialTokenIndex].jsxRole=_index.JSXRole.OneChild}else if(numExplicitChildren>1){_base.state.tokens[initialTokenIndex].jsxRole=_index.JSXRole.StaticChildren}}return}numExplicitChildren++;jsxParseElementAt();nextJSXExprToken();break;case _types.TokenType.jsxText:numExplicitChildren++;nextJSXExprToken();break;case _types.TokenType.jsxEmptyText:nextJSXExprToken();break;case _types.TokenType.braceL:_index.next.call(void 0);if(_index.match.call(void 0,_types.TokenType.ellipsis)){jsxParseSpreadChild();nextJSXExprToken();numExplicitChildren+=2}else{if(!_index.match.call(void 0,_types.TokenType.braceR)){numExplicitChildren++;_expression.parseExpression.call(void 0)}nextJSXExprToken()}break;default:_util.unexpected.call(void 0);return}}}}__name(jsxParseElementAt,\"jsxParseElementAt\");function jsxParseElement(){nextJSXTagToken();jsxParseElementAt()}__name(jsxParseElement,\"jsxParseElement\");exports.jsxParseElement=jsxParseElement;function nextJSXTagToken(){_base.state.tokens.push(new(0,_index.Token));_index.skipSpace.call(void 0);_base.state.start=_base.state.pos;const code=_base.input.charCodeAt(_base.state.pos);if(_identifier.IS_IDENTIFIER_START[code]){jsxReadWord()}else if(code===_charcodes.charCodes.quotationMark||code===_charcodes.charCodes.apostrophe){jsxReadString(code)}else{++_base.state.pos;switch(code){case _charcodes.charCodes.greaterThan:_index.finishToken.call(void 0,_types.TokenType.jsxTagEnd);break;case _charcodes.charCodes.lessThan:_index.finishToken.call(void 0,_types.TokenType.jsxTagStart);break;case _charcodes.charCodes.slash:_index.finishToken.call(void 0,_types.TokenType.slash);break;case _charcodes.charCodes.equalsTo:_index.finishToken.call(void 0,_types.TokenType.eq);break;case _charcodes.charCodes.leftCurlyBrace:_index.finishToken.call(void 0,_types.TokenType.braceL);break;case _charcodes.charCodes.dot:_index.finishToken.call(void 0,_types.TokenType.dot);break;case _charcodes.charCodes.colon:_index.finishToken.call(void 0,_types.TokenType.colon);break;default:_util.unexpected.call(void 0)}}}__name(nextJSXTagToken,\"nextJSXTagToken\");exports.nextJSXTagToken=nextJSXTagToken;function nextJSXExprToken(){_base.state.tokens.push(new(0,_index.Token));_base.state.start=_base.state.pos;jsxReadToken()}__name(nextJSXExprToken,\"nextJSXExprToken\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/parser/plugins/jsx/index.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});\n\n\n\n\n\n\n\n\n\nvar _index = require('../../tokenizer/index');\nvar _types = require('../../tokenizer/types');\nvar _base = require('../../traverser/base');\nvar _expression = require('../../traverser/expression');\nvar _util = require('../../traverser/util');\nvar _charcodes = require('../../util/charcodes');\nvar _identifier = require('../../util/identifier');\nvar _typescript = require('../typescript');\n\n/**\n * Read token with JSX contents.\n *\n * In addition to detecting jsxTagStart and also regular tokens that might be\n * part of an expression, this code detects the start and end of text ranges\n * within JSX children. In order to properly count the number of children, we\n * distinguish jsxText from jsxEmptyText, which is a text range that simplifies\n * to the empty string after JSX whitespace trimming.\n *\n * It turns out that a JSX text range will simplify to the empty string if and\n * only if both of these conditions hold:\n * - The range consists entirely of whitespace characters (only counting space,\n *   tab, \\r, and \\n).\n * - The range has at least one newline.\n * This can be proven by analyzing any implementation of whitespace trimming,\n * e.g. formatJSXTextLiteral in Sucrase or cleanJSXElementLiteralChild in Babel.\n */\nfunction jsxReadToken() {\n  let sawNewline = false;\n  let sawNonWhitespace = false;\n  while (true) {\n    if (_base.state.pos >= _base.input.length) {\n      _util.unexpected.call(void 0, \"Unterminated JSX contents\");\n      return;\n    }\n\n    const ch = _base.input.charCodeAt(_base.state.pos);\n    if (ch === _charcodes.charCodes.lessThan || ch === _charcodes.charCodes.leftCurlyBrace) {\n      if (_base.state.pos === _base.state.start) {\n        if (ch === _charcodes.charCodes.lessThan) {\n          _base.state.pos++;\n          _index.finishToken.call(void 0, _types.TokenType.jsxTagStart);\n          return;\n        }\n        _index.getTokenFromCode.call(void 0, ch);\n        return;\n      }\n      if (sawNewline && !sawNonWhitespace) {\n        _index.finishToken.call(void 0, _types.TokenType.jsxEmptyText);\n      } else {\n        _index.finishToken.call(void 0, _types.TokenType.jsxText);\n      }\n      return;\n    }\n\n    // This is part of JSX text.\n    if (ch === _charcodes.charCodes.lineFeed) {\n      sawNewline = true;\n    } else if (ch !== _charcodes.charCodes.space && ch !== _charcodes.charCodes.carriageReturn && ch !== _charcodes.charCodes.tab) {\n      sawNonWhitespace = true;\n    }\n    _base.state.pos++;\n  }\n}\n\nfunction jsxReadString(quote) {\n  _base.state.pos++;\n  for (;;) {\n    if (_base.state.pos >= _base.input.length) {\n      _util.unexpected.call(void 0, \"Unterminated string constant\");\n      return;\n    }\n\n    const ch = _base.input.charCodeAt(_base.state.pos);\n    if (ch === quote) {\n      _base.state.pos++;\n      break;\n    }\n    _base.state.pos++;\n  }\n  _index.finishToken.call(void 0, _types.TokenType.string);\n}\n\n// Read a JSX identifier (valid tag or attribute name).\n//\n// Optimized version since JSX identifiers can't contain\n// escape characters and so can be read as single slice.\n// Also assumes that first character was already checked\n// by isIdentifierStart in readToken.\n\nfunction jsxReadWord() {\n  let ch;\n  do {\n    if (_base.state.pos > _base.input.length) {\n      _util.unexpected.call(void 0, \"Unexpectedly reached the end of input.\");\n      return;\n    }\n    ch = _base.input.charCodeAt(++_base.state.pos);\n  } while (_identifier.IS_IDENTIFIER_CHAR[ch] || ch === _charcodes.charCodes.dash);\n  _index.finishToken.call(void 0, _types.TokenType.jsxName);\n}\n\n// Parse next token as JSX identifier\nfunction jsxParseIdentifier() {\n  nextJSXTagToken();\n}\n\n// Parse namespaced identifier.\nfunction jsxParseNamespacedName(identifierRole) {\n  jsxParseIdentifier();\n  if (!_index.eat.call(void 0, _types.TokenType.colon)) {\n    // Plain identifier, so this is an access.\n    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;\n    return;\n  }\n  // Process the second half of the namespaced name.\n  jsxParseIdentifier();\n}\n\n// Parses element name in any form - namespaced, member\n// or single identifier.\nfunction jsxParseElementName() {\n  const firstTokenIndex = _base.state.tokens.length;\n  jsxParseNamespacedName(_index.IdentifierRole.Access);\n  let hadDot = false;\n  while (_index.match.call(void 0, _types.TokenType.dot)) {\n    hadDot = true;\n    nextJSXTagToken();\n    jsxParseIdentifier();\n  }\n  // For tags like <div> with a lowercase letter and no dots, the name is\n  // actually *not* an identifier access, since it's referring to a built-in\n  // tag name. Remove the identifier role in this case so that it's not\n  // accidentally transformed by the imports transform when preserving JSX.\n  if (!hadDot) {\n    const firstToken = _base.state.tokens[firstTokenIndex];\n    const firstChar = _base.input.charCodeAt(firstToken.start);\n    if (firstChar >= _charcodes.charCodes.lowercaseA && firstChar <= _charcodes.charCodes.lowercaseZ) {\n      firstToken.identifierRole = null;\n    }\n  }\n}\n\n// Parses any type of JSX attribute value.\nfunction jsxParseAttributeValue() {\n  switch (_base.state.type) {\n    case _types.TokenType.braceL:\n      _index.next.call(void 0, );\n      _expression.parseExpression.call(void 0, );\n      nextJSXTagToken();\n      return;\n\n    case _types.TokenType.jsxTagStart:\n      jsxParseElement();\n      nextJSXTagToken();\n      return;\n\n    case _types.TokenType.string:\n      nextJSXTagToken();\n      return;\n\n    default:\n      _util.unexpected.call(void 0, \"JSX value should be either an expression or a quoted JSX text\");\n  }\n}\n\n// Parse JSX spread child, after already processing the {\n// Does not parse the closing }\nfunction jsxParseSpreadChild() {\n  _util.expect.call(void 0, _types.TokenType.ellipsis);\n  _expression.parseExpression.call(void 0, );\n}\n\n// Parses JSX opening tag starting after \"<\".\n// Returns true if the tag was self-closing.\n// Does not parse the last token.\nfunction jsxParseOpeningElement(initialTokenIndex) {\n  if (_index.match.call(void 0, _types.TokenType.jsxTagEnd)) {\n    // This is an open-fragment.\n    return false;\n  }\n  jsxParseElementName();\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsTryParseJSXTypeArgument.call(void 0, );\n  }\n  let hasSeenPropSpread = false;\n  while (!_index.match.call(void 0, _types.TokenType.slash) && !_index.match.call(void 0, _types.TokenType.jsxTagEnd) && !_base.state.error) {\n    if (_index.eat.call(void 0, _types.TokenType.braceL)) {\n      hasSeenPropSpread = true;\n      _util.expect.call(void 0, _types.TokenType.ellipsis);\n      _expression.parseMaybeAssign.call(void 0, );\n      // }\n      nextJSXTagToken();\n      continue;\n    }\n    if (\n      hasSeenPropSpread &&\n      _base.state.end - _base.state.start === 3 &&\n      _base.input.charCodeAt(_base.state.start) === _charcodes.charCodes.lowercaseK &&\n      _base.input.charCodeAt(_base.state.start + 1) === _charcodes.charCodes.lowercaseE &&\n      _base.input.charCodeAt(_base.state.start + 2) === _charcodes.charCodes.lowercaseY\n    ) {\n      _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.KeyAfterPropSpread;\n    }\n    jsxParseNamespacedName(_index.IdentifierRole.ObjectKey);\n    if (_index.match.call(void 0, _types.TokenType.eq)) {\n      nextJSXTagToken();\n      jsxParseAttributeValue();\n    }\n  }\n  const isSelfClosing = _index.match.call(void 0, _types.TokenType.slash);\n  if (isSelfClosing) {\n    // /\n    nextJSXTagToken();\n  }\n  return isSelfClosing;\n}\n\n// Parses JSX closing tag starting after \"</\".\n// Does not parse the last token.\nfunction jsxParseClosingElement() {\n  if (_index.match.call(void 0, _types.TokenType.jsxTagEnd)) {\n    // Fragment syntax, so we immediately have a tag end.\n    return;\n  }\n  jsxParseElementName();\n}\n\n// Parses entire JSX element, including its opening tag\n// (starting after \"<\"), attributes, contents and closing tag.\n// Does not parse the last token.\nfunction jsxParseElementAt() {\n  const initialTokenIndex = _base.state.tokens.length - 1;\n  _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.NoChildren;\n  let numExplicitChildren = 0;\n  const isSelfClosing = jsxParseOpeningElement(initialTokenIndex);\n  if (!isSelfClosing) {\n    nextJSXExprToken();\n    while (true) {\n      switch (_base.state.type) {\n        case _types.TokenType.jsxTagStart:\n          nextJSXTagToken();\n          if (_index.match.call(void 0, _types.TokenType.slash)) {\n            nextJSXTagToken();\n            jsxParseClosingElement();\n            // Key after prop spread takes precedence over number of children,\n            // since it means we switch to createElement, which doesn't care\n            // about number of children.\n            if (_base.state.tokens[initialTokenIndex].jsxRole !== _index.JSXRole.KeyAfterPropSpread) {\n              if (numExplicitChildren === 1) {\n                _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.OneChild;\n              } else if (numExplicitChildren > 1) {\n                _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.StaticChildren;\n              }\n            }\n            return;\n          }\n          numExplicitChildren++;\n          jsxParseElementAt();\n          nextJSXExprToken();\n          break;\n\n        case _types.TokenType.jsxText:\n          numExplicitChildren++;\n          nextJSXExprToken();\n          break;\n\n        case _types.TokenType.jsxEmptyText:\n          nextJSXExprToken();\n          break;\n\n        case _types.TokenType.braceL:\n          _index.next.call(void 0, );\n          if (_index.match.call(void 0, _types.TokenType.ellipsis)) {\n            jsxParseSpreadChild();\n            nextJSXExprToken();\n            // Spread children are a mechanism to explicitly mark children as\n            // static, so count it as 2 children to satisfy the \"more than one\n            // child\" condition.\n            numExplicitChildren += 2;\n          } else {\n            // If we see {}, this is an empty pseudo-expression that doesn't\n            // count as a child.\n            if (!_index.match.call(void 0, _types.TokenType.braceR)) {\n              numExplicitChildren++;\n              _expression.parseExpression.call(void 0, );\n            }\n            nextJSXExprToken();\n          }\n\n          break;\n\n        // istanbul ignore next - should never happen\n        default:\n          _util.unexpected.call(void 0, );\n          return;\n      }\n    }\n  }\n}\n\n// Parses entire JSX element from current position.\n// Does not parse the last token.\n function jsxParseElement() {\n  nextJSXTagToken();\n  jsxParseElementAt();\n} exports.jsxParseElement = jsxParseElement;\n\n// ==================================\n// Overrides\n// ==================================\n\n function nextJSXTagToken() {\n  _base.state.tokens.push(new (0, _index.Token)());\n  _index.skipSpace.call(void 0, );\n  _base.state.start = _base.state.pos;\n  const code = _base.input.charCodeAt(_base.state.pos);\n\n  if (_identifier.IS_IDENTIFIER_START[code]) {\n    jsxReadWord();\n  } else if (code === _charcodes.charCodes.quotationMark || code === _charcodes.charCodes.apostrophe) {\n    jsxReadString(code);\n  } else {\n    // The following tokens are just one character each.\n    ++_base.state.pos;\n    switch (code) {\n      case _charcodes.charCodes.greaterThan:\n        _index.finishToken.call(void 0, _types.TokenType.jsxTagEnd);\n        break;\n      case _charcodes.charCodes.lessThan:\n        _index.finishToken.call(void 0, _types.TokenType.jsxTagStart);\n        break;\n      case _charcodes.charCodes.slash:\n        _index.finishToken.call(void 0, _types.TokenType.slash);\n        break;\n      case _charcodes.charCodes.equalsTo:\n        _index.finishToken.call(void 0, _types.TokenType.eq);\n        break;\n      case _charcodes.charCodes.leftCurlyBrace:\n        _index.finishToken.call(void 0, _types.TokenType.braceL);\n        break;\n      case _charcodes.charCodes.dot:\n        _index.finishToken.call(void 0, _types.TokenType.dot);\n        break;\n      case _charcodes.charCodes.colon:\n        _index.finishToken.call(void 0, _types.TokenType.colon);\n        break;\n      default:\n        _util.unexpected.call(void 0, );\n    }\n  }\n} exports.nextJSXTagToken = nextJSXTagToken;\n\nfunction nextJSXExprToken() {\n  _base.state.tokens.push(new (0, _index.Token)());\n  _base.state.start = _base.state.pos;\n  jsxReadToken();\n}\n"]}}