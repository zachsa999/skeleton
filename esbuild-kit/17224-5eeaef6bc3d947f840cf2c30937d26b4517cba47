{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */const isNumber=require(\"is-number\");const toRegexRange=__name((min,max,options)=>{if(isNumber(min)===false){throw new TypeError(\"toRegexRange: expected the first argument to be a number\")}if(max===void 0||min===max){return String(min)}if(isNumber(max)===false){throw new TypeError(\"toRegexRange: expected the second argument to be a number.\")}let opts={relaxZeros:true,...options};if(typeof opts.strictZeros===\"boolean\"){opts.relaxZeros=opts.strictZeros===false}let relax=String(opts.relaxZeros);let shorthand=String(opts.shorthand);let capture=String(opts.capture);let wrap=String(opts.wrap);let cacheKey=min+\":\"+max+\"=\"+relax+shorthand+capture+wrap;if(toRegexRange.cache.hasOwnProperty(cacheKey)){return toRegexRange.cache[cacheKey].result}let a=Math.min(min,max);let b=Math.max(min,max);if(Math.abs(a-b)===1){let result=min+\"|\"+max;if(opts.capture){return`(${result})`}if(opts.wrap===false){return result}return`(?:${result})`}let isPadded=hasPadding(min)||hasPadding(max);let state={min,max,a,b};let positives=[];let negatives=[];if(isPadded){state.isPadded=isPadded;state.maxLen=String(state.max).length}if(a<0){let newMin=b<0?Math.abs(b):1;negatives=splitToPatterns(newMin,Math.abs(a),state,opts);a=state.a=0}if(b>=0){positives=splitToPatterns(a,b,state,opts)}state.negatives=negatives;state.positives=positives;state.result=collatePatterns(negatives,positives,opts);if(opts.capture===true){state.result=`(${state.result})`}else if(opts.wrap!==false&&positives.length+negatives.length>1){state.result=`(?:${state.result})`}toRegexRange.cache[cacheKey]=state;return state.result},\"toRegexRange\");function collatePatterns(neg,pos,options){let onlyNegative=filterPatterns(neg,pos,\"-\",false,options)||[];let onlyPositive=filterPatterns(pos,neg,\"\",false,options)||[];let intersected=filterPatterns(neg,pos,\"-?\",true,options)||[];let subpatterns=onlyNegative.concat(intersected).concat(onlyPositive);return subpatterns.join(\"|\")}__name(collatePatterns,\"collatePatterns\");function splitToRanges(min,max){let nines=1;let zeros=1;let stop=countNines(min,nines);let stops=new Set([max]);while(min<=stop&&stop<=max){stops.add(stop);nines+=1;stop=countNines(min,nines)}stop=countZeros(max+1,zeros)-1;while(min<stop&&stop<=max){stops.add(stop);zeros+=1;stop=countZeros(max+1,zeros)-1}stops=[...stops];stops.sort(compare);return stops}__name(splitToRanges,\"splitToRanges\");function rangeToPattern(start,stop,options){if(start===stop){return{pattern:start,count:[],digits:0}}let zipped=zip(start,stop);let digits=zipped.length;let pattern=\"\";let count=0;for(let i=0;i<digits;i++){let[startDigit,stopDigit]=zipped[i];if(startDigit===stopDigit){pattern+=startDigit}else if(startDigit!==\"0\"||stopDigit!==\"9\"){pattern+=toCharacterClass(startDigit,stopDigit,options)}else{count++}}if(count){pattern+=options.shorthand===true?\"\\\\d\":\"[0-9]\"}return{pattern,count:[count],digits}}__name(rangeToPattern,\"rangeToPattern\");function splitToPatterns(min,max,tok,options){let ranges=splitToRanges(min,max);let tokens=[];let start=min;let prev;for(let i=0;i<ranges.length;i++){let max2=ranges[i];let obj=rangeToPattern(String(start),String(max2),options);let zeros=\"\";if(!tok.isPadded&&prev&&prev.pattern===obj.pattern){if(prev.count.length>1){prev.count.pop()}prev.count.push(obj.count[0]);prev.string=prev.pattern+toQuantifier(prev.count);start=max2+1;continue}if(tok.isPadded){zeros=padZeros(max2,tok,options)}obj.string=zeros+obj.pattern+toQuantifier(obj.count);tokens.push(obj);start=max2+1;prev=obj}return tokens}__name(splitToPatterns,\"splitToPatterns\");function filterPatterns(arr,comparison,prefix,intersection,options){let result=[];for(let ele of arr){let{string}=ele;if(!intersection&&!contains(comparison,\"string\",string)){result.push(prefix+string)}if(intersection&&contains(comparison,\"string\",string)){result.push(prefix+string)}}return result}__name(filterPatterns,\"filterPatterns\");function zip(a,b){let arr=[];for(let i=0;i<a.length;i++)arr.push([a[i],b[i]]);return arr}__name(zip,\"zip\");function compare(a,b){return a>b?1:b>a?-1:0}__name(compare,\"compare\");function contains(arr,key,val){return arr.some(ele=>ele[key]===val)}__name(contains,\"contains\");function countNines(min,len){return Number(String(min).slice(0,-len)+\"9\".repeat(len))}__name(countNines,\"countNines\");function countZeros(integer,zeros){return integer-integer%Math.pow(10,zeros)}__name(countZeros,\"countZeros\");function toQuantifier(digits){let[start=0,stop=\"\"]=digits;if(stop||start>1){return`{${start+(stop?\",\"+stop:\"\")}}`}return\"\"}__name(toQuantifier,\"toQuantifier\");function toCharacterClass(a,b,options){return`[${a}${b-a===1?\"\":\"-\"}${b}]`}__name(toCharacterClass,\"toCharacterClass\");function hasPadding(str){return/^-?(0+)\\d/.test(str)}__name(hasPadding,\"hasPadding\");function padZeros(value,tok,options){if(!tok.isPadded){return value}let diff=Math.abs(tok.maxLen-String(value).length);let relax=options.relaxZeros!==false;switch(diff){case 0:return\"\";case 1:return relax?\"0?\":\"0\";case 2:return relax?\"0{0,2}\":\"00\";default:{return relax?`0{0,${diff}}`:`0{${diff}}`}}}__name(padZeros,\"padZeros\");toRegexRange.cache={};toRegexRange.clearCache=()=>toRegexRange.cache={};module.exports=toRegexRange;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["max"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js"],"sourcesContent":["/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst isNumber = require('is-number');\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n"]}}