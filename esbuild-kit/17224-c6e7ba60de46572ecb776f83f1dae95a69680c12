{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _index=require(\"../index\");var _flow=require(\"../plugins/flow\");var _typescript=require(\"../plugins/typescript\");var _tokenizer=require(\"../tokenizer\");var _keywords=require(\"../tokenizer/keywords\");var _state=require(\"../tokenizer/state\");var _types=require(\"../tokenizer/types\");var _charcodes=require(\"../util/charcodes\");var _base=require(\"./base\");var _expression=require(\"./expression\");var _lval=require(\"./lval\");var _util=require(\"./util\");function parseTopLevel(){parseBlockBody(_types.TokenType.eof);_base.state.scopes.push(new(0,_state.Scope)(0,_base.state.tokens.length,true));if(_base.state.scopeDepth!==0){throw new Error(`Invalid scope depth at end of file: ${_base.state.scopeDepth}`)}return new(0,_index.File)(_base.state.tokens,_base.state.scopes)}__name(parseTopLevel,\"parseTopLevel\");exports.parseTopLevel=parseTopLevel;function parseStatement(declaration){if(_base.isFlowEnabled){if(_flow.flowTryParseStatement.call(void 0)){return}}if(_tokenizer.match.call(void 0,_types.TokenType.at)){parseDecorators()}parseStatementContent(declaration)}__name(parseStatement,\"parseStatement\");exports.parseStatement=parseStatement;function parseStatementContent(declaration){if(_base.isTypeScriptEnabled){if(_typescript.tsTryParseStatementContent.call(void 0)){return}}const starttype=_base.state.type;switch(starttype){case _types.TokenType._break:case _types.TokenType._continue:parseBreakContinueStatement();return;case _types.TokenType._debugger:parseDebuggerStatement();return;case _types.TokenType._do:parseDoStatement();return;case _types.TokenType._for:parseForStatement();return;case _types.TokenType._function:if(_tokenizer.lookaheadType.call(void 0)===_types.TokenType.dot)break;if(!declaration)_util.unexpected.call(void 0);parseFunctionStatement();return;case _types.TokenType._class:if(!declaration)_util.unexpected.call(void 0);parseClass(true);return;case _types.TokenType._if:parseIfStatement();return;case _types.TokenType._return:parseReturnStatement();return;case _types.TokenType._switch:parseSwitchStatement();return;case _types.TokenType._throw:parseThrowStatement();return;case _types.TokenType._try:parseTryStatement();return;case _types.TokenType._let:case _types.TokenType._const:if(!declaration)_util.unexpected.call(void 0);case _types.TokenType._var:parseVarStatement(starttype!==_types.TokenType._var);return;case _types.TokenType._while:parseWhileStatement();return;case _types.TokenType.braceL:parseBlock();return;case _types.TokenType.semi:parseEmptyStatement();return;case _types.TokenType._export:case _types.TokenType._import:{const nextType=_tokenizer.lookaheadType.call(void 0);if(nextType===_types.TokenType.parenL||nextType===_types.TokenType.dot){break}_tokenizer.next.call(void 0);if(starttype===_types.TokenType._import){parseImport()}else{parseExport()}return}case _types.TokenType.name:if(_base.state.contextualKeyword===_keywords.ContextualKeyword._async){const functionStart=_base.state.start;const snapshot=_base.state.snapshot();_tokenizer.next.call(void 0);if(_tokenizer.match.call(void 0,_types.TokenType._function)&&!_util.canInsertSemicolon.call(void 0)){_util.expect.call(void 0,_types.TokenType._function);parseFunction(functionStart,true);return}else{_base.state.restoreFromSnapshot(snapshot)}}else if(_base.state.contextualKeyword===_keywords.ContextualKeyword._using&&!_util.hasFollowingLineBreak.call(void 0)&&_tokenizer.lookaheadType.call(void 0)===_types.TokenType.name){parseVarStatement(true);return}default:break}const initialTokensLength=_base.state.tokens.length;_expression.parseExpression.call(void 0);let simpleName=null;if(_base.state.tokens.length===initialTokensLength+1){const token=_base.state.tokens[_base.state.tokens.length-1];if(token.type===_types.TokenType.name){simpleName=token.contextualKeyword}}if(simpleName==null){_util.semicolon.call(void 0);return}if(_tokenizer.eat.call(void 0,_types.TokenType.colon)){parseLabeledStatement()}else{parseIdentifierStatement(simpleName)}}__name(parseStatementContent,\"parseStatementContent\");function parseDecorators(){while(_tokenizer.match.call(void 0,_types.TokenType.at)){parseDecorator()}}__name(parseDecorators,\"parseDecorators\");exports.parseDecorators=parseDecorators;function parseDecorator(){_tokenizer.next.call(void 0);if(_tokenizer.eat.call(void 0,_types.TokenType.parenL)){_expression.parseExpression.call(void 0);_util.expect.call(void 0,_types.TokenType.parenR)}else{_expression.parseIdentifier.call(void 0);while(_tokenizer.eat.call(void 0,_types.TokenType.dot)){_expression.parseIdentifier.call(void 0)}parseMaybeDecoratorArguments()}}__name(parseDecorator,\"parseDecorator\");function parseMaybeDecoratorArguments(){if(_base.isTypeScriptEnabled){_typescript.tsParseMaybeDecoratorArguments.call(void 0)}else{baseParseMaybeDecoratorArguments()}}__name(parseMaybeDecoratorArguments,\"parseMaybeDecoratorArguments\");function baseParseMaybeDecoratorArguments(){if(_tokenizer.eat.call(void 0,_types.TokenType.parenL)){_expression.parseCallExpressionArguments.call(void 0)}}__name(baseParseMaybeDecoratorArguments,\"baseParseMaybeDecoratorArguments\");exports.baseParseMaybeDecoratorArguments=baseParseMaybeDecoratorArguments;function parseBreakContinueStatement(){_tokenizer.next.call(void 0);if(!_util.isLineTerminator.call(void 0)){_expression.parseIdentifier.call(void 0);_util.semicolon.call(void 0)}}__name(parseBreakContinueStatement,\"parseBreakContinueStatement\");function parseDebuggerStatement(){_tokenizer.next.call(void 0);_util.semicolon.call(void 0)}__name(parseDebuggerStatement,\"parseDebuggerStatement\");function parseDoStatement(){_tokenizer.next.call(void 0);parseStatement(false);_util.expect.call(void 0,_types.TokenType._while);_expression.parseParenExpression.call(void 0);_tokenizer.eat.call(void 0,_types.TokenType.semi)}__name(parseDoStatement,\"parseDoStatement\");function parseForStatement(){_base.state.scopeDepth++;const startTokenIndex=_base.state.tokens.length;parseAmbiguousForStatement();const endTokenIndex=_base.state.tokens.length;_base.state.scopes.push(new(0,_state.Scope)(startTokenIndex,endTokenIndex,false));_base.state.scopeDepth--}__name(parseForStatement,\"parseForStatement\");function isUsingInLoop(){if(!_util.isContextual.call(void 0,_keywords.ContextualKeyword._using)){return false}if(_util.isLookaheadContextual.call(void 0,_keywords.ContextualKeyword._of)){return false}return true}__name(isUsingInLoop,\"isUsingInLoop\");function parseAmbiguousForStatement(){_tokenizer.next.call(void 0);let forAwait=false;if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._await)){forAwait=true;_tokenizer.next.call(void 0)}_util.expect.call(void 0,_types.TokenType.parenL);if(_tokenizer.match.call(void 0,_types.TokenType.semi)){if(forAwait){_util.unexpected.call(void 0)}parseFor();return}if(_tokenizer.match.call(void 0,_types.TokenType._var)||_tokenizer.match.call(void 0,_types.TokenType._let)||_tokenizer.match.call(void 0,_types.TokenType._const)||isUsingInLoop()){_tokenizer.next.call(void 0);parseVar(true,_base.state.type!==_types.TokenType._var);if(_tokenizer.match.call(void 0,_types.TokenType._in)||_util.isContextual.call(void 0,_keywords.ContextualKeyword._of)){parseForIn(forAwait);return}parseFor();return}_expression.parseExpression.call(void 0,true);if(_tokenizer.match.call(void 0,_types.TokenType._in)||_util.isContextual.call(void 0,_keywords.ContextualKeyword._of)){parseForIn(forAwait);return}if(forAwait){_util.unexpected.call(void 0)}parseFor()}__name(parseAmbiguousForStatement,\"parseAmbiguousForStatement\");function parseFunctionStatement(){const functionStart=_base.state.start;_tokenizer.next.call(void 0);parseFunction(functionStart,true)}__name(parseFunctionStatement,\"parseFunctionStatement\");function parseIfStatement(){_tokenizer.next.call(void 0);_expression.parseParenExpression.call(void 0);parseStatement(false);if(_tokenizer.eat.call(void 0,_types.TokenType._else)){parseStatement(false)}}__name(parseIfStatement,\"parseIfStatement\");function parseReturnStatement(){_tokenizer.next.call(void 0);if(!_util.isLineTerminator.call(void 0)){_expression.parseExpression.call(void 0);_util.semicolon.call(void 0)}}__name(parseReturnStatement,\"parseReturnStatement\");function parseSwitchStatement(){_tokenizer.next.call(void 0);_expression.parseParenExpression.call(void 0);_base.state.scopeDepth++;const startTokenIndex=_base.state.tokens.length;_util.expect.call(void 0,_types.TokenType.braceL);while(!_tokenizer.match.call(void 0,_types.TokenType.braceR)&&!_base.state.error){if(_tokenizer.match.call(void 0,_types.TokenType._case)||_tokenizer.match.call(void 0,_types.TokenType._default)){const isCase=_tokenizer.match.call(void 0,_types.TokenType._case);_tokenizer.next.call(void 0);if(isCase){_expression.parseExpression.call(void 0)}_util.expect.call(void 0,_types.TokenType.colon)}else{parseStatement(true)}}_tokenizer.next.call(void 0);const endTokenIndex=_base.state.tokens.length;_base.state.scopes.push(new(0,_state.Scope)(startTokenIndex,endTokenIndex,false));_base.state.scopeDepth--}__name(parseSwitchStatement,\"parseSwitchStatement\");function parseThrowStatement(){_tokenizer.next.call(void 0);_expression.parseExpression.call(void 0);_util.semicolon.call(void 0)}__name(parseThrowStatement,\"parseThrowStatement\");function parseCatchClauseParam(){_lval.parseBindingAtom.call(void 0,true);if(_base.isTypeScriptEnabled){_typescript.tsTryParseTypeAnnotation.call(void 0)}}__name(parseCatchClauseParam,\"parseCatchClauseParam\");function parseTryStatement(){_tokenizer.next.call(void 0);parseBlock();if(_tokenizer.match.call(void 0,_types.TokenType._catch)){_tokenizer.next.call(void 0);let catchBindingStartTokenIndex=null;if(_tokenizer.match.call(void 0,_types.TokenType.parenL)){_base.state.scopeDepth++;catchBindingStartTokenIndex=_base.state.tokens.length;_util.expect.call(void 0,_types.TokenType.parenL);parseCatchClauseParam();_util.expect.call(void 0,_types.TokenType.parenR)}parseBlock();if(catchBindingStartTokenIndex!=null){const endTokenIndex=_base.state.tokens.length;_base.state.scopes.push(new(0,_state.Scope)(catchBindingStartTokenIndex,endTokenIndex,false));_base.state.scopeDepth--}}if(_tokenizer.eat.call(void 0,_types.TokenType._finally)){parseBlock()}}__name(parseTryStatement,\"parseTryStatement\");function parseVarStatement(isBlockScope){_tokenizer.next.call(void 0);parseVar(false,isBlockScope);_util.semicolon.call(void 0)}__name(parseVarStatement,\"parseVarStatement\");exports.parseVarStatement=parseVarStatement;function parseWhileStatement(){_tokenizer.next.call(void 0);_expression.parseParenExpression.call(void 0);parseStatement(false)}__name(parseWhileStatement,\"parseWhileStatement\");function parseEmptyStatement(){_tokenizer.next.call(void 0)}__name(parseEmptyStatement,\"parseEmptyStatement\");function parseLabeledStatement(){parseStatement(true)}__name(parseLabeledStatement,\"parseLabeledStatement\");function parseIdentifierStatement(contextualKeyword){if(_base.isTypeScriptEnabled){_typescript.tsParseIdentifierStatement.call(void 0,contextualKeyword)}else if(_base.isFlowEnabled){_flow.flowParseIdentifierStatement.call(void 0,contextualKeyword)}else{_util.semicolon.call(void 0)}}__name(parseIdentifierStatement,\"parseIdentifierStatement\");function parseBlock(isFunctionScope=false,contextId=0){const startTokenIndex=_base.state.tokens.length;_base.state.scopeDepth++;_util.expect.call(void 0,_types.TokenType.braceL);if(contextId){_base.state.tokens[_base.state.tokens.length-1].contextId=contextId}parseBlockBody(_types.TokenType.braceR);if(contextId){_base.state.tokens[_base.state.tokens.length-1].contextId=contextId}const endTokenIndex=_base.state.tokens.length;_base.state.scopes.push(new(0,_state.Scope)(startTokenIndex,endTokenIndex,isFunctionScope));_base.state.scopeDepth--}__name(parseBlock,\"parseBlock\");exports.parseBlock=parseBlock;function parseBlockBody(end){while(!_tokenizer.eat.call(void 0,end)&&!_base.state.error){parseStatement(true)}}__name(parseBlockBody,\"parseBlockBody\");exports.parseBlockBody=parseBlockBody;function parseFor(){_util.expect.call(void 0,_types.TokenType.semi);if(!_tokenizer.match.call(void 0,_types.TokenType.semi)){_expression.parseExpression.call(void 0)}_util.expect.call(void 0,_types.TokenType.semi);if(!_tokenizer.match.call(void 0,_types.TokenType.parenR)){_expression.parseExpression.call(void 0)}_util.expect.call(void 0,_types.TokenType.parenR);parseStatement(false)}__name(parseFor,\"parseFor\");function parseForIn(forAwait){if(forAwait){_util.eatContextual.call(void 0,_keywords.ContextualKeyword._of)}else{_tokenizer.next.call(void 0)}_expression.parseExpression.call(void 0);_util.expect.call(void 0,_types.TokenType.parenR);parseStatement(false)}__name(parseForIn,\"parseForIn\");function parseVar(isFor,isBlockScope){while(true){parseVarHead(isBlockScope);if(_tokenizer.eat.call(void 0,_types.TokenType.eq)){const eqIndex=_base.state.tokens.length-1;_expression.parseMaybeAssign.call(void 0,isFor);_base.state.tokens[eqIndex].rhsEndIndex=_base.state.tokens.length}if(!_tokenizer.eat.call(void 0,_types.TokenType.comma)){break}}}__name(parseVar,\"parseVar\");function parseVarHead(isBlockScope){_lval.parseBindingAtom.call(void 0,isBlockScope);if(_base.isTypeScriptEnabled){_typescript.tsAfterParseVarHead.call(void 0)}else if(_base.isFlowEnabled){_flow.flowAfterParseVarHead.call(void 0)}}__name(parseVarHead,\"parseVarHead\");function parseFunction(functionStart,isStatement,optionalId=false){if(_tokenizer.match.call(void 0,_types.TokenType.star)){_tokenizer.next.call(void 0)}if(isStatement&&!optionalId&&!_tokenizer.match.call(void 0,_types.TokenType.name)&&!_tokenizer.match.call(void 0,_types.TokenType._yield)){_util.unexpected.call(void 0)}let nameScopeStartTokenIndex=null;if(_tokenizer.match.call(void 0,_types.TokenType.name)){if(!isStatement){nameScopeStartTokenIndex=_base.state.tokens.length;_base.state.scopeDepth++}_lval.parseBindingIdentifier.call(void 0,false)}const startTokenIndex=_base.state.tokens.length;_base.state.scopeDepth++;parseFunctionParams();_expression.parseFunctionBodyAndFinish.call(void 0,functionStart);const endTokenIndex=_base.state.tokens.length;_base.state.scopes.push(new(0,_state.Scope)(startTokenIndex,endTokenIndex,true));_base.state.scopeDepth--;if(nameScopeStartTokenIndex!==null){_base.state.scopes.push(new(0,_state.Scope)(nameScopeStartTokenIndex,endTokenIndex,true));_base.state.scopeDepth--}}__name(parseFunction,\"parseFunction\");exports.parseFunction=parseFunction;function parseFunctionParams(allowModifiers=false,funcContextId=0){if(_base.isTypeScriptEnabled){_typescript.tsStartParseFunctionParams.call(void 0)}else if(_base.isFlowEnabled){_flow.flowStartParseFunctionParams.call(void 0)}_util.expect.call(void 0,_types.TokenType.parenL);if(funcContextId){_base.state.tokens[_base.state.tokens.length-1].contextId=funcContextId}_lval.parseBindingList.call(void 0,_types.TokenType.parenR,false,false,allowModifiers,funcContextId);if(funcContextId){_base.state.tokens[_base.state.tokens.length-1].contextId=funcContextId}}__name(parseFunctionParams,\"parseFunctionParams\");exports.parseFunctionParams=parseFunctionParams;function parseClass(isStatement,optionalId=false){const contextId=_base.getNextContextId.call(void 0);_tokenizer.next.call(void 0);_base.state.tokens[_base.state.tokens.length-1].contextId=contextId;_base.state.tokens[_base.state.tokens.length-1].isExpression=!isStatement;let nameScopeStartTokenIndex=null;if(!isStatement){nameScopeStartTokenIndex=_base.state.tokens.length;_base.state.scopeDepth++}parseClassId(isStatement,optionalId);parseClassSuper();const openBraceIndex=_base.state.tokens.length;parseClassBody(contextId);if(_base.state.error){return}_base.state.tokens[openBraceIndex].contextId=contextId;_base.state.tokens[_base.state.tokens.length-1].contextId=contextId;if(nameScopeStartTokenIndex!==null){const endTokenIndex=_base.state.tokens.length;_base.state.scopes.push(new(0,_state.Scope)(nameScopeStartTokenIndex,endTokenIndex,false));_base.state.scopeDepth--}}__name(parseClass,\"parseClass\");exports.parseClass=parseClass;function isClassProperty(){return _tokenizer.match.call(void 0,_types.TokenType.eq)||_tokenizer.match.call(void 0,_types.TokenType.semi)||_tokenizer.match.call(void 0,_types.TokenType.braceR)||_tokenizer.match.call(void 0,_types.TokenType.bang)||_tokenizer.match.call(void 0,_types.TokenType.colon)}__name(isClassProperty,\"isClassProperty\");function isClassMethod(){return _tokenizer.match.call(void 0,_types.TokenType.parenL)||_tokenizer.match.call(void 0,_types.TokenType.lessThan)}__name(isClassMethod,\"isClassMethod\");function parseClassBody(classContextId){_util.expect.call(void 0,_types.TokenType.braceL);while(!_tokenizer.eat.call(void 0,_types.TokenType.braceR)&&!_base.state.error){if(_tokenizer.eat.call(void 0,_types.TokenType.semi)){continue}if(_tokenizer.match.call(void 0,_types.TokenType.at)){parseDecorator();continue}const memberStart=_base.state.start;parseClassMember(memberStart,classContextId)}}__name(parseClassBody,\"parseClassBody\");function parseClassMember(memberStart,classContextId){if(_base.isTypeScriptEnabled){_typescript.tsParseModifiers.call(void 0,[_keywords.ContextualKeyword._declare,_keywords.ContextualKeyword._public,_keywords.ContextualKeyword._protected,_keywords.ContextualKeyword._private,_keywords.ContextualKeyword._override])}let isStatic=false;if(_tokenizer.match.call(void 0,_types.TokenType.name)&&_base.state.contextualKeyword===_keywords.ContextualKeyword._static){_expression.parseIdentifier.call(void 0);if(isClassMethod()){parseClassMethod(memberStart,false);return}else if(isClassProperty()){parseClassProperty();return}_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._static;isStatic=true;if(_tokenizer.match.call(void 0,_types.TokenType.braceL)){_base.state.tokens[_base.state.tokens.length-1].contextId=classContextId;parseBlock();return}}parseClassMemberWithIsStatic(memberStart,isStatic,classContextId)}__name(parseClassMember,\"parseClassMember\");function parseClassMemberWithIsStatic(memberStart,isStatic,classContextId){if(_base.isTypeScriptEnabled){if(_typescript.tsTryParseClassMemberWithIsStatic.call(void 0,isStatic)){return}}if(_tokenizer.eat.call(void 0,_types.TokenType.star)){parseClassPropertyName(classContextId);parseClassMethod(memberStart,false);return}parseClassPropertyName(classContextId);let isConstructor=false;const token=_base.state.tokens[_base.state.tokens.length-1];if(token.contextualKeyword===_keywords.ContextualKeyword._constructor){isConstructor=true}parsePostMemberNameModifiers();if(isClassMethod()){parseClassMethod(memberStart,isConstructor)}else if(isClassProperty()){parseClassProperty()}else if(token.contextualKeyword===_keywords.ContextualKeyword._async&&!_util.isLineTerminator.call(void 0)){_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._async;const isGenerator=_tokenizer.match.call(void 0,_types.TokenType.star);if(isGenerator){_tokenizer.next.call(void 0)}parseClassPropertyName(classContextId);parsePostMemberNameModifiers();parseClassMethod(memberStart,false)}else if((token.contextualKeyword===_keywords.ContextualKeyword._get||token.contextualKeyword===_keywords.ContextualKeyword._set)&&!(_util.isLineTerminator.call(void 0)&&_tokenizer.match.call(void 0,_types.TokenType.star))){if(token.contextualKeyword===_keywords.ContextualKeyword._get){_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._get}else{_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._set}parseClassPropertyName(classContextId);parseClassMethod(memberStart,false)}else if(token.contextualKeyword===_keywords.ContextualKeyword._accessor&&!_util.isLineTerminator.call(void 0)){parseClassPropertyName(classContextId);parseClassProperty()}else if(_util.isLineTerminator.call(void 0)){parseClassProperty()}else{_util.unexpected.call(void 0)}}__name(parseClassMemberWithIsStatic,\"parseClassMemberWithIsStatic\");function parseClassMethod(functionStart,isConstructor){if(_base.isTypeScriptEnabled){_typescript.tsTryParseTypeParameters.call(void 0)}else if(_base.isFlowEnabled){if(_tokenizer.match.call(void 0,_types.TokenType.lessThan)){_flow.flowParseTypeParameterDeclaration.call(void 0)}}_expression.parseMethod.call(void 0,functionStart,isConstructor)}__name(parseClassMethod,\"parseClassMethod\");function parseClassPropertyName(classContextId){_expression.parsePropertyName.call(void 0,classContextId)}__name(parseClassPropertyName,\"parseClassPropertyName\");exports.parseClassPropertyName=parseClassPropertyName;function parsePostMemberNameModifiers(){if(_base.isTypeScriptEnabled){const oldIsType=_tokenizer.pushTypeContext.call(void 0,0);_tokenizer.eat.call(void 0,_types.TokenType.question);_tokenizer.popTypeContext.call(void 0,oldIsType)}}__name(parsePostMemberNameModifiers,\"parsePostMemberNameModifiers\");exports.parsePostMemberNameModifiers=parsePostMemberNameModifiers;function parseClassProperty(){if(_base.isTypeScriptEnabled){_tokenizer.eatTypeToken.call(void 0,_types.TokenType.bang);_typescript.tsTryParseTypeAnnotation.call(void 0)}else if(_base.isFlowEnabled){if(_tokenizer.match.call(void 0,_types.TokenType.colon)){_flow.flowParseTypeAnnotation.call(void 0)}}if(_tokenizer.match.call(void 0,_types.TokenType.eq)){const equalsTokenIndex=_base.state.tokens.length;_tokenizer.next.call(void 0);_expression.parseMaybeAssign.call(void 0);_base.state.tokens[equalsTokenIndex].rhsEndIndex=_base.state.tokens.length}_util.semicolon.call(void 0)}__name(parseClassProperty,\"parseClassProperty\");exports.parseClassProperty=parseClassProperty;function parseClassId(isStatement,optionalId=false){if(_base.isTypeScriptEnabled&&(!isStatement||optionalId)&&_util.isContextual.call(void 0,_keywords.ContextualKeyword._implements)){return}if(_tokenizer.match.call(void 0,_types.TokenType.name)){_lval.parseBindingIdentifier.call(void 0,true)}if(_base.isTypeScriptEnabled){_typescript.tsTryParseTypeParameters.call(void 0)}else if(_base.isFlowEnabled){if(_tokenizer.match.call(void 0,_types.TokenType.lessThan)){_flow.flowParseTypeParameterDeclaration.call(void 0)}}}__name(parseClassId,\"parseClassId\");function parseClassSuper(){let hasSuper=false;if(_tokenizer.eat.call(void 0,_types.TokenType._extends)){_expression.parseExprSubscripts.call(void 0);hasSuper=true}else{hasSuper=false}if(_base.isTypeScriptEnabled){_typescript.tsAfterParseClassSuper.call(void 0,hasSuper)}else if(_base.isFlowEnabled){_flow.flowAfterParseClassSuper.call(void 0,hasSuper)}}__name(parseClassSuper,\"parseClassSuper\");function parseExport(){const exportIndex=_base.state.tokens.length-1;if(_base.isTypeScriptEnabled){if(_typescript.tsTryParseExport.call(void 0)){return}}if(shouldParseExportStar()){parseExportStar()}else if(isExportDefaultSpecifier()){_expression.parseIdentifier.call(void 0);if(_tokenizer.match.call(void 0,_types.TokenType.comma)&&_tokenizer.lookaheadType.call(void 0)===_types.TokenType.star){_util.expect.call(void 0,_types.TokenType.comma);_util.expect.call(void 0,_types.TokenType.star);_util.expectContextual.call(void 0,_keywords.ContextualKeyword._as);_expression.parseIdentifier.call(void 0)}else{parseExportSpecifiersMaybe()}parseExportFrom()}else if(_tokenizer.eat.call(void 0,_types.TokenType._default)){parseExportDefaultExpression()}else if(shouldParseExportDeclaration()){parseExportDeclaration()}else{parseExportSpecifiers();parseExportFrom()}_base.state.tokens[exportIndex].rhsEndIndex=_base.state.tokens.length}__name(parseExport,\"parseExport\");exports.parseExport=parseExport;function parseExportDefaultExpression(){if(_base.isTypeScriptEnabled){if(_typescript.tsTryParseExportDefaultExpression.call(void 0)){return}}if(_base.isFlowEnabled){if(_flow.flowTryParseExportDefaultExpression.call(void 0)){return}}const functionStart=_base.state.start;if(_tokenizer.eat.call(void 0,_types.TokenType._function)){parseFunction(functionStart,true,true)}else if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._async)&&_tokenizer.lookaheadType.call(void 0)===_types.TokenType._function){_util.eatContextual.call(void 0,_keywords.ContextualKeyword._async);_tokenizer.eat.call(void 0,_types.TokenType._function);parseFunction(functionStart,true,true)}else if(_tokenizer.match.call(void 0,_types.TokenType._class)){parseClass(true,true)}else if(_tokenizer.match.call(void 0,_types.TokenType.at)){parseDecorators();parseClass(true,true)}else{_expression.parseMaybeAssign.call(void 0);_util.semicolon.call(void 0)}}__name(parseExportDefaultExpression,\"parseExportDefaultExpression\");function parseExportDeclaration(){if(_base.isTypeScriptEnabled){_typescript.tsParseExportDeclaration.call(void 0)}else if(_base.isFlowEnabled){_flow.flowParseExportDeclaration.call(void 0)}else{parseStatement(true)}}__name(parseExportDeclaration,\"parseExportDeclaration\");function isExportDefaultSpecifier(){if(_base.isTypeScriptEnabled&&_typescript.tsIsDeclarationStart.call(void 0)){return false}else if(_base.isFlowEnabled&&_flow.flowShouldDisallowExportDefaultSpecifier.call(void 0)){return false}if(_tokenizer.match.call(void 0,_types.TokenType.name)){return _base.state.contextualKeyword!==_keywords.ContextualKeyword._async}if(!_tokenizer.match.call(void 0,_types.TokenType._default)){return false}const _next=_tokenizer.nextTokenStart.call(void 0);const lookahead=_tokenizer.lookaheadTypeAndKeyword.call(void 0);const hasFrom=lookahead.type===_types.TokenType.name&&lookahead.contextualKeyword===_keywords.ContextualKeyword._from;if(lookahead.type===_types.TokenType.comma){return true}if(hasFrom){const nextAfterFrom=_base.input.charCodeAt(_tokenizer.nextTokenStartSince.call(void 0,_next+4));return nextAfterFrom===_charcodes.charCodes.quotationMark||nextAfterFrom===_charcodes.charCodes.apostrophe}return false}__name(isExportDefaultSpecifier,\"isExportDefaultSpecifier\");function parseExportSpecifiersMaybe(){if(_tokenizer.eat.call(void 0,_types.TokenType.comma)){parseExportSpecifiers()}}__name(parseExportSpecifiersMaybe,\"parseExportSpecifiersMaybe\");function parseExportFrom(){if(_util.eatContextual.call(void 0,_keywords.ContextualKeyword._from)){_expression.parseExprAtom.call(void 0);maybeParseImportAssertions()}_util.semicolon.call(void 0)}__name(parseExportFrom,\"parseExportFrom\");exports.parseExportFrom=parseExportFrom;function shouldParseExportStar(){if(_base.isFlowEnabled){return _flow.flowShouldParseExportStar.call(void 0)}else{return _tokenizer.match.call(void 0,_types.TokenType.star)}}__name(shouldParseExportStar,\"shouldParseExportStar\");function parseExportStar(){if(_base.isFlowEnabled){_flow.flowParseExportStar.call(void 0)}else{baseParseExportStar()}}__name(parseExportStar,\"parseExportStar\");function baseParseExportStar(){_util.expect.call(void 0,_types.TokenType.star);if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._as)){parseExportNamespace()}else{parseExportFrom()}}__name(baseParseExportStar,\"baseParseExportStar\");exports.baseParseExportStar=baseParseExportStar;function parseExportNamespace(){_tokenizer.next.call(void 0);_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._as;_expression.parseIdentifier.call(void 0);parseExportSpecifiersMaybe();parseExportFrom()}__name(parseExportNamespace,\"parseExportNamespace\");function shouldParseExportDeclaration(){return _base.isTypeScriptEnabled&&_typescript.tsIsDeclarationStart.call(void 0)||_base.isFlowEnabled&&_flow.flowShouldParseExportDeclaration.call(void 0)||_base.state.type===_types.TokenType._var||_base.state.type===_types.TokenType._const||_base.state.type===_types.TokenType._let||_base.state.type===_types.TokenType._function||_base.state.type===_types.TokenType._class||_util.isContextual.call(void 0,_keywords.ContextualKeyword._async)||_tokenizer.match.call(void 0,_types.TokenType.at)}__name(shouldParseExportDeclaration,\"shouldParseExportDeclaration\");function parseExportSpecifiers(){let first=true;_util.expect.call(void 0,_types.TokenType.braceL);while(!_tokenizer.eat.call(void 0,_types.TokenType.braceR)&&!_base.state.error){if(first){first=false}else{_util.expect.call(void 0,_types.TokenType.comma);if(_tokenizer.eat.call(void 0,_types.TokenType.braceR)){break}}parseExportSpecifier()}}__name(parseExportSpecifiers,\"parseExportSpecifiers\");exports.parseExportSpecifiers=parseExportSpecifiers;function parseExportSpecifier(){if(_base.isTypeScriptEnabled){_typescript.tsParseExportSpecifier.call(void 0);return}_expression.parseIdentifier.call(void 0);_base.state.tokens[_base.state.tokens.length-1].identifierRole=_tokenizer.IdentifierRole.ExportAccess;if(_util.eatContextual.call(void 0,_keywords.ContextualKeyword._as)){_expression.parseIdentifier.call(void 0)}}__name(parseExportSpecifier,\"parseExportSpecifier\");function isImportReflection(){const snapshot=_base.state.snapshot();_util.expectContextual.call(void 0,_keywords.ContextualKeyword._module);if(_util.eatContextual.call(void 0,_keywords.ContextualKeyword._from)){if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._from)){_base.state.restoreFromSnapshot(snapshot);return true}else{_base.state.restoreFromSnapshot(snapshot);return false}}else if(_tokenizer.match.call(void 0,_types.TokenType.comma)){_base.state.restoreFromSnapshot(snapshot);return false}else{_base.state.restoreFromSnapshot(snapshot);return true}}__name(isImportReflection,\"isImportReflection\");function parseMaybeImportReflection(){if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._module)&&isImportReflection()){_tokenizer.next.call(void 0)}}__name(parseMaybeImportReflection,\"parseMaybeImportReflection\");function parseImport(){if(_base.isTypeScriptEnabled&&_tokenizer.match.call(void 0,_types.TokenType.name)&&_tokenizer.lookaheadType.call(void 0)===_types.TokenType.eq){_typescript.tsParseImportEqualsDeclaration.call(void 0);return}if(_base.isTypeScriptEnabled&&_util.isContextual.call(void 0,_keywords.ContextualKeyword._type)){const lookahead=_tokenizer.lookaheadTypeAndKeyword.call(void 0);if(lookahead.type===_types.TokenType.name&&lookahead.contextualKeyword!==_keywords.ContextualKeyword._from){_util.expectContextual.call(void 0,_keywords.ContextualKeyword._type);if(_tokenizer.lookaheadType.call(void 0)===_types.TokenType.eq){_typescript.tsParseImportEqualsDeclaration.call(void 0);return}}else if(lookahead.type===_types.TokenType.star||lookahead.type===_types.TokenType.braceL){_util.expectContextual.call(void 0,_keywords.ContextualKeyword._type)}}if(_tokenizer.match.call(void 0,_types.TokenType.string)){_expression.parseExprAtom.call(void 0)}else{parseMaybeImportReflection();parseImportSpecifiers();_util.expectContextual.call(void 0,_keywords.ContextualKeyword._from);_expression.parseExprAtom.call(void 0)}maybeParseImportAssertions();_util.semicolon.call(void 0)}__name(parseImport,\"parseImport\");exports.parseImport=parseImport;function shouldParseDefaultImport(){return _tokenizer.match.call(void 0,_types.TokenType.name)}__name(shouldParseDefaultImport,\"shouldParseDefaultImport\");function parseImportSpecifierLocal(){_lval.parseImportedIdentifier.call(void 0)}__name(parseImportSpecifierLocal,\"parseImportSpecifierLocal\");function parseImportSpecifiers(){if(_base.isFlowEnabled){_flow.flowStartParseImportSpecifiers.call(void 0)}let first=true;if(shouldParseDefaultImport()){parseImportSpecifierLocal();if(!_tokenizer.eat.call(void 0,_types.TokenType.comma))return}if(_tokenizer.match.call(void 0,_types.TokenType.star)){_tokenizer.next.call(void 0);_util.expectContextual.call(void 0,_keywords.ContextualKeyword._as);parseImportSpecifierLocal();return}_util.expect.call(void 0,_types.TokenType.braceL);while(!_tokenizer.eat.call(void 0,_types.TokenType.braceR)&&!_base.state.error){if(first){first=false}else{if(_tokenizer.eat.call(void 0,_types.TokenType.colon)){_util.unexpected.call(void 0,\"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\")}_util.expect.call(void 0,_types.TokenType.comma);if(_tokenizer.eat.call(void 0,_types.TokenType.braceR)){break}}parseImportSpecifier()}}__name(parseImportSpecifiers,\"parseImportSpecifiers\");function parseImportSpecifier(){if(_base.isTypeScriptEnabled){_typescript.tsParseImportSpecifier.call(void 0);return}if(_base.isFlowEnabled){_flow.flowParseImportSpecifier.call(void 0);return}_lval.parseImportedIdentifier.call(void 0);if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._as)){_base.state.tokens[_base.state.tokens.length-1].identifierRole=_tokenizer.IdentifierRole.ImportAccess;_tokenizer.next.call(void 0);_lval.parseImportedIdentifier.call(void 0)}}__name(parseImportSpecifier,\"parseImportSpecifier\");function maybeParseImportAssertions(){if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._assert)&&!_util.hasPrecedingLineBreak.call(void 0)){_tokenizer.next.call(void 0);_expression.parseObj.call(void 0,false,false)}}__name(maybeParseImportAssertions,\"maybeParseImportAssertions\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/parser/traverser/statement.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});/* eslint max-len: 0 */\n\nvar _index = require('../index');\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar _flow = require('../plugins/flow');\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar _typescript = require('../plugins/typescript');\n\n\n\n\n\n\n\n\n\n\n\n\nvar _tokenizer = require('../tokenizer');\nvar _keywords = require('../tokenizer/keywords');\nvar _state = require('../tokenizer/state');\nvar _types = require('../tokenizer/types');\nvar _charcodes = require('../util/charcodes');\nvar _base = require('./base');\n\n\n\n\n\n\n\n\n\n\n\n\nvar _expression = require('./expression');\n\n\n\n\n\nvar _lval = require('./lval');\n\n\n\n\n\n\n\n\n\n\n\n\nvar _util = require('./util');\n\n function parseTopLevel() {\n  parseBlockBody(_types.TokenType.eof);\n  _base.state.scopes.push(new (0, _state.Scope)(0, _base.state.tokens.length, true));\n  if (_base.state.scopeDepth !== 0) {\n    throw new Error(`Invalid scope depth at end of file: ${_base.state.scopeDepth}`);\n  }\n  return new (0, _index.File)(_base.state.tokens, _base.state.scopes);\n} exports.parseTopLevel = parseTopLevel;\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\n function parseStatement(declaration) {\n  if (_base.isFlowEnabled) {\n    if (_flow.flowTryParseStatement.call(void 0, )) {\n      return;\n    }\n  }\n  if (_tokenizer.match.call(void 0, _types.TokenType.at)) {\n    parseDecorators();\n  }\n  parseStatementContent(declaration);\n} exports.parseStatement = parseStatement;\n\nfunction parseStatementContent(declaration) {\n  if (_base.isTypeScriptEnabled) {\n    if (_typescript.tsTryParseStatementContent.call(void 0, )) {\n      return;\n    }\n  }\n\n  const starttype = _base.state.type;\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n    case _types.TokenType._break:\n    case _types.TokenType._continue:\n      parseBreakContinueStatement();\n      return;\n    case _types.TokenType._debugger:\n      parseDebuggerStatement();\n      return;\n    case _types.TokenType._do:\n      parseDoStatement();\n      return;\n    case _types.TokenType._for:\n      parseForStatement();\n      return;\n    case _types.TokenType._function:\n      if (_tokenizer.lookaheadType.call(void 0, ) === _types.TokenType.dot) break;\n      if (!declaration) _util.unexpected.call(void 0, );\n      parseFunctionStatement();\n      return;\n\n    case _types.TokenType._class:\n      if (!declaration) _util.unexpected.call(void 0, );\n      parseClass(true);\n      return;\n\n    case _types.TokenType._if:\n      parseIfStatement();\n      return;\n    case _types.TokenType._return:\n      parseReturnStatement();\n      return;\n    case _types.TokenType._switch:\n      parseSwitchStatement();\n      return;\n    case _types.TokenType._throw:\n      parseThrowStatement();\n      return;\n    case _types.TokenType._try:\n      parseTryStatement();\n      return;\n\n    case _types.TokenType._let:\n    case _types.TokenType._const:\n      if (!declaration) _util.unexpected.call(void 0, ); // NOTE: falls through to _var\n\n    case _types.TokenType._var:\n      parseVarStatement(starttype !== _types.TokenType._var);\n      return;\n\n    case _types.TokenType._while:\n      parseWhileStatement();\n      return;\n    case _types.TokenType.braceL:\n      parseBlock();\n      return;\n    case _types.TokenType.semi:\n      parseEmptyStatement();\n      return;\n    case _types.TokenType._export:\n    case _types.TokenType._import: {\n      const nextType = _tokenizer.lookaheadType.call(void 0, );\n      if (nextType === _types.TokenType.parenL || nextType === _types.TokenType.dot) {\n        break;\n      }\n      _tokenizer.next.call(void 0, );\n      if (starttype === _types.TokenType._import) {\n        parseImport();\n      } else {\n        parseExport();\n      }\n      return;\n    }\n    case _types.TokenType.name:\n      if (_base.state.contextualKeyword === _keywords.ContextualKeyword._async) {\n        const functionStart = _base.state.start;\n        // peek ahead and see if next token is a function\n        const snapshot = _base.state.snapshot();\n        _tokenizer.next.call(void 0, );\n        if (_tokenizer.match.call(void 0, _types.TokenType._function) && !_util.canInsertSemicolon.call(void 0, )) {\n          _util.expect.call(void 0, _types.TokenType._function);\n          parseFunction(functionStart, true);\n          return;\n        } else {\n          _base.state.restoreFromSnapshot(snapshot);\n        }\n      } else if (\n        _base.state.contextualKeyword === _keywords.ContextualKeyword._using &&\n        !_util.hasFollowingLineBreak.call(void 0, ) &&\n        // Statements like `using[0]` and `using in foo` aren't actual using\n        // declarations.\n        _tokenizer.lookaheadType.call(void 0, ) === _types.TokenType.name\n      ) {\n        parseVarStatement(true);\n        return;\n      }\n    default:\n      // Do nothing.\n      break;\n  }\n\n  // If the statement does not start with a statement keyword or a\n  // brace, it's an ExpressionStatement or LabeledStatement. We\n  // simply start parsing an expression, and afterwards, if the\n  // next token is a colon and the expression was a simple\n  // Identifier node, we switch to interpreting it as a label.\n  const initialTokensLength = _base.state.tokens.length;\n  _expression.parseExpression.call(void 0, );\n  let simpleName = null;\n  if (_base.state.tokens.length === initialTokensLength + 1) {\n    const token = _base.state.tokens[_base.state.tokens.length - 1];\n    if (token.type === _types.TokenType.name) {\n      simpleName = token.contextualKeyword;\n    }\n  }\n  if (simpleName == null) {\n    _util.semicolon.call(void 0, );\n    return;\n  }\n  if (_tokenizer.eat.call(void 0, _types.TokenType.colon)) {\n    parseLabeledStatement();\n  } else {\n    // This was an identifier, so we might want to handle flow/typescript-specific cases.\n    parseIdentifierStatement(simpleName);\n  }\n}\n\n function parseDecorators() {\n  while (_tokenizer.match.call(void 0, _types.TokenType.at)) {\n    parseDecorator();\n  }\n} exports.parseDecorators = parseDecorators;\n\nfunction parseDecorator() {\n  _tokenizer.next.call(void 0, );\n  if (_tokenizer.eat.call(void 0, _types.TokenType.parenL)) {\n    _expression.parseExpression.call(void 0, );\n    _util.expect.call(void 0, _types.TokenType.parenR);\n  } else {\n    _expression.parseIdentifier.call(void 0, );\n    while (_tokenizer.eat.call(void 0, _types.TokenType.dot)) {\n      _expression.parseIdentifier.call(void 0, );\n    }\n    parseMaybeDecoratorArguments();\n  }\n}\n\nfunction parseMaybeDecoratorArguments() {\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsParseMaybeDecoratorArguments.call(void 0, );\n  } else {\n    baseParseMaybeDecoratorArguments();\n  }\n}\n\n function baseParseMaybeDecoratorArguments() {\n  if (_tokenizer.eat.call(void 0, _types.TokenType.parenL)) {\n    _expression.parseCallExpressionArguments.call(void 0, );\n  }\n} exports.baseParseMaybeDecoratorArguments = baseParseMaybeDecoratorArguments;\n\nfunction parseBreakContinueStatement() {\n  _tokenizer.next.call(void 0, );\n  if (!_util.isLineTerminator.call(void 0, )) {\n    _expression.parseIdentifier.call(void 0, );\n    _util.semicolon.call(void 0, );\n  }\n}\n\nfunction parseDebuggerStatement() {\n  _tokenizer.next.call(void 0, );\n  _util.semicolon.call(void 0, );\n}\n\nfunction parseDoStatement() {\n  _tokenizer.next.call(void 0, );\n  parseStatement(false);\n  _util.expect.call(void 0, _types.TokenType._while);\n  _expression.parseParenExpression.call(void 0, );\n  _tokenizer.eat.call(void 0, _types.TokenType.semi);\n}\n\nfunction parseForStatement() {\n  _base.state.scopeDepth++;\n  const startTokenIndex = _base.state.tokens.length;\n  parseAmbiguousForStatement();\n  const endTokenIndex = _base.state.tokens.length;\n  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, false));\n  _base.state.scopeDepth--;\n}\n\n/**\n * Determine if this token is a `using` declaration (explicit resource\n * management) as part of a loop.\n * https://github.com/tc39/proposal-explicit-resource-management\n */\nfunction isUsingInLoop() {\n  if (!_util.isContextual.call(void 0, _keywords.ContextualKeyword._using)) {\n    return false;\n  }\n  // This must be `for (using of`, where `using` is the name of the loop\n  // variable.\n  if (_util.isLookaheadContextual.call(void 0, _keywords.ContextualKeyword._of)) {\n    return false;\n  }\n  return true;\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\nfunction parseAmbiguousForStatement() {\n  _tokenizer.next.call(void 0, );\n\n  let forAwait = false;\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._await)) {\n    forAwait = true;\n    _tokenizer.next.call(void 0, );\n  }\n  _util.expect.call(void 0, _types.TokenType.parenL);\n\n  if (_tokenizer.match.call(void 0, _types.TokenType.semi)) {\n    if (forAwait) {\n      _util.unexpected.call(void 0, );\n    }\n    parseFor();\n    return;\n  }\n\n  if (_tokenizer.match.call(void 0, _types.TokenType._var) || _tokenizer.match.call(void 0, _types.TokenType._let) || _tokenizer.match.call(void 0, _types.TokenType._const) || isUsingInLoop()) {\n    _tokenizer.next.call(void 0, );\n    parseVar(true, _base.state.type !== _types.TokenType._var);\n    if (_tokenizer.match.call(void 0, _types.TokenType._in) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._of)) {\n      parseForIn(forAwait);\n      return;\n    }\n    parseFor();\n    return;\n  }\n\n  _expression.parseExpression.call(void 0, true);\n  if (_tokenizer.match.call(void 0, _types.TokenType._in) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._of)) {\n    parseForIn(forAwait);\n    return;\n  }\n  if (forAwait) {\n    _util.unexpected.call(void 0, );\n  }\n  parseFor();\n}\n\nfunction parseFunctionStatement() {\n  const functionStart = _base.state.start;\n  _tokenizer.next.call(void 0, );\n  parseFunction(functionStart, true);\n}\n\nfunction parseIfStatement() {\n  _tokenizer.next.call(void 0, );\n  _expression.parseParenExpression.call(void 0, );\n  parseStatement(false);\n  if (_tokenizer.eat.call(void 0, _types.TokenType._else)) {\n    parseStatement(false);\n  }\n}\n\nfunction parseReturnStatement() {\n  _tokenizer.next.call(void 0, );\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (!_util.isLineTerminator.call(void 0, )) {\n    _expression.parseExpression.call(void 0, );\n    _util.semicolon.call(void 0, );\n  }\n}\n\nfunction parseSwitchStatement() {\n  _tokenizer.next.call(void 0, );\n  _expression.parseParenExpression.call(void 0, );\n  _base.state.scopeDepth++;\n  const startTokenIndex = _base.state.tokens.length;\n  _util.expect.call(void 0, _types.TokenType.braceL);\n\n  // Don't bother validation; just go through any sequence of cases, defaults, and statements.\n  while (!_tokenizer.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {\n    if (_tokenizer.match.call(void 0, _types.TokenType._case) || _tokenizer.match.call(void 0, _types.TokenType._default)) {\n      const isCase = _tokenizer.match.call(void 0, _types.TokenType._case);\n      _tokenizer.next.call(void 0, );\n      if (isCase) {\n        _expression.parseExpression.call(void 0, );\n      }\n      _util.expect.call(void 0, _types.TokenType.colon);\n    } else {\n      parseStatement(true);\n    }\n  }\n  _tokenizer.next.call(void 0, ); // Closing brace\n  const endTokenIndex = _base.state.tokens.length;\n  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, false));\n  _base.state.scopeDepth--;\n}\n\nfunction parseThrowStatement() {\n  _tokenizer.next.call(void 0, );\n  _expression.parseExpression.call(void 0, );\n  _util.semicolon.call(void 0, );\n}\n\nfunction parseCatchClauseParam() {\n  _lval.parseBindingAtom.call(void 0, true /* isBlockScope */);\n\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsTryParseTypeAnnotation.call(void 0, );\n  }\n}\n\nfunction parseTryStatement() {\n  _tokenizer.next.call(void 0, );\n\n  parseBlock();\n\n  if (_tokenizer.match.call(void 0, _types.TokenType._catch)) {\n    _tokenizer.next.call(void 0, );\n    let catchBindingStartTokenIndex = null;\n    if (_tokenizer.match.call(void 0, _types.TokenType.parenL)) {\n      _base.state.scopeDepth++;\n      catchBindingStartTokenIndex = _base.state.tokens.length;\n      _util.expect.call(void 0, _types.TokenType.parenL);\n      parseCatchClauseParam();\n      _util.expect.call(void 0, _types.TokenType.parenR);\n    }\n    parseBlock();\n    if (catchBindingStartTokenIndex != null) {\n      // We need a special scope for the catch binding which includes the binding itself and the\n      // catch block.\n      const endTokenIndex = _base.state.tokens.length;\n      _base.state.scopes.push(new (0, _state.Scope)(catchBindingStartTokenIndex, endTokenIndex, false));\n      _base.state.scopeDepth--;\n    }\n  }\n  if (_tokenizer.eat.call(void 0, _types.TokenType._finally)) {\n    parseBlock();\n  }\n}\n\n function parseVarStatement(isBlockScope) {\n  _tokenizer.next.call(void 0, );\n  parseVar(false, isBlockScope);\n  _util.semicolon.call(void 0, );\n} exports.parseVarStatement = parseVarStatement;\n\nfunction parseWhileStatement() {\n  _tokenizer.next.call(void 0, );\n  _expression.parseParenExpression.call(void 0, );\n  parseStatement(false);\n}\n\nfunction parseEmptyStatement() {\n  _tokenizer.next.call(void 0, );\n}\n\nfunction parseLabeledStatement() {\n  parseStatement(true);\n}\n\n/**\n * Parse a statement starting with an identifier of the given name. Subclasses match on the name\n * to handle statements like \"declare\".\n */\nfunction parseIdentifierStatement(contextualKeyword) {\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsParseIdentifierStatement.call(void 0, contextualKeyword);\n  } else if (_base.isFlowEnabled) {\n    _flow.flowParseIdentifierStatement.call(void 0, contextualKeyword);\n  } else {\n    _util.semicolon.call(void 0, );\n  }\n}\n\n// Parse a semicolon-enclosed block of statements.\n function parseBlock(isFunctionScope = false, contextId = 0) {\n  const startTokenIndex = _base.state.tokens.length;\n  _base.state.scopeDepth++;\n  _util.expect.call(void 0, _types.TokenType.braceL);\n  if (contextId) {\n    _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;\n  }\n  parseBlockBody(_types.TokenType.braceR);\n  if (contextId) {\n    _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;\n  }\n  const endTokenIndex = _base.state.tokens.length;\n  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, isFunctionScope));\n  _base.state.scopeDepth--;\n} exports.parseBlock = parseBlock;\n\n function parseBlockBody(end) {\n  while (!_tokenizer.eat.call(void 0, end) && !_base.state.error) {\n    parseStatement(true);\n  }\n} exports.parseBlockBody = parseBlockBody;\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\nfunction parseFor() {\n  _util.expect.call(void 0, _types.TokenType.semi);\n  if (!_tokenizer.match.call(void 0, _types.TokenType.semi)) {\n    _expression.parseExpression.call(void 0, );\n  }\n  _util.expect.call(void 0, _types.TokenType.semi);\n  if (!_tokenizer.match.call(void 0, _types.TokenType.parenR)) {\n    _expression.parseExpression.call(void 0, );\n  }\n  _util.expect.call(void 0, _types.TokenType.parenR);\n  parseStatement(false);\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\nfunction parseForIn(forAwait) {\n  if (forAwait) {\n    _util.eatContextual.call(void 0, _keywords.ContextualKeyword._of);\n  } else {\n    _tokenizer.next.call(void 0, );\n  }\n  _expression.parseExpression.call(void 0, );\n  _util.expect.call(void 0, _types.TokenType.parenR);\n  parseStatement(false);\n}\n\n// Parse a list of variable declarations.\n\nfunction parseVar(isFor, isBlockScope) {\n  while (true) {\n    parseVarHead(isBlockScope);\n    if (_tokenizer.eat.call(void 0, _types.TokenType.eq)) {\n      const eqIndex = _base.state.tokens.length - 1;\n      _expression.parseMaybeAssign.call(void 0, isFor);\n      _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;\n    }\n    if (!_tokenizer.eat.call(void 0, _types.TokenType.comma)) {\n      break;\n    }\n  }\n}\n\nfunction parseVarHead(isBlockScope) {\n  _lval.parseBindingAtom.call(void 0, isBlockScope);\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsAfterParseVarHead.call(void 0, );\n  } else if (_base.isFlowEnabled) {\n    _flow.flowAfterParseVarHead.call(void 0, );\n  }\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\n function parseFunction(\n  functionStart,\n  isStatement,\n  optionalId = false,\n) {\n  if (_tokenizer.match.call(void 0, _types.TokenType.star)) {\n    _tokenizer.next.call(void 0, );\n  }\n\n  if (isStatement && !optionalId && !_tokenizer.match.call(void 0, _types.TokenType.name) && !_tokenizer.match.call(void 0, _types.TokenType._yield)) {\n    _util.unexpected.call(void 0, );\n  }\n\n  let nameScopeStartTokenIndex = null;\n\n  if (_tokenizer.match.call(void 0, _types.TokenType.name)) {\n    // Expression-style functions should limit their name's scope to the function body, so we make\n    // a new function scope to enforce that.\n    if (!isStatement) {\n      nameScopeStartTokenIndex = _base.state.tokens.length;\n      _base.state.scopeDepth++;\n    }\n    _lval.parseBindingIdentifier.call(void 0, false);\n  }\n\n  const startTokenIndex = _base.state.tokens.length;\n  _base.state.scopeDepth++;\n  parseFunctionParams();\n  _expression.parseFunctionBodyAndFinish.call(void 0, functionStart);\n  const endTokenIndex = _base.state.tokens.length;\n  // In addition to the block scope of the function body, we need a separate function-style scope\n  // that includes the params.\n  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));\n  _base.state.scopeDepth--;\n  if (nameScopeStartTokenIndex !== null) {\n    _base.state.scopes.push(new (0, _state.Scope)(nameScopeStartTokenIndex, endTokenIndex, true));\n    _base.state.scopeDepth--;\n  }\n} exports.parseFunction = parseFunction;\n\n function parseFunctionParams(\n  allowModifiers = false,\n  funcContextId = 0,\n) {\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsStartParseFunctionParams.call(void 0, );\n  } else if (_base.isFlowEnabled) {\n    _flow.flowStartParseFunctionParams.call(void 0, );\n  }\n\n  _util.expect.call(void 0, _types.TokenType.parenL);\n  if (funcContextId) {\n    _base.state.tokens[_base.state.tokens.length - 1].contextId = funcContextId;\n  }\n  _lval.parseBindingList.call(void 0, \n    _types.TokenType.parenR,\n    false /* isBlockScope */,\n    false /* allowEmpty */,\n    allowModifiers,\n    funcContextId,\n  );\n  if (funcContextId) {\n    _base.state.tokens[_base.state.tokens.length - 1].contextId = funcContextId;\n  }\n} exports.parseFunctionParams = parseFunctionParams;\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\n function parseClass(isStatement, optionalId = false) {\n  // Put a context ID on the class keyword, the open-brace, and the close-brace, so that later\n  // code can easily navigate to meaningful points on the class.\n  const contextId = _base.getNextContextId.call(void 0, );\n\n  _tokenizer.next.call(void 0, );\n  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;\n  _base.state.tokens[_base.state.tokens.length - 1].isExpression = !isStatement;\n  // Like with functions, we declare a special \"name scope\" from the start of the name to the end\n  // of the class, but only with expression-style classes, to represent the fact that the name is\n  // available to the body of the class but not an outer declaration.\n  let nameScopeStartTokenIndex = null;\n  if (!isStatement) {\n    nameScopeStartTokenIndex = _base.state.tokens.length;\n    _base.state.scopeDepth++;\n  }\n  parseClassId(isStatement, optionalId);\n  parseClassSuper();\n  const openBraceIndex = _base.state.tokens.length;\n  parseClassBody(contextId);\n  if (_base.state.error) {\n    return;\n  }\n  _base.state.tokens[openBraceIndex].contextId = contextId;\n  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;\n  if (nameScopeStartTokenIndex !== null) {\n    const endTokenIndex = _base.state.tokens.length;\n    _base.state.scopes.push(new (0, _state.Scope)(nameScopeStartTokenIndex, endTokenIndex, false));\n    _base.state.scopeDepth--;\n  }\n} exports.parseClass = parseClass;\n\nfunction isClassProperty() {\n  return _tokenizer.match.call(void 0, _types.TokenType.eq) || _tokenizer.match.call(void 0, _types.TokenType.semi) || _tokenizer.match.call(void 0, _types.TokenType.braceR) || _tokenizer.match.call(void 0, _types.TokenType.bang) || _tokenizer.match.call(void 0, _types.TokenType.colon);\n}\n\nfunction isClassMethod() {\n  return _tokenizer.match.call(void 0, _types.TokenType.parenL) || _tokenizer.match.call(void 0, _types.TokenType.lessThan);\n}\n\nfunction parseClassBody(classContextId) {\n  _util.expect.call(void 0, _types.TokenType.braceL);\n\n  while (!_tokenizer.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {\n    if (_tokenizer.eat.call(void 0, _types.TokenType.semi)) {\n      continue;\n    }\n\n    if (_tokenizer.match.call(void 0, _types.TokenType.at)) {\n      parseDecorator();\n      continue;\n    }\n    const memberStart = _base.state.start;\n    parseClassMember(memberStart, classContextId);\n  }\n}\n\nfunction parseClassMember(memberStart, classContextId) {\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsParseModifiers.call(void 0, [\n      _keywords.ContextualKeyword._declare,\n      _keywords.ContextualKeyword._public,\n      _keywords.ContextualKeyword._protected,\n      _keywords.ContextualKeyword._private,\n      _keywords.ContextualKeyword._override,\n    ]);\n  }\n  let isStatic = false;\n  if (_tokenizer.match.call(void 0, _types.TokenType.name) && _base.state.contextualKeyword === _keywords.ContextualKeyword._static) {\n    _expression.parseIdentifier.call(void 0, ); // eats 'static'\n    if (isClassMethod()) {\n      parseClassMethod(memberStart, /* isConstructor */ false);\n      return;\n    } else if (isClassProperty()) {\n      parseClassProperty();\n      return;\n    }\n    // otherwise something static\n    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._static;\n    isStatic = true;\n\n    if (_tokenizer.match.call(void 0, _types.TokenType.braceL)) {\n      // This is a static block. Mark the word \"static\" with the class context ID for class element\n      // detection and parse as a regular block.\n      _base.state.tokens[_base.state.tokens.length - 1].contextId = classContextId;\n      parseBlock();\n      return;\n    }\n  }\n\n  parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);\n}\n\nfunction parseClassMemberWithIsStatic(\n  memberStart,\n  isStatic,\n  classContextId,\n) {\n  if (_base.isTypeScriptEnabled) {\n    if (_typescript.tsTryParseClassMemberWithIsStatic.call(void 0, isStatic)) {\n      return;\n    }\n  }\n  if (_tokenizer.eat.call(void 0, _types.TokenType.star)) {\n    // a generator\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */ false);\n    return;\n  }\n\n  // Get the identifier name so we can tell if it's actually a keyword like \"async\", \"get\", or\n  // \"set\".\n  parseClassPropertyName(classContextId);\n  let isConstructor = false;\n  const token = _base.state.tokens[_base.state.tokens.length - 1];\n  // We allow \"constructor\" as either an identifier or a string.\n  if (token.contextualKeyword === _keywords.ContextualKeyword._constructor) {\n    isConstructor = true;\n  }\n  parsePostMemberNameModifiers();\n\n  if (isClassMethod()) {\n    parseClassMethod(memberStart, isConstructor);\n  } else if (isClassProperty()) {\n    parseClassProperty();\n  } else if (token.contextualKeyword === _keywords.ContextualKeyword._async && !_util.isLineTerminator.call(void 0, )) {\n    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._async;\n    // an async method\n    const isGenerator = _tokenizer.match.call(void 0, _types.TokenType.star);\n    if (isGenerator) {\n      _tokenizer.next.call(void 0, );\n    }\n\n    // The so-called parsed name would have been \"async\": get the real name.\n    parseClassPropertyName(classContextId);\n    parsePostMemberNameModifiers();\n    parseClassMethod(memberStart, false /* isConstructor */);\n  } else if (\n    (token.contextualKeyword === _keywords.ContextualKeyword._get ||\n      token.contextualKeyword === _keywords.ContextualKeyword._set) &&\n    !(_util.isLineTerminator.call(void 0, ) && _tokenizer.match.call(void 0, _types.TokenType.star))\n  ) {\n    if (token.contextualKeyword === _keywords.ContextualKeyword._get) {\n      _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._get;\n    } else {\n      _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._set;\n    }\n    // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n    // a getter or setter\n    // The so-called parsed name would have been \"get/set\": get the real name.\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */ false);\n  } else if (token.contextualKeyword === _keywords.ContextualKeyword._accessor && !_util.isLineTerminator.call(void 0, )) {\n    parseClassPropertyName(classContextId);\n    parseClassProperty();\n  } else if (_util.isLineTerminator.call(void 0, )) {\n    // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n    parseClassProperty();\n  } else {\n    _util.unexpected.call(void 0, );\n  }\n}\n\nfunction parseClassMethod(functionStart, isConstructor) {\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsTryParseTypeParameters.call(void 0, );\n  } else if (_base.isFlowEnabled) {\n    if (_tokenizer.match.call(void 0, _types.TokenType.lessThan)) {\n      _flow.flowParseTypeParameterDeclaration.call(void 0, );\n    }\n  }\n  _expression.parseMethod.call(void 0, functionStart, isConstructor);\n}\n\n// Return the name of the class property, if it is a simple identifier.\n function parseClassPropertyName(classContextId) {\n  _expression.parsePropertyName.call(void 0, classContextId);\n} exports.parseClassPropertyName = parseClassPropertyName;\n\n function parsePostMemberNameModifiers() {\n  if (_base.isTypeScriptEnabled) {\n    const oldIsType = _tokenizer.pushTypeContext.call(void 0, 0);\n    _tokenizer.eat.call(void 0, _types.TokenType.question);\n    _tokenizer.popTypeContext.call(void 0, oldIsType);\n  }\n} exports.parsePostMemberNameModifiers = parsePostMemberNameModifiers;\n\n function parseClassProperty() {\n  if (_base.isTypeScriptEnabled) {\n    _tokenizer.eatTypeToken.call(void 0, _types.TokenType.bang);\n    _typescript.tsTryParseTypeAnnotation.call(void 0, );\n  } else if (_base.isFlowEnabled) {\n    if (_tokenizer.match.call(void 0, _types.TokenType.colon)) {\n      _flow.flowParseTypeAnnotation.call(void 0, );\n    }\n  }\n\n  if (_tokenizer.match.call(void 0, _types.TokenType.eq)) {\n    const equalsTokenIndex = _base.state.tokens.length;\n    _tokenizer.next.call(void 0, );\n    _expression.parseMaybeAssign.call(void 0, );\n    _base.state.tokens[equalsTokenIndex].rhsEndIndex = _base.state.tokens.length;\n  }\n  _util.semicolon.call(void 0, );\n} exports.parseClassProperty = parseClassProperty;\n\nfunction parseClassId(isStatement, optionalId = false) {\n  if (\n    _base.isTypeScriptEnabled &&\n    (!isStatement || optionalId) &&\n    _util.isContextual.call(void 0, _keywords.ContextualKeyword._implements)\n  ) {\n    return;\n  }\n\n  if (_tokenizer.match.call(void 0, _types.TokenType.name)) {\n    _lval.parseBindingIdentifier.call(void 0, true);\n  }\n\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsTryParseTypeParameters.call(void 0, );\n  } else if (_base.isFlowEnabled) {\n    if (_tokenizer.match.call(void 0, _types.TokenType.lessThan)) {\n      _flow.flowParseTypeParameterDeclaration.call(void 0, );\n    }\n  }\n}\n\n// Returns true if there was a superclass.\nfunction parseClassSuper() {\n  let hasSuper = false;\n  if (_tokenizer.eat.call(void 0, _types.TokenType._extends)) {\n    _expression.parseExprSubscripts.call(void 0, );\n    hasSuper = true;\n  } else {\n    hasSuper = false;\n  }\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsAfterParseClassSuper.call(void 0, hasSuper);\n  } else if (_base.isFlowEnabled) {\n    _flow.flowAfterParseClassSuper.call(void 0, hasSuper);\n  }\n}\n\n// Parses module export declaration.\n\n function parseExport() {\n  const exportIndex = _base.state.tokens.length - 1;\n  if (_base.isTypeScriptEnabled) {\n    if (_typescript.tsTryParseExport.call(void 0, )) {\n      return;\n    }\n  }\n  // export * from '...'\n  if (shouldParseExportStar()) {\n    parseExportStar();\n  } else if (isExportDefaultSpecifier()) {\n    // export default from\n    _expression.parseIdentifier.call(void 0, );\n    if (_tokenizer.match.call(void 0, _types.TokenType.comma) && _tokenizer.lookaheadType.call(void 0, ) === _types.TokenType.star) {\n      _util.expect.call(void 0, _types.TokenType.comma);\n      _util.expect.call(void 0, _types.TokenType.star);\n      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._as);\n      _expression.parseIdentifier.call(void 0, );\n    } else {\n      parseExportSpecifiersMaybe();\n    }\n    parseExportFrom();\n  } else if (_tokenizer.eat.call(void 0, _types.TokenType._default)) {\n    // export default ...\n    parseExportDefaultExpression();\n  } else if (shouldParseExportDeclaration()) {\n    parseExportDeclaration();\n  } else {\n    // export { x, y as z } [from '...']\n    parseExportSpecifiers();\n    parseExportFrom();\n  }\n  _base.state.tokens[exportIndex].rhsEndIndex = _base.state.tokens.length;\n} exports.parseExport = parseExport;\n\nfunction parseExportDefaultExpression() {\n  if (_base.isTypeScriptEnabled) {\n    if (_typescript.tsTryParseExportDefaultExpression.call(void 0, )) {\n      return;\n    }\n  }\n  if (_base.isFlowEnabled) {\n    if (_flow.flowTryParseExportDefaultExpression.call(void 0, )) {\n      return;\n    }\n  }\n  const functionStart = _base.state.start;\n  if (_tokenizer.eat.call(void 0, _types.TokenType._function)) {\n    parseFunction(functionStart, true, true);\n  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._async) && _tokenizer.lookaheadType.call(void 0, ) === _types.TokenType._function) {\n    // async function declaration\n    _util.eatContextual.call(void 0, _keywords.ContextualKeyword._async);\n    _tokenizer.eat.call(void 0, _types.TokenType._function);\n    parseFunction(functionStart, true, true);\n  } else if (_tokenizer.match.call(void 0, _types.TokenType._class)) {\n    parseClass(true, true);\n  } else if (_tokenizer.match.call(void 0, _types.TokenType.at)) {\n    parseDecorators();\n    parseClass(true, true);\n  } else {\n    _expression.parseMaybeAssign.call(void 0, );\n    _util.semicolon.call(void 0, );\n  }\n}\n\nfunction parseExportDeclaration() {\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsParseExportDeclaration.call(void 0, );\n  } else if (_base.isFlowEnabled) {\n    _flow.flowParseExportDeclaration.call(void 0, );\n  } else {\n    parseStatement(true);\n  }\n}\n\nfunction isExportDefaultSpecifier() {\n  if (_base.isTypeScriptEnabled && _typescript.tsIsDeclarationStart.call(void 0, )) {\n    return false;\n  } else if (_base.isFlowEnabled && _flow.flowShouldDisallowExportDefaultSpecifier.call(void 0, )) {\n    return false;\n  }\n  if (_tokenizer.match.call(void 0, _types.TokenType.name)) {\n    return _base.state.contextualKeyword !== _keywords.ContextualKeyword._async;\n  }\n\n  if (!_tokenizer.match.call(void 0, _types.TokenType._default)) {\n    return false;\n  }\n\n  const _next = _tokenizer.nextTokenStart.call(void 0, );\n  const lookahead = _tokenizer.lookaheadTypeAndKeyword.call(void 0, );\n  const hasFrom =\n    lookahead.type === _types.TokenType.name && lookahead.contextualKeyword === _keywords.ContextualKeyword._from;\n  if (lookahead.type === _types.TokenType.comma) {\n    return true;\n  }\n  // lookahead again when `export default from` is seen\n  if (hasFrom) {\n    const nextAfterFrom = _base.input.charCodeAt(_tokenizer.nextTokenStartSince.call(void 0, _next + 4));\n    return nextAfterFrom === _charcodes.charCodes.quotationMark || nextAfterFrom === _charcodes.charCodes.apostrophe;\n  }\n  return false;\n}\n\nfunction parseExportSpecifiersMaybe() {\n  if (_tokenizer.eat.call(void 0, _types.TokenType.comma)) {\n    parseExportSpecifiers();\n  }\n}\n\n function parseExportFrom() {\n  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._from)) {\n    _expression.parseExprAtom.call(void 0, );\n    maybeParseImportAssertions();\n  }\n  _util.semicolon.call(void 0, );\n} exports.parseExportFrom = parseExportFrom;\n\nfunction shouldParseExportStar() {\n  if (_base.isFlowEnabled) {\n    return _flow.flowShouldParseExportStar.call(void 0, );\n  } else {\n    return _tokenizer.match.call(void 0, _types.TokenType.star);\n  }\n}\n\nfunction parseExportStar() {\n  if (_base.isFlowEnabled) {\n    _flow.flowParseExportStar.call(void 0, );\n  } else {\n    baseParseExportStar();\n  }\n}\n\n function baseParseExportStar() {\n  _util.expect.call(void 0, _types.TokenType.star);\n\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._as)) {\n    parseExportNamespace();\n  } else {\n    parseExportFrom();\n  }\n} exports.baseParseExportStar = baseParseExportStar;\n\nfunction parseExportNamespace() {\n  _tokenizer.next.call(void 0, );\n  _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._as;\n  _expression.parseIdentifier.call(void 0, );\n  parseExportSpecifiersMaybe();\n  parseExportFrom();\n}\n\nfunction shouldParseExportDeclaration() {\n  return (\n    (_base.isTypeScriptEnabled && _typescript.tsIsDeclarationStart.call(void 0, )) ||\n    (_base.isFlowEnabled && _flow.flowShouldParseExportDeclaration.call(void 0, )) ||\n    _base.state.type === _types.TokenType._var ||\n    _base.state.type === _types.TokenType._const ||\n    _base.state.type === _types.TokenType._let ||\n    _base.state.type === _types.TokenType._function ||\n    _base.state.type === _types.TokenType._class ||\n    _util.isContextual.call(void 0, _keywords.ContextualKeyword._async) ||\n    _tokenizer.match.call(void 0, _types.TokenType.at)\n  );\n}\n\n// Parses a comma-separated list of module exports.\n function parseExportSpecifiers() {\n  let first = true;\n\n  // export { x, y as z } [from '...']\n  _util.expect.call(void 0, _types.TokenType.braceL);\n\n  while (!_tokenizer.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {\n    if (first) {\n      first = false;\n    } else {\n      _util.expect.call(void 0, _types.TokenType.comma);\n      if (_tokenizer.eat.call(void 0, _types.TokenType.braceR)) {\n        break;\n      }\n    }\n    parseExportSpecifier();\n  }\n} exports.parseExportSpecifiers = parseExportSpecifiers;\n\nfunction parseExportSpecifier() {\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsParseExportSpecifier.call(void 0, );\n    return;\n  }\n  _expression.parseIdentifier.call(void 0, );\n  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _tokenizer.IdentifierRole.ExportAccess;\n  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as)) {\n    _expression.parseIdentifier.call(void 0, );\n  }\n}\n\n/**\n * Starting at the `module` token in an import, determine if it was truly an\n * import reflection token or just looks like one.\n *\n * Returns true for:\n * import module foo from \"foo\";\n * import module from from \"foo\";\n *\n * Returns false for:\n * import module from \"foo\";\n * import module, {bar} from \"foo\";\n */\nfunction isImportReflection() {\n  const snapshot = _base.state.snapshot();\n  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._module);\n  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._from)) {\n    if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._from)) {\n      _base.state.restoreFromSnapshot(snapshot);\n      return true;\n    } else {\n      _base.state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  } else if (_tokenizer.match.call(void 0, _types.TokenType.comma)) {\n    _base.state.restoreFromSnapshot(snapshot);\n    return false;\n  } else {\n    _base.state.restoreFromSnapshot(snapshot);\n    return true;\n  }\n}\n\n/**\n * Eat the \"module\" token from the import reflection proposal.\n * https://github.com/tc39/proposal-import-reflection\n */\nfunction parseMaybeImportReflection() {\n  // isImportReflection does snapshot/restore, so only run it if we see the word\n  // \"module\".\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._module) && isImportReflection()) {\n    _tokenizer.next.call(void 0, );\n  }\n}\n\n// Parses import declaration.\n\n function parseImport() {\n  if (_base.isTypeScriptEnabled && _tokenizer.match.call(void 0, _types.TokenType.name) && _tokenizer.lookaheadType.call(void 0, ) === _types.TokenType.eq) {\n    _typescript.tsParseImportEqualsDeclaration.call(void 0, );\n    return;\n  }\n  if (_base.isTypeScriptEnabled && _util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {\n    const lookahead = _tokenizer.lookaheadTypeAndKeyword.call(void 0, );\n    if (lookahead.type === _types.TokenType.name && lookahead.contextualKeyword !== _keywords.ContextualKeyword._from) {\n      // One of these `import type` cases:\n      // import type T = require('T');\n      // import type A from 'A';\n      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);\n      if (_tokenizer.lookaheadType.call(void 0, ) === _types.TokenType.eq) {\n        _typescript.tsParseImportEqualsDeclaration.call(void 0, );\n        return;\n      }\n      // If this is an `import type...from` statement, then we already ate the\n      // type token, so proceed to the regular import parser.\n    } else if (lookahead.type === _types.TokenType.star || lookahead.type === _types.TokenType.braceL) {\n      // One of these `import type` cases, in which case we can eat the type token\n      // and proceed as normal:\n      // import type * as A from 'A';\n      // import type {a} from 'A';\n      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);\n    }\n    // Otherwise, we are importing the name \"type\".\n  }\n\n  // import '...'\n  if (_tokenizer.match.call(void 0, _types.TokenType.string)) {\n    _expression.parseExprAtom.call(void 0, );\n  } else {\n    parseMaybeImportReflection();\n    parseImportSpecifiers();\n    _util.expectContextual.call(void 0, _keywords.ContextualKeyword._from);\n    _expression.parseExprAtom.call(void 0, );\n  }\n  maybeParseImportAssertions();\n  _util.semicolon.call(void 0, );\n} exports.parseImport = parseImport;\n\n// eslint-disable-next-line no-unused-vars\nfunction shouldParseDefaultImport() {\n  return _tokenizer.match.call(void 0, _types.TokenType.name);\n}\n\nfunction parseImportSpecifierLocal() {\n  _lval.parseImportedIdentifier.call(void 0, );\n}\n\n// Parses a comma-separated list of module imports.\nfunction parseImportSpecifiers() {\n  if (_base.isFlowEnabled) {\n    _flow.flowStartParseImportSpecifiers.call(void 0, );\n  }\n\n  let first = true;\n  if (shouldParseDefaultImport()) {\n    // import defaultObj, { x, y as z } from '...'\n    parseImportSpecifierLocal();\n\n    if (!_tokenizer.eat.call(void 0, _types.TokenType.comma)) return;\n  }\n\n  if (_tokenizer.match.call(void 0, _types.TokenType.star)) {\n    _tokenizer.next.call(void 0, );\n    _util.expectContextual.call(void 0, _keywords.ContextualKeyword._as);\n\n    parseImportSpecifierLocal();\n\n    return;\n  }\n\n  _util.expect.call(void 0, _types.TokenType.braceL);\n  while (!_tokenizer.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {\n    if (first) {\n      first = false;\n    } else {\n      // Detect an attempt to deep destructure\n      if (_tokenizer.eat.call(void 0, _types.TokenType.colon)) {\n        _util.unexpected.call(void 0, \n          \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n        );\n      }\n\n      _util.expect.call(void 0, _types.TokenType.comma);\n      if (_tokenizer.eat.call(void 0, _types.TokenType.braceR)) {\n        break;\n      }\n    }\n\n    parseImportSpecifier();\n  }\n}\n\nfunction parseImportSpecifier() {\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsParseImportSpecifier.call(void 0, );\n    return;\n  }\n  if (_base.isFlowEnabled) {\n    _flow.flowParseImportSpecifier.call(void 0, );\n    return;\n  }\n  _lval.parseImportedIdentifier.call(void 0, );\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._as)) {\n    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _tokenizer.IdentifierRole.ImportAccess;\n    _tokenizer.next.call(void 0, );\n    _lval.parseImportedIdentifier.call(void 0, );\n  }\n}\n\n/**\n * Parse import assertions like `assert {type: \"json\"}`.\n *\n * Import assertions technically have their own syntax, but are always parseable\n * as a plain JS object, so just do that for simplicity.\n */\nfunction maybeParseImportAssertions() {\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._assert) && !_util.hasPrecedingLineBreak.call(void 0, )) {\n    _tokenizer.next.call(void 0, );\n    _expression.parseObj.call(void 0, false, false);\n  }\n}\n"]}}