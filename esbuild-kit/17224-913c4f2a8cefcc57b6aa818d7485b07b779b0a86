{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interopRequireDefault,\"_interopRequireDefault\");var _types=require(\"../parser/tokenizer/types\");var _getImportExportSpecifierInfo=require(\"./getImportExportSpecifierInfo\");var _getImportExportSpecifierInfo2=_interopRequireDefault(_getImportExportSpecifierInfo);function getTSImportedNames(tokens){const importedNames=new Set;for(let i=0;i<tokens.tokens.length;i++){if(tokens.matches1AtIndex(i,_types.TokenType._import)&&!tokens.matches3AtIndex(i,_types.TokenType._import,_types.TokenType.name,_types.TokenType.eq)){collectNamesForImport(tokens,i,importedNames)}}return importedNames}__name(getTSImportedNames,\"getTSImportedNames\");exports.default=getTSImportedNames;function collectNamesForImport(tokens,index,importedNames){index++;if(tokens.matches1AtIndex(index,_types.TokenType.parenL)){return}if(tokens.matches1AtIndex(index,_types.TokenType.name)){importedNames.add(tokens.identifierNameAtIndex(index));index++;if(tokens.matches1AtIndex(index,_types.TokenType.comma)){index++}}if(tokens.matches1AtIndex(index,_types.TokenType.star)){index+=2;importedNames.add(tokens.identifierNameAtIndex(index));index++}if(tokens.matches1AtIndex(index,_types.TokenType.braceL)){index++;collectNamesForNamedImport(tokens,index,importedNames)}}__name(collectNamesForImport,\"collectNamesForImport\");function collectNamesForNamedImport(tokens,index,importedNames){while(true){if(tokens.matches1AtIndex(index,_types.TokenType.braceR)){return}const specifierInfo=_getImportExportSpecifierInfo2.default.call(void 0,tokens,index);index=specifierInfo.endIndex;if(!specifierInfo.isType){importedNames.add(specifierInfo.rightName)}if(tokens.matches2AtIndex(index,_types.TokenType.comma,_types.TokenType.braceR)){return}else if(tokens.matches1AtIndex(index,_types.TokenType.braceR)){return}else if(tokens.matches1AtIndex(index,_types.TokenType.comma)){index++}else{throw new Error(`Unexpected token: ${JSON.stringify(tokens.tokens[index])}`)}}}__name(collectNamesForNamedImport,\"collectNamesForNamedImport\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAG,SAAS,uBAAuB,IAAK,CAAE,OAAO,KAAO,IAAI,WAAa,IAAM,CAAE,QAAS,GAAI,CAAG,CAArF,wDAAsF,IAAI,OAAS,QAAQ,2BAA2B,EAEzN,IAAI,8BAAgC,QAAQ,gCAAgC,EAAG,IAAI,+BAAiC,uBAAuB,6BAA6B,EASvK,SAAS,mBAAmB,OAAQ,CACnC,MAAM,cAAgB,IAAI,IAC1B,QAAS,EAAI,EAAG,EAAI,OAAO,OAAO,OAAQ,IAAK,CAC7C,GACE,OAAO,gBAAgB,EAAG,OAAO,UAAU,OAAO,GAClD,CAAC,OAAO,gBAAgB,EAAG,OAAO,UAAU,QAAS,OAAO,UAAU,KAAM,OAAO,UAAU,EAAE,EAC/F,CACA,sBAAsB,OAAQ,EAAG,aAAa,CAChD,CACF,CACA,OAAO,aACT,CAXU,gDAWR,QAAQ,QAAU,mBAEpB,SAAS,sBACP,OACA,MACA,cACA,CACA,QAEA,GAAI,OAAO,gBAAgB,MAAO,OAAO,UAAU,MAAM,EAAG,CAE1D,MACF,CAEA,GAAI,OAAO,gBAAgB,MAAO,OAAO,UAAU,IAAI,EAAG,CACxD,cAAc,IAAI,OAAO,sBAAsB,KAAK,CAAC,EACrD,QACA,GAAI,OAAO,gBAAgB,MAAO,OAAO,UAAU,KAAK,EAAG,CACzD,OACF,CACF,CAEA,GAAI,OAAO,gBAAgB,MAAO,OAAO,UAAU,IAAI,EAAG,CAExD,OAAS,EACT,cAAc,IAAI,OAAO,sBAAsB,KAAK,CAAC,EACrD,OACF,CAEA,GAAI,OAAO,gBAAgB,MAAO,OAAO,UAAU,MAAM,EAAG,CAC1D,QACA,2BAA2B,OAAQ,MAAO,aAAa,CACzD,CACF,CA/BS,sDAiCT,SAAS,2BACP,OACA,MACA,cACA,CACA,MAAO,KAAM,CACX,GAAI,OAAO,gBAAgB,MAAO,OAAO,UAAU,MAAM,EAAG,CAC1D,MACF,CAEA,MAAM,cAAgB,+BAA+B,QAAQ,KAAK,OAAQ,OAAQ,KAAK,EACvF,MAAQ,cAAc,SACtB,GAAI,CAAC,cAAc,OAAQ,CACzB,cAAc,IAAI,cAAc,SAAS,CAC3C,CAEA,GAAI,OAAO,gBAAgB,MAAO,OAAO,UAAU,MAAO,OAAO,UAAU,MAAM,EAAG,CAClF,MACF,SAAW,OAAO,gBAAgB,MAAO,OAAO,UAAU,MAAM,EAAG,CACjE,MACF,SAAW,OAAO,gBAAgB,MAAO,OAAO,UAAU,KAAK,EAAG,CAChE,OACF,KAAO,CACL,MAAM,IAAI,MAAM,qBAAqB,KAAK,UAAU,OAAO,OAAO,KAAK,CAAC,GAAG,CAC7E,CACF,CACF,CA1BS","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/util/getTSImportedNames.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var _types = require('../parser/tokenizer/types');\n\nvar _getImportExportSpecifierInfo = require('./getImportExportSpecifierInfo'); var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);\n\n/**\n * Special case code to scan for imported names in ESM TypeScript. We need to do this so we can\n * properly get globals so we can compute shadowed globals.\n *\n * This is similar to logic in CJSImportProcessor, but trimmed down to avoid logic with CJS\n * replacement and flow type imports.\n */\n function getTSImportedNames(tokens) {\n  const importedNames = new Set();\n  for (let i = 0; i < tokens.tokens.length; i++) {\n    if (\n      tokens.matches1AtIndex(i, _types.TokenType._import) &&\n      !tokens.matches3AtIndex(i, _types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)\n    ) {\n      collectNamesForImport(tokens, i, importedNames);\n    }\n  }\n  return importedNames;\n} exports.default = getTSImportedNames;\n\nfunction collectNamesForImport(\n  tokens,\n  index,\n  importedNames,\n) {\n  index++;\n\n  if (tokens.matches1AtIndex(index, _types.TokenType.parenL)) {\n    // Dynamic import, so nothing to do\n    return;\n  }\n\n  if (tokens.matches1AtIndex(index, _types.TokenType.name)) {\n    importedNames.add(tokens.identifierNameAtIndex(index));\n    index++;\n    if (tokens.matches1AtIndex(index, _types.TokenType.comma)) {\n      index++;\n    }\n  }\n\n  if (tokens.matches1AtIndex(index, _types.TokenType.star)) {\n    // * as\n    index += 2;\n    importedNames.add(tokens.identifierNameAtIndex(index));\n    index++;\n  }\n\n  if (tokens.matches1AtIndex(index, _types.TokenType.braceL)) {\n    index++;\n    collectNamesForNamedImport(tokens, index, importedNames);\n  }\n}\n\nfunction collectNamesForNamedImport(\n  tokens,\n  index,\n  importedNames,\n) {\n  while (true) {\n    if (tokens.matches1AtIndex(index, _types.TokenType.braceR)) {\n      return;\n    }\n\n    const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, tokens, index);\n    index = specifierInfo.endIndex;\n    if (!specifierInfo.isType) {\n      importedNames.add(specifierInfo.rightName);\n    }\n\n    if (tokens.matches2AtIndex(index, _types.TokenType.comma, _types.TokenType.braceR)) {\n      return;\n    } else if (tokens.matches1AtIndex(index, _types.TokenType.braceR)) {\n      return;\n    } else if (tokens.matches1AtIndex(index, _types.TokenType.comma)) {\n      index++;\n    } else {\n      throw new Error(`Unexpected token: ${JSON.stringify(tokens.tokens[index])}`);\n    }\n  }\n}\n"]}}