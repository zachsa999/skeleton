{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const DEFAULT_RAW={colon:\": \",indent:\"    \",beforeDecl:\"\\n\",beforeRule:\"\\n\",beforeOpen:\" \",beforeClose:\"\\n\",beforeComment:\"\\n\",after:\"\\n\",emptyBody:\"\",commentLeft:\" \",commentRight:\" \",semicolon:false};function capitalize(str){return str[0].toUpperCase()+str.slice(1)}__name(capitalize,\"capitalize\");class Stringifier{constructor(builder){this.builder=builder}stringify(node,semicolon){if(!this[node.type]){throw new Error(\"Unknown AST node type \"+node.type+\". Maybe you need to change PostCSS stringifier.\")}this[node.type](node,semicolon)}document(node){this.body(node)}root(node){this.body(node);if(node.raws.after)this.builder(node.raws.after)}comment(node){let left=this.raw(node,\"left\",\"commentLeft\");let right=this.raw(node,\"right\",\"commentRight\");this.builder(\"/*\"+left+node.text+right+\"*/\",node)}decl(node,semicolon){let between=this.raw(node,\"between\",\"colon\");let string=node.prop+between+this.rawValue(node,\"value\");if(node.important){string+=node.raws.important||\" !important\"}if(semicolon)string+=\";\";this.builder(string,node)}rule(node){this.block(node,this.rawValue(node,\"selector\"));if(node.raws.ownSemicolon){this.builder(node.raws.ownSemicolon,node,\"end\")}}atrule(node,semicolon){let name=\"@\"+node.name;let params=node.params?this.rawValue(node,\"params\"):\"\";if(typeof node.raws.afterName!==\"undefined\"){name+=node.raws.afterName}else if(params){name+=\" \"}if(node.nodes){this.block(node,name+params)}else{let end=(node.raws.between||\"\")+(semicolon?\";\":\"\");this.builder(name+params+end,node)}}body(node){let last=node.nodes.length-1;while(last>0){if(node.nodes[last].type!==\"comment\")break;last-=1}let semicolon=this.raw(node,\"semicolon\");for(let i=0;i<node.nodes.length;i++){let child=node.nodes[i];let before=this.raw(child,\"before\");if(before)this.builder(before);this.stringify(child,last!==i||semicolon)}}block(node,start){let between=this.raw(node,\"between\",\"beforeOpen\");this.builder(start+between+\"{\",node,\"start\");let after;if(node.nodes&&node.nodes.length){this.body(node);after=this.raw(node,\"after\")}else{after=this.raw(node,\"after\",\"emptyBody\")}if(after)this.builder(after);this.builder(\"}\",node,\"end\")}raw(node,own,detect){let value;if(!detect)detect=own;if(own){value=node.raws[own];if(typeof value!==\"undefined\")return value}let parent=node.parent;if(detect===\"before\"){if(!parent||parent.type===\"root\"&&parent.first===node){return\"\"}if(parent&&parent.type===\"document\"){return\"\"}}if(!parent)return DEFAULT_RAW[detect];let root=node.root();if(!root.rawCache)root.rawCache={};if(typeof root.rawCache[detect]!==\"undefined\"){return root.rawCache[detect]}if(detect===\"before\"||detect===\"after\"){return this.beforeAfter(node,detect)}else{let method=\"raw\"+capitalize(detect);if(this[method]){value=this[method](root,node)}else{root.walk(i=>{value=i.raws[own];if(typeof value!==\"undefined\")return false})}}if(typeof value===\"undefined\")value=DEFAULT_RAW[detect];root.rawCache[detect]=value;return value}rawSemicolon(root){let value;root.walk(i=>{if(i.nodes&&i.nodes.length&&i.last.type===\"decl\"){value=i.raws.semicolon;if(typeof value!==\"undefined\")return false}});return value}rawEmptyBody(root){let value;root.walk(i=>{if(i.nodes&&i.nodes.length===0){value=i.raws.after;if(typeof value!==\"undefined\")return false}});return value}rawIndent(root){if(root.raws.indent)return root.raws.indent;let value;root.walk(i=>{let p=i.parent;if(p&&p!==root&&p.parent&&p.parent===root){if(typeof i.raws.before!==\"undefined\"){let parts=i.raws.before.split(\"\\n\");value=parts[parts.length-1];value=value.replace(/\\S/g,\"\");return false}}});return value}rawBeforeComment(root,node){let value;root.walkComments(i=>{if(typeof i.raws.before!==\"undefined\"){value=i.raws.before;if(value.includes(\"\\n\")){value=value.replace(/[^\\n]+$/,\"\")}return false}});if(typeof value===\"undefined\"){value=this.raw(node,null,\"beforeDecl\")}else if(value){value=value.replace(/\\S/g,\"\")}return value}rawBeforeDecl(root,node){let value;root.walkDecls(i=>{if(typeof i.raws.before!==\"undefined\"){value=i.raws.before;if(value.includes(\"\\n\")){value=value.replace(/[^\\n]+$/,\"\")}return false}});if(typeof value===\"undefined\"){value=this.raw(node,null,\"beforeRule\")}else if(value){value=value.replace(/\\S/g,\"\")}return value}rawBeforeRule(root){let value;root.walk(i=>{if(i.nodes&&(i.parent!==root||root.first!==i)){if(typeof i.raws.before!==\"undefined\"){value=i.raws.before;if(value.includes(\"\\n\")){value=value.replace(/[^\\n]+$/,\"\")}return false}}});if(value)value=value.replace(/\\S/g,\"\");return value}rawBeforeClose(root){let value;root.walk(i=>{if(i.nodes&&i.nodes.length>0){if(typeof i.raws.after!==\"undefined\"){value=i.raws.after;if(value.includes(\"\\n\")){value=value.replace(/[^\\n]+$/,\"\")}return false}}});if(value)value=value.replace(/\\S/g,\"\");return value}rawBeforeOpen(root){let value;root.walk(i=>{if(i.type!==\"decl\"){value=i.raws.between;if(typeof value!==\"undefined\")return false}});return value}rawColon(root){let value;root.walkDecls(i=>{if(typeof i.raws.between!==\"undefined\"){value=i.raws.between.replace(/[^\\s:]/g,\"\");return false}});return value}beforeAfter(node,detect){let value;if(node.type===\"decl\"){value=this.raw(node,null,\"beforeDecl\")}else if(node.type===\"comment\"){value=this.raw(node,null,\"beforeComment\")}else if(detect===\"before\"){value=this.raw(node,null,\"beforeRule\")}else{value=this.raw(node,null,\"beforeClose\")}let buf=node.parent;let depth=0;while(buf&&buf.type!==\"root\"){depth+=1;buf=buf.parent}if(value.includes(\"\\n\")){let indent=this.raw(node,null,\"indent\");if(indent.length){for(let step=0;step<depth;step++)value+=indent}}return value}rawValue(node,prop){let value=node[prop];let raw=node.raws[prop];if(raw&&raw.value===value){return raw.raw}return value}}__name(Stringifier,\"Stringifier\");module.exports=Stringifier;Stringifier.default=Stringifier;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/postcss@8.4.24/node_modules/postcss/lib/stringifier.js"],"sourcesContent":["'use strict'\n\nconst DEFAULT_RAW = {\n  colon: ': ',\n  indent: '    ',\n  beforeDecl: '\\n',\n  beforeRule: '\\n',\n  beforeOpen: ' ',\n  beforeClose: '\\n',\n  beforeComment: '\\n',\n  after: '\\n',\n  emptyBody: '',\n  commentLeft: ' ',\n  commentRight: ' ',\n  semicolon: false\n}\n\nfunction capitalize(str) {\n  return str[0].toUpperCase() + str.slice(1)\n}\n\nclass Stringifier {\n  constructor(builder) {\n    this.builder = builder\n  }\n\n  stringify(node, semicolon) {\n    /* c8 ignore start */\n    if (!this[node.type]) {\n      throw new Error(\n        'Unknown AST node type ' +\n          node.type +\n          '. ' +\n          'Maybe you need to change PostCSS stringifier.'\n      )\n    }\n    /* c8 ignore stop */\n    this[node.type](node, semicolon)\n  }\n\n  document(node) {\n    this.body(node)\n  }\n\n  root(node) {\n    this.body(node)\n    if (node.raws.after) this.builder(node.raws.after)\n  }\n\n  comment(node) {\n    let left = this.raw(node, 'left', 'commentLeft')\n    let right = this.raw(node, 'right', 'commentRight')\n    this.builder('/*' + left + node.text + right + '*/', node)\n  }\n\n  decl(node, semicolon) {\n    let between = this.raw(node, 'between', 'colon')\n    let string = node.prop + between + this.rawValue(node, 'value')\n\n    if (node.important) {\n      string += node.raws.important || ' !important'\n    }\n\n    if (semicolon) string += ';'\n    this.builder(string, node)\n  }\n\n  rule(node) {\n    this.block(node, this.rawValue(node, 'selector'))\n    if (node.raws.ownSemicolon) {\n      this.builder(node.raws.ownSemicolon, node, 'end')\n    }\n  }\n\n  atrule(node, semicolon) {\n    let name = '@' + node.name\n    let params = node.params ? this.rawValue(node, 'params') : ''\n\n    if (typeof node.raws.afterName !== 'undefined') {\n      name += node.raws.afterName\n    } else if (params) {\n      name += ' '\n    }\n\n    if (node.nodes) {\n      this.block(node, name + params)\n    } else {\n      let end = (node.raws.between || '') + (semicolon ? ';' : '')\n      this.builder(name + params + end, node)\n    }\n  }\n\n  body(node) {\n    let last = node.nodes.length - 1\n    while (last > 0) {\n      if (node.nodes[last].type !== 'comment') break\n      last -= 1\n    }\n\n    let semicolon = this.raw(node, 'semicolon')\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i]\n      let before = this.raw(child, 'before')\n      if (before) this.builder(before)\n      this.stringify(child, last !== i || semicolon)\n    }\n  }\n\n  block(node, start) {\n    let between = this.raw(node, 'between', 'beforeOpen')\n    this.builder(start + between + '{', node, 'start')\n\n    let after\n    if (node.nodes && node.nodes.length) {\n      this.body(node)\n      after = this.raw(node, 'after')\n    } else {\n      after = this.raw(node, 'after', 'emptyBody')\n    }\n\n    if (after) this.builder(after)\n    this.builder('}', node, 'end')\n  }\n\n  raw(node, own, detect) {\n    let value\n    if (!detect) detect = own\n\n    // Already had\n    if (own) {\n      value = node.raws[own]\n      if (typeof value !== 'undefined') return value\n    }\n\n    let parent = node.parent\n\n    if (detect === 'before') {\n      // Hack for first rule in CSS\n      if (!parent || (parent.type === 'root' && parent.first === node)) {\n        return ''\n      }\n\n      // `root` nodes in `document` should use only their own raws\n      if (parent && parent.type === 'document') {\n        return ''\n      }\n    }\n\n    // Floating child without parent\n    if (!parent) return DEFAULT_RAW[detect]\n\n    // Detect style by other nodes\n    let root = node.root()\n    if (!root.rawCache) root.rawCache = {}\n    if (typeof root.rawCache[detect] !== 'undefined') {\n      return root.rawCache[detect]\n    }\n\n    if (detect === 'before' || detect === 'after') {\n      return this.beforeAfter(node, detect)\n    } else {\n      let method = 'raw' + capitalize(detect)\n      if (this[method]) {\n        value = this[method](root, node)\n      } else {\n        root.walk(i => {\n          value = i.raws[own]\n          if (typeof value !== 'undefined') return false\n        })\n      }\n    }\n\n    if (typeof value === 'undefined') value = DEFAULT_RAW[detect]\n\n    root.rawCache[detect] = value\n    return value\n  }\n\n  rawSemicolon(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length && i.last.type === 'decl') {\n        value = i.raws.semicolon\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawEmptyBody(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length === 0) {\n        value = i.raws.after\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawIndent(root) {\n    if (root.raws.indent) return root.raws.indent\n    let value\n    root.walk(i => {\n      let p = i.parent\n      if (p && p !== root && p.parent && p.parent === root) {\n        if (typeof i.raws.before !== 'undefined') {\n          let parts = i.raws.before.split('\\n')\n          value = parts[parts.length - 1]\n          value = value.replace(/\\S/g, '')\n          return false\n        }\n      }\n    })\n    return value\n  }\n\n  rawBeforeComment(root, node) {\n    let value\n    root.walkComments(i => {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before\n        if (value.includes('\\n')) {\n          value = value.replace(/[^\\n]+$/, '')\n        }\n        return false\n      }\n    })\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeDecl')\n    } else if (value) {\n      value = value.replace(/\\S/g, '')\n    }\n    return value\n  }\n\n  rawBeforeDecl(root, node) {\n    let value\n    root.walkDecls(i => {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before\n        if (value.includes('\\n')) {\n          value = value.replace(/[^\\n]+$/, '')\n        }\n        return false\n      }\n    })\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeRule')\n    } else if (value) {\n      value = value.replace(/\\S/g, '')\n    }\n    return value\n  }\n\n  rawBeforeRule(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && (i.parent !== root || root.first !== i)) {\n        if (typeof i.raws.before !== 'undefined') {\n          value = i.raws.before\n          if (value.includes('\\n')) {\n            value = value.replace(/[^\\n]+$/, '')\n          }\n          return false\n        }\n      }\n    })\n    if (value) value = value.replace(/\\S/g, '')\n    return value\n  }\n\n  rawBeforeClose(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length > 0) {\n        if (typeof i.raws.after !== 'undefined') {\n          value = i.raws.after\n          if (value.includes('\\n')) {\n            value = value.replace(/[^\\n]+$/, '')\n          }\n          return false\n        }\n      }\n    })\n    if (value) value = value.replace(/\\S/g, '')\n    return value\n  }\n\n  rawBeforeOpen(root) {\n    let value\n    root.walk(i => {\n      if (i.type !== 'decl') {\n        value = i.raws.between\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawColon(root) {\n    let value\n    root.walkDecls(i => {\n      if (typeof i.raws.between !== 'undefined') {\n        value = i.raws.between.replace(/[^\\s:]/g, '')\n        return false\n      }\n    })\n    return value\n  }\n\n  beforeAfter(node, detect) {\n    let value\n    if (node.type === 'decl') {\n      value = this.raw(node, null, 'beforeDecl')\n    } else if (node.type === 'comment') {\n      value = this.raw(node, null, 'beforeComment')\n    } else if (detect === 'before') {\n      value = this.raw(node, null, 'beforeRule')\n    } else {\n      value = this.raw(node, null, 'beforeClose')\n    }\n\n    let buf = node.parent\n    let depth = 0\n    while (buf && buf.type !== 'root') {\n      depth += 1\n      buf = buf.parent\n    }\n\n    if (value.includes('\\n')) {\n      let indent = this.raw(node, null, 'indent')\n      if (indent.length) {\n        for (let step = 0; step < depth; step++) value += indent\n      }\n    }\n\n    return value\n  }\n\n  rawValue(node, prop) {\n    let value = node[prop]\n    let raw = node.raws[prop]\n    if (raw && raw.value === value) {\n      return raw.raw\n    }\n\n    return value\n  }\n}\n\nmodule.exports = Stringifier\nStringifier.default = Stringifier\n"]}}