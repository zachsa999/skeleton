{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const fill=require(\"fill-range\");const utils=require(\"./utils\");const compile=__name((ast,options={})=>{let walk=__name((node,parent={})=>{let invalidBlock=utils.isInvalidBrace(parent);let invalidNode=node.invalid===true&&options.escapeInvalid===true;let invalid=invalidBlock===true||invalidNode===true;let prefix=options.escapeInvalid===true?\"\\\\\":\"\";let output=\"\";if(node.isOpen===true){return prefix+node.value}if(node.isClose===true){return prefix+node.value}if(node.type===\"open\"){return invalid?prefix+node.value:\"(\"}if(node.type===\"close\"){return invalid?prefix+node.value:\")\"}if(node.type===\"comma\"){return node.prev.type===\"comma\"?\"\":invalid?node.value:\"|\"}if(node.value){return node.value}if(node.nodes&&node.ranges>0){let args=utils.reduce(node.nodes);let range=fill(...args,{...options,wrap:false,toRegex:true});if(range.length!==0){return args.length>1&&range.length>1?`(${range})`:range}}if(node.nodes){for(let child of node.nodes){output+=walk(child,node)}}return output},\"walk\");return walk(ast)},\"compile\");module.exports=compile;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAEA,MAAM,KAAO,QAAQ,YAAY,EACjC,MAAM,MAAQ,QAAQ,SAAS,EAE/B,MAAM,QAAU,QAAC,IAAK,QAAU,CAAC,IAAM,CACrC,IAAI,KAAO,QAAC,KAAM,OAAS,CAAC,IAAM,CAChC,IAAI,aAAe,MAAM,eAAe,MAAM,EAC9C,IAAI,YAAc,KAAK,UAAY,MAAQ,QAAQ,gBAAkB,KACrE,IAAI,QAAU,eAAiB,MAAQ,cAAgB,KACvD,IAAI,OAAS,QAAQ,gBAAkB,KAAO,KAAO,GACrD,IAAI,OAAS,GAEb,GAAI,KAAK,SAAW,KAAM,CACxB,OAAO,OAAS,KAAK,KACvB,CACA,GAAI,KAAK,UAAY,KAAM,CACzB,OAAO,OAAS,KAAK,KACvB,CAEA,GAAI,KAAK,OAAS,OAAQ,CACxB,OAAO,QAAW,OAAS,KAAK,MAAS,GAC3C,CAEA,GAAI,KAAK,OAAS,QAAS,CACzB,OAAO,QAAW,OAAS,KAAK,MAAS,GAC3C,CAEA,GAAI,KAAK,OAAS,QAAS,CACzB,OAAO,KAAK,KAAK,OAAS,QAAU,GAAM,QAAU,KAAK,MAAQ,GACnE,CAEA,GAAI,KAAK,MAAO,CACd,OAAO,KAAK,KACd,CAEA,GAAI,KAAK,OAAS,KAAK,OAAS,EAAG,CACjC,IAAI,KAAO,MAAM,OAAO,KAAK,KAAK,EAClC,IAAI,MAAQ,KAAK,GAAG,KAAM,CAAE,GAAG,QAAS,KAAM,MAAO,QAAS,IAAK,CAAC,EAEpE,GAAI,MAAM,SAAW,EAAG,CACtB,OAAO,KAAK,OAAS,GAAK,MAAM,OAAS,EAAI,IAAI,SAAW,KAC9D,CACF,CAEA,GAAI,KAAK,MAAO,CACd,QAAS,SAAS,KAAK,MAAO,CAC5B,QAAU,KAAK,MAAO,IAAI,CAC5B,CACF,CACA,OAAO,MACT,EA7CW,QA+CX,OAAO,KAAK,GAAG,CACjB,EAjDgB,WAmDhB,OAAO,QAAU","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js"],"sourcesContent":["'use strict';\n\nconst fill = require('fill-range');\nconst utils = require('./utils');\n\nconst compile = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? (prefix + node.value) : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? (prefix + node.value) : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      let range = fill(...args, { ...options, wrap: false, toRegex: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n\n  return walk(ast);\n};\n\nmodule.exports = compile;\n"]}}