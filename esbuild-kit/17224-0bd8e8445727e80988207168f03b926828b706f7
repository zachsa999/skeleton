{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:true,get:all[name]})}__name(_export,\"_export\");_export(exports,{normalizeScreens:function(){return normalizeScreens},isScreenSortable:function(){return isScreenSortable},compareScreens:function(){return compareScreens},toScreen:function(){return toScreen}});function normalizeScreens(screens,root=true){if(Array.isArray(screens)){return screens.map(screen=>{if(root&&Array.isArray(screen)){throw new Error(\"The tuple syntax is not supported for `screens`.\")}if(typeof screen===\"string\"){return{name:screen.toString(),not:false,values:[{min:screen,max:void 0}]}}let[name,options]=screen;name=name.toString();if(typeof options===\"string\"){return{name,not:false,values:[{min:options,max:void 0}]}}if(Array.isArray(options)){return{name,not:false,values:options.map(option=>resolveValue(option))}}return{name,not:false,values:[resolveValue(options)]}})}return normalizeScreens(Object.entries(screens!==null&&screens!==void 0?screens:{}),false)}__name(normalizeScreens,\"normalizeScreens\");function isScreenSortable(screen){if(screen.values.length!==1){return{result:false,reason:\"multiple-values\"}}else if(screen.values[0].raw!==void 0){return{result:false,reason:\"raw-values\"}}else if(screen.values[0].min!==void 0&&screen.values[0].max!==void 0){return{result:false,reason:\"min-and-max\"}}return{result:true,reason:null}}__name(isScreenSortable,\"isScreenSortable\");function compareScreens(type,a,z){let aScreen=toScreen(a,type);let zScreen=toScreen(z,type);let aSorting=isScreenSortable(aScreen);let bSorting=isScreenSortable(zScreen);if(aSorting.reason===\"multiple-values\"||bSorting.reason===\"multiple-values\"){throw new Error(\"Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.\")}else if(aSorting.reason===\"raw-values\"||bSorting.reason===\"raw-values\"){throw new Error(\"Attempted to sort a screen with raw values. This should never happen. Please open a bug report.\")}else if(aSorting.reason===\"min-and-max\"||bSorting.reason===\"min-and-max\"){throw new Error(\"Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.\")}let{min:aMin,max:aMax}=aScreen.values[0];let{min:zMin,max:zMax}=zScreen.values[0];if(a.not)[aMin,aMax]=[aMax,aMin];if(z.not)[zMin,zMax]=[zMax,zMin];aMin=aMin===void 0?aMin:parseFloat(aMin);aMax=aMax===void 0?aMax:parseFloat(aMax);zMin=zMin===void 0?zMin:parseFloat(zMin);zMax=zMax===void 0?zMax:parseFloat(zMax);let[aValue,zValue]=type===\"min\"?[aMin,zMin]:[zMax,aMax];return aValue-zValue}__name(compareScreens,\"compareScreens\");function toScreen(value,type){if(typeof value===\"object\"){return value}return{name:\"arbitrary-screen\",values:[{[type]:value}]}}__name(toScreen,\"toScreen\");function resolveValue({\"min-width\":_minWidth,min=_minWidth,max,raw}={}){return{min,max,raw}}__name(resolveValue,\"resolveValue\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/util/normalizeScreens.js"],"sourcesContent":["/**\n * @typedef {object} ScreenValue\n * @property {number|undefined} min\n * @property {number|undefined} max\n * @property {string|undefined} raw\n */ /**\n * @typedef {object} Screen\n * @property {string} name\n * @property {boolean} not\n * @property {ScreenValue[]} values\n */ /**\n * A function that normalizes the various forms that the screens object can be\n * provided in.\n *\n * Input(s):\n *   - ['100px', '200px'] // Raw strings\n *   - { sm: '100px', md: '200px' } // Object with string values\n *   - { sm: { min: '100px' }, md: { max: '100px' } } // Object with object values\n *   - { sm: [{ min: '100px' }, { max: '200px' }] } // Object with object array (multiple values)\n *\n * Output(s):\n *   - [{ name: 'sm', values: [{ min: '100px', max: '200px' }] }] // List of objects, that contains multiple values\n *\n * @returns {Screen[]}\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    normalizeScreens: function() {\n        return normalizeScreens;\n    },\n    isScreenSortable: function() {\n        return isScreenSortable;\n    },\n    compareScreens: function() {\n        return compareScreens;\n    },\n    toScreen: function() {\n        return toScreen;\n    }\n});\nfunction normalizeScreens(screens, root = true) {\n    if (Array.isArray(screens)) {\n        return screens.map((screen)=>{\n            if (root && Array.isArray(screen)) {\n                throw new Error(\"The tuple syntax is not supported for `screens`.\");\n            }\n            if (typeof screen === \"string\") {\n                return {\n                    name: screen.toString(),\n                    not: false,\n                    values: [\n                        {\n                            min: screen,\n                            max: undefined\n                        }\n                    ]\n                };\n            }\n            let [name, options] = screen;\n            name = name.toString();\n            if (typeof options === \"string\") {\n                return {\n                    name,\n                    not: false,\n                    values: [\n                        {\n                            min: options,\n                            max: undefined\n                        }\n                    ]\n                };\n            }\n            if (Array.isArray(options)) {\n                return {\n                    name,\n                    not: false,\n                    values: options.map((option)=>resolveValue(option))\n                };\n            }\n            return {\n                name,\n                not: false,\n                values: [\n                    resolveValue(options)\n                ]\n            };\n        });\n    }\n    return normalizeScreens(Object.entries(screens !== null && screens !== void 0 ? screens : {}), false);\n}\nfunction isScreenSortable(screen) {\n    if (screen.values.length !== 1) {\n        return {\n            result: false,\n            reason: \"multiple-values\"\n        };\n    } else if (screen.values[0].raw !== undefined) {\n        return {\n            result: false,\n            reason: \"raw-values\"\n        };\n    } else if (screen.values[0].min !== undefined && screen.values[0].max !== undefined) {\n        return {\n            result: false,\n            reason: \"min-and-max\"\n        };\n    }\n    return {\n        result: true,\n        reason: null\n    };\n}\nfunction compareScreens(type, a, z) {\n    let aScreen = toScreen(a, type);\n    let zScreen = toScreen(z, type);\n    let aSorting = isScreenSortable(aScreen);\n    let bSorting = isScreenSortable(zScreen);\n    // These cases should never happen and indicate a bug in Tailwind CSS itself\n    if (aSorting.reason === \"multiple-values\" || bSorting.reason === \"multiple-values\") {\n        throw new Error(\"Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.\");\n    } else if (aSorting.reason === \"raw-values\" || bSorting.reason === \"raw-values\") {\n        throw new Error(\"Attempted to sort a screen with raw values. This should never happen. Please open a bug report.\");\n    } else if (aSorting.reason === \"min-and-max\" || bSorting.reason === \"min-and-max\") {\n        throw new Error(\"Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.\");\n    }\n    // Let the sorting begin\n    let { min: aMin , max: aMax  } = aScreen.values[0];\n    let { min: zMin , max: zMax  } = zScreen.values[0];\n    // Negating screens flip their behavior. Basically `not min-width` is `max-width`\n    if (a.not) [aMin, aMax] = [\n        aMax,\n        aMin\n    ];\n    if (z.not) [zMin, zMax] = [\n        zMax,\n        zMin\n    ];\n    aMin = aMin === undefined ? aMin : parseFloat(aMin);\n    aMax = aMax === undefined ? aMax : parseFloat(aMax);\n    zMin = zMin === undefined ? zMin : parseFloat(zMin);\n    zMax = zMax === undefined ? zMax : parseFloat(zMax);\n    let [aValue, zValue] = type === \"min\" ? [\n        aMin,\n        zMin\n    ] : [\n        zMax,\n        aMax\n    ];\n    return aValue - zValue;\n}\nfunction toScreen(value, type) {\n    if (typeof value === \"object\") {\n        return value;\n    }\n    return {\n        name: \"arbitrary-screen\",\n        values: [\n            {\n                [type]: value\n            }\n        ]\n    };\n}\nfunction resolveValue({ \"min-width\": _minWidth , min =_minWidth , max , raw  } = {}) {\n    return {\n        min,\n        max,\n        raw\n    };\n}\n"]}}