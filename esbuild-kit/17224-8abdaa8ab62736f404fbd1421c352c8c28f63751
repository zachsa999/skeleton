{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _types=require(\"../parser/tokenizer/types\");function getImportExportSpecifierInfo(tokens,index=tokens.currentIndex()){let endIndex=index+1;if(isSpecifierEnd(tokens,endIndex)){const name=tokens.identifierNameAtIndex(index);return{isType:false,leftName:name,rightName:name,endIndex}}endIndex++;if(isSpecifierEnd(tokens,endIndex)){return{isType:true,leftName:null,rightName:null,endIndex}}endIndex++;if(isSpecifierEnd(tokens,endIndex)){return{isType:false,leftName:tokens.identifierNameAtIndex(index),rightName:tokens.identifierNameAtIndex(index+2),endIndex}}endIndex++;if(isSpecifierEnd(tokens,endIndex)){return{isType:true,leftName:null,rightName:null,endIndex}}throw new Error(`Unexpected import/export specifier at ${index}`)}__name(getImportExportSpecifierInfo,\"getImportExportSpecifierInfo\");exports.default=getImportExportSpecifierInfo;function isSpecifierEnd(tokens,index){const token=tokens.tokens[index];return token.type===_types.TokenType.braceR||token.type===_types.TokenType.comma}__name(isSpecifierEnd,\"isSpecifierEnd\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAE,IAAI,OAAS,QAAQ,2BAA2B,EAwCxH,SAAS,6BACR,OACA,MAAQ,OAAO,aAAa,EAC5B,CACA,IAAI,SAAW,MAAQ,EACvB,GAAI,eAAe,OAAQ,QAAQ,EAAG,CAEpC,MAAM,KAAO,OAAO,sBAAsB,KAAK,EAC/C,MAAO,CACL,OAAQ,MACR,SAAU,KACV,UAAW,KACX,QACF,CACF,CACA,WACA,GAAI,eAAe,OAAQ,QAAQ,EAAG,CAEpC,MAAO,CACL,OAAQ,KACR,SAAU,KACV,UAAW,KACX,QACF,CACF,CACA,WACA,GAAI,eAAe,OAAQ,QAAQ,EAAG,CAEpC,MAAO,CACL,OAAQ,MACR,SAAU,OAAO,sBAAsB,KAAK,EAC5C,UAAW,OAAO,sBAAsB,MAAQ,CAAC,EACjD,QACF,CACF,CACA,WACA,GAAI,eAAe,OAAQ,QAAQ,EAAG,CAEpC,MAAO,CACL,OAAQ,KACR,SAAU,KACV,UAAW,KACX,QACF,CACF,CACA,MAAM,IAAI,MAAM,yCAAyC,OAAO,CAClE,CA9CU,oEA8CR,QAAQ,QAAU,6BAEpB,SAAS,eAAe,OAAQ,MAAO,CACrC,MAAM,MAAQ,OAAO,OAAO,KAAK,EACjC,OAAO,MAAM,OAAS,OAAO,UAAU,QAAU,MAAM,OAAS,OAAO,UAAU,KACnF,CAHS","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/util/getImportExportSpecifierInfo.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});var _types = require('../parser/tokenizer/types');\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Determine information about this named import or named export specifier.\n *\n * This syntax is the `a` from statements like these:\n * import {A} from \"./foo\";\n * export {A};\n * export {A} from \"./foo\";\n *\n * As it turns out, we can exactly characterize the syntax meaning by simply\n * counting the number of tokens, which can be from 1 to 4:\n * {A}\n * {type A}\n * {A as B}\n * {type A as B}\n *\n * In the type case, we never actually need the names in practice, so don't get\n * them.\n *\n * TODO: There's some redundancy with the type detection here and the isType\n * flag that's already present on tokens in TS mode. This function could\n * potentially be simplified and/or pushed to the call sites to avoid the object\n * allocation.\n */\n function getImportExportSpecifierInfo(\n  tokens,\n  index = tokens.currentIndex(),\n) {\n  let endIndex = index + 1;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {A}\n    const name = tokens.identifierNameAtIndex(index);\n    return {\n      isType: false,\n      leftName: name,\n      rightName: name,\n      endIndex,\n    };\n  }\n  endIndex++;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {type A}\n    return {\n      isType: true,\n      leftName: null,\n      rightName: null,\n      endIndex,\n    };\n  }\n  endIndex++;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {A as B}\n    return {\n      isType: false,\n      leftName: tokens.identifierNameAtIndex(index),\n      rightName: tokens.identifierNameAtIndex(index + 2),\n      endIndex,\n    };\n  }\n  endIndex++;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {type A as B}\n    return {\n      isType: true,\n      leftName: null,\n      rightName: null,\n      endIndex,\n    };\n  }\n  throw new Error(`Unexpected import/export specifier at ${index}`);\n} exports.default = getImportExportSpecifierInfo;\n\nfunction isSpecifierEnd(tokens, index) {\n  const token = tokens.tokens[index];\n  return token.type === _types.TokenType.braceR || token.type === _types.TokenType.comma;\n}\n"]}}