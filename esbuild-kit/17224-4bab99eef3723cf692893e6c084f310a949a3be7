{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _genmapping=require(\"@jridgewell/gen-mapping\");var _charcodes=require(\"./parser/util/charcodes\");function computeSourceMap({code:generatedCode,mappings:rawMappings},filePath,options,source,tokens){const sourceColumns=computeSourceColumns(source,tokens);const map=new(0,_genmapping.GenMapping)({file:options.compiledFilename});let tokenIndex=0;let currentMapping=rawMappings[0];while(currentMapping===void 0&&tokenIndex<rawMappings.length-1){tokenIndex++;currentMapping=rawMappings[tokenIndex]}let line=0;let lineStart=0;if(currentMapping!==lineStart){_genmapping.maybeAddSegment.call(void 0,map,line,0,filePath,line,0)}for(let i=0;i<generatedCode.length;i++){if(i===currentMapping){const genColumn=currentMapping-lineStart;const sourceColumn=sourceColumns[tokenIndex];_genmapping.maybeAddSegment.call(void 0,map,line,genColumn,filePath,line,sourceColumn);while((currentMapping===i||currentMapping===void 0)&&tokenIndex<rawMappings.length-1){tokenIndex++;currentMapping=rawMappings[tokenIndex]}}if(generatedCode.charCodeAt(i)===_charcodes.charCodes.lineFeed){line++;lineStart=i+1;if(currentMapping!==lineStart){_genmapping.maybeAddSegment.call(void 0,map,line,0,filePath,line,0)}}}const{sourceRoot,sourcesContent,...sourceMap}=_genmapping.toEncodedMap.call(void 0,map);return sourceMap}__name(computeSourceMap,\"computeSourceMap\");exports.default=computeSourceMap;function computeSourceColumns(code,tokens){const sourceColumns=new Array(tokens.length);let tokenIndex=0;let currentMapping=tokens[tokenIndex].start;let lineStart=0;for(let i=0;i<code.length;i++){if(i===currentMapping){sourceColumns[tokenIndex]=currentMapping-lineStart;tokenIndex++;currentMapping=tokens[tokenIndex].start}if(code.charCodeAt(i)===_charcodes.charCodes.lineFeed){lineStart=i+1}}return sourceColumns}__name(computeSourceColumns,\"computeSourceColumns\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAE,IAAI,YAAc,QAAQ,yBAAyB,EAI5H,IAAI,WAAa,QAAQ,yBAAyB,EAiBjD,SAAS,iBACR,CAAC,KAAM,cAAe,SAAU,WAAW,EAC3C,SACA,QACA,OACA,OACA,CACA,MAAM,cAAgB,qBAAqB,OAAQ,MAAM,EACzD,MAAM,IAAM,IAAK,EAAG,YAAY,YAAY,CAAC,KAAM,QAAQ,gBAAgB,CAAC,EAC5E,IAAI,WAAa,EAGjB,IAAI,eAAiB,YAAY,CAAC,EAClC,MAAO,iBAAmB,QAAa,WAAa,YAAY,OAAS,EAAG,CAC1E,aACA,eAAiB,YAAY,UAAU,CACzC,CACA,IAAI,KAAO,EACX,IAAI,UAAY,EAChB,GAAI,iBAAmB,UAAW,CAChC,YAAY,gBAAgB,KAAK,OAAQ,IAAK,KAAM,EAAG,SAAU,KAAM,CAAC,CAC1E,CACA,QAAS,EAAI,EAAG,EAAI,cAAc,OAAQ,IAAK,CAC7C,GAAI,IAAM,eAAgB,CACxB,MAAM,UAAY,eAAiB,UACnC,MAAM,aAAe,cAAc,UAAU,EAC7C,YAAY,gBAAgB,KAAK,OAAQ,IAAK,KAAM,UAAW,SAAU,KAAM,YAAY,EAC3F,OACG,iBAAmB,GAAK,iBAAmB,SAC5C,WAAa,YAAY,OAAS,EAClC,CACA,aACA,eAAiB,YAAY,UAAU,CACzC,CACF,CACA,GAAI,cAAc,WAAW,CAAC,IAAM,WAAW,UAAU,SAAU,CACjE,OACA,UAAY,EAAI,EAChB,GAAI,iBAAmB,UAAW,CAChC,YAAY,gBAAgB,KAAK,OAAQ,IAAK,KAAM,EAAG,SAAU,KAAM,CAAC,CAC1E,CACF,CACF,CACA,KAAM,CAAC,WAAY,eAAgB,GAAG,SAAS,EAAI,YAAY,aAAa,KAAK,OAAQ,GAAG,EAC5F,OAAO,SACT,CA7CU,4CA6CR,QAAQ,QAAU,iBAMpB,SAAS,qBAAqB,KAAM,OAAQ,CAC1C,MAAM,cAAgB,IAAI,MAAM,OAAO,MAAM,EAC7C,IAAI,WAAa,EACjB,IAAI,eAAiB,OAAO,UAAU,EAAE,MACxC,IAAI,UAAY,EAChB,QAAS,EAAI,EAAG,EAAI,KAAK,OAAQ,IAAK,CACpC,GAAI,IAAM,eAAgB,CACxB,cAAc,UAAU,EAAI,eAAiB,UAC7C,aACA,eAAiB,OAAO,UAAU,EAAE,KACtC,CACA,GAAI,KAAK,WAAW,CAAC,IAAM,WAAW,UAAU,SAAU,CACxD,UAAY,EAAI,CAClB,CACF,CACA,OAAO,aACT,CAhBS","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/computeSourceMap.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});var _genmapping = require('@jridgewell/gen-mapping');\n\n\n\nvar _charcodes = require('./parser/util/charcodes');\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Generate a source map indicating that each line maps directly to the original line,\n * with the tokens in their new positions.\n */\n function computeSourceMap(\n  {code: generatedCode, mappings: rawMappings},\n  filePath,\n  options,\n  source,\n  tokens,\n) {\n  const sourceColumns = computeSourceColumns(source, tokens);\n  const map = new (0, _genmapping.GenMapping)({file: options.compiledFilename});\n  let tokenIndex = 0;\n  // currentMapping is the output source index for the current input token being\n  // considered.\n  let currentMapping = rawMappings[0];\n  while (currentMapping === undefined && tokenIndex < rawMappings.length - 1) {\n    tokenIndex++;\n    currentMapping = rawMappings[tokenIndex];\n  }\n  let line = 0;\n  let lineStart = 0;\n  if (currentMapping !== lineStart) {\n    _genmapping.maybeAddSegment.call(void 0, map, line, 0, filePath, line, 0);\n  }\n  for (let i = 0; i < generatedCode.length; i++) {\n    if (i === currentMapping) {\n      const genColumn = currentMapping - lineStart;\n      const sourceColumn = sourceColumns[tokenIndex];\n      _genmapping.maybeAddSegment.call(void 0, map, line, genColumn, filePath, line, sourceColumn);\n      while (\n        (currentMapping === i || currentMapping === undefined) &&\n        tokenIndex < rawMappings.length - 1\n      ) {\n        tokenIndex++;\n        currentMapping = rawMappings[tokenIndex];\n      }\n    }\n    if (generatedCode.charCodeAt(i) === _charcodes.charCodes.lineFeed) {\n      line++;\n      lineStart = i + 1;\n      if (currentMapping !== lineStart) {\n        _genmapping.maybeAddSegment.call(void 0, map, line, 0, filePath, line, 0);\n      }\n    }\n  }\n  const {sourceRoot, sourcesContent, ...sourceMap} = _genmapping.toEncodedMap.call(void 0, map);\n  return sourceMap ;\n} exports.default = computeSourceMap;\n\n/**\n * Create an array mapping each token index to the 0-based column of the start\n * position of the token.\n */\nfunction computeSourceColumns(code, tokens) {\n  const sourceColumns = new Array(tokens.length);\n  let tokenIndex = 0;\n  let currentMapping = tokens[tokenIndex].start;\n  let lineStart = 0;\n  for (let i = 0; i < code.length; i++) {\n    if (i === currentMapping) {\n      sourceColumns[tokenIndex] = currentMapping - lineStart;\n      tokenIndex++;\n      currentMapping = tokens[tokenIndex].start;\n    }\n    if (code.charCodeAt(i) === _charcodes.charCodes.lineFeed) {\n      lineStart = i + 1;\n    }\n  }\n  return sourceColumns;\n}\n"]}}