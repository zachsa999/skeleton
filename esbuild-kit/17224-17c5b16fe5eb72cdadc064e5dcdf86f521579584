{"code":"(()=>{\nvar __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});var SourceMapGenerator=require(\"./source-map-generator\").SourceMapGenerator;var util=require(\"./util\");var REGEX_NEWLINE=/(\\r?\\n)/;var NEWLINE_CODE=10;var isSourceNode=\"$$$isSourceNode$$$\";function SourceNode(aLine,aColumn,aSource,aChunks,aName){this.children=[];this.sourceContents={};this.line=aLine==null?null:aLine;this.column=aColumn==null?null:aColumn;this.source=aSource==null?null:aSource;this.name=aName==null?null:aName;this[isSourceNode]=true;if(aChunks!=null)this.add(aChunks)}__name(SourceNode,\"SourceNode\");SourceNode.fromStringWithSourceMap=__name(function SourceNode_fromStringWithSourceMap(aGeneratedCode,aSourceMapConsumer,aRelativePath){var node=new SourceNode;var remainingLines=aGeneratedCode.split(REGEX_NEWLINE);var remainingLinesIndex=0;var shiftNextLine=__name(function(){var lineContents=getNextLine();var newLine=getNextLine()||\"\";return lineContents+newLine;function getNextLine(){return remainingLinesIndex<remainingLines.length?remainingLines[remainingLinesIndex++]:void 0}__name(getNextLine,\"getNextLine\")},\"shiftNextLine\");var lastGeneratedLine=1,lastGeneratedColumn=0;var lastMapping=null;aSourceMapConsumer.eachMapping(function(mapping){if(lastMapping!==null){if(lastGeneratedLine<mapping.generatedLine){addMappingWithCode(lastMapping,shiftNextLine());lastGeneratedLine++;lastGeneratedColumn=0}else{var nextLine=remainingLines[remainingLinesIndex]||\"\";var code=nextLine.substr(0,mapping.generatedColumn-lastGeneratedColumn);remainingLines[remainingLinesIndex]=nextLine.substr(mapping.generatedColumn-lastGeneratedColumn);lastGeneratedColumn=mapping.generatedColumn;addMappingWithCode(lastMapping,code);lastMapping=mapping;return}}while(lastGeneratedLine<mapping.generatedLine){node.add(shiftNextLine());lastGeneratedLine++}if(lastGeneratedColumn<mapping.generatedColumn){var nextLine=remainingLines[remainingLinesIndex]||\"\";node.add(nextLine.substr(0,mapping.generatedColumn));remainingLines[remainingLinesIndex]=nextLine.substr(mapping.generatedColumn);lastGeneratedColumn=mapping.generatedColumn}lastMapping=mapping},this);if(remainingLinesIndex<remainingLines.length){if(lastMapping){addMappingWithCode(lastMapping,shiftNextLine())}node.add(remainingLines.splice(remainingLinesIndex).join(\"\"))}aSourceMapConsumer.sources.forEach(function(sourceFile){var content=aSourceMapConsumer.sourceContentFor(sourceFile);if(content!=null){if(aRelativePath!=null){sourceFile=util.join(aRelativePath,sourceFile)}node.setSourceContent(sourceFile,content)}});return node;function addMappingWithCode(mapping,code){if(mapping===null||mapping.source===void 0){node.add(code)}else{var source=aRelativePath?util.join(aRelativePath,mapping.source):mapping.source;node.add(new SourceNode(mapping.originalLine,mapping.originalColumn,source,code,mapping.name))}}__name(addMappingWithCode,\"addMappingWithCode\")},\"SourceNode_fromStringWithSourceMap\");SourceNode.prototype.add=__name(function SourceNode_add(aChunk){if(Array.isArray(aChunk)){aChunk.forEach(function(chunk){this.add(chunk)},this)}else if(aChunk[isSourceNode]||typeof aChunk===\"string\"){if(aChunk){this.children.push(aChunk)}}else{throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \"+aChunk)}return this},\"SourceNode_add\");SourceNode.prototype.prepend=__name(function SourceNode_prepend(aChunk){if(Array.isArray(aChunk)){for(var i=aChunk.length-1;i>=0;i--){this.prepend(aChunk[i])}}else if(aChunk[isSourceNode]||typeof aChunk===\"string\"){this.children.unshift(aChunk)}else{throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \"+aChunk)}return this},\"SourceNode_prepend\");SourceNode.prototype.walk=__name(function SourceNode_walk(aFn){var chunk;for(var i=0,len=this.children.length;i<len;i++){chunk=this.children[i];if(chunk[isSourceNode]){chunk.walk(aFn)}else{if(chunk!==\"\"){aFn(chunk,{source:this.source,line:this.line,column:this.column,name:this.name})}}}},\"SourceNode_walk\");SourceNode.prototype.join=__name(function SourceNode_join(aSep){var newChildren;var i;var len=this.children.length;if(len>0){newChildren=[];for(i=0;i<len-1;i++){newChildren.push(this.children[i]);newChildren.push(aSep)}newChildren.push(this.children[i]);this.children=newChildren}return this},\"SourceNode_join\");SourceNode.prototype.replaceRight=__name(function SourceNode_replaceRight(aPattern,aReplacement){var lastChild=this.children[this.children.length-1];if(lastChild[isSourceNode]){lastChild.replaceRight(aPattern,aReplacement)}else if(typeof lastChild===\"string\"){this.children[this.children.length-1]=lastChild.replace(aPattern,aReplacement)}else{this.children.push(\"\".replace(aPattern,aReplacement))}return this},\"SourceNode_replaceRight\");SourceNode.prototype.setSourceContent=__name(function SourceNode_setSourceContent(aSourceFile,aSourceContent){this.sourceContents[util.toSetString(aSourceFile)]=aSourceContent},\"SourceNode_setSourceContent\");SourceNode.prototype.walkSourceContents=__name(function SourceNode_walkSourceContents(aFn){for(var i=0,len=this.children.length;i<len;i++){if(this.children[i][isSourceNode]){this.children[i].walkSourceContents(aFn)}}var sources=Object.keys(this.sourceContents);for(var i=0,len=sources.length;i<len;i++){aFn(util.fromSetString(sources[i]),this.sourceContents[sources[i]])}},\"SourceNode_walkSourceContents\");SourceNode.prototype.toString=__name(function SourceNode_toString(){var str=\"\";this.walk(function(chunk){str+=chunk});return str},\"SourceNode_toString\");SourceNode.prototype.toStringWithSourceMap=__name(function SourceNode_toStringWithSourceMap(aArgs){var generated={code:\"\",line:1,column:0};var map=new SourceMapGenerator(aArgs);var sourceMappingActive=false;var lastOriginalSource=null;var lastOriginalLine=null;var lastOriginalColumn=null;var lastOriginalName=null;this.walk(function(chunk,original){generated.code+=chunk;if(original.source!==null&&original.line!==null&&original.column!==null){if(lastOriginalSource!==original.source||lastOriginalLine!==original.line||lastOriginalColumn!==original.column||lastOriginalName!==original.name){map.addMapping({source:original.source,original:{line:original.line,column:original.column},generated:{line:generated.line,column:generated.column},name:original.name})}lastOriginalSource=original.source;lastOriginalLine=original.line;lastOriginalColumn=original.column;lastOriginalName=original.name;sourceMappingActive=true}else if(sourceMappingActive){map.addMapping({generated:{line:generated.line,column:generated.column}});lastOriginalSource=null;sourceMappingActive=false}for(var idx=0,length=chunk.length;idx<length;idx++){if(chunk.charCodeAt(idx)===NEWLINE_CODE){generated.line++;generated.column=0;if(idx+1===length){lastOriginalSource=null;sourceMappingActive=false}else if(sourceMappingActive){map.addMapping({source:original.source,original:{line:original.line,column:original.column},generated:{line:generated.line,column:generated.column},name:original.name})}}else{generated.column++}}});this.walkSourceContents(function(sourceFile,sourceContent){map.setSourceContent(sourceFile,sourceContent)});return{code:generated.code,map}},\"SourceNode_toStringWithSourceMap\");exports.SourceNode=SourceNode;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/source-map-js@1.0.2/node_modules/source-map-js/lib/source-node.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex] || '';\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex] || '';\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n"]}}