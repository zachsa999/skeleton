{"code":"(()=>{\nvar openParentheses=\"(\".charCodeAt(0);var closeParentheses=\")\".charCodeAt(0);var singleQuote=\"'\".charCodeAt(0);var doubleQuote='\"'.charCodeAt(0);var backslash=\"\\\\\".charCodeAt(0);var slash=\"/\".charCodeAt(0);var comma=\",\".charCodeAt(0);var colon=\":\".charCodeAt(0);var star=\"*\".charCodeAt(0);var uLower=\"u\".charCodeAt(0);var uUpper=\"U\".charCodeAt(0);var plus=\"+\".charCodeAt(0);var isUnicodeRange=/^[a-f0-9?-]+$/i;module.exports=function(input){var tokens=[];var value=input;var next,quote,prev,token,escape,escapePos,whitespacePos,parenthesesOpenPos;var pos=0;var code=value.charCodeAt(pos);var max=value.length;var stack=[{nodes:tokens}];var balanced=0;var parent;var name=\"\";var before=\"\";var after=\"\";while(pos<max){if(code<=32){next=pos;do{next+=1;code=value.charCodeAt(next)}while(code<=32);token=value.slice(pos,next);prev=tokens[tokens.length-1];if(code===closeParentheses&&balanced){after=token}else if(prev&&prev.type===\"div\"){prev.after=token;prev.sourceEndIndex+=token.length}else if(code===comma||code===colon||code===slash&&value.charCodeAt(next+1)!==star&&(!parent||parent&&parent.type===\"function\"&&parent.value!==\"calc\")){before=token}else{tokens.push({type:\"space\",sourceIndex:pos,sourceEndIndex:next,value:token})}pos=next}else if(code===singleQuote||code===doubleQuote){next=pos;quote=code===singleQuote?\"'\":'\"';token={type:\"string\",sourceIndex:pos,quote};do{escape=false;next=value.indexOf(quote,next+1);if(~next){escapePos=next;while(value.charCodeAt(escapePos-1)===backslash){escapePos-=1;escape=!escape}}else{value+=quote;next=value.length-1;token.unclosed=true}}while(escape);token.value=value.slice(pos+1,next);token.sourceEndIndex=token.unclosed?next:next+1;tokens.push(token);pos=next+1;code=value.charCodeAt(pos)}else if(code===slash&&value.charCodeAt(pos+1)===star){next=value.indexOf(\"*/\",pos);token={type:\"comment\",sourceIndex:pos,sourceEndIndex:next+2};if(next===-1){token.unclosed=true;next=value.length;token.sourceEndIndex=next}token.value=value.slice(pos+2,next);tokens.push(token);pos=next+2;code=value.charCodeAt(pos)}else if((code===slash||code===star)&&parent&&parent.type===\"function\"&&parent.value===\"calc\"){token=value[pos];tokens.push({type:\"word\",sourceIndex:pos-before.length,sourceEndIndex:pos+token.length,value:token});pos+=1;code=value.charCodeAt(pos)}else if(code===slash||code===comma||code===colon){token=value[pos];tokens.push({type:\"div\",sourceIndex:pos-before.length,sourceEndIndex:pos+token.length,value:token,before,after:\"\"});before=\"\";pos+=1;code=value.charCodeAt(pos)}else if(openParentheses===code){next=pos;do{next+=1;code=value.charCodeAt(next)}while(code<=32);parenthesesOpenPos=pos;token={type:\"function\",sourceIndex:pos-name.length,value:name,before:value.slice(parenthesesOpenPos+1,next)};pos=next;if(name===\"url\"&&code!==singleQuote&&code!==doubleQuote){next-=1;do{escape=false;next=value.indexOf(\")\",next+1);if(~next){escapePos=next;while(value.charCodeAt(escapePos-1)===backslash){escapePos-=1;escape=!escape}}else{value+=\")\";next=value.length-1;token.unclosed=true}}while(escape);whitespacePos=next;do{whitespacePos-=1;code=value.charCodeAt(whitespacePos)}while(code<=32);if(parenthesesOpenPos<whitespacePos){if(pos!==whitespacePos+1){token.nodes=[{type:\"word\",sourceIndex:pos,sourceEndIndex:whitespacePos+1,value:value.slice(pos,whitespacePos+1)}]}else{token.nodes=[]}if(token.unclosed&&whitespacePos+1!==next){token.after=\"\";token.nodes.push({type:\"space\",sourceIndex:whitespacePos+1,sourceEndIndex:next,value:value.slice(whitespacePos+1,next)})}else{token.after=value.slice(whitespacePos+1,next);token.sourceEndIndex=next}}else{token.after=\"\";token.nodes=[]}pos=next+1;token.sourceEndIndex=token.unclosed?next:pos;code=value.charCodeAt(pos);tokens.push(token)}else{balanced+=1;token.after=\"\";token.sourceEndIndex=pos+1;tokens.push(token);stack.push(token);tokens=token.nodes=[];parent=token}name=\"\"}else if(closeParentheses===code&&balanced){pos+=1;code=value.charCodeAt(pos);parent.after=after;parent.sourceEndIndex+=after.length;after=\"\";balanced-=1;stack[stack.length-1].sourceEndIndex=pos;stack.pop();parent=stack[balanced];tokens=parent.nodes}else{next=pos;do{if(code===backslash){next+=1}next+=1;code=value.charCodeAt(next)}while(next<max&&!(code<=32||code===singleQuote||code===doubleQuote||code===comma||code===colon||code===slash||code===openParentheses||code===star&&parent&&parent.type===\"function\"&&parent.value===\"calc\"||code===slash&&parent.type===\"function\"&&parent.value===\"calc\"||code===closeParentheses&&balanced));token=value.slice(pos,next);if(openParentheses===code){name=token}else if((uLower===token.charCodeAt(0)||uUpper===token.charCodeAt(0))&&plus===token.charCodeAt(1)&&isUnicodeRange.test(token.slice(2))){tokens.push({type:\"unicode-range\",sourceIndex:pos,sourceEndIndex:next,value:token})}else{tokens.push({type:\"word\",sourceIndex:pos,sourceEndIndex:next,value:token})}pos=next}}for(pos=stack.length-1;pos;pos-=1){stack[pos].unclosed=true;stack[pos].sourceEndIndex=value.length}return stack[0].nodes};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/parse.js"],"sourcesContent":["var openParentheses = \"(\".charCodeAt(0);\nvar closeParentheses = \")\".charCodeAt(0);\nvar singleQuote = \"'\".charCodeAt(0);\nvar doubleQuote = '\"'.charCodeAt(0);\nvar backslash = \"\\\\\".charCodeAt(0);\nvar slash = \"/\".charCodeAt(0);\nvar comma = \",\".charCodeAt(0);\nvar colon = \":\".charCodeAt(0);\nvar star = \"*\".charCodeAt(0);\nvar uLower = \"u\".charCodeAt(0);\nvar uUpper = \"U\".charCodeAt(0);\nvar plus = \"+\".charCodeAt(0);\nvar isUnicodeRange = /^[a-f0-9?-]+$/i;\n\nmodule.exports = function(input) {\n  var tokens = [];\n  var value = input;\n\n  var next,\n    quote,\n    prev,\n    token,\n    escape,\n    escapePos,\n    whitespacePos,\n    parenthesesOpenPos;\n  var pos = 0;\n  var code = value.charCodeAt(pos);\n  var max = value.length;\n  var stack = [{ nodes: tokens }];\n  var balanced = 0;\n  var parent;\n\n  var name = \"\";\n  var before = \"\";\n  var after = \"\";\n\n  while (pos < max) {\n    // Whitespaces\n    if (code <= 32) {\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      token = value.slice(pos, next);\n\n      prev = tokens[tokens.length - 1];\n      if (code === closeParentheses && balanced) {\n        after = token;\n      } else if (prev && prev.type === \"div\") {\n        prev.after = token;\n        prev.sourceEndIndex += token.length;\n      } else if (\n        code === comma ||\n        code === colon ||\n        (code === slash &&\n          value.charCodeAt(next + 1) !== star &&\n          (!parent ||\n            (parent && parent.type === \"function\" && parent.value !== \"calc\")))\n      ) {\n        before = token;\n      } else {\n        tokens.push({\n          type: \"space\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n\n      // Quotes\n    } else if (code === singleQuote || code === doubleQuote) {\n      next = pos;\n      quote = code === singleQuote ? \"'\" : '\"';\n      token = {\n        type: \"string\",\n        sourceIndex: pos,\n        quote: quote\n      };\n      do {\n        escape = false;\n        next = value.indexOf(quote, next + 1);\n        if (~next) {\n          escapePos = next;\n          while (value.charCodeAt(escapePos - 1) === backslash) {\n            escapePos -= 1;\n            escape = !escape;\n          }\n        } else {\n          value += quote;\n          next = value.length - 1;\n          token.unclosed = true;\n        }\n      } while (escape);\n      token.value = value.slice(pos + 1, next);\n      token.sourceEndIndex = token.unclosed ? next : next + 1;\n      tokens.push(token);\n      pos = next + 1;\n      code = value.charCodeAt(pos);\n\n      // Comments\n    } else if (code === slash && value.charCodeAt(pos + 1) === star) {\n      next = value.indexOf(\"*/\", pos);\n\n      token = {\n        type: \"comment\",\n        sourceIndex: pos,\n        sourceEndIndex: next + 2\n      };\n\n      if (next === -1) {\n        token.unclosed = true;\n        next = value.length;\n        token.sourceEndIndex = next;\n      }\n\n      token.value = value.slice(pos + 2, next);\n      tokens.push(token);\n\n      pos = next + 2;\n      code = value.charCodeAt(pos);\n\n      // Operation within calc\n    } else if (\n      (code === slash || code === star) &&\n      parent &&\n      parent.type === \"function\" &&\n      parent.value === \"calc\"\n    ) {\n      token = value[pos];\n      tokens.push({\n        type: \"word\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token\n      });\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Dividers\n    } else if (code === slash || code === comma || code === colon) {\n      token = value[pos];\n\n      tokens.push({\n        type: \"div\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token,\n        before: before,\n        after: \"\"\n      });\n      before = \"\";\n\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Open parentheses\n    } else if (openParentheses === code) {\n      // Whitespaces after open parentheses\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      parenthesesOpenPos = pos;\n      token = {\n        type: \"function\",\n        sourceIndex: pos - name.length,\n        value: name,\n        before: value.slice(parenthesesOpenPos + 1, next)\n      };\n      pos = next;\n\n      if (name === \"url\" && code !== singleQuote && code !== doubleQuote) {\n        next -= 1;\n        do {\n          escape = false;\n          next = value.indexOf(\")\", next + 1);\n          if (~next) {\n            escapePos = next;\n            while (value.charCodeAt(escapePos - 1) === backslash) {\n              escapePos -= 1;\n              escape = !escape;\n            }\n          } else {\n            value += \")\";\n            next = value.length - 1;\n            token.unclosed = true;\n          }\n        } while (escape);\n        // Whitespaces before closed\n        whitespacePos = next;\n        do {\n          whitespacePos -= 1;\n          code = value.charCodeAt(whitespacePos);\n        } while (code <= 32);\n        if (parenthesesOpenPos < whitespacePos) {\n          if (pos !== whitespacePos + 1) {\n            token.nodes = [\n              {\n                type: \"word\",\n                sourceIndex: pos,\n                sourceEndIndex: whitespacePos + 1,\n                value: value.slice(pos, whitespacePos + 1)\n              }\n            ];\n          } else {\n            token.nodes = [];\n          }\n          if (token.unclosed && whitespacePos + 1 !== next) {\n            token.after = \"\";\n            token.nodes.push({\n              type: \"space\",\n              sourceIndex: whitespacePos + 1,\n              sourceEndIndex: next,\n              value: value.slice(whitespacePos + 1, next)\n            });\n          } else {\n            token.after = value.slice(whitespacePos + 1, next);\n            token.sourceEndIndex = next;\n          }\n        } else {\n          token.after = \"\";\n          token.nodes = [];\n        }\n        pos = next + 1;\n        token.sourceEndIndex = token.unclosed ? next : pos;\n        code = value.charCodeAt(pos);\n        tokens.push(token);\n      } else {\n        balanced += 1;\n        token.after = \"\";\n        token.sourceEndIndex = pos + 1;\n        tokens.push(token);\n        stack.push(token);\n        tokens = token.nodes = [];\n        parent = token;\n      }\n      name = \"\";\n\n      // Close parentheses\n    } else if (closeParentheses === code && balanced) {\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      parent.after = after;\n      parent.sourceEndIndex += after.length;\n      after = \"\";\n      balanced -= 1;\n      stack[stack.length - 1].sourceEndIndex = pos;\n      stack.pop();\n      parent = stack[balanced];\n      tokens = parent.nodes;\n\n      // Words\n    } else {\n      next = pos;\n      do {\n        if (code === backslash) {\n          next += 1;\n        }\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (\n        next < max &&\n        !(\n          code <= 32 ||\n          code === singleQuote ||\n          code === doubleQuote ||\n          code === comma ||\n          code === colon ||\n          code === slash ||\n          code === openParentheses ||\n          (code === star &&\n            parent &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === slash &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === closeParentheses && balanced)\n        )\n      );\n      token = value.slice(pos, next);\n\n      if (openParentheses === code) {\n        name = token;\n      } else if (\n        (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&\n        plus === token.charCodeAt(1) &&\n        isUnicodeRange.test(token.slice(2))\n      ) {\n        tokens.push({\n          type: \"unicode-range\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      } else {\n        tokens.push({\n          type: \"word\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n    }\n  }\n\n  for (pos = stack.length - 1; pos; pos -= 1) {\n    stack[pos].unclosed = true;\n    stack[pos].sourceEndIndex = value.length;\n  }\n\n  return stack[0].nodes;\n};\n"]}}