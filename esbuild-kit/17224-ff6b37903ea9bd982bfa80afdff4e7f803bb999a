{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});Object.defineProperty(exports,\"movePseudos\",{enumerable:true,get:function(){return movePseudos}});let elementProperties={\"::after\":[\"terminal\",\"jumpable\"],\"::backdrop\":[\"terminal\"],\"::before\":[\"terminal\",\"jumpable\"],\"::cue\":[\"terminal\"],\"::cue-region\":[\"terminal\"],\"::first-letter\":[\"terminal\",\"jumpable\"],\"::first-line\":[\"terminal\",\"jumpable\"],\"::grammar-error\":[\"terminal\"],\"::marker\":[\"terminal\"],\"::part\":[\"terminal\",\"actionable\"],\"::placeholder\":[\"terminal\"],\"::selection\":[\"terminal\"],\"::slotted\":[\"terminal\"],\"::spelling-error\":[\"terminal\"],\"::target-text\":[\"terminal\"],\"::file-selector-button\":[\"terminal\",\"actionable\"],\"::-webkit-progress-bar\":[\"terminal\",\"actionable\"],\"::-webkit-scrollbar\":[\"terminal\",\"actionable\"],\"::-webkit-scrollbar-button\":[\"terminal\",\"actionable\"],\"::-webkit-scrollbar-thumb\":[\"terminal\",\"actionable\"],\"::-webkit-scrollbar-track\":[\"terminal\",\"actionable\"],\"::-webkit-scrollbar-track-piece\":[\"terminal\",\"actionable\"],\"::-webkit-scrollbar-corner\":[\"terminal\",\"actionable\"],\"::-webkit-resizer\":[\"terminal\",\"actionable\"],\":after\":[\"terminal\",\"jumpable\"],\":before\":[\"terminal\",\"jumpable\"],\":first-letter\":[\"terminal\",\"jumpable\"],\":first-line\":[\"terminal\",\"jumpable\"],__default__:[\"actionable\"]};function movePseudos(sel){let[pseudos]=movablePseudos(sel);pseudos.forEach(([sel2,pseudo])=>sel2.removeChild(pseudo));sel.nodes.push(...pseudos.map(([,pseudo])=>pseudo));return sel}__name(movePseudos,\"movePseudos\");function movablePseudos(sel){let buffer=[];let lastSeenElement=null;for(let node of sel.nodes){if(node.type===\"combinator\"){buffer=buffer.filter(([,node2])=>propertiesForPseudo(node2).includes(\"jumpable\"));lastSeenElement=null}else if(node.type===\"pseudo\"){if(isMovablePseudoElement(node)){lastSeenElement=node;buffer.push([sel,node,null])}else if(lastSeenElement&&isAttachablePseudoClass(node,lastSeenElement)){buffer.push([sel,node,lastSeenElement])}else{lastSeenElement=null}var _node_nodes;for(let sub of(_node_nodes=node.nodes)!==null&&_node_nodes!==void 0?_node_nodes:[]){let[movable,lastSeenElementInSub]=movablePseudos(sub);lastSeenElement=lastSeenElementInSub||lastSeenElement;buffer.push(...movable)}}}return[buffer,lastSeenElement]}__name(movablePseudos,\"movablePseudos\");function isPseudoElement(node){return node.value.startsWith(\"::\")||elementProperties[node.value]!==void 0}__name(isPseudoElement,\"isPseudoElement\");function isMovablePseudoElement(node){return isPseudoElement(node)&&propertiesForPseudo(node).includes(\"terminal\")}__name(isMovablePseudoElement,\"isMovablePseudoElement\");function isAttachablePseudoClass(node,pseudo){if(node.type!==\"pseudo\")return false;if(isPseudoElement(node))return false;return propertiesForPseudo(pseudo).includes(\"actionable\")}__name(isAttachablePseudoClass,\"isAttachablePseudoClass\");function propertiesForPseudo(pseudo){var _elementProperties_pseudo_value;return(_elementProperties_pseudo_value=elementProperties[pseudo.value])!==null&&_elementProperties_pseudo_value!==void 0?_elementProperties_pseudo_value:elementProperties.__default__}__name(propertiesForPseudo,\"propertiesForPseudo\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["sel","node"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/util/pseudoElements.js"],"sourcesContent":["/** @typedef {import('postcss-selector-parser').Root} Root */ /** @typedef {import('postcss-selector-parser').Selector} Selector */ /** @typedef {import('postcss-selector-parser').Pseudo} Pseudo */ /** @typedef {import('postcss-selector-parser').Node} Node */ // There are some pseudo-elements that may or may not be:\n// **Actionable**\n// Zero or more user-action pseudo-classes may be attached to the pseudo-element itself\n// structural-pseudo-classes are NOT allowed but we don't make\n// The spec is not clear on whether this is allowed or not â€” but in practice it is.\n// **Terminal**\n// It MUST be placed at the end of a selector\n//\n// This is the required in the spec. However, some pseudo elements are not \"terminal\" because\n// they represent a \"boundary piercing\" that is compiled out by a build step.\n// **Jumpable**\n// Any terminal element may \"jump\" over combinators when moving to the end of the selector\n//\n// This is a backwards-compat quirk of :before and :after variants.\n/** @typedef {'terminal' | 'actionable' | 'jumpable'} PseudoProperty */ /** @type {Record<string, PseudoProperty[]>} */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"movePseudos\", {\n    enumerable: true,\n    get: function() {\n        return movePseudos;\n    }\n});\nlet elementProperties = {\n    \"::after\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \"::backdrop\": [\n        \"terminal\"\n    ],\n    \"::before\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \"::cue\": [\n        \"terminal\"\n    ],\n    \"::cue-region\": [\n        \"terminal\"\n    ],\n    \"::first-letter\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \"::first-line\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \"::grammar-error\": [\n        \"terminal\"\n    ],\n    \"::marker\": [\n        \"terminal\"\n    ],\n    \"::part\": [\n        \"terminal\",\n        \"actionable\"\n    ],\n    \"::placeholder\": [\n        \"terminal\"\n    ],\n    \"::selection\": [\n        \"terminal\"\n    ],\n    \"::slotted\": [\n        \"terminal\"\n    ],\n    \"::spelling-error\": [\n        \"terminal\"\n    ],\n    \"::target-text\": [\n        \"terminal\"\n    ],\n    // other\n    \"::file-selector-button\": [\n        \"terminal\",\n        \"actionable\"\n    ],\n    \"::-webkit-progress-bar\": [\n        \"terminal\",\n        \"actionable\"\n    ],\n    // Webkit scroll bar pseudo elements can be combined with user-action pseudo classes\n    \"::-webkit-scrollbar\": [\n        \"terminal\",\n        \"actionable\"\n    ],\n    \"::-webkit-scrollbar-button\": [\n        \"terminal\",\n        \"actionable\"\n    ],\n    \"::-webkit-scrollbar-thumb\": [\n        \"terminal\",\n        \"actionable\"\n    ],\n    \"::-webkit-scrollbar-track\": [\n        \"terminal\",\n        \"actionable\"\n    ],\n    \"::-webkit-scrollbar-track-piece\": [\n        \"terminal\",\n        \"actionable\"\n    ],\n    \"::-webkit-scrollbar-corner\": [\n        \"terminal\",\n        \"actionable\"\n    ],\n    \"::-webkit-resizer\": [\n        \"terminal\",\n        \"actionable\"\n    ],\n    // Note: As a rule, double colons (::) should be used instead of a single colon\n    // (:). This distinguishes pseudo-classes from pseudo-elements. However, since\n    // this distinction was not present in older versions of the W3C spec, most\n    // browsers support both syntaxes for the original pseudo-elements.\n    \":after\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \":before\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \":first-letter\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \":first-line\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    // The default value is used when the pseudo-element is not recognized\n    // Because it's not recognized, we don't know if it's terminal or not\n    // So we assume it can't be moved AND can have user-action pseudo classes attached to it\n    __default__: [\n        \"actionable\"\n    ]\n};\nfunction movePseudos(sel) {\n    let [pseudos] = movablePseudos(sel);\n    // Remove all pseudo elements from their respective selectors\n    pseudos.forEach(([sel, pseudo])=>sel.removeChild(pseudo));\n    // Re-add them to the end of the selector in the correct order.\n    // This moves terminal pseudo elements to the end of the\n    // selector otherwise the selector will not be valid.\n    //\n    // Examples:\n    //  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n    //  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n    //\n    // The selector `::before:hover` does not work but we\n    // can make it work for you by flipping the order.\n    sel.nodes.push(...pseudos.map(([, pseudo])=>pseudo));\n    return sel;\n}\n/** @typedef {[sel: Selector, pseudo: Pseudo, attachedTo: Pseudo | null]} MovablePseudo */ /** @typedef {[pseudos: MovablePseudo[], lastSeenElement: Pseudo | null]} MovablePseudosResult */ /**\n * @param {Selector} sel\n * @returns {MovablePseudosResult}\n */ function movablePseudos(sel) {\n    /** @type {MovablePseudo[]} */ let buffer = [];\n    /** @type {Pseudo | null} */ let lastSeenElement = null;\n    for (let node of sel.nodes){\n        if (node.type === \"combinator\") {\n            buffer = buffer.filter(([, node])=>propertiesForPseudo(node).includes(\"jumpable\"));\n            lastSeenElement = null;\n        } else if (node.type === \"pseudo\") {\n            if (isMovablePseudoElement(node)) {\n                lastSeenElement = node;\n                buffer.push([\n                    sel,\n                    node,\n                    null\n                ]);\n            } else if (lastSeenElement && isAttachablePseudoClass(node, lastSeenElement)) {\n                buffer.push([\n                    sel,\n                    node,\n                    lastSeenElement\n                ]);\n            } else {\n                lastSeenElement = null;\n            }\n            var _node_nodes;\n            for (let sub of (_node_nodes = node.nodes) !== null && _node_nodes !== void 0 ? _node_nodes : []){\n                let [movable, lastSeenElementInSub] = movablePseudos(sub);\n                lastSeenElement = lastSeenElementInSub || lastSeenElement;\n                buffer.push(...movable);\n            }\n        }\n    }\n    return [\n        buffer,\n        lastSeenElement\n    ];\n}\n/**\n * @param {Node} node\n * @returns {boolean}\n */ function isPseudoElement(node) {\n    return node.value.startsWith(\"::\") || elementProperties[node.value] !== undefined;\n}\n/**\n * @param {Node} node\n * @returns {boolean}\n */ function isMovablePseudoElement(node) {\n    return isPseudoElement(node) && propertiesForPseudo(node).includes(\"terminal\");\n}\n/**\n * @param {Node} node\n * @param {Pseudo} pseudo\n * @returns {boolean}\n */ function isAttachablePseudoClass(node, pseudo) {\n    if (node.type !== \"pseudo\") return false;\n    if (isPseudoElement(node)) return false;\n    return propertiesForPseudo(pseudo).includes(\"actionable\");\n}\n/**\n * @param {Pseudo} pseudo\n * @returns {PseudoProperty[]}\n */ function propertiesForPseudo(pseudo) {\n    var _elementProperties_pseudo_value;\n    return (_elementProperties_pseudo_value = elementProperties[pseudo.value]) !== null && _elementProperties_pseudo_value !== void 0 ? _elementProperties_pseudo_value : elementProperties.__default__;\n}\n"]}}