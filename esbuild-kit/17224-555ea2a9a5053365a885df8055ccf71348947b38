{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interopRequireDefault,\"_interopRequireDefault\");var _types=require(\"../parser/tokenizer/types\");var _isIdentifier=require(\"../util/isIdentifier\");var _isIdentifier2=_interopRequireDefault(_isIdentifier);var _Transformer=require(\"./Transformer\");var _Transformer2=_interopRequireDefault(_Transformer);class TypeScriptTransformer extends _Transformer2.default{constructor(rootTransformer,tokens,isImportsTransformEnabled){super();this.rootTransformer=rootTransformer;this.tokens=tokens;this.isImportsTransformEnabled=isImportsTransformEnabled;;}process(){if(this.rootTransformer.processPossibleArrowParamEnd()||this.rootTransformer.processPossibleAsyncArrowWithTypeParams()||this.rootTransformer.processPossibleTypeRange()){return true}if(this.tokens.matches1(_types.TokenType._public)||this.tokens.matches1(_types.TokenType._protected)||this.tokens.matches1(_types.TokenType._private)||this.tokens.matches1(_types.TokenType._abstract)||this.tokens.matches1(_types.TokenType._readonly)||this.tokens.matches1(_types.TokenType._override)||this.tokens.matches1(_types.TokenType.nonNullAssertion)){this.tokens.removeInitialToken();return true}if(this.tokens.matches1(_types.TokenType._enum)||this.tokens.matches2(_types.TokenType._const,_types.TokenType._enum)){this.processEnum();return true}if(this.tokens.matches2(_types.TokenType._export,_types.TokenType._enum)||this.tokens.matches3(_types.TokenType._export,_types.TokenType._const,_types.TokenType._enum)){this.processEnum(true);return true}return false}processEnum(isExport=false){this.tokens.removeInitialToken();while(this.tokens.matches1(_types.TokenType._const)||this.tokens.matches1(_types.TokenType._enum)){this.tokens.removeToken()}const enumName=this.tokens.identifierName();this.tokens.removeToken();if(isExport&&!this.isImportsTransformEnabled){this.tokens.appendCode(\"export \")}this.tokens.appendCode(`var ${enumName}; (function (${enumName})`);this.tokens.copyExpectedToken(_types.TokenType.braceL);this.processEnumBody(enumName);this.tokens.copyExpectedToken(_types.TokenType.braceR);if(isExport&&this.isImportsTransformEnabled){this.tokens.appendCode(`)(${enumName} || (exports.${enumName} = ${enumName} = {}));`)}else{this.tokens.appendCode(`)(${enumName} || (${enumName} = {}));`)}}processEnumBody(enumName){let previousValueCode=null;while(true){if(this.tokens.matches1(_types.TokenType.braceR)){break}const{nameStringCode,variableName}=this.extractEnumKeyInfo(this.tokens.currentToken());this.tokens.removeInitialToken();if(this.tokens.matches3(_types.TokenType.eq,_types.TokenType.string,_types.TokenType.comma)||this.tokens.matches3(_types.TokenType.eq,_types.TokenType.string,_types.TokenType.braceR)){this.processStringLiteralEnumMember(enumName,nameStringCode,variableName)}else if(this.tokens.matches1(_types.TokenType.eq)){this.processExplicitValueEnumMember(enumName,nameStringCode,variableName)}else{this.processImplicitValueEnumMember(enumName,nameStringCode,variableName,previousValueCode)}if(this.tokens.matches1(_types.TokenType.comma)){this.tokens.removeToken()}if(variableName!=null){previousValueCode=variableName}else{previousValueCode=`${enumName}[${nameStringCode}]`}}}extractEnumKeyInfo(nameToken){if(nameToken.type===_types.TokenType.name){const name=this.tokens.identifierNameForToken(nameToken);return{nameStringCode:`\"${name}\"`,variableName:_isIdentifier2.default.call(void 0,name)?name:null}}else if(nameToken.type===_types.TokenType.string){const name=this.tokens.stringValueForToken(nameToken);return{nameStringCode:this.tokens.code.slice(nameToken.start,nameToken.end),variableName:_isIdentifier2.default.call(void 0,name)?name:null}}else{throw new Error(\"Expected name or string at beginning of enum element.\")}}processStringLiteralEnumMember(enumName,nameStringCode,variableName){if(variableName!=null){this.tokens.appendCode(`const ${variableName}`);this.tokens.copyToken();this.tokens.copyToken();this.tokens.appendCode(`; ${enumName}[${nameStringCode}] = ${variableName};`)}else{this.tokens.appendCode(`${enumName}[${nameStringCode}]`);this.tokens.copyToken();this.tokens.copyToken();this.tokens.appendCode(\";\")}}processExplicitValueEnumMember(enumName,nameStringCode,variableName){const rhsEndIndex=this.tokens.currentToken().rhsEndIndex;if(rhsEndIndex==null){throw new Error(\"Expected rhsEndIndex on enum assign.\")}if(variableName!=null){this.tokens.appendCode(`const ${variableName}`);this.tokens.copyToken();while(this.tokens.currentIndex()<rhsEndIndex){this.rootTransformer.processToken()}this.tokens.appendCode(`; ${enumName}[${enumName}[${nameStringCode}] = ${variableName}] = ${nameStringCode};`)}else{this.tokens.appendCode(`${enumName}[${enumName}[${nameStringCode}]`);this.tokens.copyToken();while(this.tokens.currentIndex()<rhsEndIndex){this.rootTransformer.processToken()}this.tokens.appendCode(`] = ${nameStringCode};`)}}processImplicitValueEnumMember(enumName,nameStringCode,variableName,previousValueCode){let valueCode=previousValueCode!=null?`${previousValueCode} + 1`:\"0\";if(variableName!=null){this.tokens.appendCode(`const ${variableName} = ${valueCode}; `);valueCode=variableName}this.tokens.appendCode(`${enumName}[${enumName}[${nameStringCode}] = ${valueCode}] = ${nameStringCode};`)}}__name(TypeScriptTransformer,\"TypeScriptTransformer\");exports.default=TypeScriptTransformer;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/transformers/TypeScriptTransformer.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar _types = require('../parser/tokenizer/types');\n\nvar _isIdentifier = require('../util/isIdentifier'); var _isIdentifier2 = _interopRequireDefault(_isIdentifier);\n\nvar _Transformer = require('./Transformer'); var _Transformer2 = _interopRequireDefault(_Transformer);\n\n class TypeScriptTransformer extends _Transformer2.default {\n  constructor(\n     rootTransformer,\n     tokens,\n     isImportsTransformEnabled,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.isImportsTransformEnabled = isImportsTransformEnabled;;\n  }\n\n  process() {\n    if (\n      this.rootTransformer.processPossibleArrowParamEnd() ||\n      this.rootTransformer.processPossibleAsyncArrowWithTypeParams() ||\n      this.rootTransformer.processPossibleTypeRange()\n    ) {\n      return true;\n    }\n    if (\n      this.tokens.matches1(_types.TokenType._public) ||\n      this.tokens.matches1(_types.TokenType._protected) ||\n      this.tokens.matches1(_types.TokenType._private) ||\n      this.tokens.matches1(_types.TokenType._abstract) ||\n      this.tokens.matches1(_types.TokenType._readonly) ||\n      this.tokens.matches1(_types.TokenType._override) ||\n      this.tokens.matches1(_types.TokenType.nonNullAssertion)\n    ) {\n      this.tokens.removeInitialToken();\n      return true;\n    }\n    if (this.tokens.matches1(_types.TokenType._enum) || this.tokens.matches2(_types.TokenType._const, _types.TokenType._enum)) {\n      this.processEnum();\n      return true;\n    }\n    if (\n      this.tokens.matches2(_types.TokenType._export, _types.TokenType._enum) ||\n      this.tokens.matches3(_types.TokenType._export, _types.TokenType._const, _types.TokenType._enum)\n    ) {\n      this.processEnum(true);\n      return true;\n    }\n    return false;\n  }\n\n  processEnum(isExport = false) {\n    // We might have \"export const enum\", so just remove all relevant tokens.\n    this.tokens.removeInitialToken();\n    while (this.tokens.matches1(_types.TokenType._const) || this.tokens.matches1(_types.TokenType._enum)) {\n      this.tokens.removeToken();\n    }\n    const enumName = this.tokens.identifierName();\n    this.tokens.removeToken();\n    if (isExport && !this.isImportsTransformEnabled) {\n      this.tokens.appendCode(\"export \");\n    }\n    this.tokens.appendCode(`var ${enumName}; (function (${enumName})`);\n    this.tokens.copyExpectedToken(_types.TokenType.braceL);\n    this.processEnumBody(enumName);\n    this.tokens.copyExpectedToken(_types.TokenType.braceR);\n    if (isExport && this.isImportsTransformEnabled) {\n      this.tokens.appendCode(`)(${enumName} || (exports.${enumName} = ${enumName} = {}));`);\n    } else {\n      this.tokens.appendCode(`)(${enumName} || (${enumName} = {}));`);\n    }\n  }\n\n  /**\n   * Transform an enum into equivalent JS. This has complexity in a few places:\n   * - TS allows string enums, numeric enums, and a mix of the two styles within an enum.\n   * - Enum keys are allowed to be referenced in later enum values.\n   * - Enum keys are allowed to be strings.\n   * - When enum values are omitted, they should follow an auto-increment behavior.\n   */\n  processEnumBody(enumName) {\n    // Code that can be used to reference the previous enum member, or null if this is the first\n    // enum member.\n    let previousValueCode = null;\n    while (true) {\n      if (this.tokens.matches1(_types.TokenType.braceR)) {\n        break;\n      }\n      const {nameStringCode, variableName} = this.extractEnumKeyInfo(this.tokens.currentToken());\n      this.tokens.removeInitialToken();\n\n      if (\n        this.tokens.matches3(_types.TokenType.eq, _types.TokenType.string, _types.TokenType.comma) ||\n        this.tokens.matches3(_types.TokenType.eq, _types.TokenType.string, _types.TokenType.braceR)\n      ) {\n        this.processStringLiteralEnumMember(enumName, nameStringCode, variableName);\n      } else if (this.tokens.matches1(_types.TokenType.eq)) {\n        this.processExplicitValueEnumMember(enumName, nameStringCode, variableName);\n      } else {\n        this.processImplicitValueEnumMember(\n          enumName,\n          nameStringCode,\n          variableName,\n          previousValueCode,\n        );\n      }\n      if (this.tokens.matches1(_types.TokenType.comma)) {\n        this.tokens.removeToken();\n      }\n\n      if (variableName != null) {\n        previousValueCode = variableName;\n      } else {\n        previousValueCode = `${enumName}[${nameStringCode}]`;\n      }\n    }\n  }\n\n  /**\n   * Detect name information about this enum key, which will be used to determine which code to emit\n   * and whether we should declare a variable as part of this declaration.\n   *\n   * Some cases to keep in mind:\n   * - Enum keys can be implicitly referenced later, e.g. `X = 1, Y = X`. In Sucrase, we implement\n   *   this by declaring a variable `X` so that later expressions can use it.\n   * - In addition to the usual identifier key syntax, enum keys are allowed to be string literals,\n   *   e.g. `\"hello world\" = 3,`. Template literal syntax is NOT allowed.\n   * - Even if the enum key is defined as a string literal, it may still be referenced by identifier\n   *   later, e.g. `\"X\" = 1, Y = X`. That means that we need to detect whether or not a string\n   *   literal is identifier-like and emit a variable if so, even if the declaration did not use an\n   *   identifier.\n   * - Reserved keywords like `break` are valid enum keys, but are not valid to be referenced later\n   *   and would be a syntax error if we emitted a variable, so we need to skip the variable\n   *   declaration in those cases.\n   *\n   * The variableName return value captures these nuances: if non-null, we can and must emit a\n   * variable declaration, and if null, we can't and shouldn't.\n   */\n  extractEnumKeyInfo(nameToken) {\n    if (nameToken.type === _types.TokenType.name) {\n      const name = this.tokens.identifierNameForToken(nameToken);\n      return {\n        nameStringCode: `\"${name}\"`,\n        variableName: _isIdentifier2.default.call(void 0, name) ? name : null,\n      };\n    } else if (nameToken.type === _types.TokenType.string) {\n      const name = this.tokens.stringValueForToken(nameToken);\n      return {\n        nameStringCode: this.tokens.code.slice(nameToken.start, nameToken.end),\n        variableName: _isIdentifier2.default.call(void 0, name) ? name : null,\n      };\n    } else {\n      throw new Error(\"Expected name or string at beginning of enum element.\");\n    }\n  }\n\n  /**\n   * Handle an enum member where the RHS is just a string literal (not omitted, not a number, and\n   * not a complex expression). This is the typical form for TS string enums, and in this case, we\n   * do *not* create a reverse mapping.\n   *\n   * This is called after deleting the key token, when the token processor is at the equals sign.\n   *\n   * Example 1:\n   * someKey = \"some value\"\n   * ->\n   * const someKey = \"some value\"; MyEnum[\"someKey\"] = someKey;\n   *\n   * Example 2:\n   * \"some key\" = \"some value\"\n   * ->\n   * MyEnum[\"some key\"] = \"some value\";\n   */\n  processStringLiteralEnumMember(\n    enumName,\n    nameStringCode,\n    variableName,\n  ) {\n    if (variableName != null) {\n      this.tokens.appendCode(`const ${variableName}`);\n      // =\n      this.tokens.copyToken();\n      // value string\n      this.tokens.copyToken();\n      this.tokens.appendCode(`; ${enumName}[${nameStringCode}] = ${variableName};`);\n    } else {\n      this.tokens.appendCode(`${enumName}[${nameStringCode}]`);\n      // =\n      this.tokens.copyToken();\n      // value string\n      this.tokens.copyToken();\n      this.tokens.appendCode(\";\");\n    }\n  }\n\n  /**\n   * Handle an enum member initialized with an expression on the right-hand side (other than a\n   * string literal). In these cases, we should transform the expression and emit code that sets up\n   * a reverse mapping.\n   *\n   * The TypeScript implementation of this operation distinguishes between expressions that can be\n   * \"constant folded\" at compile time (i.e. consist of number literals and simple math operations\n   * on those numbers) and ones that are dynamic. For constant expressions, it emits the resolved\n   * numeric value, and auto-incrementing is only allowed in that case. Evaluating expressions at\n   * compile time would add significant complexity to Sucrase, so Sucrase instead leaves the\n   * expression as-is, and will later emit something like `MyEnum[\"previousKey\"] + 1` to implement\n   * auto-incrementing.\n   *\n   * This is called after deleting the key token, when the token processor is at the equals sign.\n   *\n   * Example 1:\n   * someKey = 1 + 1\n   * ->\n   * const someKey = 1 + 1; MyEnum[MyEnum[\"someKey\"] = someKey] = \"someKey\";\n   *\n   * Example 2:\n   * \"some key\" = 1 + 1\n   * ->\n   * MyEnum[MyEnum[\"some key\"] = 1 + 1] = \"some key\";\n   */\n  processExplicitValueEnumMember(\n    enumName,\n    nameStringCode,\n    variableName,\n  ) {\n    const rhsEndIndex = this.tokens.currentToken().rhsEndIndex;\n    if (rhsEndIndex == null) {\n      throw new Error(\"Expected rhsEndIndex on enum assign.\");\n    }\n\n    if (variableName != null) {\n      this.tokens.appendCode(`const ${variableName}`);\n      this.tokens.copyToken();\n      while (this.tokens.currentIndex() < rhsEndIndex) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.appendCode(\n        `; ${enumName}[${enumName}[${nameStringCode}] = ${variableName}] = ${nameStringCode};`,\n      );\n    } else {\n      this.tokens.appendCode(`${enumName}[${enumName}[${nameStringCode}]`);\n      this.tokens.copyToken();\n      while (this.tokens.currentIndex() < rhsEndIndex) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.appendCode(`] = ${nameStringCode};`);\n    }\n  }\n\n  /**\n   * Handle an enum member with no right-hand side expression. In this case, the value is the\n   * previous value plus 1, or 0 if there was no previous value. We should also always emit a\n   * reverse mapping.\n   *\n   * Example 1:\n   * someKey2\n   * ->\n   * const someKey2 = someKey1 + 1; MyEnum[MyEnum[\"someKey2\"] = someKey2] = \"someKey2\";\n   *\n   * Example 2:\n   * \"some key 2\"\n   * ->\n   * MyEnum[MyEnum[\"some key 2\"] = someKey1 + 1] = \"some key 2\";\n   */\n  processImplicitValueEnumMember(\n    enumName,\n    nameStringCode,\n    variableName,\n    previousValueCode,\n  ) {\n    let valueCode = previousValueCode != null ? `${previousValueCode} + 1` : \"0\";\n    if (variableName != null) {\n      this.tokens.appendCode(`const ${variableName} = ${valueCode}; `);\n      valueCode = variableName;\n    }\n    this.tokens.appendCode(\n      `${enumName}[${enumName}[${nameStringCode}] = ${valueCode}] = ${nameStringCode};`,\n    );\n  }\n} exports.default = TypeScriptTransformer;\n"]}}