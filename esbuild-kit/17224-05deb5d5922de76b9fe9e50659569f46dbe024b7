{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});exports.convertPatternGroupToTask=exports.convertPatternGroupsToTasks=exports.groupPatternsByBaseDirectory=exports.getNegativePatternsAsPositive=exports.getPositivePatterns=exports.convertPatternsToTasks=exports.generate=void 0;const utils=require(\"../utils\");function generate(patterns,settings){const positivePatterns=getPositivePatterns(patterns);const negativePatterns=getNegativePatternsAsPositive(patterns,settings.ignore);const staticPatterns=positivePatterns.filter(pattern=>utils.pattern.isStaticPattern(pattern,settings));const dynamicPatterns=positivePatterns.filter(pattern=>utils.pattern.isDynamicPattern(pattern,settings));const staticTasks=convertPatternsToTasks(staticPatterns,negativePatterns,false);const dynamicTasks=convertPatternsToTasks(dynamicPatterns,negativePatterns,true);return staticTasks.concat(dynamicTasks)}__name(generate,\"generate\");exports.generate=generate;function convertPatternsToTasks(positive,negative,dynamic){const tasks=[];const patternsOutsideCurrentDirectory=utils.pattern.getPatternsOutsideCurrentDirectory(positive);const patternsInsideCurrentDirectory=utils.pattern.getPatternsInsideCurrentDirectory(positive);const outsideCurrentDirectoryGroup=groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);const insideCurrentDirectoryGroup=groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup,negative,dynamic));if(\".\"in insideCurrentDirectoryGroup){tasks.push(convertPatternGroupToTask(\".\",patternsInsideCurrentDirectory,negative,dynamic))}else{tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup,negative,dynamic))}return tasks}__name(convertPatternsToTasks,\"convertPatternsToTasks\");exports.convertPatternsToTasks=convertPatternsToTasks;function getPositivePatterns(patterns){return utils.pattern.getPositivePatterns(patterns)}__name(getPositivePatterns,\"getPositivePatterns\");exports.getPositivePatterns=getPositivePatterns;function getNegativePatternsAsPositive(patterns,ignore){const negative=utils.pattern.getNegativePatterns(patterns).concat(ignore);const positive=negative.map(utils.pattern.convertToPositivePattern);return positive}__name(getNegativePatternsAsPositive,\"getNegativePatternsAsPositive\");exports.getNegativePatternsAsPositive=getNegativePatternsAsPositive;function groupPatternsByBaseDirectory(patterns){const group={};return patterns.reduce((collection,pattern)=>{const base=utils.pattern.getBaseDirectory(pattern);if(base in collection){collection[base].push(pattern)}else{collection[base]=[pattern]}return collection},group)}__name(groupPatternsByBaseDirectory,\"groupPatternsByBaseDirectory\");exports.groupPatternsByBaseDirectory=groupPatternsByBaseDirectory;function convertPatternGroupsToTasks(positive,negative,dynamic){return Object.keys(positive).map(base=>{return convertPatternGroupToTask(base,positive[base],negative,dynamic)})}__name(convertPatternGroupsToTasks,\"convertPatternGroupsToTasks\");exports.convertPatternGroupsToTasks=convertPatternGroupsToTasks;function convertPatternGroupToTask(base,positive,negative,dynamic){return{dynamic,positive,negative,base,patterns:[].concat(positive,negative.map(utils.pattern.convertToNegativePattern))}}__name(convertPatternGroupToTask,\"convertPatternGroupToTask\");exports.convertPatternGroupToTask=convertPatternGroupToTask;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CAAE,MAAO,IAAK,CAAC,EAC5D,QAAQ,0BAA4B,QAAQ,4BAA8B,QAAQ,6BAA+B,QAAQ,8BAAgC,QAAQ,oBAAsB,QAAQ,uBAAyB,QAAQ,SAAW,OAC3O,MAAM,MAAQ,QAAQ,UAAU,EAChC,SAAS,SAAS,SAAU,SAAU,CAClC,MAAM,iBAAmB,oBAAoB,QAAQ,EACrD,MAAM,iBAAmB,8BAA8B,SAAU,SAAS,MAAM,EAChF,MAAM,eAAiB,iBAAiB,OAAQ,SAAY,MAAM,QAAQ,gBAAgB,QAAS,QAAQ,CAAC,EAC5G,MAAM,gBAAkB,iBAAiB,OAAQ,SAAY,MAAM,QAAQ,iBAAiB,QAAS,QAAQ,CAAC,EAC9G,MAAM,YAAc,uBAAuB,eAAgB,iBAAgC,KAAK,EAChG,MAAM,aAAe,uBAAuB,gBAAiB,iBAAgC,IAAI,EACjG,OAAO,YAAY,OAAO,YAAY,CAC1C,CARS,4BAST,QAAQ,SAAW,SAOnB,SAAS,uBAAuB,SAAU,SAAU,QAAS,CACzD,MAAM,MAAQ,CAAC,EACf,MAAM,gCAAkC,MAAM,QAAQ,mCAAmC,QAAQ,EACjG,MAAM,+BAAiC,MAAM,QAAQ,kCAAkC,QAAQ,EAC/F,MAAM,6BAA+B,6BAA6B,+BAA+B,EACjG,MAAM,4BAA8B,6BAA6B,8BAA8B,EAC/F,MAAM,KAAK,GAAG,4BAA4B,6BAA8B,SAAU,OAAO,CAAC,EAK1F,GAAI,MAAO,4BAA6B,CACpC,MAAM,KAAK,0BAA0B,IAAK,+BAAgC,SAAU,OAAO,CAAC,CAChG,KACK,CACD,MAAM,KAAK,GAAG,4BAA4B,4BAA6B,SAAU,OAAO,CAAC,CAC7F,CACA,OAAO,KACX,CAlBS,wDAmBT,QAAQ,uBAAyB,uBACjC,SAAS,oBAAoB,SAAU,CACnC,OAAO,MAAM,QAAQ,oBAAoB,QAAQ,CACrD,CAFS,kDAGT,QAAQ,oBAAsB,oBAC9B,SAAS,8BAA8B,SAAU,OAAQ,CACrD,MAAM,SAAW,MAAM,QAAQ,oBAAoB,QAAQ,EAAE,OAAO,MAAM,EAC1E,MAAM,SAAW,SAAS,IAAI,MAAM,QAAQ,wBAAwB,EACpE,OAAO,QACX,CAJS,sEAKT,QAAQ,8BAAgC,8BACxC,SAAS,6BAA6B,SAAU,CAC5C,MAAM,MAAQ,CAAC,EACf,OAAO,SAAS,OAAO,CAAC,WAAY,UAAY,CAC5C,MAAM,KAAO,MAAM,QAAQ,iBAAiB,OAAO,EACnD,GAAI,QAAQ,WAAY,CACpB,WAAW,IAAI,EAAE,KAAK,OAAO,CACjC,KACK,CACD,WAAW,IAAI,EAAI,CAAC,OAAO,CAC/B,CACA,OAAO,UACX,EAAG,KAAK,CACZ,CAZS,oEAaT,QAAQ,6BAA+B,6BACvC,SAAS,4BAA4B,SAAU,SAAU,QAAS,CAC9D,OAAO,OAAO,KAAK,QAAQ,EAAE,IAAK,MAAS,CACvC,OAAO,0BAA0B,KAAM,SAAS,IAAI,EAAG,SAAU,OAAO,CAC5E,CAAC,CACL,CAJS,kEAKT,QAAQ,4BAA8B,4BACtC,SAAS,0BAA0B,KAAM,SAAU,SAAU,QAAS,CAClE,MAAO,CACH,QACA,SACA,SACA,KACA,SAAU,CAAC,EAAE,OAAO,SAAU,SAAS,IAAI,MAAM,QAAQ,wBAAwB,CAAC,CACtF,CACJ,CARS,8DAST,QAAQ,0BAA4B","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/managers/tasks.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;\r\nconst utils = require(\"../utils\");\r\nfunction generate(patterns, settings) {\r\n    const positivePatterns = getPositivePatterns(patterns);\r\n    const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);\r\n    const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));\r\n    const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));\r\n    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);\r\n    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);\r\n    return staticTasks.concat(dynamicTasks);\r\n}\r\nexports.generate = generate;\r\n/**\r\n * Returns tasks grouped by basic pattern directories.\r\n *\r\n * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.\r\n * This is necessary because directory traversal starts at the base directory and goes deeper.\r\n */\r\nfunction convertPatternsToTasks(positive, negative, dynamic) {\r\n    const tasks = [];\r\n    const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);\r\n    const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);\r\n    const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);\r\n    const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);\r\n    tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));\r\n    /*\r\n     * For the sake of reducing future accesses to the file system, we merge all tasks within the current directory\r\n     * into a global task, if at least one pattern refers to the root (`.`). In this case, the global task covers the rest.\r\n     */\r\n    if ('.' in insideCurrentDirectoryGroup) {\r\n        tasks.push(convertPatternGroupToTask('.', patternsInsideCurrentDirectory, negative, dynamic));\r\n    }\r\n    else {\r\n        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));\r\n    }\r\n    return tasks;\r\n}\r\nexports.convertPatternsToTasks = convertPatternsToTasks;\r\nfunction getPositivePatterns(patterns) {\r\n    return utils.pattern.getPositivePatterns(patterns);\r\n}\r\nexports.getPositivePatterns = getPositivePatterns;\r\nfunction getNegativePatternsAsPositive(patterns, ignore) {\r\n    const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);\r\n    const positive = negative.map(utils.pattern.convertToPositivePattern);\r\n    return positive;\r\n}\r\nexports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;\r\nfunction groupPatternsByBaseDirectory(patterns) {\r\n    const group = {};\r\n    return patterns.reduce((collection, pattern) => {\r\n        const base = utils.pattern.getBaseDirectory(pattern);\r\n        if (base in collection) {\r\n            collection[base].push(pattern);\r\n        }\r\n        else {\r\n            collection[base] = [pattern];\r\n        }\r\n        return collection;\r\n    }, group);\r\n}\r\nexports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;\r\nfunction convertPatternGroupsToTasks(positive, negative, dynamic) {\r\n    return Object.keys(positive).map((base) => {\r\n        return convertPatternGroupToTask(base, positive[base], negative, dynamic);\r\n    });\r\n}\r\nexports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;\r\nfunction convertPatternGroupToTask(base, positive, negative, dynamic) {\r\n    return {\r\n        dynamic,\r\n        positive,\r\n        negative,\r\n        base,\r\n        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))\r\n    };\r\n}\r\nexports.convertPatternGroupToTask = convertPatternGroupToTask;\r\n"]}}