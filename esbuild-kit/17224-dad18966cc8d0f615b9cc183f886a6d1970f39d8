{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */const util=require(\"util\");const toRegexRange=require(\"to-regex-range\");const isObject=__name(val=>val!==null&&typeof val===\"object\"&&!Array.isArray(val),\"isObject\");const transform=__name(toNumber=>{return value=>toNumber===true?Number(value):String(value)},\"transform\");const isValidValue=__name(value=>{return typeof value===\"number\"||typeof value===\"string\"&&value!==\"\"},\"isValidValue\");const isNumber=__name(num=>Number.isInteger(+num),\"isNumber\");const zeros=__name(input=>{let value=`${input}`;let index=-1;if(value[0]===\"-\")value=value.slice(1);if(value===\"0\")return false;while(value[++index]===\"0\");return index>0},\"zeros\");const stringify=__name((start,end,options)=>{if(typeof start===\"string\"||typeof end===\"string\"){return true}return options.stringify===true},\"stringify\");const pad=__name((input,maxLength,toNumber)=>{if(maxLength>0){let dash=input[0]===\"-\"?\"-\":\"\";if(dash)input=input.slice(1);input=dash+input.padStart(dash?maxLength-1:maxLength,\"0\")}if(toNumber===false){return String(input)}return input},\"pad\");const toMaxLen=__name((input,maxLength)=>{let negative=input[0]===\"-\"?\"-\":\"\";if(negative){input=input.slice(1);maxLength--}while(input.length<maxLength)input=\"0\"+input;return negative?\"-\"+input:input},\"toMaxLen\");const toSequence=__name((parts,options)=>{parts.negatives.sort((a,b)=>a<b?-1:a>b?1:0);parts.positives.sort((a,b)=>a<b?-1:a>b?1:0);let prefix=options.capture?\"\":\"?:\";let positives=\"\";let negatives=\"\";let result;if(parts.positives.length){positives=parts.positives.join(\"|\")}if(parts.negatives.length){negatives=`-(${prefix}${parts.negatives.join(\"|\")})`}if(positives&&negatives){result=`${positives}|${negatives}`}else{result=positives||negatives}if(options.wrap){return`(${prefix}${result})`}return result},\"toSequence\");const toRange=__name((a,b,isNumbers,options)=>{if(isNumbers){return toRegexRange(a,b,{wrap:false,...options})}let start=String.fromCharCode(a);if(a===b)return start;let stop=String.fromCharCode(b);return`[${start}-${stop}]`},\"toRange\");const toRegex=__name((start,end,options)=>{if(Array.isArray(start)){let wrap=options.wrap===true;let prefix=options.capture?\"\":\"?:\";return wrap?`(${prefix}${start.join(\"|\")})`:start.join(\"|\")}return toRegexRange(start,end,options)},\"toRegex\");const rangeError=__name((...args)=>{return new RangeError(\"Invalid range arguments: \"+util.inspect(...args))},\"rangeError\");const invalidRange=__name((start,end,options)=>{if(options.strictRanges===true)throw rangeError([start,end]);return[]},\"invalidRange\");const invalidStep=__name((step,options)=>{if(options.strictRanges===true){throw new TypeError(`Expected step \"${step}\" to be a number`)}return[]},\"invalidStep\");const fillNumbers=__name((start,end,step=1,options={})=>{let a=Number(start);let b=Number(end);if(!Number.isInteger(a)||!Number.isInteger(b)){if(options.strictRanges===true)throw rangeError([start,end]);return[]}if(a===0)a=0;if(b===0)b=0;let descending=a>b;let startString=String(start);let endString=String(end);let stepString=String(step);step=Math.max(Math.abs(step),1);let padded=zeros(startString)||zeros(endString)||zeros(stepString);let maxLen=padded?Math.max(startString.length,endString.length,stepString.length):0;let toNumber=padded===false&&stringify(start,end,options)===false;let format=options.transform||transform(toNumber);if(options.toRegex&&step===1){return toRange(toMaxLen(start,maxLen),toMaxLen(end,maxLen),true,options)}let parts={negatives:[],positives:[]};let push=__name(num=>parts[num<0?\"negatives\":\"positives\"].push(Math.abs(num)),\"push\");let range=[];let index=0;while(descending?a>=b:a<=b){if(options.toRegex===true&&step>1){push(a)}else{range.push(pad(format(a,index),maxLen,toNumber))}a=descending?a-step:a+step;index++}if(options.toRegex===true){return step>1?toSequence(parts,options):toRegex(range,null,{wrap:false,...options})}return range},\"fillNumbers\");const fillLetters=__name((start,end,step=1,options={})=>{if(!isNumber(start)&&start.length>1||!isNumber(end)&&end.length>1){return invalidRange(start,end,options)}let format=options.transform||(val=>String.fromCharCode(val));let a=`${start}`.charCodeAt(0);let b=`${end}`.charCodeAt(0);let descending=a>b;let min=Math.min(a,b);let max=Math.max(a,b);if(options.toRegex&&step===1){return toRange(min,max,false,options)}let range=[];let index=0;while(descending?a>=b:a<=b){range.push(format(a,index));a=descending?a-step:a+step;index++}if(options.toRegex===true){return toRegex(range,null,{wrap:false,options})}return range},\"fillLetters\");const fill=__name((start,end,step,options={})=>{if(end==null&&isValidValue(start)){return[start]}if(!isValidValue(start)||!isValidValue(end)){return invalidRange(start,end,options)}if(typeof step===\"function\"){return fill(start,end,1,{transform:step})}if(isObject(step)){return fill(start,end,0,step)}let opts={...options};if(opts.capture===true)opts.wrap=true;step=step||opts.step||1;if(!isNumber(step)){if(step!=null&&!isObject(step))return invalidStep(step,opts);return fill(start,end,1,step)}if(isNumber(start)&&isNumber(end)){return fillNumbers(start,end,step,opts)}return fillLetters(start,end,Math.max(Math.abs(step),1),opts)},\"fill\");module.exports=fill;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js"],"sourcesContent":["/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nconst util = require('util');\nconst toRegexRange = require('to-regex-range');\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;\n"]}}