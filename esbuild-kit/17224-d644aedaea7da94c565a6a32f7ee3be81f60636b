{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interopRequireDefault,\"_interopRequireDefault\");function _optionalChain(ops){let lastAccessLHS=void 0;let value=ops[0];let i=1;while(i<ops.length){const op=ops[i];const fn=ops[i+1];i+=2;if((op===\"optionalAccess\"||op===\"optionalCall\")&&value==null){return void 0}if(op===\"access\"||op===\"optionalAccess\"){lastAccessLHS=value;value=fn(value)}else if(op===\"call\"||op===\"optionalCall\"){value=fn((...args)=>value.call(lastAccessLHS,...args));lastAccessLHS=void 0}}return value}__name(_optionalChain,\"_optionalChain\");var _types=require(\"../parser/tokenizer/types\");var _Transformer=require(\"./Transformer\");var _Transformer2=_interopRequireDefault(_Transformer);const JEST_GLOBAL_NAME=\"jest\";const HOISTED_METHODS=[\"mock\",\"unmock\",\"enableAutomock\",\"disableAutomock\"];class JestHoistTransformer extends _Transformer2.default{__init(){this.hoistedFunctionNames=[]}constructor(rootTransformer,tokens,nameManager,importProcessor){super();this.rootTransformer=rootTransformer;this.tokens=tokens;this.nameManager=nameManager;this.importProcessor=importProcessor;JestHoistTransformer.prototype.__init.call(this);;}process(){if(this.tokens.currentToken().scopeDepth===0&&this.tokens.matches4(_types.TokenType.name,_types.TokenType.dot,_types.TokenType.name,_types.TokenType.parenL)&&this.tokens.identifierName()===JEST_GLOBAL_NAME){if(_optionalChain([this,\"access\",_=>_.importProcessor,\"optionalAccess\",_2=>_2.getGlobalNames,\"call\",_3=>_3(),\"optionalAccess\",_4=>_4.has,\"call\",_5=>_5(JEST_GLOBAL_NAME)])){return false}return this.extractHoistedCalls()}return false}getHoistedCode(){if(this.hoistedFunctionNames.length>0){return this.hoistedFunctionNames.map(name=>`${name}();`).join(\"\")}return\"\"}extractHoistedCalls(){this.tokens.removeToken();let followsNonHoistedJestCall=false;while(this.tokens.matches3(_types.TokenType.dot,_types.TokenType.name,_types.TokenType.parenL)){const methodName=this.tokens.identifierNameAtIndex(this.tokens.currentIndex()+1);const shouldHoist=HOISTED_METHODS.includes(methodName);if(shouldHoist){const hoistedFunctionName=this.nameManager.claimFreeName(\"__jestHoist\");this.hoistedFunctionNames.push(hoistedFunctionName);this.tokens.replaceToken(`function ${hoistedFunctionName}(){${JEST_GLOBAL_NAME}.`);this.tokens.copyToken();this.tokens.copyToken();this.rootTransformer.processBalancedCode();this.tokens.copyExpectedToken(_types.TokenType.parenR);this.tokens.appendCode(\";}\");followsNonHoistedJestCall=false}else{if(followsNonHoistedJestCall){this.tokens.copyToken()}else{this.tokens.replaceToken(`${JEST_GLOBAL_NAME}.`)}this.tokens.copyToken();this.tokens.copyToken();this.rootTransformer.processBalancedCode();this.tokens.copyExpectedToken(_types.TokenType.parenR);followsNonHoistedJestCall=true}}return true}}__name(JestHoistTransformer,\"JestHoistTransformer\");exports.default=JestHoistTransformer;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAG,SAAS,uBAAuB,IAAK,CAAE,OAAO,KAAO,IAAI,WAAa,IAAM,CAAE,QAAS,GAAI,CAAG,CAArF,wDAAuF,SAAS,eAAe,IAAK,CAAE,IAAI,cAAgB,OAAW,IAAI,MAAQ,IAAI,CAAC,EAAG,IAAI,EAAI,EAAG,MAAO,EAAI,IAAI,OAAQ,CAAE,MAAM,GAAK,IAAI,CAAC,EAAG,MAAM,GAAK,IAAI,EAAI,CAAC,EAAG,GAAK,EAAG,IAAK,KAAO,kBAAoB,KAAO,iBAAmB,OAAS,KAAM,CAAE,OAAO,MAAW,CAAE,GAAI,KAAO,UAAY,KAAO,iBAAkB,CAAE,cAAgB,MAAO,MAAQ,GAAG,KAAK,CAAG,SAAW,KAAO,QAAU,KAAO,eAAgB,CAAE,MAAQ,GAAG,IAAI,OAAS,MAAM,KAAK,cAAe,GAAG,IAAI,CAAC,EAAG,cAAgB,MAAW,CAAE,CAAE,OAAO,KAAO,CAAzf,wCAEnL,IAAI,OAAS,QAAQ,2BAA2B,EAGhD,IAAI,aAAe,QAAQ,eAAe,EAAG,IAAI,cAAgB,uBAAuB,YAAY,EAEpG,MAAM,iBAAmB,OACzB,MAAM,gBAAkB,CAAC,OAAQ,SAAU,iBAAkB,iBAAiB,EAU7E,MAAM,6BAA6B,cAAc,OAAQ,CACtD,QAAS,CAAC,KAAK,qBAAuB,CAAC,CAAC,CAE1C,YACG,gBACA,OACA,YACA,gBACD,CACA,MAAM,EAAE,KAAK,gBAAkB,gBAAgB,KAAK,OAAS,OAAO,KAAK,YAAc,YAAY,KAAK,gBAAkB,gBAAgB,qBAAqB,UAAU,OAAO,KAAK,IAAI,EAAE,CAC7L,CAEA,SAAU,CACR,GACE,KAAK,OAAO,aAAa,EAAE,aAAe,GAC1C,KAAK,OAAO,SAAS,OAAO,UAAU,KAAM,OAAO,UAAU,IAAK,OAAO,UAAU,KAAM,OAAO,UAAU,MAAM,GAChH,KAAK,OAAO,eAAe,IAAM,iBACjC,CAGA,GAAI,eAAe,CAAC,KAAM,SAAU,GAAK,EAAE,gBAAiB,iBAAkB,IAAM,GAAG,eAAgB,OAAQ,IAAM,GAAG,EAAG,iBAAkB,IAAM,GAAG,IAAK,OAAQ,IAAM,GAAG,gBAAgB,CAAC,CAAC,EAAG,CAC/L,MAAO,MACT,CACA,OAAO,KAAK,oBAAoB,CAClC,CAEA,MAAO,MACT,CAEA,gBAAiB,CACf,GAAI,KAAK,qBAAqB,OAAS,EAAG,CAGxC,OAAO,KAAK,qBAAqB,IAAK,MAAS,GAAG,SAAS,EAAE,KAAK,EAAE,CACtE,CACA,MAAO,EACT,CAUC,qBAAsB,CAGrB,KAAK,OAAO,YAAY,EAGxB,IAAI,0BAA4B,MAGhC,MAAO,KAAK,OAAO,SAAS,OAAO,UAAU,IAAK,OAAO,UAAU,KAAM,OAAO,UAAU,MAAM,EAAG,CACjG,MAAM,WAAa,KAAK,OAAO,sBAAsB,KAAK,OAAO,aAAa,EAAI,CAAC,EACnF,MAAM,YAAc,gBAAgB,SAAS,UAAU,EACvD,GAAI,YAAa,CAGf,MAAM,oBAAsB,KAAK,YAAY,cAAc,aAAa,EACxE,KAAK,qBAAqB,KAAK,mBAAmB,EAClD,KAAK,OAAO,aAAa,YAAY,yBAAyB,mBAAmB,EACjF,KAAK,OAAO,UAAU,EACtB,KAAK,OAAO,UAAU,EACtB,KAAK,gBAAgB,oBAAoB,EACzC,KAAK,OAAO,kBAAkB,OAAO,UAAU,MAAM,EACrD,KAAK,OAAO,WAAW,IAAI,EAC3B,0BAA4B,KAC9B,KAAO,CAEL,GAAI,0BAA2B,CAI7B,KAAK,OAAO,UAAU,CACxB,KAAO,CAGL,KAAK,OAAO,aAAa,GAAG,mBAAmB,CACjD,CACA,KAAK,OAAO,UAAU,EACtB,KAAK,OAAO,UAAU,EACtB,KAAK,gBAAgB,oBAAoB,EACzC,KAAK,OAAO,kBAAkB,OAAO,UAAU,MAAM,EACrD,0BAA4B,IAC9B,CACF,CAEA,MAAO,KACT,CACF,CA5FO,oDA4FL,QAAQ,QAAU","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/transformers/JestHoistTransformer.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\nvar _types = require('../parser/tokenizer/types');\n\n\nvar _Transformer = require('./Transformer'); var _Transformer2 = _interopRequireDefault(_Transformer);\n\nconst JEST_GLOBAL_NAME = \"jest\";\nconst HOISTED_METHODS = [\"mock\", \"unmock\", \"enableAutomock\", \"disableAutomock\"];\n\n/**\n * Implementation of babel-plugin-jest-hoist, which hoists up some jest method\n * calls above the imports to allow them to override other imports.\n *\n * To preserve line numbers, rather than directly moving the jest.mock code, we\n * wrap each invocation in a function statement and then call the function from\n * the top of the file.\n */\n class JestHoistTransformer extends _Transformer2.default {\n    __init() {this.hoistedFunctionNames = []}\n\n  constructor(\n     rootTransformer,\n     tokens,\n     nameManager,\n     importProcessor,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.nameManager = nameManager;this.importProcessor = importProcessor;JestHoistTransformer.prototype.__init.call(this);;\n  }\n\n  process() {\n    if (\n      this.tokens.currentToken().scopeDepth === 0 &&\n      this.tokens.matches4(_types.TokenType.name, _types.TokenType.dot, _types.TokenType.name, _types.TokenType.parenL) &&\n      this.tokens.identifierName() === JEST_GLOBAL_NAME\n    ) {\n      // TODO: This only works if imports transform is active, which it will be for jest.\n      //       But if jest adds module support and we no longer need the import transform, this needs fixing.\n      if (_optionalChain([this, 'access', _ => _.importProcessor, 'optionalAccess', _2 => _2.getGlobalNames, 'call', _3 => _3(), 'optionalAccess', _4 => _4.has, 'call', _5 => _5(JEST_GLOBAL_NAME)])) {\n        return false;\n      }\n      return this.extractHoistedCalls();\n    }\n\n    return false;\n  }\n\n  getHoistedCode() {\n    if (this.hoistedFunctionNames.length > 0) {\n      // This will be placed before module interop code, but that's fine since\n      // imports aren't allowed in module mock factories.\n      return this.hoistedFunctionNames.map((name) => `${name}();`).join(\"\");\n    }\n    return \"\";\n  }\n\n  /**\n   * Extracts any methods calls on the jest-object that should be hoisted.\n   *\n   * According to the jest docs, https://jestjs.io/docs/en/jest-object#jestmockmodulename-factory-options,\n   * mock, unmock, enableAutomock, disableAutomock, are the methods that should be hoisted.\n   *\n   * We do not apply the same checks of the arguments as babel-plugin-jest-hoist does.\n   */\n   extractHoistedCalls() {\n    // We're handling a chain of calls where `jest` may or may not need to be inserted for each call\n    // in the chain, so remove the initial `jest` to make the loop implementation cleaner.\n    this.tokens.removeToken();\n    // Track some state so that multiple non-hoisted chained calls in a row keep their chaining\n    // syntax.\n    let followsNonHoistedJestCall = false;\n\n    // Iterate through all chained calls on the jest object.\n    while (this.tokens.matches3(_types.TokenType.dot, _types.TokenType.name, _types.TokenType.parenL)) {\n      const methodName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n      const shouldHoist = HOISTED_METHODS.includes(methodName);\n      if (shouldHoist) {\n        // We've matched e.g. `.mock(...)` or similar call.\n        // Replace the initial `.` with `function __jestHoist(){jest.`\n        const hoistedFunctionName = this.nameManager.claimFreeName(\"__jestHoist\");\n        this.hoistedFunctionNames.push(hoistedFunctionName);\n        this.tokens.replaceToken(`function ${hoistedFunctionName}(){${JEST_GLOBAL_NAME}.`);\n        this.tokens.copyToken();\n        this.tokens.copyToken();\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(_types.TokenType.parenR);\n        this.tokens.appendCode(\";}\");\n        followsNonHoistedJestCall = false;\n      } else {\n        // This is a non-hoisted method, so just transform the code as usual.\n        if (followsNonHoistedJestCall) {\n          // If we didn't hoist the previous call, we can leave the code as-is to chain off of the\n          // previous method call. It's important to preserve the code here because we don't know\n          // for sure that the method actually returned the jest object for chaining.\n          this.tokens.copyToken();\n        } else {\n          // If we hoisted the previous call, we know it returns the jest object back, so we insert\n          // the identifier `jest` to continue the chain.\n          this.tokens.replaceToken(`${JEST_GLOBAL_NAME}.`);\n        }\n        this.tokens.copyToken();\n        this.tokens.copyToken();\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(_types.TokenType.parenR);\n        followsNonHoistedJestCall = true;\n      }\n    }\n\n    return true;\n  }\n} exports.default = JestHoistTransformer;\n"]}}