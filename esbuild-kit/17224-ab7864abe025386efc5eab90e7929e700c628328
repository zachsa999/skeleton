{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interopRequireDefault,\"_interopRequireDefault\");var _keywords=require(\"../parser/tokenizer/keywords\");var _types=require(\"../parser/tokenizer/types\");var _Transformer=require(\"./Transformer\");var _Transformer2=_interopRequireDefault(_Transformer);class FlowTransformer extends _Transformer2.default{constructor(rootTransformer,tokens,isImportsTransformEnabled){super();this.rootTransformer=rootTransformer;this.tokens=tokens;this.isImportsTransformEnabled=isImportsTransformEnabled;;}process(){if(this.rootTransformer.processPossibleArrowParamEnd()||this.rootTransformer.processPossibleAsyncArrowWithTypeParams()||this.rootTransformer.processPossibleTypeRange()){return true}if(this.tokens.matches1(_types.TokenType._enum)){this.processEnum();return true}if(this.tokens.matches2(_types.TokenType._export,_types.TokenType._enum)){this.processNamedExportEnum();return true}if(this.tokens.matches3(_types.TokenType._export,_types.TokenType._default,_types.TokenType._enum)){this.processDefaultExportEnum();return true}return false}processNamedExportEnum(){if(this.isImportsTransformEnabled){this.tokens.removeInitialToken();const enumName=this.tokens.identifierNameAtRelativeIndex(1);this.processEnum();this.tokens.appendCode(` exports.${enumName} = ${enumName};`)}else{this.tokens.copyToken();this.processEnum()}}processDefaultExportEnum(){this.tokens.removeInitialToken();this.tokens.removeToken();const enumName=this.tokens.identifierNameAtRelativeIndex(1);this.processEnum();if(this.isImportsTransformEnabled){this.tokens.appendCode(` exports.default = ${enumName};`)}else{this.tokens.appendCode(` export default ${enumName};`)}}processEnum(){this.tokens.replaceToken(\"const\");this.tokens.copyExpectedToken(_types.TokenType.name);let isSymbolEnum=false;if(this.tokens.matchesContextual(_keywords.ContextualKeyword._of)){this.tokens.removeToken();isSymbolEnum=this.tokens.matchesContextual(_keywords.ContextualKeyword._symbol);this.tokens.removeToken()}const hasInitializers=this.tokens.matches3(_types.TokenType.braceL,_types.TokenType.name,_types.TokenType.eq);this.tokens.appendCode(' = require(\"flow-enums-runtime\")');const isMirrored=!isSymbolEnum&&!hasInitializers;this.tokens.replaceTokenTrimmingLeftWhitespace(isMirrored?\".Mirrored([\":\"({\");while(!this.tokens.matches1(_types.TokenType.braceR)){if(this.tokens.matches1(_types.TokenType.ellipsis)){this.tokens.removeToken();break}this.processEnumElement(isSymbolEnum,hasInitializers);if(this.tokens.matches1(_types.TokenType.comma)){this.tokens.copyToken()}}this.tokens.replaceToken(isMirrored?\"]);\":\"});\")}processEnumElement(isSymbolEnum,hasInitializers){if(isSymbolEnum){const elementName=this.tokens.identifierName();this.tokens.copyToken();this.tokens.appendCode(`: Symbol(\"${elementName}\")`)}else if(hasInitializers){this.tokens.copyToken();this.tokens.replaceTokenTrimmingLeftWhitespace(\":\");this.tokens.copyToken()}else{this.tokens.replaceToken(`\"${this.tokens.identifierName()}\"`)}}}__name(FlowTransformer,\"FlowTransformer\");exports.default=FlowTransformer;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/transformers/FlowTransformer.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var _keywords = require('../parser/tokenizer/keywords');\nvar _types = require('../parser/tokenizer/types');\n\n\nvar _Transformer = require('./Transformer'); var _Transformer2 = _interopRequireDefault(_Transformer);\n\n class FlowTransformer extends _Transformer2.default {\n  constructor(\n     rootTransformer,\n     tokens,\n     isImportsTransformEnabled,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.isImportsTransformEnabled = isImportsTransformEnabled;;\n  }\n\n  process() {\n    if (\n      this.rootTransformer.processPossibleArrowParamEnd() ||\n      this.rootTransformer.processPossibleAsyncArrowWithTypeParams() ||\n      this.rootTransformer.processPossibleTypeRange()\n    ) {\n      return true;\n    }\n    if (this.tokens.matches1(_types.TokenType._enum)) {\n      this.processEnum();\n      return true;\n    }\n    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._enum)) {\n      this.processNamedExportEnum();\n      return true;\n    }\n    if (this.tokens.matches3(_types.TokenType._export, _types.TokenType._default, _types.TokenType._enum)) {\n      this.processDefaultExportEnum();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle a declaration like:\n   * export enum E ...\n   *\n   * With this imports transform, this becomes:\n   * const E = [[enum]]; exports.E = E;\n   *\n   * otherwise, it becomes:\n   * export const E = [[enum]];\n   */\n  processNamedExportEnum() {\n    if (this.isImportsTransformEnabled) {\n      // export\n      this.tokens.removeInitialToken();\n      const enumName = this.tokens.identifierNameAtRelativeIndex(1);\n      this.processEnum();\n      this.tokens.appendCode(` exports.${enumName} = ${enumName};`);\n    } else {\n      this.tokens.copyToken();\n      this.processEnum();\n    }\n  }\n\n  /**\n   * Handle a declaration like:\n   * export default enum E\n   *\n   * With the imports transform, this becomes:\n   * const E = [[enum]]; exports.default = E;\n   *\n   * otherwise, it becomes:\n   * const E = [[enum]]; export default E;\n   */\n  processDefaultExportEnum() {\n    // export\n    this.tokens.removeInitialToken();\n    // default\n    this.tokens.removeToken();\n    const enumName = this.tokens.identifierNameAtRelativeIndex(1);\n    this.processEnum();\n    if (this.isImportsTransformEnabled) {\n      this.tokens.appendCode(` exports.default = ${enumName};`);\n    } else {\n      this.tokens.appendCode(` export default ${enumName};`);\n    }\n  }\n\n  /**\n   * Transpile flow enums to invoke the \"flow-enums-runtime\" library.\n   *\n   * Currently, the transpiled code always uses `require(\"flow-enums-runtime\")`,\n   * but if future flexibility is needed, we could expose a config option for\n   * this string (similar to configurable JSX). Even when targeting ESM, the\n   * default behavior of babel-plugin-transform-flow-enums is to use require\n   * rather than injecting an import.\n   *\n   * Flow enums are quite a bit simpler than TS enums and have some convenient\n   * constraints:\n   * - Element initializers must be either always present or always absent. That\n   *   means that we can use fixed lookahead on the first element (if any) and\n   *   assume that all elements are like that.\n   * - The right-hand side of an element initializer must be a literal value,\n   *   not a complex expression and not referencing other elements. That means\n   *   we can simply copy a single token.\n   *\n   * Enums can be broken up into three basic cases:\n   *\n   * Mirrored enums:\n   * enum E {A, B}\n   *   ->\n   * const E = require(\"flow-enums-runtime\").Mirrored([\"A\", \"B\"]);\n   *\n   * Initializer enums:\n   * enum E {A = 1, B = 2}\n   *   ->\n   * const E = require(\"flow-enums-runtime\")({A: 1, B: 2});\n   *\n   * Symbol enums:\n   * enum E of symbol {A, B}\n   *   ->\n   * const E = require(\"flow-enums-runtime\")({A: Symbol(\"A\"), B: Symbol(\"B\")});\n   *\n   * We can statically detect which of the three cases this is by looking at the\n   * \"of\" declaration (if any) and seeing if the first element has an initializer.\n   * Since the other transform details are so similar between the three cases, we\n   * use a single implementation and vary the transform within processEnumElement\n   * based on case.\n   */\n  processEnum() {\n    // enum E -> const E\n    this.tokens.replaceToken(\"const\");\n    this.tokens.copyExpectedToken(_types.TokenType.name);\n\n    let isSymbolEnum = false;\n    if (this.tokens.matchesContextual(_keywords.ContextualKeyword._of)) {\n      this.tokens.removeToken();\n      isSymbolEnum = this.tokens.matchesContextual(_keywords.ContextualKeyword._symbol);\n      this.tokens.removeToken();\n    }\n    const hasInitializers = this.tokens.matches3(_types.TokenType.braceL, _types.TokenType.name, _types.TokenType.eq);\n    this.tokens.appendCode(' = require(\"flow-enums-runtime\")');\n\n    const isMirrored = !isSymbolEnum && !hasInitializers;\n    this.tokens.replaceTokenTrimmingLeftWhitespace(isMirrored ? \".Mirrored([\" : \"({\");\n\n    while (!this.tokens.matches1(_types.TokenType.braceR)) {\n      // ... is allowed at the end and has no runtime behavior.\n      if (this.tokens.matches1(_types.TokenType.ellipsis)) {\n        this.tokens.removeToken();\n        break;\n      }\n      this.processEnumElement(isSymbolEnum, hasInitializers);\n      if (this.tokens.matches1(_types.TokenType.comma)) {\n        this.tokens.copyToken();\n      }\n    }\n\n    this.tokens.replaceToken(isMirrored ? \"]);\" : \"});\");\n  }\n\n  /**\n   * Process an individual enum element, producing either an array element or an\n   * object element based on what type of enum this is.\n   */\n  processEnumElement(isSymbolEnum, hasInitializers) {\n    if (isSymbolEnum) {\n      // Symbol enums never have initializers and are expanded to object elements.\n      // A, -> A: Symbol(\"A\"),\n      const elementName = this.tokens.identifierName();\n      this.tokens.copyToken();\n      this.tokens.appendCode(`: Symbol(\"${elementName}\")`);\n    } else if (hasInitializers) {\n      // Initializers are expanded to object elements.\n      // A = 1, -> A: 1,\n      this.tokens.copyToken();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(\":\");\n      this.tokens.copyToken();\n    } else {\n      // Enum elements without initializers become string literal array elements.\n      // A, -> \"A\",\n      this.tokens.replaceToken(`\"${this.tokens.identifierName()}\"`);\n    }\n  }\n} exports.default = FlowTransformer;\n"]}}