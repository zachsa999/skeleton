{"code":"(()=>{\nvar __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});(function(global,factory){typeof exports===\"object\"&&typeof module!==\"undefined\"?module.exports=factory():typeof define===\"function\"&&define.amd?define(factory):(global=typeof globalThis!==\"undefined\"?globalThis:global||self,global.resolveURI=factory())})(exports,function(){\"use strict\";const schemeRegex=/^[\\w+.-]+:\\/\\//;const urlRegex=/^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;const fileRegex=/^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;var UrlType;(function(UrlType2){UrlType2[UrlType2[\"Empty\"]=1]=\"Empty\";UrlType2[UrlType2[\"Hash\"]=2]=\"Hash\";UrlType2[UrlType2[\"Query\"]=3]=\"Query\";UrlType2[UrlType2[\"RelativePath\"]=4]=\"RelativePath\";UrlType2[UrlType2[\"AbsolutePath\"]=5]=\"AbsolutePath\";UrlType2[UrlType2[\"SchemeRelative\"]=6]=\"SchemeRelative\";UrlType2[UrlType2[\"Absolute\"]=7]=\"Absolute\"})(UrlType||(UrlType={}));function isAbsoluteUrl(input){return schemeRegex.test(input)}__name(isAbsoluteUrl,\"isAbsoluteUrl\");function isSchemeRelativeUrl(input){return input.startsWith(\"//\")}__name(isSchemeRelativeUrl,\"isSchemeRelativeUrl\");function isAbsolutePath(input){return input.startsWith(\"/\")}__name(isAbsolutePath,\"isAbsolutePath\");function isFileUrl(input){return input.startsWith(\"file:\")}__name(isFileUrl,\"isFileUrl\");function isRelative(input){return/^[.?#]/.test(input)}__name(isRelative,\"isRelative\");function parseAbsoluteUrl(input){const match=urlRegex.exec(input);return makeUrl(match[1],match[2]||\"\",match[3],match[4]||\"\",match[5]||\"/\",match[6]||\"\",match[7]||\"\")}__name(parseAbsoluteUrl,\"parseAbsoluteUrl\");function parseFileUrl(input){const match=fileRegex.exec(input);const path=match[2];return makeUrl(\"file:\",\"\",match[1]||\"\",\"\",isAbsolutePath(path)?path:\"/\"+path,match[3]||\"\",match[4]||\"\")}__name(parseFileUrl,\"parseFileUrl\");function makeUrl(scheme,user,host,port,path,query,hash){return{scheme,user,host,port,path,query,hash,type:UrlType.Absolute}}__name(makeUrl,\"makeUrl\");function parseUrl(input){if(isSchemeRelativeUrl(input)){const url2=parseAbsoluteUrl(\"http:\"+input);url2.scheme=\"\";url2.type=UrlType.SchemeRelative;return url2}if(isAbsolutePath(input)){const url2=parseAbsoluteUrl(\"http://foo.com\"+input);url2.scheme=\"\";url2.host=\"\";url2.type=UrlType.AbsolutePath;return url2}if(isFileUrl(input))return parseFileUrl(input);if(isAbsoluteUrl(input))return parseAbsoluteUrl(input);const url=parseAbsoluteUrl(\"http://foo.com/\"+input);url.scheme=\"\";url.host=\"\";url.type=input?input.startsWith(\"?\")?UrlType.Query:input.startsWith(\"#\")?UrlType.Hash:UrlType.RelativePath:UrlType.Empty;return url}__name(parseUrl,\"parseUrl\");function stripPathFilename(path){if(path.endsWith(\"/..\"))return path;const index=path.lastIndexOf(\"/\");return path.slice(0,index+1)}__name(stripPathFilename,\"stripPathFilename\");function mergePaths(url,base){normalizePath(base,base.type);if(url.path===\"/\"){url.path=base.path}else{url.path=stripPathFilename(base.path)+url.path}}__name(mergePaths,\"mergePaths\");function normalizePath(url,type){const rel=type<=UrlType.RelativePath;const pieces=url.path.split(\"/\");let pointer=1;let positive=0;let addTrailingSlash=false;for(let i=1;i<pieces.length;i++){const piece=pieces[i];if(!piece){addTrailingSlash=true;continue}addTrailingSlash=false;if(piece===\".\")continue;if(piece===\"..\"){if(positive){addTrailingSlash=true;positive--;pointer--}else if(rel){pieces[pointer++]=piece}continue}pieces[pointer++]=piece;positive++}let path=\"\";for(let i=1;i<pointer;i++){path+=\"/\"+pieces[i]}if(!path||addTrailingSlash&&!path.endsWith(\"/..\")){path+=\"/\"}url.path=path}__name(normalizePath,\"normalizePath\");function resolve(input,base){if(!input&&!base)return\"\";const url=parseUrl(input);let inputType=url.type;if(base&&inputType!==UrlType.Absolute){const baseUrl=parseUrl(base);const baseType=baseUrl.type;switch(inputType){case UrlType.Empty:url.hash=baseUrl.hash;case UrlType.Hash:url.query=baseUrl.query;case UrlType.Query:case UrlType.RelativePath:mergePaths(url,baseUrl);case UrlType.AbsolutePath:url.user=baseUrl.user;url.host=baseUrl.host;url.port=baseUrl.port;case UrlType.SchemeRelative:url.scheme=baseUrl.scheme}if(baseType>inputType)inputType=baseType}normalizePath(url,inputType);const queryHash=url.query+url.hash;switch(inputType){case UrlType.Hash:case UrlType.Query:return queryHash;case UrlType.RelativePath:{const path=url.path.slice(1);if(!path)return queryHash||\".\";if(isRelative(base||input)&&!isRelative(path)){return\"./\"+path+queryHash}return path+queryHash}case UrlType.AbsolutePath:return url.path+queryHash;default:return url.scheme+\"//\"+url.user+url.host+url.port+url.path+queryHash}}__name(resolve,\"resolve\");return resolve});\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["UrlType","url"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/@jridgewell+resolve-uri@3.1.0/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.resolveURI = factory());\n})(this, (function () { 'use strict';\n\n    // Matches the scheme of a URL, eg \"http://\"\n    const schemeRegex = /^[\\w+.-]+:\\/\\//;\n    /**\n     * Matches the parts of a URL:\n     * 1. Scheme, including \":\", guaranteed.\n     * 2. User/password, including \"@\", optional.\n     * 3. Host, guaranteed.\n     * 4. Port, including \":\", optional.\n     * 5. Path, including \"/\", optional.\n     * 6. Query, including \"?\", optional.\n     * 7. Hash, including \"#\", optional.\n     */\n    const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n    /**\n     * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n     * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n     *\n     * 1. Host, optional.\n     * 2. Path, which may include \"/\", guaranteed.\n     * 3. Query, including \"?\", optional.\n     * 4. Hash, including \"#\", optional.\n     */\n    const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n    var UrlType;\n    (function (UrlType) {\n        UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n        UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n        UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n        UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n        UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n        UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n        UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n    })(UrlType || (UrlType = {}));\n    function isAbsoluteUrl(input) {\n        return schemeRegex.test(input);\n    }\n    function isSchemeRelativeUrl(input) {\n        return input.startsWith('//');\n    }\n    function isAbsolutePath(input) {\n        return input.startsWith('/');\n    }\n    function isFileUrl(input) {\n        return input.startsWith('file:');\n    }\n    function isRelative(input) {\n        return /^[.?#]/.test(input);\n    }\n    function parseAbsoluteUrl(input) {\n        const match = urlRegex.exec(input);\n        return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n    }\n    function parseFileUrl(input) {\n        const match = fileRegex.exec(input);\n        const path = match[2];\n        return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n    }\n    function makeUrl(scheme, user, host, port, path, query, hash) {\n        return {\n            scheme,\n            user,\n            host,\n            port,\n            path,\n            query,\n            hash,\n            type: UrlType.Absolute,\n        };\n    }\n    function parseUrl(input) {\n        if (isSchemeRelativeUrl(input)) {\n            const url = parseAbsoluteUrl('http:' + input);\n            url.scheme = '';\n            url.type = UrlType.SchemeRelative;\n            return url;\n        }\n        if (isAbsolutePath(input)) {\n            const url = parseAbsoluteUrl('http://foo.com' + input);\n            url.scheme = '';\n            url.host = '';\n            url.type = UrlType.AbsolutePath;\n            return url;\n        }\n        if (isFileUrl(input))\n            return parseFileUrl(input);\n        if (isAbsoluteUrl(input))\n            return parseAbsoluteUrl(input);\n        const url = parseAbsoluteUrl('http://foo.com/' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = input\n            ? input.startsWith('?')\n                ? UrlType.Query\n                : input.startsWith('#')\n                    ? UrlType.Hash\n                    : UrlType.RelativePath\n            : UrlType.Empty;\n        return url;\n    }\n    function stripPathFilename(path) {\n        // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n        // paths. It's not a file, so we can't strip it.\n        if (path.endsWith('/..'))\n            return path;\n        const index = path.lastIndexOf('/');\n        return path.slice(0, index + 1);\n    }\n    function mergePaths(url, base) {\n        normalizePath(base, base.type);\n        // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n        // path).\n        if (url.path === '/') {\n            url.path = base.path;\n        }\n        else {\n            // Resolution happens relative to the base path's directory, not the file.\n            url.path = stripPathFilename(base.path) + url.path;\n        }\n    }\n    /**\n     * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n     * \"foo/.\". We need to normalize to a standard representation.\n     */\n    function normalizePath(url, type) {\n        const rel = type <= UrlType.RelativePath;\n        const pieces = url.path.split('/');\n        // We need to preserve the first piece always, so that we output a leading slash. The item at\n        // pieces[0] is an empty string.\n        let pointer = 1;\n        // Positive is the number of real directories we've output, used for popping a parent directory.\n        // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n        let positive = 0;\n        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n        // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n        // real directory, we won't need to append, unless the other conditions happen again.\n        let addTrailingSlash = false;\n        for (let i = 1; i < pieces.length; i++) {\n            const piece = pieces[i];\n            // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n            if (!piece) {\n                addTrailingSlash = true;\n                continue;\n            }\n            // If we encounter a real directory, then we don't need to append anymore.\n            addTrailingSlash = false;\n            // A current directory, which we can always drop.\n            if (piece === '.')\n                continue;\n            // A parent directory, we need to see if there are any real directories we can pop. Else, we\n            // have an excess of parents, and we'll need to keep the \"..\".\n            if (piece === '..') {\n                if (positive) {\n                    addTrailingSlash = true;\n                    positive--;\n                    pointer--;\n                }\n                else if (rel) {\n                    // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                    // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                    pieces[pointer++] = piece;\n                }\n                continue;\n            }\n            // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n            // any popped or dropped directories.\n            pieces[pointer++] = piece;\n            positive++;\n        }\n        let path = '';\n        for (let i = 1; i < pointer; i++) {\n            path += '/' + pieces[i];\n        }\n        if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n            path += '/';\n        }\n        url.path = path;\n    }\n    /**\n     * Attempts to resolve `input` URL/path relative to `base`.\n     */\n    function resolve(input, base) {\n        if (!input && !base)\n            return '';\n        const url = parseUrl(input);\n        let inputType = url.type;\n        if (base && inputType !== UrlType.Absolute) {\n            const baseUrl = parseUrl(base);\n            const baseType = baseUrl.type;\n            switch (inputType) {\n                case UrlType.Empty:\n                    url.hash = baseUrl.hash;\n                // fall through\n                case UrlType.Hash:\n                    url.query = baseUrl.query;\n                // fall through\n                case UrlType.Query:\n                case UrlType.RelativePath:\n                    mergePaths(url, baseUrl);\n                // fall through\n                case UrlType.AbsolutePath:\n                    // The host, user, and port are joined, you can't copy one without the others.\n                    url.user = baseUrl.user;\n                    url.host = baseUrl.host;\n                    url.port = baseUrl.port;\n                // fall through\n                case UrlType.SchemeRelative:\n                    // The input doesn't have a schema at least, so we need to copy at least that over.\n                    url.scheme = baseUrl.scheme;\n            }\n            if (baseType > inputType)\n                inputType = baseType;\n        }\n        normalizePath(url, inputType);\n        const queryHash = url.query + url.hash;\n        switch (inputType) {\n            // This is impossible, because of the empty checks at the start of the function.\n            // case UrlType.Empty:\n            case UrlType.Hash:\n            case UrlType.Query:\n                return queryHash;\n            case UrlType.RelativePath: {\n                // The first char is always a \"/\", and we need it to be relative.\n                const path = url.path.slice(1);\n                if (!path)\n                    return queryHash || '.';\n                if (isRelative(base || input) && !isRelative(path)) {\n                    // If base started with a leading \".\", or there is no base and input started with a \".\",\n                    // then we need to ensure that the relative path starts with a \".\". We don't know if\n                    // relative starts with a \"..\", though, so check before prepending.\n                    return './' + path + queryHash;\n                }\n                return path + queryHash;\n            }\n            case UrlType.AbsolutePath:\n                return url.path + queryHash;\n            default:\n                return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n        }\n    }\n\n    return resolve;\n\n}));\n//# sourceMappingURL=resolve-uri.umd.js.map\n"]}}