{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _tokenizer=require(\"../parser/tokenizer\");var _types=require(\"../parser/tokenizer/types\");const EMPTY_DECLARATION_INFO={typeDeclarations:new Set,valueDeclarations:new Set};exports.EMPTY_DECLARATION_INFO=EMPTY_DECLARATION_INFO;function getDeclarationInfo(tokens){const typeDeclarations=new Set;const valueDeclarations=new Set;for(let i=0;i<tokens.tokens.length;i++){const token=tokens.tokens[i];if(token.type===_types.TokenType.name&&_tokenizer.isTopLevelDeclaration.call(void 0,token)){if(token.isType){typeDeclarations.add(tokens.identifierNameForToken(token))}else{valueDeclarations.add(tokens.identifierNameForToken(token))}}}return{typeDeclarations,valueDeclarations}}__name(getDeclarationInfo,\"getDeclarationInfo\");exports.default=getDeclarationInfo;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAE,IAAI,WAAa,QAAQ,qBAAqB,EACvH,IAAI,OAAS,QAAQ,2BAA2B,EAQ/C,MAAM,uBAAyB,CAC9B,iBAAkB,IAAI,IACtB,kBAAmB,IAAI,GACzB,EAAG,QAAQ,uBAAyB,uBAanC,SAAS,mBAAmB,OAAQ,CACnC,MAAM,iBAAmB,IAAI,IAC7B,MAAM,kBAAoB,IAAI,IAC9B,QAAS,EAAI,EAAG,EAAI,OAAO,OAAO,OAAQ,IAAK,CAC7C,MAAM,MAAQ,OAAO,OAAO,CAAC,EAC7B,GAAI,MAAM,OAAS,OAAO,UAAU,MAAQ,WAAW,sBAAsB,KAAK,OAAQ,KAAK,EAAG,CAChG,GAAI,MAAM,OAAQ,CAChB,iBAAiB,IAAI,OAAO,uBAAuB,KAAK,CAAC,CAC3D,KAAO,CACL,kBAAkB,IAAI,OAAO,uBAAuB,KAAK,CAAC,CAC5D,CACF,CACF,CACA,MAAO,CAAC,iBAAkB,iBAAiB,CAC7C,CAdU,gDAcR,QAAQ,QAAU","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/util/getDeclarationInfo.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});var _tokenizer = require('../parser/tokenizer');\nvar _types = require('../parser/tokenizer/types');\n\n\n\n\n\n\n\n const EMPTY_DECLARATION_INFO = {\n  typeDeclarations: new Set(),\n  valueDeclarations: new Set(),\n}; exports.EMPTY_DECLARATION_INFO = EMPTY_DECLARATION_INFO;\n\n/**\n * Get all top-level identifiers that should be preserved when exported in TypeScript.\n *\n * Examples:\n * - If an identifier is declared as `const x`, then `export {x}` should be preserved.\n * - If it's declared as `type x`, then `export {x}` should be removed.\n * - If it's declared as both `const x` and `type x`, then the export should be preserved.\n * - Classes and enums should be preserved (even though they also introduce types).\n * - Imported identifiers should be preserved since we don't have enough information to\n *   rule them out. --isolatedModules disallows re-exports, which catches errors here.\n */\n function getDeclarationInfo(tokens) {\n  const typeDeclarations = new Set();\n  const valueDeclarations = new Set();\n  for (let i = 0; i < tokens.tokens.length; i++) {\n    const token = tokens.tokens[i];\n    if (token.type === _types.TokenType.name && _tokenizer.isTopLevelDeclaration.call(void 0, token)) {\n      if (token.isType) {\n        typeDeclarations.add(tokens.identifierNameForToken(token));\n      } else {\n        valueDeclarations.add(tokens.identifierNameForToken(token));\n      }\n    }\n  }\n  return {typeDeclarations, valueDeclarations};\n} exports.default = getDeclarationInfo;\n"]}}