{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const stringify=require(\"./stringify\");const{MAX_LENGTH,CHAR_BACKSLASH,CHAR_BACKTICK,CHAR_COMMA,CHAR_DOT,CHAR_LEFT_PARENTHESES,CHAR_RIGHT_PARENTHESES,CHAR_LEFT_CURLY_BRACE,CHAR_RIGHT_CURLY_BRACE,CHAR_LEFT_SQUARE_BRACKET,CHAR_RIGHT_SQUARE_BRACKET,CHAR_DOUBLE_QUOTE,CHAR_SINGLE_QUOTE,CHAR_NO_BREAK_SPACE,CHAR_ZERO_WIDTH_NOBREAK_SPACE}=require(\"./constants\");const parse=__name((input,options={})=>{if(typeof input!==\"string\"){throw new TypeError(\"Expected a string\")}let opts=options||{};let max=typeof opts.maxLength===\"number\"?Math.min(MAX_LENGTH,opts.maxLength):MAX_LENGTH;if(input.length>max){throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`)}let ast={type:\"root\",input,nodes:[]};let stack=[ast];let block=ast;let prev=ast;let brackets=0;let length=input.length;let index=0;let depth=0;let value;let memo={};const advance=__name(()=>input[index++],\"advance\");const push=__name(node=>{if(node.type===\"text\"&&prev.type===\"dot\"){prev.type=\"text\"}if(prev&&prev.type===\"text\"&&node.type===\"text\"){prev.value+=node.value;return}block.nodes.push(node);node.parent=block;node.prev=prev;prev=node;return node},\"push\");push({type:\"bos\"});while(index<length){block=stack[stack.length-1];value=advance();if(value===CHAR_ZERO_WIDTH_NOBREAK_SPACE||value===CHAR_NO_BREAK_SPACE){continue}if(value===CHAR_BACKSLASH){push({type:\"text\",value:(options.keepEscaping?value:\"\")+advance()});continue}if(value===CHAR_RIGHT_SQUARE_BRACKET){push({type:\"text\",value:\"\\\\\"+value});continue}if(value===CHAR_LEFT_SQUARE_BRACKET){brackets++;let closed=true;let next;while(index<length&&(next=advance())){value+=next;if(next===CHAR_LEFT_SQUARE_BRACKET){brackets++;continue}if(next===CHAR_BACKSLASH){value+=advance();continue}if(next===CHAR_RIGHT_SQUARE_BRACKET){brackets--;if(brackets===0){break}}}push({type:\"text\",value});continue}if(value===CHAR_LEFT_PARENTHESES){block=push({type:\"paren\",nodes:[]});stack.push(block);push({type:\"text\",value});continue}if(value===CHAR_RIGHT_PARENTHESES){if(block.type!==\"paren\"){push({type:\"text\",value});continue}block=stack.pop();push({type:\"text\",value});block=stack[stack.length-1];continue}if(value===CHAR_DOUBLE_QUOTE||value===CHAR_SINGLE_QUOTE||value===CHAR_BACKTICK){let open=value;let next;if(options.keepQuotes!==true){value=\"\"}while(index<length&&(next=advance())){if(next===CHAR_BACKSLASH){value+=next+advance();continue}if(next===open){if(options.keepQuotes===true)value+=next;break}value+=next}push({type:\"text\",value});continue}if(value===CHAR_LEFT_CURLY_BRACE){depth++;let dollar=prev.value&&prev.value.slice(-1)===\"$\"||block.dollar===true;let brace={type:\"brace\",open:true,close:false,dollar,depth,commas:0,ranges:0,nodes:[]};block=push(brace);stack.push(block);push({type:\"open\",value});continue}if(value===CHAR_RIGHT_CURLY_BRACE){if(block.type!==\"brace\"){push({type:\"text\",value});continue}let type=\"close\";block=stack.pop();block.close=true;push({type,value});depth--;block=stack[stack.length-1];continue}if(value===CHAR_COMMA&&depth>0){if(block.ranges>0){block.ranges=0;let open=block.nodes.shift();block.nodes=[open,{type:\"text\",value:stringify(block)}]}push({type:\"comma\",value});block.commas++;continue}if(value===CHAR_DOT&&depth>0&&block.commas===0){let siblings=block.nodes;if(depth===0||siblings.length===0){push({type:\"text\",value});continue}if(prev.type===\"dot\"){block.range=[];prev.value+=value;prev.type=\"range\";if(block.nodes.length!==3&&block.nodes.length!==5){block.invalid=true;block.ranges=0;prev.type=\"text\";continue}block.ranges++;block.args=[];continue}if(prev.type===\"range\"){siblings.pop();let before=siblings[siblings.length-1];before.value+=prev.value+value;prev=before;block.ranges--;continue}push({type:\"dot\",value});continue}push({type:\"text\",value})}do{block=stack.pop();if(block.type!==\"root\"){block.nodes.forEach(node=>{if(!node.nodes){if(node.type===\"open\")node.isOpen=true;if(node.type===\"close\")node.isClose=true;if(!node.nodes)node.type=\"text\";node.invalid=true}});let parent=stack[stack.length-1];let index2=parent.nodes.indexOf(block);parent.nodes.splice(index2,1,...block.nodes)}}while(stack.length>0);push({type:\"eos\"});return ast},\"parse\");module.exports=parse;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["index"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js"],"sourcesContent":["'use strict';\n\nconst stringify = require('./stringify');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = require('./constants');\n\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = { type: 'root', input, nodes: [] };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  let memo = {};\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n\n      let closed = true;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nmodule.exports = parse;\n"]}}