{"code":"(()=>{\nvar __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});(function(global,factory){typeof exports===\"object\"&&typeof module!==\"undefined\"?factory(exports,require(\"@jridgewell/set-array\"),require(\"@jridgewell/sourcemap-codec\"),require(\"@jridgewell/trace-mapping\")):typeof define===\"function\"&&define.amd?define([\"exports\",\"@jridgewell/set-array\",\"@jridgewell/sourcemap-codec\",\"@jridgewell/trace-mapping\"],factory):(global=typeof globalThis!==\"undefined\"?globalThis:global||self,factory(global.genMapping={},global.setArray,global.sourcemapCodec,global.traceMapping))})(exports,function(exports2,setArray,sourcemapCodec,traceMapping){\"use strict\";const COLUMN=0;const SOURCES_INDEX=1;const SOURCE_LINE=2;const SOURCE_COLUMN=3;const NAMES_INDEX=4;const NO_NAME=-1;exports2.addSegment=void 0;exports2.addMapping=void 0;exports2.maybeAddSegment=void 0;exports2.maybeAddMapping=void 0;exports2.setSourceContent=void 0;exports2.toDecodedMap=void 0;exports2.toEncodedMap=void 0;exports2.fromMap=void 0;exports2.allMappings=void 0;let addSegmentInternal;class GenMapping{constructor({file,sourceRoot}={}){this._names=new setArray.SetArray;this._sources=new setArray.SetArray;this._sourcesContent=[];this._mappings=[];this.file=file;this.sourceRoot=sourceRoot}}__name(GenMapping,\"GenMapping\");(()=>{exports2.addSegment=(map,genLine,genColumn,source,sourceLine,sourceColumn,name,content)=>{return addSegmentInternal(false,map,genLine,genColumn,source,sourceLine,sourceColumn,name,content)};exports2.maybeAddSegment=(map,genLine,genColumn,source,sourceLine,sourceColumn,name,content)=>{return addSegmentInternal(true,map,genLine,genColumn,source,sourceLine,sourceColumn,name,content)};exports2.addMapping=(map,mapping)=>{return addMappingInternal(false,map,mapping)};exports2.maybeAddMapping=(map,mapping)=>{return addMappingInternal(true,map,mapping)};exports2.setSourceContent=(map,source,content)=>{const{_sources:sources,_sourcesContent:sourcesContent}=map;sourcesContent[setArray.put(sources,source)]=content};exports2.toDecodedMap=map=>{const{file,sourceRoot,_mappings:mappings,_sources:sources,_sourcesContent:sourcesContent,_names:names}=map;removeEmptyFinalLines(mappings);return{version:3,file:file||void 0,names:names.array,sourceRoot:sourceRoot||void 0,sources:sources.array,sourcesContent,mappings}};exports2.toEncodedMap=map=>{const decoded=exports2.toDecodedMap(map);return Object.assign(Object.assign({},decoded),{mappings:sourcemapCodec.encode(decoded.mappings)})};exports2.allMappings=map=>{const out=[];const{_mappings:mappings,_sources:sources,_names:names}=map;for(let i=0;i<mappings.length;i++){const line=mappings[i];for(let j=0;j<line.length;j++){const seg=line[j];const generated={line:i+1,column:seg[COLUMN]};let source=void 0;let original=void 0;let name=void 0;if(seg.length!==1){source=sources.array[seg[SOURCES_INDEX]];original={line:seg[SOURCE_LINE]+1,column:seg[SOURCE_COLUMN]};if(seg.length===5)name=names.array[seg[NAMES_INDEX]]}out.push({generated,source,original,name})}}return out};exports2.fromMap=input=>{const map=new traceMapping.TraceMap(input);const gen=new GenMapping({file:map.file,sourceRoot:map.sourceRoot});putAll(gen._names,map.names);putAll(gen._sources,map.sources);gen._sourcesContent=map.sourcesContent||map.sources.map(()=>null);gen._mappings=traceMapping.decodedMappings(map);return gen};addSegmentInternal=__name((skipable,map,genLine,genColumn,source,sourceLine,sourceColumn,name,content)=>{const{_mappings:mappings,_sources:sources,_sourcesContent:sourcesContent,_names:names}=map;const line=getLine(mappings,genLine);const index=getColumnIndex(line,genColumn);if(!source){if(skipable&&skipSourceless(line,index))return;return insert(line,index,[genColumn])}const sourcesIndex=setArray.put(sources,source);const namesIndex=name?setArray.put(names,name):NO_NAME;if(sourcesIndex===sourcesContent.length)sourcesContent[sourcesIndex]=content!==null&&content!==void 0?content:null;if(skipable&&skipSource(line,index,sourcesIndex,sourceLine,sourceColumn,namesIndex)){return}return insert(line,index,name?[genColumn,sourcesIndex,sourceLine,sourceColumn,namesIndex]:[genColumn,sourcesIndex,sourceLine,sourceColumn])},\"addSegmentInternal\")})();function getLine(mappings,index){for(let i=mappings.length;i<=index;i++){mappings[i]=[]}return mappings[index]}__name(getLine,\"getLine\");function getColumnIndex(line,genColumn){let index=line.length;for(let i=index-1;i>=0;index=i--){const current=line[i];if(genColumn>=current[COLUMN])break}return index}__name(getColumnIndex,\"getColumnIndex\");function insert(array,index,value){for(let i=array.length;i>index;i--){array[i]=array[i-1]}array[index]=value}__name(insert,\"insert\");function removeEmptyFinalLines(mappings){const{length}=mappings;let len=length;for(let i=len-1;i>=0;len=i,i--){if(mappings[i].length>0)break}if(len<length)mappings.length=len}__name(removeEmptyFinalLines,\"removeEmptyFinalLines\");function putAll(strarr,array){for(let i=0;i<array.length;i++)setArray.put(strarr,array[i])}__name(putAll,\"putAll\");function skipSourceless(line,index){if(index===0)return true;const prev=line[index-1];return prev.length===1}__name(skipSourceless,\"skipSourceless\");function skipSource(line,index,sourcesIndex,sourceLine,sourceColumn,namesIndex){if(index===0)return false;const prev=line[index-1];if(prev.length===1)return false;return sourcesIndex===prev[SOURCES_INDEX]&&sourceLine===prev[SOURCE_LINE]&&sourceColumn===prev[SOURCE_COLUMN]&&namesIndex===(prev.length===5?prev[NAMES_INDEX]:NO_NAME)}__name(skipSource,\"skipSource\");function addMappingInternal(skipable,map,mapping){const{generated,source,original,name,content}=mapping;if(!source){return addSegmentInternal(skipable,map,generated.line-1,generated.column,null,null,null,null,null)}const s=source;return addSegmentInternal(skipable,map,generated.line-1,generated.column,s,original.line-1,original.column,name,content)}__name(addMappingInternal,\"addMappingInternal\");exports2.GenMapping=GenMapping;Object.defineProperty(exports2,\"__esModule\",{value:true})});\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["exports"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/@jridgewell+gen-mapping@0.3.3/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/set-array'), require('@jridgewell/sourcemap-codec'), require('@jridgewell/trace-mapping')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/set-array', '@jridgewell/sourcemap-codec', '@jridgewell/trace-mapping'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.genMapping = {}, global.setArray, global.sourcemapCodec, global.traceMapping));\n})(this, (function (exports, setArray, sourcemapCodec, traceMapping) { 'use strict';\n\n    const COLUMN = 0;\n    const SOURCES_INDEX = 1;\n    const SOURCE_LINE = 2;\n    const SOURCE_COLUMN = 3;\n    const NAMES_INDEX = 4;\n\n    const NO_NAME = -1;\n    /**\n     * A low-level API to associate a generated position with an original source position. Line and\n     * column here are 0-based, unlike `addMapping`.\n     */\n    exports.addSegment = void 0;\n    /**\n     * A high-level API to associate a generated position with an original source position. Line is\n     * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n     */\n    exports.addMapping = void 0;\n    /**\n     * Same as `addSegment`, but will only add the segment if it generates useful information in the\n     * resulting map. This only works correctly if segments are added **in order**, meaning you should\n     * not add a segment with a lower generated line/column than one that came before.\n     */\n    exports.maybeAddSegment = void 0;\n    /**\n     * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n     * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n     * not add a mapping with a lower generated line/column than one that came before.\n     */\n    exports.maybeAddMapping = void 0;\n    /**\n     * Adds/removes the content of the source file to the source map.\n     */\n    exports.setSourceContent = void 0;\n    /**\n     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    exports.toDecodedMap = void 0;\n    /**\n     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    exports.toEncodedMap = void 0;\n    /**\n     * Constructs a new GenMapping, using the already present mappings of the input.\n     */\n    exports.fromMap = void 0;\n    /**\n     * Returns an array of high-level mapping objects for every recorded segment, which could then be\n     * passed to the `source-map` library.\n     */\n    exports.allMappings = void 0;\n    // This split declaration is only so that terser can elminiate the static initialization block.\n    let addSegmentInternal;\n    /**\n     * Provides the state to generate a sourcemap.\n     */\n    class GenMapping {\n        constructor({ file, sourceRoot } = {}) {\n            this._names = new setArray.SetArray();\n            this._sources = new setArray.SetArray();\n            this._sourcesContent = [];\n            this._mappings = [];\n            this.file = file;\n            this.sourceRoot = sourceRoot;\n        }\n    }\n    (() => {\n        exports.addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n            return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n        };\n        exports.maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n            return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n        };\n        exports.addMapping = (map, mapping) => {\n            return addMappingInternal(false, map, mapping);\n        };\n        exports.maybeAddMapping = (map, mapping) => {\n            return addMappingInternal(true, map, mapping);\n        };\n        exports.setSourceContent = (map, source, content) => {\n            const { _sources: sources, _sourcesContent: sourcesContent } = map;\n            sourcesContent[setArray.put(sources, source)] = content;\n        };\n        exports.toDecodedMap = (map) => {\n            const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;\n            removeEmptyFinalLines(mappings);\n            return {\n                version: 3,\n                file: file || undefined,\n                names: names.array,\n                sourceRoot: sourceRoot || undefined,\n                sources: sources.array,\n                sourcesContent,\n                mappings,\n            };\n        };\n        exports.toEncodedMap = (map) => {\n            const decoded = exports.toDecodedMap(map);\n            return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });\n        };\n        exports.allMappings = (map) => {\n            const out = [];\n            const { _mappings: mappings, _sources: sources, _names: names } = map;\n            for (let i = 0; i < mappings.length; i++) {\n                const line = mappings[i];\n                for (let j = 0; j < line.length; j++) {\n                    const seg = line[j];\n                    const generated = { line: i + 1, column: seg[COLUMN] };\n                    let source = undefined;\n                    let original = undefined;\n                    let name = undefined;\n                    if (seg.length !== 1) {\n                        source = sources.array[seg[SOURCES_INDEX]];\n                        original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n                        if (seg.length === 5)\n                            name = names.array[seg[NAMES_INDEX]];\n                    }\n                    out.push({ generated, source, original, name });\n                }\n            }\n            return out;\n        };\n        exports.fromMap = (input) => {\n            const map = new traceMapping.TraceMap(input);\n            const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n            putAll(gen._names, map.names);\n            putAll(gen._sources, map.sources);\n            gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n            gen._mappings = traceMapping.decodedMappings(map);\n            return gen;\n        };\n        // Internal helpers\n        addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n            const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;\n            const line = getLine(mappings, genLine);\n            const index = getColumnIndex(line, genColumn);\n            if (!source) {\n                if (skipable && skipSourceless(line, index))\n                    return;\n                return insert(line, index, [genColumn]);\n            }\n            const sourcesIndex = setArray.put(sources, source);\n            const namesIndex = name ? setArray.put(names, name) : NO_NAME;\n            if (sourcesIndex === sourcesContent.length)\n                sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;\n            if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n                return;\n            }\n            return insert(line, index, name\n                ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n                : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n        };\n    })();\n    function getLine(mappings, index) {\n        for (let i = mappings.length; i <= index; i++) {\n            mappings[i] = [];\n        }\n        return mappings[index];\n    }\n    function getColumnIndex(line, genColumn) {\n        let index = line.length;\n        for (let i = index - 1; i >= 0; index = i--) {\n            const current = line[i];\n            if (genColumn >= current[COLUMN])\n                break;\n        }\n        return index;\n    }\n    function insert(array, index, value) {\n        for (let i = array.length; i > index; i--) {\n            array[i] = array[i - 1];\n        }\n        array[index] = value;\n    }\n    function removeEmptyFinalLines(mappings) {\n        const { length } = mappings;\n        let len = length;\n        for (let i = len - 1; i >= 0; len = i, i--) {\n            if (mappings[i].length > 0)\n                break;\n        }\n        if (len < length)\n            mappings.length = len;\n    }\n    function putAll(strarr, array) {\n        for (let i = 0; i < array.length; i++)\n            setArray.put(strarr, array[i]);\n    }\n    function skipSourceless(line, index) {\n        // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n        // doesn't generate any useful information.\n        if (index === 0)\n            return true;\n        const prev = line[index - 1];\n        // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n        // genrate any new information. Else, this segment will end the source/named segment and point to\n        // a sourceless position, which is useful.\n        return prev.length === 1;\n    }\n    function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n        // A source/named segment at the start of a line gives position at that genColumn\n        if (index === 0)\n            return false;\n        const prev = line[index - 1];\n        // If the previous segment is sourceless, then we're transitioning to a source.\n        if (prev.length === 1)\n            return false;\n        // If the previous segment maps to the exact same source position, then this segment doesn't\n        // provide any new position information.\n        return (sourcesIndex === prev[SOURCES_INDEX] &&\n            sourceLine === prev[SOURCE_LINE] &&\n            sourceColumn === prev[SOURCE_COLUMN] &&\n            namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME));\n    }\n    function addMappingInternal(skipable, map, mapping) {\n        const { generated, source, original, name, content } = mapping;\n        if (!source) {\n            return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);\n        }\n        const s = source;\n        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name, content);\n    }\n\n    exports.GenMapping = GenMapping;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=gen-mapping.umd.js.map\n"]}}