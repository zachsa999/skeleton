{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interopRequireDefault,\"_interopRequireDefault\");var _types=require(\"./parser/tokenizer/types\");var _isAsyncOperation=require(\"./util/isAsyncOperation\");var _isAsyncOperation2=_interopRequireDefault(_isAsyncOperation);class TokenProcessor{__init(){this.resultCode=\"\"}__init2(){this.resultMappings=new Array(this.tokens.length)}__init3(){this.tokenIndex=0}constructor(code,tokens,isFlowEnabled,disableESTransforms,helperManager){;this.code=code;this.tokens=tokens;this.isFlowEnabled=isFlowEnabled;this.disableESTransforms=disableESTransforms;this.helperManager=helperManager;TokenProcessor.prototype.__init.call(this);TokenProcessor.prototype.__init2.call(this);TokenProcessor.prototype.__init3.call(this)}snapshot(){return{resultCode:this.resultCode,tokenIndex:this.tokenIndex}}restoreToSnapshot(snapshot){this.resultCode=snapshot.resultCode;this.tokenIndex=snapshot.tokenIndex}dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot){const result=this.resultCode.slice(snapshot.resultCode.length);this.resultCode=snapshot.resultCode;return result}reset(){this.resultCode=\"\";this.resultMappings=new Array(this.tokens.length);this.tokenIndex=0}matchesContextualAtIndex(index,contextualKeyword){return this.matches1AtIndex(index,_types.TokenType.name)&&this.tokens[index].contextualKeyword===contextualKeyword}identifierNameAtIndex(index){return this.identifierNameForToken(this.tokens[index])}identifierNameAtRelativeIndex(relativeIndex){return this.identifierNameForToken(this.tokenAtRelativeIndex(relativeIndex))}identifierName(){return this.identifierNameForToken(this.currentToken())}identifierNameForToken(token){return this.code.slice(token.start,token.end)}rawCodeForToken(token){return this.code.slice(token.start,token.end)}stringValueAtIndex(index){return this.stringValueForToken(this.tokens[index])}stringValue(){return this.stringValueForToken(this.currentToken())}stringValueForToken(token){return this.code.slice(token.start+1,token.end-1)}matches1AtIndex(index,t1){return this.tokens[index].type===t1}matches2AtIndex(index,t1,t2){return this.tokens[index].type===t1&&this.tokens[index+1].type===t2}matches3AtIndex(index,t1,t2,t3){return this.tokens[index].type===t1&&this.tokens[index+1].type===t2&&this.tokens[index+2].type===t3}matches1(t1){return this.tokens[this.tokenIndex].type===t1}matches2(t1,t2){return this.tokens[this.tokenIndex].type===t1&&this.tokens[this.tokenIndex+1].type===t2}matches3(t1,t2,t3){return this.tokens[this.tokenIndex].type===t1&&this.tokens[this.tokenIndex+1].type===t2&&this.tokens[this.tokenIndex+2].type===t3}matches4(t1,t2,t3,t4){return this.tokens[this.tokenIndex].type===t1&&this.tokens[this.tokenIndex+1].type===t2&&this.tokens[this.tokenIndex+2].type===t3&&this.tokens[this.tokenIndex+3].type===t4}matches5(t1,t2,t3,t4,t5){return this.tokens[this.tokenIndex].type===t1&&this.tokens[this.tokenIndex+1].type===t2&&this.tokens[this.tokenIndex+2].type===t3&&this.tokens[this.tokenIndex+3].type===t4&&this.tokens[this.tokenIndex+4].type===t5}matchesContextual(contextualKeyword){return this.matchesContextualAtIndex(this.tokenIndex,contextualKeyword)}matchesContextIdAndLabel(type,contextId){return this.matches1(type)&&this.currentToken().contextId===contextId}previousWhitespaceAndComments(){let whitespaceAndComments=this.code.slice(this.tokenIndex>0?this.tokens[this.tokenIndex-1].end:0,this.tokenIndex<this.tokens.length?this.tokens[this.tokenIndex].start:this.code.length);if(this.isFlowEnabled){whitespaceAndComments=whitespaceAndComments.replace(/@flow/g,\"\")}return whitespaceAndComments}replaceToken(newCode){this.resultCode+=this.previousWhitespaceAndComments();this.appendTokenPrefix();this.resultMappings[this.tokenIndex]=this.resultCode.length;this.resultCode+=newCode;this.appendTokenSuffix();this.tokenIndex++}replaceTokenTrimmingLeftWhitespace(newCode){this.resultCode+=this.previousWhitespaceAndComments().replace(/[^\\r\\n]/g,\"\");this.appendTokenPrefix();this.resultMappings[this.tokenIndex]=this.resultCode.length;this.resultCode+=newCode;this.appendTokenSuffix();this.tokenIndex++}removeInitialToken(){this.replaceToken(\"\")}removeToken(){this.replaceTokenTrimmingLeftWhitespace(\"\")}removeBalancedCode(){let braceDepth=0;while(!this.isAtEnd()){if(this.matches1(_types.TokenType.braceL)){braceDepth++}else if(this.matches1(_types.TokenType.braceR)){if(braceDepth===0){return}braceDepth--}this.removeToken()}}copyExpectedToken(tokenType){if(this.tokens[this.tokenIndex].type!==tokenType){throw new Error(`Expected token ${tokenType}`)}this.copyToken()}copyToken(){this.resultCode+=this.previousWhitespaceAndComments();this.appendTokenPrefix();this.resultMappings[this.tokenIndex]=this.resultCode.length;this.resultCode+=this.code.slice(this.tokens[this.tokenIndex].start,this.tokens[this.tokenIndex].end);this.appendTokenSuffix();this.tokenIndex++}copyTokenWithPrefix(prefix){this.resultCode+=this.previousWhitespaceAndComments();this.appendTokenPrefix();this.resultCode+=prefix;this.resultMappings[this.tokenIndex]=this.resultCode.length;this.resultCode+=this.code.slice(this.tokens[this.tokenIndex].start,this.tokens[this.tokenIndex].end);this.appendTokenSuffix();this.tokenIndex++}appendTokenPrefix(){const token=this.currentToken();if(token.numNullishCoalesceStarts||token.isOptionalChainStart){token.isAsyncOperation=_isAsyncOperation2.default.call(void 0,this)}if(this.disableESTransforms){return}if(token.numNullishCoalesceStarts){for(let i=0;i<token.numNullishCoalesceStarts;i++){if(token.isAsyncOperation){this.resultCode+=\"await \";this.resultCode+=this.helperManager.getHelperName(\"asyncNullishCoalesce\")}else{this.resultCode+=this.helperManager.getHelperName(\"nullishCoalesce\")}this.resultCode+=\"(\"}}if(token.isOptionalChainStart){if(token.isAsyncOperation){this.resultCode+=\"await \"}if(this.tokenIndex>0&&this.tokenAtRelativeIndex(-1).type===_types.TokenType._delete){if(token.isAsyncOperation){this.resultCode+=this.helperManager.getHelperName(\"asyncOptionalChainDelete\")}else{this.resultCode+=this.helperManager.getHelperName(\"optionalChainDelete\")}}else if(token.isAsyncOperation){this.resultCode+=this.helperManager.getHelperName(\"asyncOptionalChain\")}else{this.resultCode+=this.helperManager.getHelperName(\"optionalChain\")}this.resultCode+=\"([\"}}appendTokenSuffix(){const token=this.currentToken();if(token.isOptionalChainEnd&&!this.disableESTransforms){this.resultCode+=\"])\"}if(token.numNullishCoalesceEnds&&!this.disableESTransforms){for(let i=0;i<token.numNullishCoalesceEnds;i++){this.resultCode+=\"))\"}}}appendCode(code){this.resultCode+=code}currentToken(){return this.tokens[this.tokenIndex]}currentTokenCode(){const token=this.currentToken();return this.code.slice(token.start,token.end)}tokenAtRelativeIndex(relativeIndex){return this.tokens[this.tokenIndex+relativeIndex]}currentIndex(){return this.tokenIndex}nextToken(){if(this.tokenIndex===this.tokens.length){throw new Error(\"Unexpectedly reached end of input.\")}this.tokenIndex++}previousToken(){this.tokenIndex--}finish(){if(this.tokenIndex!==this.tokens.length){throw new Error(\"Tried to finish processing tokens before reaching the end.\")}this.resultCode+=this.previousWhitespaceAndComments();return{code:this.resultCode,mappings:this.resultMappings}}isAtEnd(){return this.tokenIndex===this.tokens.length}}__name(TokenProcessor,\"TokenProcessor\");exports.default=TokenProcessor;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/TokenProcessor.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\nvar _types = require('./parser/tokenizer/types');\nvar _isAsyncOperation = require('./util/isAsyncOperation'); var _isAsyncOperation2 = _interopRequireDefault(_isAsyncOperation);\n\n\n\n\n\n\n\n\n\n\n\n class TokenProcessor {\n   __init() {this.resultCode = \"\"}\n  // Array mapping input token index to optional string index position in the\n  // output code.\n   __init2() {this.resultMappings = new Array(this.tokens.length)}\n   __init3() {this.tokenIndex = 0}\n\n  constructor(\n     code,\n     tokens,\n     isFlowEnabled,\n     disableESTransforms,\n     helperManager,\n  ) {;this.code = code;this.tokens = tokens;this.isFlowEnabled = isFlowEnabled;this.disableESTransforms = disableESTransforms;this.helperManager = helperManager;TokenProcessor.prototype.__init.call(this);TokenProcessor.prototype.__init2.call(this);TokenProcessor.prototype.__init3.call(this);}\n\n  /**\n   * Snapshot the token state in a way that can be restored later, useful for\n   * things like lookahead.\n   *\n   * resultMappings do not need to be copied since in all use cases, they will\n   * be overwritten anyway after restore.\n   */\n  snapshot() {\n    return {\n      resultCode: this.resultCode,\n      tokenIndex: this.tokenIndex,\n    };\n  }\n\n  restoreToSnapshot(snapshot) {\n    this.resultCode = snapshot.resultCode;\n    this.tokenIndex = snapshot.tokenIndex;\n  }\n\n  /**\n   * Remove and return the code generated since the snapshot, leaving the\n   * current token position in-place. Unlike most TokenProcessor operations,\n   * this operation can result in input/output line number mismatches because\n   * the removed code may contain newlines, so this operation should be used\n   * sparingly.\n   */\n  dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot) {\n    const result = this.resultCode.slice(snapshot.resultCode.length);\n    this.resultCode = snapshot.resultCode;\n    return result;\n  }\n\n  reset() {\n    this.resultCode = \"\";\n    this.resultMappings = new Array(this.tokens.length);\n    this.tokenIndex = 0;\n  }\n\n  matchesContextualAtIndex(index, contextualKeyword) {\n    return (\n      this.matches1AtIndex(index, _types.TokenType.name) &&\n      this.tokens[index].contextualKeyword === contextualKeyword\n    );\n  }\n\n  identifierNameAtIndex(index) {\n    // TODO: We need to process escapes since technically you can have unicode escapes in variable\n    // names.\n    return this.identifierNameForToken(this.tokens[index]);\n  }\n\n  identifierNameAtRelativeIndex(relativeIndex) {\n    return this.identifierNameForToken(this.tokenAtRelativeIndex(relativeIndex));\n  }\n\n  identifierName() {\n    return this.identifierNameForToken(this.currentToken());\n  }\n\n  identifierNameForToken(token) {\n    return this.code.slice(token.start, token.end);\n  }\n\n  rawCodeForToken(token) {\n    return this.code.slice(token.start, token.end);\n  }\n\n  stringValueAtIndex(index) {\n    return this.stringValueForToken(this.tokens[index]);\n  }\n\n  stringValue() {\n    return this.stringValueForToken(this.currentToken());\n  }\n\n  stringValueForToken(token) {\n    // This is used to identify when two imports are the same and to resolve TypeScript enum keys.\n    // Ideally we'd process escapes within the strings, but for now we pretty much take the raw\n    // code.\n    return this.code.slice(token.start + 1, token.end - 1);\n  }\n\n  matches1AtIndex(index, t1) {\n    return this.tokens[index].type === t1;\n  }\n\n  matches2AtIndex(index, t1, t2) {\n    return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2;\n  }\n\n  matches3AtIndex(index, t1, t2, t3) {\n    return (\n      this.tokens[index].type === t1 &&\n      this.tokens[index + 1].type === t2 &&\n      this.tokens[index + 2].type === t3\n    );\n  }\n\n  matches1(t1) {\n    return this.tokens[this.tokenIndex].type === t1;\n  }\n\n  matches2(t1, t2) {\n    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2;\n  }\n\n  matches3(t1, t2, t3) {\n    return (\n      this.tokens[this.tokenIndex].type === t1 &&\n      this.tokens[this.tokenIndex + 1].type === t2 &&\n      this.tokens[this.tokenIndex + 2].type === t3\n    );\n  }\n\n  matches4(t1, t2, t3, t4) {\n    return (\n      this.tokens[this.tokenIndex].type === t1 &&\n      this.tokens[this.tokenIndex + 1].type === t2 &&\n      this.tokens[this.tokenIndex + 2].type === t3 &&\n      this.tokens[this.tokenIndex + 3].type === t4\n    );\n  }\n\n  matches5(t1, t2, t3, t4, t5) {\n    return (\n      this.tokens[this.tokenIndex].type === t1 &&\n      this.tokens[this.tokenIndex + 1].type === t2 &&\n      this.tokens[this.tokenIndex + 2].type === t3 &&\n      this.tokens[this.tokenIndex + 3].type === t4 &&\n      this.tokens[this.tokenIndex + 4].type === t5\n    );\n  }\n\n  matchesContextual(contextualKeyword) {\n    return this.matchesContextualAtIndex(this.tokenIndex, contextualKeyword);\n  }\n\n  matchesContextIdAndLabel(type, contextId) {\n    return this.matches1(type) && this.currentToken().contextId === contextId;\n  }\n\n  previousWhitespaceAndComments() {\n    let whitespaceAndComments = this.code.slice(\n      this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0,\n      this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length,\n    );\n    if (this.isFlowEnabled) {\n      whitespaceAndComments = whitespaceAndComments.replace(/@flow/g, \"\");\n    }\n    return whitespaceAndComments;\n  }\n\n  replaceToken(newCode) {\n    this.resultCode += this.previousWhitespaceAndComments();\n    this.appendTokenPrefix();\n    this.resultMappings[this.tokenIndex] = this.resultCode.length;\n    this.resultCode += newCode;\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n  replaceTokenTrimmingLeftWhitespace(newCode) {\n    this.resultCode += this.previousWhitespaceAndComments().replace(/[^\\r\\n]/g, \"\");\n    this.appendTokenPrefix();\n    this.resultMappings[this.tokenIndex] = this.resultCode.length;\n    this.resultCode += newCode;\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n  removeInitialToken() {\n    this.replaceToken(\"\");\n  }\n\n  removeToken() {\n    this.replaceTokenTrimmingLeftWhitespace(\"\");\n  }\n\n  /**\n   * Remove all code until the next }, accounting for balanced braces.\n   */\n  removeBalancedCode() {\n    let braceDepth = 0;\n    while (!this.isAtEnd()) {\n      if (this.matches1(_types.TokenType.braceL)) {\n        braceDepth++;\n      } else if (this.matches1(_types.TokenType.braceR)) {\n        if (braceDepth === 0) {\n          return;\n        }\n        braceDepth--;\n      }\n      this.removeToken();\n    }\n  }\n\n  copyExpectedToken(tokenType) {\n    if (this.tokens[this.tokenIndex].type !== tokenType) {\n      throw new Error(`Expected token ${tokenType}`);\n    }\n    this.copyToken();\n  }\n\n  copyToken() {\n    this.resultCode += this.previousWhitespaceAndComments();\n    this.appendTokenPrefix();\n    this.resultMappings[this.tokenIndex] = this.resultCode.length;\n    this.resultCode += this.code.slice(\n      this.tokens[this.tokenIndex].start,\n      this.tokens[this.tokenIndex].end,\n    );\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n  copyTokenWithPrefix(prefix) {\n    this.resultCode += this.previousWhitespaceAndComments();\n    this.appendTokenPrefix();\n    this.resultCode += prefix;\n    this.resultMappings[this.tokenIndex] = this.resultCode.length;\n    this.resultCode += this.code.slice(\n      this.tokens[this.tokenIndex].start,\n      this.tokens[this.tokenIndex].end,\n    );\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n   appendTokenPrefix() {\n    const token = this.currentToken();\n    if (token.numNullishCoalesceStarts || token.isOptionalChainStart) {\n      token.isAsyncOperation = _isAsyncOperation2.default.call(void 0, this);\n    }\n    if (this.disableESTransforms) {\n      return;\n    }\n    if (token.numNullishCoalesceStarts) {\n      for (let i = 0; i < token.numNullishCoalesceStarts; i++) {\n        if (token.isAsyncOperation) {\n          this.resultCode += \"await \";\n          this.resultCode += this.helperManager.getHelperName(\"asyncNullishCoalesce\");\n        } else {\n          this.resultCode += this.helperManager.getHelperName(\"nullishCoalesce\");\n        }\n        this.resultCode += \"(\";\n      }\n    }\n    if (token.isOptionalChainStart) {\n      if (token.isAsyncOperation) {\n        this.resultCode += \"await \";\n      }\n      if (this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === _types.TokenType._delete) {\n        if (token.isAsyncOperation) {\n          this.resultCode += this.helperManager.getHelperName(\"asyncOptionalChainDelete\");\n        } else {\n          this.resultCode += this.helperManager.getHelperName(\"optionalChainDelete\");\n        }\n      } else if (token.isAsyncOperation) {\n        this.resultCode += this.helperManager.getHelperName(\"asyncOptionalChain\");\n      } else {\n        this.resultCode += this.helperManager.getHelperName(\"optionalChain\");\n      }\n      this.resultCode += \"([\";\n    }\n  }\n\n   appendTokenSuffix() {\n    const token = this.currentToken();\n    if (token.isOptionalChainEnd && !this.disableESTransforms) {\n      this.resultCode += \"])\";\n    }\n    if (token.numNullishCoalesceEnds && !this.disableESTransforms) {\n      for (let i = 0; i < token.numNullishCoalesceEnds; i++) {\n        this.resultCode += \"))\";\n      }\n    }\n  }\n\n  appendCode(code) {\n    this.resultCode += code;\n  }\n\n  currentToken() {\n    return this.tokens[this.tokenIndex];\n  }\n\n  currentTokenCode() {\n    const token = this.currentToken();\n    return this.code.slice(token.start, token.end);\n  }\n\n  tokenAtRelativeIndex(relativeIndex) {\n    return this.tokens[this.tokenIndex + relativeIndex];\n  }\n\n  currentIndex() {\n    return this.tokenIndex;\n  }\n\n  /**\n   * Move to the next token. Only suitable in preprocessing steps. When\n   * generating new code, you should use copyToken or removeToken.\n   */\n  nextToken() {\n    if (this.tokenIndex === this.tokens.length) {\n      throw new Error(\"Unexpectedly reached end of input.\");\n    }\n    this.tokenIndex++;\n  }\n\n  previousToken() {\n    this.tokenIndex--;\n  }\n\n  finish() {\n    if (this.tokenIndex !== this.tokens.length) {\n      throw new Error(\"Tried to finish processing tokens before reaching the end.\");\n    }\n    this.resultCode += this.previousWhitespaceAndComments();\n    return {code: this.resultCode, mappings: this.resultMappings};\n  }\n\n  isAtEnd() {\n    return this.tokenIndex === this.tokens.length;\n  }\n} exports.default = TokenProcessor;\n"]}}