{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:true,get:all[name]})}__name(_export,\"_export\");_export(exports,{getClassNameFromSelector:function(){return getClassNameFromSelector},resolveMatches:function(){return resolveMatches},generateRules:function(){return generateRules}});const _postcss=_interop_require_default(require(\"postcss\"));const _postcssselectorparser=_interop_require_default(require(\"postcss-selector-parser\"));const _parseObjectStyles=_interop_require_default(require(\"../util/parseObjectStyles\"));const _isPlainObject=_interop_require_default(require(\"../util/isPlainObject\"));const _prefixSelector=_interop_require_default(require(\"../util/prefixSelector\"));const _pluginUtils=require(\"../util/pluginUtils\");const _log=_interop_require_default(require(\"../util/log\"));const _sharedState=_interop_require_wildcard(require(\"./sharedState\"));const _formatVariantSelector=require(\"../util/formatVariantSelector\");const _nameClass=require(\"../util/nameClass\");const _dataTypes=require(\"../util/dataTypes\");const _setupContextUtils=require(\"./setupContextUtils\");const _isSyntacticallyValidPropertyValue=_interop_require_default(require(\"../util/isSyntacticallyValidPropertyValue\"));const _splitAtTopLevelOnly=require(\"../util/splitAtTopLevelOnly.js\");const _featureFlags=require(\"../featureFlags\");const _applyImportantSelector=require(\"../util/applyImportantSelector\");function _interop_require_default(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interop_require_default,\"_interop_require_default\");function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!==\"function\")return null;var cacheBabelInterop=new WeakMap;var cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=__name(function(nodeInterop2){return nodeInterop2?cacheNodeInterop:cacheBabelInterop},\"_getRequireWildcardCache\"))(nodeInterop)}__name(_getRequireWildcardCache,\"_getRequireWildcardCache\");function _interop_require_wildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj}if(obj===null||typeof obj!==\"object\"&&typeof obj!==\"function\"){return{default:obj}}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj)}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!==\"default\"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}newObj.default=obj;if(cache){cache.set(obj,newObj)}return newObj}__name(_interop_require_wildcard,\"_interop_require_wildcard\");let classNameParser=(0,_postcssselectorparser.default)(selectors=>{return selectors.first.filter(({type})=>type===\"class\").pop().value});function getClassNameFromSelector(selector){return classNameParser.transformSync(selector)}__name(getClassNameFromSelector,\"getClassNameFromSelector\");function*candidatePermutations(candidate){let lastIndex=Infinity;while(lastIndex>=0){let dashIdx;let wasSlash=false;if(lastIndex===Infinity&&candidate.endsWith(\"]\")){let bracketIdx=candidate.indexOf(\"[\");if(candidate[bracketIdx-1]===\"-\"){dashIdx=bracketIdx-1}else if(candidate[bracketIdx-1]===\"/\"){dashIdx=bracketIdx-1;wasSlash=true}else{dashIdx=-1}}else if(lastIndex===Infinity&&candidate.includes(\"/\")){dashIdx=candidate.lastIndexOf(\"/\");wasSlash=true}else{dashIdx=candidate.lastIndexOf(\"-\",lastIndex)}if(dashIdx<0){break}let prefix=candidate.slice(0,dashIdx);let modifier=candidate.slice(wasSlash?dashIdx:dashIdx+1);lastIndex=dashIdx-1;if(prefix===\"\"||modifier===\"/\"){continue}yield[prefix,modifier]}}__name(candidatePermutations,\"candidatePermutations\");function applyPrefix(matches,context){if(matches.length===0||context.tailwindConfig.prefix===\"\"){return matches}for(let match of matches){let[meta]=match;if(meta.options.respectPrefix){let container=_postcss.default.root({nodes:[match[1].clone()]});let classCandidate=match[1].raws.tailwind.classCandidate;container.walkRules(r=>{let shouldPrependNegative=classCandidate.startsWith(\"-\");r.selector=(0,_prefixSelector.default)(context.tailwindConfig.prefix,r.selector,shouldPrependNegative)});match[1]=container.nodes[0]}}return matches}__name(applyPrefix,\"applyPrefix\");function applyImportant(matches,classCandidate){if(matches.length===0){return matches}let result=[];for(let[meta,rule]of matches){let container=_postcss.default.root({nodes:[rule.clone()]});container.walkRules(r=>{let ast=(0,_postcssselectorparser.default)().astSync(r.selector);ast.each(sel=>(0,_formatVariantSelector.eliminateIrrelevantSelectors)(sel,classCandidate));(0,_pluginUtils.updateAllClasses)(ast,className=>className===classCandidate?`!${className}`:className);r.selector=ast.toString();r.walkDecls(d=>d.important=true)});result.push([{...meta,important:true},container.nodes[0]])}return result}__name(applyImportant,\"applyImportant\");function applyVariant(variant,matches,context){if(matches.length===0){return matches}let args={modifier:null,value:_sharedState.NONE};{let[baseVariant,...modifiers]=(0,_splitAtTopLevelOnly.splitAtTopLevelOnly)(variant,\"/\");if(modifiers.length>1){baseVariant=baseVariant+\"/\"+modifiers.slice(0,-1).join(\"/\");modifiers=modifiers.slice(-1)}if(modifiers.length&&!context.variantMap.has(variant)){variant=baseVariant;args.modifier=modifiers[0];if(!(0,_featureFlags.flagEnabled)(context.tailwindConfig,\"generalizedModifiers\")){return[]}}}if(variant.endsWith(\"]\")&&!variant.startsWith(\"[\")){let match=/(.)(-?)\\[(.*)\\]/g.exec(variant);if(match){let[,char,seperator,value]=match;if(char===\"@\"&&seperator===\"-\")return[];if(char!==\"@\"&&seperator===\"\")return[];variant=variant.replace(`${seperator}[${value}]`,\"\");args.value=value}}if(isArbitraryValue(variant)&&!context.variantMap.has(variant)){let sort=context.offsets.recordVariant(variant);let selector=(0,_dataTypes.normalize)(variant.slice(1,-1));let selectors=(0,_splitAtTopLevelOnly.splitAtTopLevelOnly)(selector,\",\");if(selectors.length>1){return[]}if(!selectors.every(_setupContextUtils.isValidVariantFormatString)){return[]}let records=selectors.map((sel,idx)=>[context.offsets.applyParallelOffset(sort,idx),(0,_setupContextUtils.parseVariant)(sel.trim())]);context.variantMap.set(variant,records)}if(context.variantMap.has(variant)){let isArbitraryVariant=isArbitraryValue(variant);let variantFunctionTuples=context.variantMap.get(variant).slice();let result=[];for(let[meta,rule]of matches){if(meta.layer===\"user\"){continue}let container=_postcss.default.root({nodes:[rule.clone()]});for(let[variantSort,variantFunction,containerFromArray]of variantFunctionTuples){let prepareBackup=function(){if(clone.raws.neededBackup){return}clone.raws.neededBackup=true;clone.walkRules(rule2=>rule2.raws.originalSelector=rule2.selector)},modifySelectors=function(modifierFunction){prepareBackup();clone.each(rule2=>{if(rule2.type!==\"rule\"){return}rule2.selectors=rule2.selectors.map(selector=>{return modifierFunction({get className(){return getClassNameFromSelector(selector)},selector})})});return clone};__name(prepareBackup,\"prepareBackup\");__name(modifySelectors,\"modifySelectors\");let clone=(containerFromArray!==null&&containerFromArray!==void 0?containerFromArray:container).clone();let collectedFormats=[];let ruleWithVariant=variantFunction({get container(){prepareBackup();return clone},separator:context.tailwindConfig.separator,modifySelectors,wrap(wrapper){let nodes=clone.nodes;clone.removeAll();wrapper.append(nodes);clone.append(wrapper)},format(selectorFormat){collectedFormats.push({format:selectorFormat,isArbitraryVariant})},args});if(Array.isArray(ruleWithVariant)){for(let[idx,variantFunction2]of ruleWithVariant.entries()){variantFunctionTuples.push([context.offsets.applyParallelOffset(variantSort,idx),variantFunction2,clone.clone()])}continue}if(typeof ruleWithVariant===\"string\"){collectedFormats.push({format:ruleWithVariant,isArbitraryVariant})}if(ruleWithVariant===null){continue}if(clone.raws.neededBackup){delete clone.raws.neededBackup;clone.walkRules(rule2=>{let before=rule2.raws.originalSelector;if(!before)return;delete rule2.raws.originalSelector;if(before===rule2.selector)return;let modified=rule2.selector;let rebuiltBase=(0,_postcssselectorparser.default)(selectors=>{selectors.walkClasses(classNode=>{classNode.value=`${variant}${context.tailwindConfig.separator}${classNode.value}`})}).processSync(before);collectedFormats.push({format:modified.replace(rebuiltBase,\"&\"),isArbitraryVariant});rule2.selector=before})}clone.nodes[0].raws.tailwind={...clone.nodes[0].raws.tailwind,parentLayer:meta.layer};var _meta_collectedFormats;let withOffset=[{...meta,sort:context.offsets.applyVariantOffset(meta.sort,variantSort,Object.assign(args,context.variantOptions.get(variant))),collectedFormats:((_meta_collectedFormats=meta.collectedFormats)!==null&&_meta_collectedFormats!==void 0?_meta_collectedFormats:[]).concat(collectedFormats)},clone.nodes[0]];result.push(withOffset)}}return result}return[]}__name(applyVariant,\"applyVariant\");function parseRules(rule,cache,options={}){if(!(0,_isPlainObject.default)(rule)&&!Array.isArray(rule)){return[[rule],options]}if(Array.isArray(rule)){return parseRules(rule[0],cache,rule[1])}if(!cache.has(rule)){cache.set(rule,(0,_parseObjectStyles.default)(rule))}return[cache.get(rule),options]}__name(parseRules,\"parseRules\");const IS_VALID_PROPERTY_NAME=/^[a-z_-]/;function isValidPropName(name){return IS_VALID_PROPERTY_NAME.test(name)}__name(isValidPropName,\"isValidPropName\");function looksLikeUri(declaration){if(!declaration.includes(\"://\")){return false}try{const url=new URL(declaration);return url.scheme!==\"\"&&url.host!==\"\"}catch(err){return false}}__name(looksLikeUri,\"looksLikeUri\");function isParsableNode(node){let isParsable=true;node.walkDecls(decl=>{if(!isParsableCssValue(decl.prop,decl.value)){isParsable=false;return false}});return isParsable}__name(isParsableNode,\"isParsableNode\");function isParsableCssValue(property,value){if(looksLikeUri(`${property}:${value}`)){return false}try{_postcss.default.parse(`a{${property}:${value}}`).toResult();return true}catch(err){return false}}__name(isParsableCssValue,\"isParsableCssValue\");function extractArbitraryProperty(classCandidate,context){var _classCandidate_match;let[,property,value]=(_classCandidate_match=classCandidate.match(/^\\[([a-zA-Z0-9-_]+):(\\S+)\\]$/))!==null&&_classCandidate_match!==void 0?_classCandidate_match:[];if(value===void 0){return null}if(!isValidPropName(property)){return null}if(!(0,_isSyntacticallyValidPropertyValue.default)(value)){return null}let normalized=(0,_dataTypes.normalize)(value);if(!isParsableCssValue(property,normalized)){return null}let sort=context.offsets.arbitraryProperty();return[[{sort,layer:\"utilities\"},()=>({[(0,_nameClass.asClass)(classCandidate)]:{[property]:normalized}})]]}__name(extractArbitraryProperty,\"extractArbitraryProperty\");function*resolveMatchedPlugins(classCandidate,context){if(context.candidateRuleMap.has(classCandidate)){yield[context.candidateRuleMap.get(classCandidate),\"DEFAULT\"]}yield*function*(arbitraryPropertyRule){if(arbitraryPropertyRule!==null){yield[arbitraryPropertyRule,\"DEFAULT\"]}}(extractArbitraryProperty(classCandidate,context));let candidatePrefix=classCandidate;let negative=false;const twConfigPrefix=context.tailwindConfig.prefix;const twConfigPrefixLen=twConfigPrefix.length;const hasMatchingPrefix=candidatePrefix.startsWith(twConfigPrefix)||candidatePrefix.startsWith(`-${twConfigPrefix}`);if(candidatePrefix[twConfigPrefixLen]===\"-\"&&hasMatchingPrefix){negative=true;candidatePrefix=twConfigPrefix+candidatePrefix.slice(twConfigPrefixLen+1)}if(negative&&context.candidateRuleMap.has(candidatePrefix)){yield[context.candidateRuleMap.get(candidatePrefix),\"-DEFAULT\"]}for(let[prefix,modifier]of candidatePermutations(candidatePrefix)){if(context.candidateRuleMap.has(prefix)){yield[context.candidateRuleMap.get(prefix),negative?`-${modifier}`:modifier]}}}__name(resolveMatchedPlugins,\"resolveMatchedPlugins\");function splitWithSeparator(input,separator){if(input===_sharedState.NOT_ON_DEMAND){return[_sharedState.NOT_ON_DEMAND]}return(0,_splitAtTopLevelOnly.splitAtTopLevelOnly)(input,separator)}__name(splitWithSeparator,\"splitWithSeparator\");function*recordCandidates(matches,classCandidate){for(const match of matches){var _match__options;var _match__options_preserveSource;match[1].raws.tailwind={...match[1].raws.tailwind,classCandidate,preserveSource:(_match__options_preserveSource=(_match__options=match[0].options)===null||_match__options===void 0?void 0:_match__options.preserveSource)!==null&&_match__options_preserveSource!==void 0?_match__options_preserveSource:false};yield match}}__name(recordCandidates,\"recordCandidates\");function*resolveMatches(candidate,context,original=candidate){let separator=context.tailwindConfig.separator;let[classCandidate,...variants]=splitWithSeparator(candidate,separator).reverse();let important=false;if(classCandidate.startsWith(\"!\")){important=true;classCandidate=classCandidate.slice(1)}if((0,_featureFlags.flagEnabled)(context.tailwindConfig,\"variantGrouping\")){if(classCandidate.startsWith(\"(\")&&classCandidate.endsWith(\")\")){let base=variants.slice().reverse().join(separator);for(let part of(0,_splitAtTopLevelOnly.splitAtTopLevelOnly)(classCandidate.slice(1,-1),\",\")){yield*resolveMatches(base+separator+part,context,original)}}}for(let matchedPlugins of resolveMatchedPlugins(classCandidate,context)){let matches=[];let typesByMatches=new Map;let[plugins,modifier]=matchedPlugins;let isOnlyPlugin=plugins.length===1;for(let[sort,plugin]of plugins){let matchesPerPlugin=[];if(typeof plugin===\"function\"){for(let ruleSet of[].concat(plugin(modifier,{isOnlyPlugin}))){let[rules,options]=parseRules(ruleSet,context.postCssNodeCache);for(let rule of rules){matchesPerPlugin.push([{...sort,options:{...sort.options,...options}},rule])}}}else if(modifier===\"DEFAULT\"||modifier===\"-DEFAULT\"){let ruleSet=plugin;let[rules,options]=parseRules(ruleSet,context.postCssNodeCache);for(let rule of rules){matchesPerPlugin.push([{...sort,options:{...sort.options,...options}},rule])}}if(matchesPerPlugin.length>0){var _sort_options;var _sort_options_types,_sort_options1;let matchingTypes=Array.from((0,_pluginUtils.getMatchingTypes)((_sort_options_types=(_sort_options=sort.options)===null||_sort_options===void 0?void 0:_sort_options.types)!==null&&_sort_options_types!==void 0?_sort_options_types:[],modifier,(_sort_options1=sort.options)!==null&&_sort_options1!==void 0?_sort_options1:{},context.tailwindConfig)).map(([_,type])=>type);if(matchingTypes.length>0){typesByMatches.set(matchesPerPlugin,matchingTypes)}matches.push(matchesPerPlugin)}}if(isArbitraryValue(modifier)){if(matches.length>1){let findFallback=function(matches2){if(matches2.length===1){return matches2[0]}return matches2.find(rules=>{let matchingTypes=typesByMatches.get(rules);return rules.some(([{options},rule])=>{if(!isParsableNode(rule)){return false}return options.types.some(({type,preferOnConflict})=>matchingTypes.includes(type)&&preferOnConflict)})})};__name(findFallback,\"findFallback\");let[withAny,withoutAny]=matches.reduce((group,plugin)=>{let hasAnyType=plugin.some(([{options}])=>options.types.some(({type})=>type===\"any\"));if(hasAnyType){group[0].push(plugin)}else{group[1].push(plugin)}return group},[[],[]]);var _findFallback;let fallback=(_findFallback=findFallback(withoutAny))!==null&&_findFallback!==void 0?_findFallback:findFallback(withAny);if(fallback){matches=[fallback]}else{var _typesByMatches_get;let typesPerPlugin=matches.map(match=>new Set([...(_typesByMatches_get=typesByMatches.get(match))!==null&&_typesByMatches_get!==void 0?_typesByMatches_get:[]]));for(let pluginTypes of typesPerPlugin){for(let type of pluginTypes){let removeFromOwnGroup=false;for(let otherGroup of typesPerPlugin){if(pluginTypes===otherGroup)continue;if(otherGroup.has(type)){otherGroup.delete(type);removeFromOwnGroup=true}}if(removeFromOwnGroup)pluginTypes.delete(type)}}let messages=[];for(let[idx,group]of typesPerPlugin.entries()){for(let type of group){let rules=matches[idx].map(([,rule])=>rule).flat().map(rule=>rule.toString().split(\"\\n\").slice(1,-1).map(line=>line.trim()).map(x=>`      ${x}`).join(\"\\n\")).join(\"\\n\\n\");messages.push(`  Use \\`${candidate.replace(\"[\",`[${type}:`)}\\` for \\`${rules.trim()}\\``);break}}_log.default.warn([`The class \\`${candidate}\\` is ambiguous and matches multiple utilities.`,...messages,`If this is content and not a class, replace it with \\`${candidate.replace(\"[\",\"&lsqb;\").replace(\"]\",\"&rsqb;\")}\\` to silence this warning.`]);continue}}matches=matches.map(list=>list.filter(match=>isParsableNode(match[1])))}matches=matches.flat();matches=Array.from(recordCandidates(matches,classCandidate));matches=applyPrefix(matches,context);if(important){matches=applyImportant(matches,classCandidate)}for(let variant of variants){matches=applyVariant(variant,matches,context)}for(let match of matches){match[1].raws.tailwind={...match[1].raws.tailwind,candidate};match=applyFinalFormat(match,{context,candidate,original});if(match===null){continue}yield match}}}__name(resolveMatches,\"resolveMatches\");function applyFinalFormat(match,{context,candidate,original}){if(!match[0].collectedFormats){return match}let isValid=true;let finalFormat;try{finalFormat=(0,_formatVariantSelector.formatVariantSelector)(match[0].collectedFormats,{context,candidate})}catch{return null}let container=_postcss.default.root({nodes:[match[1].clone()]});container.walkRules(rule=>{if(inKeyframes(rule)){return}try{rule.selector=(0,_formatVariantSelector.finalizeSelector)(rule.selector,finalFormat,{candidate:original,context})}catch{isValid=false;return false}});if(!isValid){return null}match[1]=container.nodes[0];return match}__name(applyFinalFormat,\"applyFinalFormat\");function inKeyframes(rule){return rule.parent&&rule.parent.type===\"atrule\"&&rule.parent.name===\"keyframes\"}__name(inKeyframes,\"inKeyframes\");function getImportantStrategy(important){if(important===true){return rule=>{if(inKeyframes(rule)){return}rule.walkDecls(d=>{if(d.parent.type===\"rule\"&&!inKeyframes(d.parent)){d.important=true}})}}if(typeof important===\"string\"){return rule=>{if(inKeyframes(rule)){return}rule.selectors=rule.selectors.map(selector=>{return(0,_applyImportantSelector.applyImportantSelector)(selector,important)})}}}__name(getImportantStrategy,\"getImportantStrategy\");function generateRules(candidates,context){let allRules=[];let strategy=getImportantStrategy(context.tailwindConfig.important);for(let candidate of candidates){if(context.notClassCache.has(candidate)){continue}if(context.candidateRuleCache.has(candidate)){allRules=allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));continue}let matches=Array.from(resolveMatches(candidate,context));if(matches.length===0){context.notClassCache.add(candidate);continue}context.classCache.set(candidate,matches);var _context_candidateRuleCache_get;let rules=(_context_candidateRuleCache_get=context.candidateRuleCache.get(candidate))!==null&&_context_candidateRuleCache_get!==void 0?_context_candidateRuleCache_get:new Set;context.candidateRuleCache.set(candidate,rules);for(const match of matches){let[{sort,options},rule]=match;if(options.respectImportant&&strategy){let container=_postcss.default.root({nodes:[rule.clone()]});container.walkRules(strategy);rule=container.nodes[0]}let newEntry=[sort,rule];rules.add(newEntry);context.ruleCache.add(newEntry);allRules.push(newEntry)}}return allRules}__name(generateRules,\"generateRules\");function isArbitraryValue(input){return input.startsWith(\"[\")&&input.endsWith(\"]\")}__name(isArbitraryValue,\"isArbitraryValue\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["nodeInterop","rule","variantFunction","matches"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/lib/generateRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getClassNameFromSelector: function() {\n        return getClassNameFromSelector;\n    },\n    resolveMatches: function() {\n        return resolveMatches;\n    },\n    generateRules: function() {\n        return generateRules;\n    }\n});\nconst _postcss = /*#__PURE__*/ _interop_require_default(require(\"postcss\"));\nconst _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require(\"postcss-selector-parser\"));\nconst _parseObjectStyles = /*#__PURE__*/ _interop_require_default(require(\"../util/parseObjectStyles\"));\nconst _isPlainObject = /*#__PURE__*/ _interop_require_default(require(\"../util/isPlainObject\"));\nconst _prefixSelector = /*#__PURE__*/ _interop_require_default(require(\"../util/prefixSelector\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _log = /*#__PURE__*/ _interop_require_default(require(\"../util/log\"));\nconst _sharedState = /*#__PURE__*/ _interop_require_wildcard(require(\"./sharedState\"));\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nconst _nameClass = require(\"../util/nameClass\");\nconst _dataTypes = require(\"../util/dataTypes\");\nconst _setupContextUtils = require(\"./setupContextUtils\");\nconst _isSyntacticallyValidPropertyValue = /*#__PURE__*/ _interop_require_default(require(\"../util/isSyntacticallyValidPropertyValue\"));\nconst _splitAtTopLevelOnly = require(\"../util/splitAtTopLevelOnly.js\");\nconst _featureFlags = require(\"../featureFlags\");\nconst _applyImportantSelector = require(\"../util/applyImportantSelector\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet classNameParser = (0, _postcssselectorparser.default)((selectors)=>{\n    return selectors.first.filter(({ type  })=>type === \"class\").pop().value;\n});\nfunction getClassNameFromSelector(selector) {\n    return classNameParser.transformSync(selector);\n}\n// Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n// Example with dynamic classes:\n// ['grid-cols', '[[linename],1fr,auto]']\n// ['grid', 'cols-[[linename],1fr,auto]']\nfunction* candidatePermutations(candidate) {\n    let lastIndex = Infinity;\n    while(lastIndex >= 0){\n        let dashIdx;\n        let wasSlash = false;\n        if (lastIndex === Infinity && candidate.endsWith(\"]\")) {\n            let bracketIdx = candidate.indexOf(\"[\");\n            // If character before `[` isn't a dash or a slash, this isn't a dynamic class\n            // eg. string[]\n            if (candidate[bracketIdx - 1] === \"-\") {\n                dashIdx = bracketIdx - 1;\n            } else if (candidate[bracketIdx - 1] === \"/\") {\n                dashIdx = bracketIdx - 1;\n                wasSlash = true;\n            } else {\n                dashIdx = -1;\n            }\n        } else if (lastIndex === Infinity && candidate.includes(\"/\")) {\n            dashIdx = candidate.lastIndexOf(\"/\");\n            wasSlash = true;\n        } else {\n            dashIdx = candidate.lastIndexOf(\"-\", lastIndex);\n        }\n        if (dashIdx < 0) {\n            break;\n        }\n        let prefix = candidate.slice(0, dashIdx);\n        let modifier = candidate.slice(wasSlash ? dashIdx : dashIdx + 1);\n        lastIndex = dashIdx - 1;\n        // TODO: This feels a bit hacky\n        if (prefix === \"\" || modifier === \"/\") {\n            continue;\n        }\n        yield [\n            prefix,\n            modifier\n        ];\n    }\n}\nfunction applyPrefix(matches, context) {\n    if (matches.length === 0 || context.tailwindConfig.prefix === \"\") {\n        return matches;\n    }\n    for (let match of matches){\n        let [meta] = match;\n        if (meta.options.respectPrefix) {\n            let container = _postcss.default.root({\n                nodes: [\n                    match[1].clone()\n                ]\n            });\n            let classCandidate = match[1].raws.tailwind.classCandidate;\n            container.walkRules((r)=>{\n                // If this is a negative utility with a dash *before* the prefix we\n                // have to ensure that the generated selector matches the candidate\n                // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`\n                // The disconnect between candidate <-> class can cause @apply to hard crash.\n                let shouldPrependNegative = classCandidate.startsWith(\"-\");\n                r.selector = (0, _prefixSelector.default)(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);\n            });\n            match[1] = container.nodes[0];\n        }\n    }\n    return matches;\n}\nfunction applyImportant(matches, classCandidate) {\n    if (matches.length === 0) {\n        return matches;\n    }\n    let result = [];\n    for (let [meta, rule] of matches){\n        let container = _postcss.default.root({\n            nodes: [\n                rule.clone()\n            ]\n        });\n        container.walkRules((r)=>{\n            let ast = (0, _postcssselectorparser.default)().astSync(r.selector);\n            // Remove extraneous selectors that do not include the base candidate\n            ast.each((sel)=>(0, _formatVariantSelector.eliminateIrrelevantSelectors)(sel, classCandidate));\n            // Update all instances of the base candidate to include the important marker\n            (0, _pluginUtils.updateAllClasses)(ast, (className)=>className === classCandidate ? `!${className}` : className);\n            r.selector = ast.toString();\n            r.walkDecls((d)=>d.important = true);\n        });\n        result.push([\n            {\n                ...meta,\n                important: true\n            },\n            container.nodes[0]\n        ]);\n    }\n    return result;\n}\n// Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\nfunction applyVariant(variant, matches, context) {\n    if (matches.length === 0) {\n        return matches;\n    }\n    /** @type {{modifier: string | null, value: string | null}} */ let args = {\n        modifier: null,\n        value: _sharedState.NONE\n    };\n    // Retrieve \"modifier\"\n    {\n        let [baseVariant, ...modifiers] = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(variant, \"/\");\n        // This is a hack to support variants with `/` in them, like `ar-1/10/20:text-red-500`\n        // In this case 1/10 is a value but /20 is a modifier\n        if (modifiers.length > 1) {\n            baseVariant = baseVariant + \"/\" + modifiers.slice(0, -1).join(\"/\");\n            modifiers = modifiers.slice(-1);\n        }\n        if (modifiers.length && !context.variantMap.has(variant)) {\n            variant = baseVariant;\n            args.modifier = modifiers[0];\n            if (!(0, _featureFlags.flagEnabled)(context.tailwindConfig, \"generalizedModifiers\")) {\n                return [];\n            }\n        }\n    }\n    // Retrieve \"arbitrary value\"\n    if (variant.endsWith(\"]\") && !variant.startsWith(\"[\")) {\n        // We either have:\n        //   @[200px]\n        //   group-[:hover]\n        //\n        // But we don't want:\n        //   @-[200px]        (`-` is incorrect)\n        //   group[:hover]    (`-` is missing)\n        let match = /(.)(-?)\\[(.*)\\]/g.exec(variant);\n        if (match) {\n            let [, char, seperator, value] = match;\n            // @-[200px] case\n            if (char === \"@\" && seperator === \"-\") return [];\n            // group[:hover] case\n            if (char !== \"@\" && seperator === \"\") return [];\n            variant = variant.replace(`${seperator}[${value}]`, \"\");\n            args.value = value;\n        }\n    }\n    // Register arbitrary variants\n    if (isArbitraryValue(variant) && !context.variantMap.has(variant)) {\n        let sort = context.offsets.recordVariant(variant);\n        let selector = (0, _dataTypes.normalize)(variant.slice(1, -1));\n        let selectors = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(selector, \",\");\n        // We do not support multiple selectors for arbitrary variants\n        if (selectors.length > 1) {\n            return [];\n        }\n        if (!selectors.every(_setupContextUtils.isValidVariantFormatString)) {\n            return [];\n        }\n        let records = selectors.map((sel, idx)=>[\n                context.offsets.applyParallelOffset(sort, idx),\n                (0, _setupContextUtils.parseVariant)(sel.trim())\n            ]);\n        context.variantMap.set(variant, records);\n    }\n    if (context.variantMap.has(variant)) {\n        let isArbitraryVariant = isArbitraryValue(variant);\n        let variantFunctionTuples = context.variantMap.get(variant).slice();\n        let result = [];\n        for (let [meta, rule] of matches){\n            // Don't generate variants for user css\n            if (meta.layer === \"user\") {\n                continue;\n            }\n            let container = _postcss.default.root({\n                nodes: [\n                    rule.clone()\n                ]\n            });\n            for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples){\n                let clone = (containerFromArray !== null && containerFromArray !== void 0 ? containerFromArray : container).clone();\n                let collectedFormats = [];\n                function prepareBackup() {\n                    // Already prepared, chicken out\n                    if (clone.raws.neededBackup) {\n                        return;\n                    }\n                    clone.raws.neededBackup = true;\n                    clone.walkRules((rule)=>rule.raws.originalSelector = rule.selector);\n                }\n                function modifySelectors(modifierFunction) {\n                    prepareBackup();\n                    clone.each((rule)=>{\n                        if (rule.type !== \"rule\") {\n                            return;\n                        }\n                        rule.selectors = rule.selectors.map((selector)=>{\n                            return modifierFunction({\n                                get className () {\n                                    return getClassNameFromSelector(selector);\n                                },\n                                selector\n                            });\n                        });\n                    });\n                    return clone;\n                }\n                let ruleWithVariant = variantFunction({\n                    // Public API\n                    get container () {\n                        prepareBackup();\n                        return clone;\n                    },\n                    separator: context.tailwindConfig.separator,\n                    modifySelectors,\n                    // Private API for now\n                    wrap (wrapper) {\n                        let nodes = clone.nodes;\n                        clone.removeAll();\n                        wrapper.append(nodes);\n                        clone.append(wrapper);\n                    },\n                    format (selectorFormat) {\n                        collectedFormats.push({\n                            format: selectorFormat,\n                            isArbitraryVariant\n                        });\n                    },\n                    args\n                });\n                // It can happen that a list of format strings is returned from within the function. In that\n                // case, we have to process them as well. We can use the existing `variantSort`.\n                if (Array.isArray(ruleWithVariant)) {\n                    for (let [idx, variantFunction] of ruleWithVariant.entries()){\n                        // This is a little bit scary since we are pushing to an array of items that we are\n                        // currently looping over. However, you can also think of it like a processing queue\n                        // where you keep handling jobs until everything is done and each job can queue more\n                        // jobs if needed.\n                        variantFunctionTuples.push([\n                            context.offsets.applyParallelOffset(variantSort, idx),\n                            variantFunction,\n                            // If the clone has been modified we have to pass that back\n                            // though so each rule can use the modified container\n                            clone.clone()\n                        ]);\n                    }\n                    continue;\n                }\n                if (typeof ruleWithVariant === \"string\") {\n                    collectedFormats.push({\n                        format: ruleWithVariant,\n                        isArbitraryVariant\n                    });\n                }\n                if (ruleWithVariant === null) {\n                    continue;\n                }\n                // We had to backup selectors, therefore we assume that somebody touched\n                // `container` or `modifySelectors`. Let's see if they did, so that we\n                // can restore the selectors, and collect the format strings.\n                if (clone.raws.neededBackup) {\n                    delete clone.raws.neededBackup;\n                    clone.walkRules((rule)=>{\n                        let before = rule.raws.originalSelector;\n                        if (!before) return;\n                        delete rule.raws.originalSelector;\n                        if (before === rule.selector) return; // No mutation happened\n                        let modified = rule.selector;\n                        // Rebuild the base selector, this is what plugin authors would do\n                        // as well. E.g.: `${variant}${separator}${className}`.\n                        // However, plugin authors probably also prepend or append certain\n                        // classes, pseudos, ids, ...\n                        let rebuiltBase = (0, _postcssselectorparser.default)((selectors)=>{\n                            selectors.walkClasses((classNode)=>{\n                                classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;\n                            });\n                        }).processSync(before);\n                        // Now that we know the original selector, the new selector, and\n                        // the rebuild part in between, we can replace the part that plugin\n                        // authors need to rebuild with `&`, and eventually store it in the\n                        // collectedFormats. Similar to what `format('...')` would do.\n                        //\n                        // E.g.:\n                        //                   variant: foo\n                        //                  selector: .markdown > p\n                        //      modified (by plugin): .foo .foo\\\\:markdown > p\n                        //    rebuiltBase (internal): .foo\\\\:markdown > p\n                        //                    format: .foo &\n                        collectedFormats.push({\n                            format: modified.replace(rebuiltBase, \"&\"),\n                            isArbitraryVariant\n                        });\n                        rule.selector = before;\n                    });\n                }\n                // This tracks the originating layer for the variant\n                // For example:\n                // .sm:underline {} is a variant of something in the utilities layer\n                // .sm:container {} is a variant of the container component\n                clone.nodes[0].raws.tailwind = {\n                    ...clone.nodes[0].raws.tailwind,\n                    parentLayer: meta.layer\n                };\n                var _meta_collectedFormats;\n                let withOffset = [\n                    {\n                        ...meta,\n                        sort: context.offsets.applyVariantOffset(meta.sort, variantSort, Object.assign(args, context.variantOptions.get(variant))),\n                        collectedFormats: ((_meta_collectedFormats = meta.collectedFormats) !== null && _meta_collectedFormats !== void 0 ? _meta_collectedFormats : []).concat(collectedFormats)\n                    },\n                    clone.nodes[0]\n                ];\n                result.push(withOffset);\n            }\n        }\n        return result;\n    }\n    return [];\n}\nfunction parseRules(rule, cache, options = {}) {\n    // PostCSS node\n    if (!(0, _isPlainObject.default)(rule) && !Array.isArray(rule)) {\n        return [\n            [\n                rule\n            ],\n            options\n        ];\n    }\n    // Tuple\n    if (Array.isArray(rule)) {\n        return parseRules(rule[0], cache, rule[1]);\n    }\n    // Simple object\n    if (!cache.has(rule)) {\n        cache.set(rule, (0, _parseObjectStyles.default)(rule));\n    }\n    return [\n        cache.get(rule),\n        options\n    ];\n}\nconst IS_VALID_PROPERTY_NAME = /^[a-z_-]/;\nfunction isValidPropName(name) {\n    return IS_VALID_PROPERTY_NAME.test(name);\n}\n/**\n * @param {string} declaration\n * @returns {boolean}\n */ function looksLikeUri(declaration) {\n    // Quick bailout for obvious non-urls\n    // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem\n    if (!declaration.includes(\"://\")) {\n        return false;\n    }\n    try {\n        const url = new URL(declaration);\n        return url.scheme !== \"\" && url.host !== \"\";\n    } catch (err) {\n        // Definitely not a valid url\n        return false;\n    }\n}\nfunction isParsableNode(node) {\n    let isParsable = true;\n    node.walkDecls((decl)=>{\n        if (!isParsableCssValue(decl.prop, decl.value)) {\n            isParsable = false;\n            return false;\n        }\n    });\n    return isParsable;\n}\nfunction isParsableCssValue(property, value) {\n    // We don't want to to treat [https://example.com] as a custom property\n    // Even though, according to the CSS grammar, it's a totally valid CSS declaration\n    // So we short-circuit here by checking if the custom property looks like a url\n    if (looksLikeUri(`${property}:${value}`)) {\n        return false;\n    }\n    try {\n        _postcss.default.parse(`a{${property}:${value}}`).toResult();\n        return true;\n    } catch (err) {\n        return false;\n    }\n}\nfunction extractArbitraryProperty(classCandidate, context) {\n    var _classCandidate_match;\n    let [, property, value] = (_classCandidate_match = classCandidate.match(/^\\[([a-zA-Z0-9-_]+):(\\S+)\\]$/)) !== null && _classCandidate_match !== void 0 ? _classCandidate_match : [];\n    if (value === undefined) {\n        return null;\n    }\n    if (!isValidPropName(property)) {\n        return null;\n    }\n    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n        return null;\n    }\n    let normalized = (0, _dataTypes.normalize)(value);\n    if (!isParsableCssValue(property, normalized)) {\n        return null;\n    }\n    let sort = context.offsets.arbitraryProperty();\n    return [\n        [\n            {\n                sort,\n                layer: \"utilities\"\n            },\n            ()=>({\n                    [(0, _nameClass.asClass)(classCandidate)]: {\n                        [property]: normalized\n                    }\n                })\n        ]\n    ];\n}\nfunction* resolveMatchedPlugins(classCandidate, context) {\n    if (context.candidateRuleMap.has(classCandidate)) {\n        yield [\n            context.candidateRuleMap.get(classCandidate),\n            \"DEFAULT\"\n        ];\n    }\n    yield* function*(arbitraryPropertyRule) {\n        if (arbitraryPropertyRule !== null) {\n            yield [\n                arbitraryPropertyRule,\n                \"DEFAULT\"\n            ];\n        }\n    }(extractArbitraryProperty(classCandidate, context));\n    let candidatePrefix = classCandidate;\n    let negative = false;\n    const twConfigPrefix = context.tailwindConfig.prefix;\n    const twConfigPrefixLen = twConfigPrefix.length;\n    const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);\n    if (candidatePrefix[twConfigPrefixLen] === \"-\" && hasMatchingPrefix) {\n        negative = true;\n        candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);\n    }\n    if (negative && context.candidateRuleMap.has(candidatePrefix)) {\n        yield [\n            context.candidateRuleMap.get(candidatePrefix),\n            \"-DEFAULT\"\n        ];\n    }\n    for (let [prefix, modifier] of candidatePermutations(candidatePrefix)){\n        if (context.candidateRuleMap.has(prefix)) {\n            yield [\n                context.candidateRuleMap.get(prefix),\n                negative ? `-${modifier}` : modifier\n            ];\n        }\n    }\n}\nfunction splitWithSeparator(input, separator) {\n    if (input === _sharedState.NOT_ON_DEMAND) {\n        return [\n            _sharedState.NOT_ON_DEMAND\n        ];\n    }\n    return (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(input, separator);\n}\nfunction* recordCandidates(matches, classCandidate) {\n    for (const match of matches){\n        var _match__options;\n        var _match__options_preserveSource;\n        match[1].raws.tailwind = {\n            ...match[1].raws.tailwind,\n            classCandidate,\n            preserveSource: (_match__options_preserveSource = (_match__options = match[0].options) === null || _match__options === void 0 ? void 0 : _match__options.preserveSource) !== null && _match__options_preserveSource !== void 0 ? _match__options_preserveSource : false\n        };\n        yield match;\n    }\n}\nfunction* resolveMatches(candidate, context, original = candidate) {\n    let separator = context.tailwindConfig.separator;\n    let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();\n    let important = false;\n    if (classCandidate.startsWith(\"!\")) {\n        important = true;\n        classCandidate = classCandidate.slice(1);\n    }\n    if ((0, _featureFlags.flagEnabled)(context.tailwindConfig, \"variantGrouping\")) {\n        if (classCandidate.startsWith(\"(\") && classCandidate.endsWith(\")\")) {\n            let base = variants.slice().reverse().join(separator);\n            for (let part of (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(classCandidate.slice(1, -1), \",\")){\n                yield* resolveMatches(base + separator + part, context, original);\n            }\n        }\n    }\n    // TODO: Reintroduce this in ways that doesn't break on false positives\n    // function sortAgainst(toSort, against) {\n    //   return toSort.slice().sort((a, z) => {\n    //     return bigSign(against.get(a)[0] - against.get(z)[0])\n    //   })\n    // }\n    // let sorted = sortAgainst(variants, context.variantMap)\n    // if (sorted.toString() !== variants.toString()) {\n    //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n    //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n    // }\n    for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)){\n        let matches = [];\n        let typesByMatches = new Map();\n        let [plugins, modifier] = matchedPlugins;\n        let isOnlyPlugin = plugins.length === 1;\n        for (let [sort, plugin] of plugins){\n            let matchesPerPlugin = [];\n            if (typeof plugin === \"function\") {\n                for (let ruleSet of [].concat(plugin(modifier, {\n                    isOnlyPlugin\n                }))){\n                    let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n                    for (let rule of rules){\n                        matchesPerPlugin.push([\n                            {\n                                ...sort,\n                                options: {\n                                    ...sort.options,\n                                    ...options\n                                }\n                            },\n                            rule\n                        ]);\n                    }\n                }\n            } else if (modifier === \"DEFAULT\" || modifier === \"-DEFAULT\") {\n                let ruleSet = plugin;\n                let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n                for (let rule of rules){\n                    matchesPerPlugin.push([\n                        {\n                            ...sort,\n                            options: {\n                                ...sort.options,\n                                ...options\n                            }\n                        },\n                        rule\n                    ]);\n                }\n            }\n            if (matchesPerPlugin.length > 0) {\n                var _sort_options;\n                var _sort_options_types, _sort_options1;\n                let matchingTypes = Array.from((0, _pluginUtils.getMatchingTypes)((_sort_options_types = (_sort_options = sort.options) === null || _sort_options === void 0 ? void 0 : _sort_options.types) !== null && _sort_options_types !== void 0 ? _sort_options_types : [], modifier, (_sort_options1 = sort.options) !== null && _sort_options1 !== void 0 ? _sort_options1 : {}, context.tailwindConfig)).map(([_, type])=>type);\n                if (matchingTypes.length > 0) {\n                    typesByMatches.set(matchesPerPlugin, matchingTypes);\n                }\n                matches.push(matchesPerPlugin);\n            }\n        }\n        if (isArbitraryValue(modifier)) {\n            if (matches.length > 1) {\n                // Partition plugins in 2 categories so that we can start searching in the plugins that\n                // don't have `any` as a type first.\n                let [withAny, withoutAny] = matches.reduce((group, plugin)=>{\n                    let hasAnyType = plugin.some(([{ options  }])=>options.types.some(({ type  })=>type === \"any\"));\n                    if (hasAnyType) {\n                        group[0].push(plugin);\n                    } else {\n                        group[1].push(plugin);\n                    }\n                    return group;\n                }, [\n                    [],\n                    []\n                ]);\n                function findFallback(matches) {\n                    // If only a single plugin matches, let's take that one\n                    if (matches.length === 1) {\n                        return matches[0];\n                    }\n                    // Otherwise, find the plugin that creates a valid rule given the arbitrary value, and\n                    // also has the correct type which preferOnConflicts the plugin in case of clashes.\n                    return matches.find((rules)=>{\n                        let matchingTypes = typesByMatches.get(rules);\n                        return rules.some(([{ options  }, rule])=>{\n                            if (!isParsableNode(rule)) {\n                                return false;\n                            }\n                            return options.types.some(({ type , preferOnConflict  })=>matchingTypes.includes(type) && preferOnConflict);\n                        });\n                    });\n                }\n                var _findFallback;\n                // Try to find a fallback plugin, because we already know that multiple plugins matched for\n                // the given arbitrary value.\n                let fallback = (_findFallback = findFallback(withoutAny)) !== null && _findFallback !== void 0 ? _findFallback : findFallback(withAny);\n                if (fallback) {\n                    matches = [\n                        fallback\n                    ];\n                } else {\n                    var _typesByMatches_get;\n                    let typesPerPlugin = matches.map((match)=>new Set([\n                            ...(_typesByMatches_get = typesByMatches.get(match)) !== null && _typesByMatches_get !== void 0 ? _typesByMatches_get : []\n                        ]));\n                    // Remove duplicates, so that we can detect proper unique types for each plugin.\n                    for (let pluginTypes of typesPerPlugin){\n                        for (let type of pluginTypes){\n                            let removeFromOwnGroup = false;\n                            for (let otherGroup of typesPerPlugin){\n                                if (pluginTypes === otherGroup) continue;\n                                if (otherGroup.has(type)) {\n                                    otherGroup.delete(type);\n                                    removeFromOwnGroup = true;\n                                }\n                            }\n                            if (removeFromOwnGroup) pluginTypes.delete(type);\n                        }\n                    }\n                    let messages = [];\n                    for (let [idx, group] of typesPerPlugin.entries()){\n                        for (let type of group){\n                            let rules = matches[idx].map(([, rule])=>rule).flat().map((rule)=>rule.toString().split(\"\\n\").slice(1, -1) // Remove selector and closing '}'\n                                .map((line)=>line.trim()).map((x)=>`      ${x}`) // Re-indent\n                                .join(\"\\n\")).join(\"\\n\\n\");\n                            messages.push(`  Use \\`${candidate.replace(\"[\", `[${type}:`)}\\` for \\`${rules.trim()}\\``);\n                            break;\n                        }\n                    }\n                    _log.default.warn([\n                        `The class \\`${candidate}\\` is ambiguous and matches multiple utilities.`,\n                        ...messages,\n                        `If this is content and not a class, replace it with \\`${candidate.replace(\"[\", \"&lsqb;\").replace(\"]\", \"&rsqb;\")}\\` to silence this warning.`\n                    ]);\n                    continue;\n                }\n            }\n            matches = matches.map((list)=>list.filter((match)=>isParsableNode(match[1])));\n        }\n        matches = matches.flat();\n        matches = Array.from(recordCandidates(matches, classCandidate));\n        matches = applyPrefix(matches, context);\n        if (important) {\n            matches = applyImportant(matches, classCandidate);\n        }\n        for (let variant of variants){\n            matches = applyVariant(variant, matches, context);\n        }\n        for (let match of matches){\n            match[1].raws.tailwind = {\n                ...match[1].raws.tailwind,\n                candidate\n            };\n            // Apply final format selector\n            match = applyFinalFormat(match, {\n                context,\n                candidate,\n                original\n            });\n            // Skip rules with invalid selectors\n            // This will cause the candidate to be added to the \"not class\"\n            // cache skipping it entirely for future builds\n            if (match === null) {\n                continue;\n            }\n            yield match;\n        }\n    }\n}\nfunction applyFinalFormat(match, { context , candidate , original  }) {\n    if (!match[0].collectedFormats) {\n        return match;\n    }\n    let isValid = true;\n    let finalFormat;\n    try {\n        finalFormat = (0, _formatVariantSelector.formatVariantSelector)(match[0].collectedFormats, {\n            context,\n            candidate\n        });\n    } catch  {\n        // The format selector we produced is invalid\n        // This could be because:\n        // - A bug exists\n        // - A plugin introduced an invalid variant selector (ex: `addVariant('foo', '&;foo')`)\n        // - The user used an invalid arbitrary variant (ex: `[&;foo]:underline`)\n        // Either way the build will fail because of this\n        // We would rather that the build pass \"silently\" given that this could\n        // happen because of picking up invalid things when scanning content\n        // So we'll throw out the candidate instead\n        return null;\n    }\n    let container = _postcss.default.root({\n        nodes: [\n            match[1].clone()\n        ]\n    });\n    container.walkRules((rule)=>{\n        if (inKeyframes(rule)) {\n            return;\n        }\n        try {\n            rule.selector = (0, _formatVariantSelector.finalizeSelector)(rule.selector, finalFormat, {\n                candidate: original,\n                context\n            });\n        } catch  {\n            // If this selector is invalid we also want to skip it\n            // But it's likely that being invalid here means there's a bug in a plugin rather than too loosely matching content\n            isValid = false;\n            return false;\n        }\n    });\n    if (!isValid) {\n        return null;\n    }\n    match[1] = container.nodes[0];\n    return match;\n}\nfunction inKeyframes(rule) {\n    return rule.parent && rule.parent.type === \"atrule\" && rule.parent.name === \"keyframes\";\n}\nfunction getImportantStrategy(important) {\n    if (important === true) {\n        return (rule)=>{\n            if (inKeyframes(rule)) {\n                return;\n            }\n            rule.walkDecls((d)=>{\n                if (d.parent.type === \"rule\" && !inKeyframes(d.parent)) {\n                    d.important = true;\n                }\n            });\n        };\n    }\n    if (typeof important === \"string\") {\n        return (rule)=>{\n            if (inKeyframes(rule)) {\n                return;\n            }\n            rule.selectors = rule.selectors.map((selector)=>{\n                return (0, _applyImportantSelector.applyImportantSelector)(selector, important);\n            });\n        };\n    }\n}\nfunction generateRules(candidates, context) {\n    let allRules = [];\n    let strategy = getImportantStrategy(context.tailwindConfig.important);\n    for (let candidate of candidates){\n        if (context.notClassCache.has(candidate)) {\n            continue;\n        }\n        if (context.candidateRuleCache.has(candidate)) {\n            allRules = allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));\n            continue;\n        }\n        let matches = Array.from(resolveMatches(candidate, context));\n        if (matches.length === 0) {\n            context.notClassCache.add(candidate);\n            continue;\n        }\n        context.classCache.set(candidate, matches);\n        var _context_candidateRuleCache_get;\n        let rules = (_context_candidateRuleCache_get = context.candidateRuleCache.get(candidate)) !== null && _context_candidateRuleCache_get !== void 0 ? _context_candidateRuleCache_get : new Set();\n        context.candidateRuleCache.set(candidate, rules);\n        for (const match of matches){\n            let [{ sort , options  }, rule] = match;\n            if (options.respectImportant && strategy) {\n                let container = _postcss.default.root({\n                    nodes: [\n                        rule.clone()\n                    ]\n                });\n                container.walkRules(strategy);\n                rule = container.nodes[0];\n            }\n            let newEntry = [\n                sort,\n                rule\n            ];\n            rules.add(newEntry);\n            context.ruleCache.add(newEntry);\n            allRules.push(newEntry);\n        }\n    }\n    return allRules;\n}\nfunction isArbitraryValue(input) {\n    return input.startsWith(\"[\") && input.endsWith(\"]\");\n}\n"]}}