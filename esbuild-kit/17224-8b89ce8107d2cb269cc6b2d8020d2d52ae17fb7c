{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const fill=require(\"fill-range\");const stringify=require(\"./stringify\");const utils=require(\"./utils\");const append=__name((queue=\"\",stash=\"\",enclose=false)=>{let result=[];queue=[].concat(queue);stash=[].concat(stash);if(!stash.length)return queue;if(!queue.length){return enclose?utils.flatten(stash).map(ele=>`{${ele}}`):stash}for(let item of queue){if(Array.isArray(item)){for(let value of item){result.push(append(value,stash,enclose))}}else{for(let ele of stash){if(enclose===true&&typeof ele===\"string\")ele=`{${ele}}`;result.push(Array.isArray(ele)?append(item,ele,enclose):item+ele)}}}return utils.flatten(result)},\"append\");const expand=__name((ast,options={})=>{let rangeLimit=options.rangeLimit===void 0?1e3:options.rangeLimit;let walk=__name((node,parent={})=>{node.queue=[];let p=parent;let q=parent.queue;while(p.type!==\"brace\"&&p.type!==\"root\"&&p.parent){p=p.parent;q=p.queue}if(node.invalid||node.dollar){q.push(append(q.pop(),stringify(node,options)));return}if(node.type===\"brace\"&&node.invalid!==true&&node.nodes.length===2){q.push(append(q.pop(),[\"{}\"]));return}if(node.nodes&&node.ranges>0){let args=utils.reduce(node.nodes);if(utils.exceedsLimit(...args,options.step,rangeLimit)){throw new RangeError(\"expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.\")}let range=fill(...args,options);if(range.length===0){range=stringify(node,options)}q.push(append(q.pop(),range));node.nodes=[];return}let enclose=utils.encloseBrace(node);let queue=node.queue;let block=node;while(block.type!==\"brace\"&&block.type!==\"root\"&&block.parent){block=block.parent;queue=block.queue}for(let i=0;i<node.nodes.length;i++){let child=node.nodes[i];if(child.type===\"comma\"&&node.type===\"brace\"){if(i===1)queue.push(\"\");queue.push(\"\");continue}if(child.type===\"close\"){q.push(append(q.pop(),queue,enclose));continue}if(child.value&&child.type!==\"open\"){queue.push(append(queue.pop(),child.value));continue}if(child.nodes){walk(child,node)}}return queue},\"walk\");return utils.flatten(walk(ast))},\"expand\");module.exports=expand;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js"],"sourcesContent":["'use strict';\n\nconst fill = require('fill-range');\nconst stringify = require('./stringify');\nconst utils = require('./utils');\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nmodule.exports = expand;\n"]}}