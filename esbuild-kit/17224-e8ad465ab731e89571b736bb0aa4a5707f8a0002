{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:true,get:all[name]})}__name(_export,\"_export\");_export(exports,{parseBoxShadowValue:function(){return parseBoxShadowValue},formatBoxShadowValue:function(){return formatBoxShadowValue}});const _splitAtTopLevelOnly=require(\"./splitAtTopLevelOnly\");let KEYWORDS=new Set([\"inset\",\"inherit\",\"initial\",\"revert\",\"unset\"]);let SPACE=/\\ +(?![^(]*\\))/g;let LENGTH=/^-?(\\d+|\\.\\d+)(.*?)$/g;function parseBoxShadowValue(input){let shadows=(0,_splitAtTopLevelOnly.splitAtTopLevelOnly)(input,\",\");return shadows.map(shadow=>{let value=shadow.trim();let result={raw:value};let parts=value.split(SPACE);let seen=new Set;for(let part of parts){LENGTH.lastIndex=0;if(!seen.has(\"KEYWORD\")&&KEYWORDS.has(part)){result.keyword=part;seen.add(\"KEYWORD\")}else if(LENGTH.test(part)){if(!seen.has(\"X\")){result.x=part;seen.add(\"X\")}else if(!seen.has(\"Y\")){result.y=part;seen.add(\"Y\")}else if(!seen.has(\"BLUR\")){result.blur=part;seen.add(\"BLUR\")}else if(!seen.has(\"SPREAD\")){result.spread=part;seen.add(\"SPREAD\")}}else{if(!result.color){result.color=part}else{if(!result.unknown)result.unknown=[];result.unknown.push(part)}}}result.valid=result.x!==void 0&&result.y!==void 0;return result})}__name(parseBoxShadowValue,\"parseBoxShadowValue\");function formatBoxShadowValue(shadows){return shadows.map(shadow=>{if(!shadow.valid){return shadow.raw}return[shadow.keyword,shadow.x,shadow.y,shadow.blur,shadow.spread,shadow.color].filter(Boolean).join(\" \")}).join(\", \")}__name(formatBoxShadowValue,\"formatBoxShadowValue\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CACzC,MAAO,IACX,CAAC,EACD,SAAS,QAAQ,OAAQ,IAAK,CAC1B,QAAQ,QAAQ,IAAI,OAAO,eAAe,OAAQ,KAAM,CACpD,WAAY,KACZ,IAAK,IAAI,IAAI,CACjB,CAAC,CACL,CALS,0BAMT,QAAQ,QAAS,CACb,oBAAqB,UAAW,CAC5B,OAAO,mBACX,EACA,qBAAsB,UAAW,CAC7B,OAAO,oBACX,CACJ,CAAC,EACD,MAAM,qBAAuB,QAAQ,uBAAuB,EAC5D,IAAI,SAAW,IAAI,IAAI,CACnB,QACA,UACA,UACA,SACA,OACJ,CAAC,EACD,IAAI,MAAQ,kBAEZ,IAAI,OAAS,wBACb,SAAS,oBAAoB,MAAO,CAChC,IAAI,SAAW,EAAG,qBAAqB,qBAAqB,MAAO,GAAG,EACtE,OAAO,QAAQ,IAAK,QAAS,CACzB,IAAI,MAAQ,OAAO,KAAK,EACxB,IAAI,OAAS,CACT,IAAK,KACT,EACA,IAAI,MAAQ,MAAM,MAAM,KAAK,EAC7B,IAAI,KAAO,IAAI,IACf,QAAS,QAAQ,MAAM,CAEnB,OAAO,UAAY,EAEnB,GAAI,CAAC,KAAK,IAAI,SAAS,GAAK,SAAS,IAAI,IAAI,EAAG,CAC5C,OAAO,QAAU,KACjB,KAAK,IAAI,SAAS,CACtB,SAAW,OAAO,KAAK,IAAI,EAAG,CAC1B,GAAI,CAAC,KAAK,IAAI,GAAG,EAAG,CAChB,OAAO,EAAI,KACX,KAAK,IAAI,GAAG,CAChB,SAAW,CAAC,KAAK,IAAI,GAAG,EAAG,CACvB,OAAO,EAAI,KACX,KAAK,IAAI,GAAG,CAChB,SAAW,CAAC,KAAK,IAAI,MAAM,EAAG,CAC1B,OAAO,KAAO,KACd,KAAK,IAAI,MAAM,CACnB,SAAW,CAAC,KAAK,IAAI,QAAQ,EAAG,CAC5B,OAAO,OAAS,KAChB,KAAK,IAAI,QAAQ,CACrB,CACJ,KAAO,CACH,GAAI,CAAC,OAAO,MAAO,CACf,OAAO,MAAQ,IACnB,KAAO,CACH,GAAI,CAAC,OAAO,QAAS,OAAO,QAAU,CAAC,EACvC,OAAO,QAAQ,KAAK,IAAI,CAC5B,CACJ,CACJ,CAEA,OAAO,MAAQ,OAAO,IAAM,QAAa,OAAO,IAAM,OACtD,OAAO,MACX,CAAC,CACL,CA3CS,kDA4CT,SAAS,qBAAqB,QAAS,CACnC,OAAO,QAAQ,IAAK,QAAS,CACzB,GAAI,CAAC,OAAO,MAAO,CACf,OAAO,OAAO,GAClB,CACA,MAAO,CACH,OAAO,QACP,OAAO,EACP,OAAO,EACP,OAAO,KACP,OAAO,OACP,OAAO,KACX,EAAE,OAAO,OAAO,EAAE,KAAK,GAAG,CAC9B,CAAC,EAAE,KAAK,IAAI,CAChB,CAdS","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/util/parseBoxShadowValue.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    parseBoxShadowValue: function() {\n        return parseBoxShadowValue;\n    },\n    formatBoxShadowValue: function() {\n        return formatBoxShadowValue;\n    }\n});\nconst _splitAtTopLevelOnly = require(\"./splitAtTopLevelOnly\");\nlet KEYWORDS = new Set([\n    \"inset\",\n    \"inherit\",\n    \"initial\",\n    \"revert\",\n    \"unset\"\n]);\nlet SPACE = /\\ +(?![^(]*\\))/g // Similar to the one above, but with spaces instead.\n;\nlet LENGTH = /^-?(\\d+|\\.\\d+)(.*?)$/g;\nfunction parseBoxShadowValue(input) {\n    let shadows = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(input, \",\");\n    return shadows.map((shadow)=>{\n        let value = shadow.trim();\n        let result = {\n            raw: value\n        };\n        let parts = value.split(SPACE);\n        let seen = new Set();\n        for (let part of parts){\n            // Reset index, since the regex is stateful.\n            LENGTH.lastIndex = 0;\n            // Keyword\n            if (!seen.has(\"KEYWORD\") && KEYWORDS.has(part)) {\n                result.keyword = part;\n                seen.add(\"KEYWORD\");\n            } else if (LENGTH.test(part)) {\n                if (!seen.has(\"X\")) {\n                    result.x = part;\n                    seen.add(\"X\");\n                } else if (!seen.has(\"Y\")) {\n                    result.y = part;\n                    seen.add(\"Y\");\n                } else if (!seen.has(\"BLUR\")) {\n                    result.blur = part;\n                    seen.add(\"BLUR\");\n                } else if (!seen.has(\"SPREAD\")) {\n                    result.spread = part;\n                    seen.add(\"SPREAD\");\n                }\n            } else {\n                if (!result.color) {\n                    result.color = part;\n                } else {\n                    if (!result.unknown) result.unknown = [];\n                    result.unknown.push(part);\n                }\n            }\n        }\n        // Check if valid\n        result.valid = result.x !== undefined && result.y !== undefined;\n        return result;\n    });\n}\nfunction formatBoxShadowValue(shadows) {\n    return shadows.map((shadow)=>{\n        if (!shadow.valid) {\n            return shadow.raw;\n        }\n        return [\n            shadow.keyword,\n            shadow.x,\n            shadow.y,\n            shadow.blur,\n            shadow.spread,\n            shadow.color\n        ].filter(Boolean).join(\" \");\n    }).join(\", \");\n}\n"]}}