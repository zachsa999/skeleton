{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _keywords=require(\"../parser/tokenizer/keywords\");function isAsyncOperation(tokens){let index=tokens.currentIndex();let depth=0;const startToken=tokens.currentToken();do{const token=tokens.tokens[index];if(token.isOptionalChainStart){depth++}if(token.isOptionalChainEnd){depth--}depth+=token.numNullishCoalesceStarts;depth-=token.numNullishCoalesceEnds;if(token.contextualKeyword===_keywords.ContextualKeyword._await&&token.identifierRole==null&&token.scopeDepth===startToken.scopeDepth){return true}index+=1}while(depth>0&&index<tokens.tokens.length);return false}__name(isAsyncOperation,\"isAsyncOperation\");exports.default=isAsyncOperation;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAE,IAAI,UAAY,QAAQ,8BAA8B,EAY9H,SAAS,iBAAiB,OAAQ,CACjC,IAAI,MAAQ,OAAO,aAAa,EAChC,IAAI,MAAQ,EACZ,MAAM,WAAa,OAAO,aAAa,EACvC,EAAG,CACD,MAAM,MAAQ,OAAO,OAAO,KAAK,EACjC,GAAI,MAAM,qBAAsB,CAC9B,OACF,CACA,GAAI,MAAM,mBAAoB,CAC5B,OACF,CACA,OAAS,MAAM,yBACf,OAAS,MAAM,uBAEf,GACE,MAAM,oBAAsB,UAAU,kBAAkB,QACxD,MAAM,gBAAkB,MACxB,MAAM,aAAe,WAAW,WAChC,CACA,MAAO,KACT,CACA,OAAS,CACX,OAAS,MAAQ,GAAK,MAAQ,OAAO,OAAO,QAC5C,MAAO,MACT,CAzBU,4CAyBR,QAAQ,QAAU","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/util/isAsyncOperation.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});var _keywords = require('../parser/tokenizer/keywords');\n\n\n/**\n * Determine whether this optional chain or nullish coalescing operation has any await statements in\n * it. If so, we'll need to transpile to an async operation.\n *\n * We compute this by walking the length of the operation and returning true if we see an await\n * keyword used as a real await (rather than an object key or property access). Nested optional\n * chain/nullish operations need to be tracked but don't silence await, but a nested async function\n * (or any other nested scope) will make the await not count.\n */\n function isAsyncOperation(tokens) {\n  let index = tokens.currentIndex();\n  let depth = 0;\n  const startToken = tokens.currentToken();\n  do {\n    const token = tokens.tokens[index];\n    if (token.isOptionalChainStart) {\n      depth++;\n    }\n    if (token.isOptionalChainEnd) {\n      depth--;\n    }\n    depth += token.numNullishCoalesceStarts;\n    depth -= token.numNullishCoalesceEnds;\n\n    if (\n      token.contextualKeyword === _keywords.ContextualKeyword._await &&\n      token.identifierRole == null &&\n      token.scopeDepth === startToken.scopeDepth\n    ) {\n      return true;\n    }\n    index += 1;\n  } while (depth > 0 && index < tokens.tokens.length);\n  return false;\n} exports.default = isAsyncOperation;\n"]}}