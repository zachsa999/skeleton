{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});Object.defineProperty(exports,\"hasContentChanged\",{enumerable:true,get:function(){return hasContentChanged}});const _crypto=_interop_require_default(require(\"crypto\"));const _sharedState=_interop_require_wildcard(require(\"./sharedState\"));function _interop_require_default(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interop_require_default,\"_interop_require_default\");function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!==\"function\")return null;var cacheBabelInterop=new WeakMap;var cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=__name(function(nodeInterop2){return nodeInterop2?cacheNodeInterop:cacheBabelInterop},\"_getRequireWildcardCache\"))(nodeInterop)}__name(_getRequireWildcardCache,\"_getRequireWildcardCache\");function _interop_require_wildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj}if(obj===null||typeof obj!==\"object\"&&typeof obj!==\"function\"){return{default:obj}}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj)}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!==\"default\"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}newObj.default=obj;if(cache){cache.set(obj,newObj)}return newObj}__name(_interop_require_wildcard,\"_interop_require_wildcard\");function getHash(str){try{return _crypto.default.createHash(\"md5\").update(str,\"utf-8\").digest(\"binary\")}catch(err){return\"\"}}__name(getHash,\"getHash\");function hasContentChanged(sourcePath,root){let css=root.toString();if(!css.includes(\"@tailwind\")){return false}let existingHash=_sharedState.sourceHashMap.get(sourcePath);let rootHash=getHash(css);let didChange=existingHash!==rootHash;_sharedState.sourceHashMap.set(sourcePath,rootHash);return didChange}__name(hasContentChanged,\"hasContentChanged\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CACzC,MAAO,IACX,CAAC,EACD,OAAO,eAAe,QAAS,oBAAqB,CAChD,WAAY,KACZ,IAAK,UAAW,CACZ,OAAO,iBACX,CACJ,CAAC,EACD,MAAM,QAAwB,yBAAyB,QAAQ,QAAQ,CAAC,EACxE,MAAM,aAA6B,0BAA0B,QAAQ,eAAe,CAAC,EACrF,SAAS,yBAAyB,IAAK,CACnC,OAAO,KAAO,IAAI,WAAa,IAAM,CACjC,QAAS,GACb,CACJ,CAJS,4DAKT,SAAS,yBAAyB,YAAa,CAC3C,GAAI,OAAO,UAAY,WAAY,OAAO,KAC1C,IAAI,kBAAoB,IAAI,QAC5B,IAAI,iBAAmB,IAAI,QAC3B,OAAQ,yBAA2B,gBAASA,aAAa,CACrD,OAAOA,aAAc,iBAAmB,iBAC5C,EAFmC,6BAEhC,WAAW,CAClB,CAPS,4DAQT,SAAS,0BAA0B,IAAK,YAAa,CACjD,GAAI,CAAC,aAAe,KAAO,IAAI,WAAY,CACvC,OAAO,GACX,CACA,GAAI,MAAQ,MAAQ,OAAO,MAAQ,UAAY,OAAO,MAAQ,WAAY,CACtE,MAAO,CACH,QAAS,GACb,CACJ,CACA,IAAI,MAAQ,yBAAyB,WAAW,EAChD,GAAI,OAAS,MAAM,IAAI,GAAG,EAAG,CACzB,OAAO,MAAM,IAAI,GAAG,CACxB,CACA,IAAI,OAAS,CAAC,EACd,IAAI,sBAAwB,OAAO,gBAAkB,OAAO,yBAC5D,QAAQ,OAAO,IAAI,CACf,GAAI,MAAQ,WAAa,OAAO,UAAU,eAAe,KAAK,IAAK,GAAG,EAAG,CACrE,IAAI,KAAO,sBAAwB,OAAO,yBAAyB,IAAK,GAAG,EAAI,KAC/E,GAAI,OAAS,KAAK,KAAO,KAAK,KAAM,CAChC,OAAO,eAAe,OAAQ,IAAK,IAAI,CAC3C,KAAO,CACH,OAAO,GAAG,EAAI,IAAI,GAAG,CACzB,CACJ,CACJ,CACA,OAAO,QAAU,IACjB,GAAI,MAAO,CACP,MAAM,IAAI,IAAK,MAAM,CACzB,CACA,OAAO,MACX,CA9BS,8DA+CL,SAAS,QAAQ,IAAK,CACtB,GAAI,CACA,OAAO,QAAQ,QAAQ,WAAW,KAAK,EAAE,OAAO,IAAK,OAAO,EAAE,OAAO,QAAQ,CACjF,OAAS,IAAP,CACE,MAAO,EACX,CACJ,CANa,0BAOb,SAAS,kBAAkB,WAAY,KAAM,CACzC,IAAI,IAAM,KAAK,SAAS,EAGxB,GAAI,CAAC,IAAI,SAAS,WAAW,EAAG,CAC5B,MAAO,MACX,CACA,IAAI,aAAe,aAAa,cAAc,IAAI,UAAU,EAC5D,IAAI,SAAW,QAAQ,GAAG,EAC1B,IAAI,UAAY,eAAiB,SACjC,aAAa,cAAc,IAAI,WAAY,QAAQ,EACnD,OAAO,SACX,CAZS","names":["nodeInterop"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/lib/cacheInvalidation.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"hasContentChanged\", {\n    enumerable: true,\n    get: function() {\n        return hasContentChanged;\n    }\n});\nconst _crypto = /*#__PURE__*/ _interop_require_default(require(\"crypto\"));\nconst _sharedState = /*#__PURE__*/ _interop_require_wildcard(require(\"./sharedState\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\n/**\n * Calculate the hash of a string.\n *\n * This doesn't need to be cryptographically secure or\n * anything like that since it's used only to detect\n * when the CSS changes to invalidate the context.\n *\n * This is wrapped in a try/catch because it's really dependent\n * on how Node itself is build and the environment and OpenSSL\n * version / build that is installed on the user's machine.\n *\n * Based on the environment this can just outright fail.\n *\n * See https://github.com/nodejs/node/issues/40455\n *\n * @param {string} str\n */ function getHash(str) {\n    try {\n        return _crypto.default.createHash(\"md5\").update(str, \"utf-8\").digest(\"binary\");\n    } catch (err) {\n        return \"\";\n    }\n}\nfunction hasContentChanged(sourcePath, root) {\n    let css = root.toString();\n    // We only care about files with @tailwind directives\n    // Other files use an existing context\n    if (!css.includes(\"@tailwind\")) {\n        return false;\n    }\n    let existingHash = _sharedState.sourceHashMap.get(sourcePath);\n    let rootHash = getHash(css);\n    let didChange = existingHash !== rootHash;\n    _sharedState.sourceHashMap.set(sourcePath, rootHash);\n    return didChange;\n}\n"]}}