{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:true,get:all[name]})}__name(_export,\"_export\");_export(exports,{parseCandidateFiles:function(){return parseCandidateFiles},resolvedChangedContent:function(){return resolvedChangedContent}});const _fs=_interop_require_default(require(\"fs\"));const _path=_interop_require_default(require(\"path\"));const _isglob=_interop_require_default(require(\"is-glob\"));const _fastglob=_interop_require_default(require(\"fast-glob\"));const _normalizepath=_interop_require_default(require(\"normalize-path\"));const _parseGlob=require(\"../util/parseGlob\");const _sharedState=require(\"./sharedState\");function _interop_require_default(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interop_require_default,\"_interop_require_default\");function parseCandidateFiles(context,tailwindConfig){let files=tailwindConfig.content.files;files=files.filter(filePath=>typeof filePath===\"string\");files=files.map(_normalizepath.default);let tasks=_fastglob.default.generateTasks(files);let included=[];let excluded=[];for(const task of tasks){included.push(...task.positive.map(filePath=>parseFilePath(filePath,false)));excluded.push(...task.negative.map(filePath=>parseFilePath(filePath,true)))}let paths=[...included,...excluded];paths=resolveRelativePaths(context,paths);paths=paths.flatMap(resolvePathSymlinks);paths=paths.map(resolveGlobPattern);return paths}__name(parseCandidateFiles,\"parseCandidateFiles\");function parseFilePath(filePath,ignore){let contentPath={original:filePath,base:filePath,ignore,pattern:filePath,glob:null};if((0,_isglob.default)(filePath)){Object.assign(contentPath,(0,_parseGlob.parseGlob)(filePath))}return contentPath}__name(parseFilePath,\"parseFilePath\");function resolveGlobPattern(contentPath){let base=(0,_normalizepath.default)(contentPath.base);base=_fastglob.default.escapePath(base);contentPath.pattern=contentPath.glob?`${base}/${contentPath.glob}`:base;contentPath.pattern=contentPath.ignore?`!${contentPath.pattern}`:contentPath.pattern;return contentPath}__name(resolveGlobPattern,\"resolveGlobPattern\");function resolveRelativePaths(context,contentPaths){let resolveFrom=[];if(context.userConfigPath&&context.tailwindConfig.content.relative){resolveFrom=[_path.default.dirname(context.userConfigPath)]}return contentPaths.map(contentPath=>{contentPath.base=_path.default.resolve(...resolveFrom,contentPath.base);return contentPath})}__name(resolveRelativePaths,\"resolveRelativePaths\");function resolvePathSymlinks(contentPath){let paths=[contentPath];try{let resolvedPath=_fs.default.realpathSync(contentPath.base);if(resolvedPath!==contentPath.base){paths.push({...contentPath,base:resolvedPath})}}catch{}return paths}__name(resolvePathSymlinks,\"resolvePathSymlinks\");function resolvedChangedContent(context,candidateFiles,fileModifiedMap){let changedContent=context.tailwindConfig.content.files.filter(item=>typeof item.raw===\"string\").map(({raw,extension=\"html\"})=>({content:raw,extension}));let[changedFiles,mTimesToCommit]=resolveChangedFiles(candidateFiles,fileModifiedMap);for(let changedFile of changedFiles){let extension=_path.default.extname(changedFile).slice(1);changedContent.push({file:changedFile,extension})}return[changedContent,mTimesToCommit]}__name(resolvedChangedContent,\"resolvedChangedContent\");function resolveChangedFiles(candidateFiles,fileModifiedMap){let paths=candidateFiles.map(contentPath=>contentPath.pattern);let mTimesToCommit=new Map;let changedFiles=new Set;_sharedState.env.DEBUG&&console.time(\"Finding changed files\");let files=_fastglob.default.sync(paths,{absolute:true});for(let file of files){let prevModified=fileModifiedMap.get(file)||-Infinity;let modified=_fs.default.statSync(file).mtimeMs;if(modified>prevModified){changedFiles.add(file);mTimesToCommit.set(file,modified)}}_sharedState.env.DEBUG&&console.timeEnd(\"Finding changed files\");return[changedFiles,mTimesToCommit]}__name(resolveChangedFiles,\"resolveChangedFiles\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/lib/content.js"],"sourcesContent":["// @ts-check\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    parseCandidateFiles: function() {\n        return parseCandidateFiles;\n    },\n    resolvedChangedContent: function() {\n        return resolvedChangedContent;\n    }\n});\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _isglob = /*#__PURE__*/ _interop_require_default(require(\"is-glob\"));\nconst _fastglob = /*#__PURE__*/ _interop_require_default(require(\"fast-glob\"));\nconst _normalizepath = /*#__PURE__*/ _interop_require_default(require(\"normalize-path\"));\nconst _parseGlob = require(\"../util/parseGlob\");\nconst _sharedState = require(\"./sharedState\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction parseCandidateFiles(context, tailwindConfig) {\n    let files = tailwindConfig.content.files;\n    // Normalize the file globs\n    files = files.filter((filePath)=>typeof filePath === \"string\");\n    files = files.map(_normalizepath.default);\n    // Split into included and excluded globs\n    let tasks = _fastglob.default.generateTasks(files);\n    /** @type {ContentPath[]} */ let included = [];\n    /** @type {ContentPath[]} */ let excluded = [];\n    for (const task of tasks){\n        included.push(...task.positive.map((filePath)=>parseFilePath(filePath, false)));\n        excluded.push(...task.negative.map((filePath)=>parseFilePath(filePath, true)));\n    }\n    let paths = [\n        ...included,\n        ...excluded\n    ];\n    // Resolve paths relative to the config file or cwd\n    paths = resolveRelativePaths(context, paths);\n    // Resolve symlinks if possible\n    paths = paths.flatMap(resolvePathSymlinks);\n    // Update cached patterns\n    paths = paths.map(resolveGlobPattern);\n    return paths;\n}\n/**\n *\n * @param {string} filePath\n * @param {boolean} ignore\n * @returns {ContentPath}\n */ function parseFilePath(filePath, ignore) {\n    let contentPath = {\n        original: filePath,\n        base: filePath,\n        ignore,\n        pattern: filePath,\n        glob: null\n    };\n    if ((0, _isglob.default)(filePath)) {\n        Object.assign(contentPath, (0, _parseGlob.parseGlob)(filePath));\n    }\n    return contentPath;\n}\n/**\n *\n * @param {ContentPath} contentPath\n * @returns {ContentPath}\n */ function resolveGlobPattern(contentPath) {\n    // This is required for Windows support to properly pick up Glob paths.\n    // Afaik, this technically shouldn't be needed but there's probably\n    // some internal, direct path matching with a normalized path in\n    // a package which can't handle mixed directory separators\n    let base = (0, _normalizepath.default)(contentPath.base);\n    // If the user's file path contains any special characters (like parens) for instance fast-glob\n    // is like \"OOOH SHINY\" and treats them as such. So we have to escape the base path to fix this\n    base = _fastglob.default.escapePath(base);\n    contentPath.pattern = contentPath.glob ? `${base}/${contentPath.glob}` : base;\n    contentPath.pattern = contentPath.ignore ? `!${contentPath.pattern}` : contentPath.pattern;\n    return contentPath;\n}\n/**\n * Resolve each path relative to the config file (when possible) if the experimental flag is enabled\n * Otherwise, resolve relative to the current working directory\n *\n * @param {any} context\n * @param {ContentPath[]} contentPaths\n * @returns {ContentPath[]}\n */ function resolveRelativePaths(context, contentPaths) {\n    let resolveFrom = [];\n    // Resolve base paths relative to the config file (when possible) if the experimental flag is enabled\n    if (context.userConfigPath && context.tailwindConfig.content.relative) {\n        resolveFrom = [\n            _path.default.dirname(context.userConfigPath)\n        ];\n    }\n    return contentPaths.map((contentPath)=>{\n        contentPath.base = _path.default.resolve(...resolveFrom, contentPath.base);\n        return contentPath;\n    });\n}\n/**\n * Resolve the symlink for the base directory / file in each path\n * These are added as additional dependencies to watch for changes because\n * some tools (like webpack) will only watch the actual file or directory\n * but not the symlink itself even in projects that use monorepos.\n *\n * @param {ContentPath} contentPath\n * @returns {ContentPath[]}\n */ function resolvePathSymlinks(contentPath) {\n    let paths = [\n        contentPath\n    ];\n    try {\n        let resolvedPath = _fs.default.realpathSync(contentPath.base);\n        if (resolvedPath !== contentPath.base) {\n            paths.push({\n                ...contentPath,\n                base: resolvedPath\n            });\n        }\n    } catch  {\n    // TODO: log this?\n    }\n    return paths;\n}\nfunction resolvedChangedContent(context, candidateFiles, fileModifiedMap) {\n    let changedContent = context.tailwindConfig.content.files.filter((item)=>typeof item.raw === \"string\").map(({ raw , extension =\"html\"  })=>({\n            content: raw,\n            extension\n        }));\n    let [changedFiles, mTimesToCommit] = resolveChangedFiles(candidateFiles, fileModifiedMap);\n    for (let changedFile of changedFiles){\n        let extension = _path.default.extname(changedFile).slice(1);\n        changedContent.push({\n            file: changedFile,\n            extension\n        });\n    }\n    return [\n        changedContent,\n        mTimesToCommit\n    ];\n}\n/**\n *\n * @param {ContentPath[]} candidateFiles\n * @param {Map<string, number>} fileModifiedMap\n * @returns {[Set<string>, Map<string, number>]}\n */ function resolveChangedFiles(candidateFiles, fileModifiedMap) {\n    let paths = candidateFiles.map((contentPath)=>contentPath.pattern);\n    let mTimesToCommit = new Map();\n    let changedFiles = new Set();\n    _sharedState.env.DEBUG && console.time(\"Finding changed files\");\n    let files = _fastglob.default.sync(paths, {\n        absolute: true\n    });\n    for (let file of files){\n        let prevModified = fileModifiedMap.get(file) || -Infinity;\n        let modified = _fs.default.statSync(file).mtimeMs;\n        if (modified > prevModified) {\n            changedFiles.add(file);\n            mTimesToCommit.set(file, modified);\n        }\n    }\n    _sharedState.env.DEBUG && console.timeEnd(\"Finding changed files\");\n    return [\n        changedFiles,\n        mTimesToCommit\n    ];\n}\n"]}}