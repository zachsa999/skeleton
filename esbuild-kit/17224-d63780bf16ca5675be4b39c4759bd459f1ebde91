{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});Object.defineProperty(exports,\"default\",{enumerable:true,get:function(){return setupTrackingContext}});const _fs=_interop_require_default(require(\"fs\"));const _quicklru=_interop_require_default(require(\"@alloc/quick-lru\"));const _hashConfig=_interop_require_default(require(\"../util/hashConfig\"));const _resolveconfig=_interop_require_default(require(\"../public/resolve-config\"));const _resolveConfigPath=_interop_require_default(require(\"../util/resolveConfigPath\"));const _setupContextUtils=require(\"./setupContextUtils\");const _parseDependency=_interop_require_default(require(\"../util/parseDependency\"));const _validateConfig=require(\"../util/validateConfig.js\");const _content=require(\"./content.js\");const _loadconfig=require(\"../lib/load-config\");const _getModuleDependencies=_interop_require_default(require(\"./getModuleDependencies\"));function _interop_require_default(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interop_require_default,\"_interop_require_default\");let configPathCache=new _quicklru.default({maxSize:100});let candidateFilesCache=new WeakMap;function getCandidateFiles(context,tailwindConfig){if(candidateFilesCache.has(context)){return candidateFilesCache.get(context)}let candidateFiles=(0,_content.parseCandidateFiles)(context,tailwindConfig);return candidateFilesCache.set(context,candidateFiles).get(context)}__name(getCandidateFiles,\"getCandidateFiles\");function getTailwindConfig(configOrPath){let userConfigPath=(0,_resolveConfigPath.default)(configOrPath);if(userConfigPath!==null){let[prevConfig,prevConfigHash,prevDeps,prevModified]=configPathCache.get(userConfigPath)||[];let newDeps=(0,_getModuleDependencies.default)(userConfigPath);let modified=false;let newModified=new Map;for(let file of newDeps){let time=_fs.default.statSync(file).mtimeMs;newModified.set(file,time);if(!prevModified||!prevModified.has(file)||time>prevModified.get(file)){modified=true}}if(!modified){return[prevConfig,userConfigPath,prevConfigHash,prevDeps]}for(let file of newDeps){delete require.cache[file]}let newConfig2=(0,_validateConfig.validateConfig)((0,_resolveconfig.default)((0,_loadconfig.loadConfig)(userConfigPath)));let newHash=(0,_hashConfig.default)(newConfig2);configPathCache.set(userConfigPath,[newConfig2,newHash,newDeps,newModified]);return[newConfig2,userConfigPath,newHash,newDeps]}let newConfig=(0,_resolveconfig.default)(configOrPath.config===void 0?configOrPath:configOrPath.config);newConfig=(0,_validateConfig.validateConfig)(newConfig);return[newConfig,null,(0,_hashConfig.default)(newConfig),[]]}__name(getTailwindConfig,\"getTailwindConfig\");function setupTrackingContext(configOrPath){return({tailwindDirectives,registerDependency})=>{return(root,result)=>{let[tailwindConfig,userConfigPath,tailwindConfigHash,configDependencies]=getTailwindConfig(configOrPath);let contextDependencies=new Set(configDependencies);if(tailwindDirectives.size>0){contextDependencies.add(result.opts.from);for(let message of result.messages){if(message.type===\"dependency\"){contextDependencies.add(message.file)}}}let[context,,mTimesToCommit]=(0,_setupContextUtils.getContext)(root,result,tailwindConfig,userConfigPath,tailwindConfigHash,contextDependencies);let fileModifiedMap=(0,_setupContextUtils.getFileModifiedMap)(context);let candidateFiles=getCandidateFiles(context,tailwindConfig);if(tailwindDirectives.size>0){for(let contentPath of candidateFiles){for(let dependency of(0,_parseDependency.default)(contentPath)){registerDependency(dependency)}}let[changedContent,contentMTimesToCommit]=(0,_content.resolvedChangedContent)(context,candidateFiles,fileModifiedMap);for(let content of changedContent){context.changedContent.push(content)}for(let[path,mtime]of contentMTimesToCommit.entries()){mTimesToCommit.set(path,mtime)}}for(let file of configDependencies){registerDependency({type:\"dependency\",file})}for(let[path,mtime]of mTimesToCommit.entries()){fileModifiedMap.set(path,mtime)}return context}}}__name(setupTrackingContext,\"setupTrackingContext\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["newConfig"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/lib/setupTrackingContext.js"],"sourcesContent":["// @ts-check\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, // DISABLE_TOUCH = TRUE\n// Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\n\"default\", {\n    enumerable: true,\n    get: function() {\n        return setupTrackingContext;\n    }\n});\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _quicklru = /*#__PURE__*/ _interop_require_default(require(\"@alloc/quick-lru\"));\nconst _hashConfig = /*#__PURE__*/ _interop_require_default(require(\"../util/hashConfig\"));\nconst _resolveconfig = /*#__PURE__*/ _interop_require_default(require(\"../public/resolve-config\"));\nconst _resolveConfigPath = /*#__PURE__*/ _interop_require_default(require(\"../util/resolveConfigPath\"));\nconst _setupContextUtils = require(\"./setupContextUtils\");\nconst _parseDependency = /*#__PURE__*/ _interop_require_default(require(\"../util/parseDependency\"));\nconst _validateConfig = require(\"../util/validateConfig.js\");\nconst _content = require(\"./content.js\");\nconst _loadconfig = require(\"../lib/load-config\");\nconst _getModuleDependencies = /*#__PURE__*/ _interop_require_default(require(\"./getModuleDependencies\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nlet configPathCache = new _quicklru.default({\n    maxSize: 100\n});\nlet candidateFilesCache = new WeakMap();\nfunction getCandidateFiles(context, tailwindConfig) {\n    if (candidateFilesCache.has(context)) {\n        return candidateFilesCache.get(context);\n    }\n    let candidateFiles = (0, _content.parseCandidateFiles)(context, tailwindConfig);\n    return candidateFilesCache.set(context, candidateFiles).get(context);\n}\n// Get the config object based on a path\nfunction getTailwindConfig(configOrPath) {\n    let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);\n    if (userConfigPath !== null) {\n        let [prevConfig, prevConfigHash, prevDeps, prevModified] = configPathCache.get(userConfigPath) || [];\n        let newDeps = (0, _getModuleDependencies.default)(userConfigPath);\n        let modified = false;\n        let newModified = new Map();\n        for (let file of newDeps){\n            let time = _fs.default.statSync(file).mtimeMs;\n            newModified.set(file, time);\n            if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {\n                modified = true;\n            }\n        }\n        // It hasn't changed (based on timestamps)\n        if (!modified) {\n            return [\n                prevConfig,\n                userConfigPath,\n                prevConfigHash,\n                prevDeps\n            ];\n        }\n        // It has changed (based on timestamps), or first run\n        for (let file of newDeps){\n            delete require.cache[file];\n        }\n        let newConfig = (0, _validateConfig.validateConfig)((0, _resolveconfig.default)((0, _loadconfig.loadConfig)(userConfigPath)));\n        let newHash = (0, _hashConfig.default)(newConfig);\n        configPathCache.set(userConfigPath, [\n            newConfig,\n            newHash,\n            newDeps,\n            newModified\n        ]);\n        return [\n            newConfig,\n            userConfigPath,\n            newHash,\n            newDeps\n        ];\n    }\n    // It's a plain object, not a path\n    let newConfig = (0, _resolveconfig.default)(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n    newConfig = (0, _validateConfig.validateConfig)(newConfig);\n    return [\n        newConfig,\n        null,\n        (0, _hashConfig.default)(newConfig),\n        []\n    ];\n}\nfunction setupTrackingContext(configOrPath) {\n    return ({ tailwindDirectives , registerDependency  })=>{\n        return (root, result)=>{\n            let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\n            let contextDependencies = new Set(configDependencies);\n            // If there are no @tailwind or @apply rules, we don't consider this CSS\n            // file or its dependencies to be dependencies of the context. Can reuse\n            // the context even if they change. We may want to think about `@layer`\n            // being part of this trigger too, but it's tough because it's impossible\n            // for a layer in one file to end up in the actual @tailwind rule in\n            // another file since independent sources are effectively isolated.\n            if (tailwindDirectives.size > 0) {\n                // Add current css file as a context dependencies.\n                contextDependencies.add(result.opts.from);\n                // Add all css @import dependencies as context dependencies.\n                for (let message of result.messages){\n                    if (message.type === \"dependency\") {\n                        contextDependencies.add(message.file);\n                    }\n                }\n            }\n            let [context, , mTimesToCommit] = (0, _setupContextUtils.getContext)(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);\n            let fileModifiedMap = (0, _setupContextUtils.getFileModifiedMap)(context);\n            let candidateFiles = getCandidateFiles(context, tailwindConfig);\n            // If there are no @tailwind or @apply rules, we don't consider this CSS file or it's\n            // dependencies to be dependencies of the context. Can reuse the context even if they change.\n            // We may want to think about `@layer` being part of this trigger too, but it's tough\n            // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n            // in another file since independent sources are effectively isolated.\n            if (tailwindDirectives.size > 0) {\n                // Add template paths as postcss dependencies.\n                for (let contentPath of candidateFiles){\n                    for (let dependency of (0, _parseDependency.default)(contentPath)){\n                        registerDependency(dependency);\n                    }\n                }\n                let [changedContent, contentMTimesToCommit] = (0, _content.resolvedChangedContent)(context, candidateFiles, fileModifiedMap);\n                for (let content of changedContent){\n                    context.changedContent.push(content);\n                }\n                // Add the mtimes of the content files to the commit list\n                // We can overwrite the existing values because unconditionally\n                // This is because:\n                // 1. Most of the files here won't be in the map yet\n                // 2. If they are that means it's a context dependency\n                // and we're reading this after the context. This means\n                // that the mtime we just read is strictly >= the context\n                // mtime. Unless the user / os is doing something weird\n                // in which the mtime would be going backwards. If that\n                // happens there's already going to be problems.\n                for (let [path, mtime] of contentMTimesToCommit.entries()){\n                    mTimesToCommit.set(path, mtime);\n                }\n            }\n            for (let file of configDependencies){\n                registerDependency({\n                    type: \"dependency\",\n                    file\n                });\n            }\n            // \"commit\" the new modified time for all context deps\n            // We do this here because we want content tracking to\n            // read the \"old\" mtime even when it's a context dependency.\n            for (let [path, mtime] of mTimesToCommit.entries()){\n                fileModifiedMap.set(path, mtime);\n            }\n            return context;\n        };\n    };\n}\n"]}}