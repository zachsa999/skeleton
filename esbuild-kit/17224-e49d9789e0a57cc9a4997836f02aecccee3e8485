{"code":"(()=>{\nvar __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});var util=require(\"./util\");var binarySearch=require(\"./binary-search\");var ArraySet=require(\"./array-set\").ArraySet;var base64VLQ=require(\"./base64-vlq\");var quickSort=require(\"./quick-sort\").quickSort;function SourceMapConsumer(aSourceMap,aSourceMapURL){var sourceMap=aSourceMap;if(typeof aSourceMap===\"string\"){sourceMap=util.parseSourceMapInput(aSourceMap)}return sourceMap.sections!=null?new IndexedSourceMapConsumer(sourceMap,aSourceMapURL):new BasicSourceMapConsumer(sourceMap,aSourceMapURL)}__name(SourceMapConsumer,\"SourceMapConsumer\");SourceMapConsumer.fromSourceMap=function(aSourceMap,aSourceMapURL){return BasicSourceMapConsumer.fromSourceMap(aSourceMap,aSourceMapURL)};SourceMapConsumer.prototype._version=3;SourceMapConsumer.prototype.__generatedMappings=null;Object.defineProperty(SourceMapConsumer.prototype,\"_generatedMappings\",{configurable:true,enumerable:true,get:function(){if(!this.__generatedMappings){this._parseMappings(this._mappings,this.sourceRoot)}return this.__generatedMappings}});SourceMapConsumer.prototype.__originalMappings=null;Object.defineProperty(SourceMapConsumer.prototype,\"_originalMappings\",{configurable:true,enumerable:true,get:function(){if(!this.__originalMappings){this._parseMappings(this._mappings,this.sourceRoot)}return this.__originalMappings}});SourceMapConsumer.prototype._charIsMappingSeparator=__name(function SourceMapConsumer_charIsMappingSeparator(aStr,index){var c=aStr.charAt(index);return c===\";\"||c===\",\"},\"SourceMapConsumer_charIsMappingSeparator\");SourceMapConsumer.prototype._parseMappings=__name(function SourceMapConsumer_parseMappings(aStr,aSourceRoot){throw new Error(\"Subclasses must implement _parseMappings\")},\"SourceMapConsumer_parseMappings\");SourceMapConsumer.GENERATED_ORDER=1;SourceMapConsumer.ORIGINAL_ORDER=2;SourceMapConsumer.GREATEST_LOWER_BOUND=1;SourceMapConsumer.LEAST_UPPER_BOUND=2;SourceMapConsumer.prototype.eachMapping=__name(function SourceMapConsumer_eachMapping(aCallback,aContext,aOrder){var context=aContext||null;var order=aOrder||SourceMapConsumer.GENERATED_ORDER;var mappings;switch(order){case SourceMapConsumer.GENERATED_ORDER:mappings=this._generatedMappings;break;case SourceMapConsumer.ORIGINAL_ORDER:mappings=this._originalMappings;break;default:throw new Error(\"Unknown order of iteration.\")}var sourceRoot=this.sourceRoot;var boundCallback=aCallback.bind(context);var names=this._names;var sources=this._sources;var sourceMapURL=this._sourceMapURL;for(var i=0,n=mappings.length;i<n;i++){var mapping=mappings[i];var source=mapping.source===null?null:sources.at(mapping.source);source=util.computeSourceURL(sourceRoot,source,sourceMapURL);boundCallback({source,generatedLine:mapping.generatedLine,generatedColumn:mapping.generatedColumn,originalLine:mapping.originalLine,originalColumn:mapping.originalColumn,name:mapping.name===null?null:names.at(mapping.name)})}},\"SourceMapConsumer_eachMapping\");SourceMapConsumer.prototype.allGeneratedPositionsFor=__name(function SourceMapConsumer_allGeneratedPositionsFor(aArgs){var line=util.getArg(aArgs,\"line\");var needle={source:util.getArg(aArgs,\"source\"),originalLine:line,originalColumn:util.getArg(aArgs,\"column\",0)};needle.source=this._findSourceIndex(needle.source);if(needle.source<0){return[]}var mappings=[];var index=this._findMapping(needle,this._originalMappings,\"originalLine\",\"originalColumn\",util.compareByOriginalPositions,binarySearch.LEAST_UPPER_BOUND);if(index>=0){var mapping=this._originalMappings[index];if(aArgs.column===void 0){var originalLine=mapping.originalLine;while(mapping&&mapping.originalLine===originalLine){mappings.push({line:util.getArg(mapping,\"generatedLine\",null),column:util.getArg(mapping,\"generatedColumn\",null),lastColumn:util.getArg(mapping,\"lastGeneratedColumn\",null)});mapping=this._originalMappings[++index]}}else{var originalColumn=mapping.originalColumn;while(mapping&&mapping.originalLine===line&&mapping.originalColumn==originalColumn){mappings.push({line:util.getArg(mapping,\"generatedLine\",null),column:util.getArg(mapping,\"generatedColumn\",null),lastColumn:util.getArg(mapping,\"lastGeneratedColumn\",null)});mapping=this._originalMappings[++index]}}}return mappings},\"SourceMapConsumer_allGeneratedPositionsFor\");exports.SourceMapConsumer=SourceMapConsumer;function BasicSourceMapConsumer(aSourceMap,aSourceMapURL){var sourceMap=aSourceMap;if(typeof aSourceMap===\"string\"){sourceMap=util.parseSourceMapInput(aSourceMap)}var version=util.getArg(sourceMap,\"version\");var sources=util.getArg(sourceMap,\"sources\");var names=util.getArg(sourceMap,\"names\",[]);var sourceRoot=util.getArg(sourceMap,\"sourceRoot\",null);var sourcesContent=util.getArg(sourceMap,\"sourcesContent\",null);var mappings=util.getArg(sourceMap,\"mappings\");var file=util.getArg(sourceMap,\"file\",null);if(version!=this._version){throw new Error(\"Unsupported version: \"+version)}if(sourceRoot){sourceRoot=util.normalize(sourceRoot)}sources=sources.map(String).map(util.normalize).map(function(source){return sourceRoot&&util.isAbsolute(sourceRoot)&&util.isAbsolute(source)?util.relative(sourceRoot,source):source});this._names=ArraySet.fromArray(names.map(String),true);this._sources=ArraySet.fromArray(sources,true);this._absoluteSources=this._sources.toArray().map(function(s){return util.computeSourceURL(sourceRoot,s,aSourceMapURL)});this.sourceRoot=sourceRoot;this.sourcesContent=sourcesContent;this._mappings=mappings;this._sourceMapURL=aSourceMapURL;this.file=file}__name(BasicSourceMapConsumer,\"BasicSourceMapConsumer\");BasicSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype);BasicSourceMapConsumer.prototype.consumer=SourceMapConsumer;BasicSourceMapConsumer.prototype._findSourceIndex=function(aSource){var relativeSource=aSource;if(this.sourceRoot!=null){relativeSource=util.relative(this.sourceRoot,relativeSource)}if(this._sources.has(relativeSource)){return this._sources.indexOf(relativeSource)}var i;for(i=0;i<this._absoluteSources.length;++i){if(this._absoluteSources[i]==aSource){return i}}return-1};BasicSourceMapConsumer.fromSourceMap=__name(function SourceMapConsumer_fromSourceMap(aSourceMap,aSourceMapURL){var smc=Object.create(BasicSourceMapConsumer.prototype);var names=smc._names=ArraySet.fromArray(aSourceMap._names.toArray(),true);var sources=smc._sources=ArraySet.fromArray(aSourceMap._sources.toArray(),true);smc.sourceRoot=aSourceMap._sourceRoot;smc.sourcesContent=aSourceMap._generateSourcesContent(smc._sources.toArray(),smc.sourceRoot);smc.file=aSourceMap._file;smc._sourceMapURL=aSourceMapURL;smc._absoluteSources=smc._sources.toArray().map(function(s){return util.computeSourceURL(smc.sourceRoot,s,aSourceMapURL)});var generatedMappings=aSourceMap._mappings.toArray().slice();var destGeneratedMappings=smc.__generatedMappings=[];var destOriginalMappings=smc.__originalMappings=[];for(var i=0,length=generatedMappings.length;i<length;i++){var srcMapping=generatedMappings[i];var destMapping=new Mapping;destMapping.generatedLine=srcMapping.generatedLine;destMapping.generatedColumn=srcMapping.generatedColumn;if(srcMapping.source){destMapping.source=sources.indexOf(srcMapping.source);destMapping.originalLine=srcMapping.originalLine;destMapping.originalColumn=srcMapping.originalColumn;if(srcMapping.name){destMapping.name=names.indexOf(srcMapping.name)}destOriginalMappings.push(destMapping)}destGeneratedMappings.push(destMapping)}quickSort(smc.__originalMappings,util.compareByOriginalPositions);return smc},\"SourceMapConsumer_fromSourceMap\");BasicSourceMapConsumer.prototype._version=3;Object.defineProperty(BasicSourceMapConsumer.prototype,\"sources\",{get:function(){return this._absoluteSources.slice()}});function Mapping(){this.generatedLine=0;this.generatedColumn=0;this.source=null;this.originalLine=null;this.originalColumn=null;this.name=null}__name(Mapping,\"Mapping\");const compareGenerated=util.compareByGeneratedPositionsDeflatedNoLine;function sortGenerated(array,start){let l=array.length;let n=array.length-start;if(n<=1){return}else if(n==2){let a=array[start];let b=array[start+1];if(compareGenerated(a,b)>0){array[start]=b;array[start+1]=a}}else if(n<20){for(let i=start;i<l;i++){for(let j=i;j>start;j--){let a=array[j-1];let b=array[j];if(compareGenerated(a,b)<=0){break}array[j-1]=b;array[j]=a}}}else{quickSort(array,compareGenerated,start)}}__name(sortGenerated,\"sortGenerated\");BasicSourceMapConsumer.prototype._parseMappings=__name(function SourceMapConsumer_parseMappings2(aStr,aSourceRoot){var generatedLine=1;var previousGeneratedColumn=0;var previousOriginalLine=0;var previousOriginalColumn=0;var previousSource=0;var previousName=0;var length=aStr.length;var index=0;var cachedSegments={};var temp={};var originalMappings=[];var generatedMappings=[];var mapping,str,segment,end,value;let subarrayStart=0;while(index<length){if(aStr.charAt(index)===\";\"){generatedLine++;index++;previousGeneratedColumn=0;sortGenerated(generatedMappings,subarrayStart);subarrayStart=generatedMappings.length}else if(aStr.charAt(index)===\",\"){index++}else{mapping=new Mapping;mapping.generatedLine=generatedLine;for(end=index;end<length;end++){if(this._charIsMappingSeparator(aStr,end)){break}}str=aStr.slice(index,end);segment=[];while(index<end){base64VLQ.decode(aStr,index,temp);value=temp.value;index=temp.rest;segment.push(value)}if(segment.length===2){throw new Error(\"Found a source, but no line and column\")}if(segment.length===3){throw new Error(\"Found a source and line, but no column\")}mapping.generatedColumn=previousGeneratedColumn+segment[0];previousGeneratedColumn=mapping.generatedColumn;if(segment.length>1){mapping.source=previousSource+segment[1];previousSource+=segment[1];mapping.originalLine=previousOriginalLine+segment[2];previousOriginalLine=mapping.originalLine;mapping.originalLine+=1;mapping.originalColumn=previousOriginalColumn+segment[3];previousOriginalColumn=mapping.originalColumn;if(segment.length>4){mapping.name=previousName+segment[4];previousName+=segment[4]}}generatedMappings.push(mapping);if(typeof mapping.originalLine===\"number\"){let currentSource=mapping.source;while(originalMappings.length<=currentSource){originalMappings.push(null)}if(originalMappings[currentSource]===null){originalMappings[currentSource]=[]}originalMappings[currentSource].push(mapping)}}}sortGenerated(generatedMappings,subarrayStart);this.__generatedMappings=generatedMappings;for(var i=0;i<originalMappings.length;i++){if(originalMappings[i]!=null){quickSort(originalMappings[i],util.compareByOriginalPositionsNoSource)}}this.__originalMappings=[].concat(...originalMappings)},\"SourceMapConsumer_parseMappings\");BasicSourceMapConsumer.prototype._findMapping=__name(function SourceMapConsumer_findMapping(aNeedle,aMappings,aLineName,aColumnName,aComparator,aBias){if(aNeedle[aLineName]<=0){throw new TypeError(\"Line must be greater than or equal to 1, got \"+aNeedle[aLineName])}if(aNeedle[aColumnName]<0){throw new TypeError(\"Column must be greater than or equal to 0, got \"+aNeedle[aColumnName])}return binarySearch.search(aNeedle,aMappings,aComparator,aBias)},\"SourceMapConsumer_findMapping\");BasicSourceMapConsumer.prototype.computeColumnSpans=__name(function SourceMapConsumer_computeColumnSpans(){for(var index=0;index<this._generatedMappings.length;++index){var mapping=this._generatedMappings[index];if(index+1<this._generatedMappings.length){var nextMapping=this._generatedMappings[index+1];if(mapping.generatedLine===nextMapping.generatedLine){mapping.lastGeneratedColumn=nextMapping.generatedColumn-1;continue}}mapping.lastGeneratedColumn=Infinity}},\"SourceMapConsumer_computeColumnSpans\");BasicSourceMapConsumer.prototype.originalPositionFor=__name(function SourceMapConsumer_originalPositionFor(aArgs){var needle={generatedLine:util.getArg(aArgs,\"line\"),generatedColumn:util.getArg(aArgs,\"column\")};var index=this._findMapping(needle,this._generatedMappings,\"generatedLine\",\"generatedColumn\",util.compareByGeneratedPositionsDeflated,util.getArg(aArgs,\"bias\",SourceMapConsumer.GREATEST_LOWER_BOUND));if(index>=0){var mapping=this._generatedMappings[index];if(mapping.generatedLine===needle.generatedLine){var source=util.getArg(mapping,\"source\",null);if(source!==null){source=this._sources.at(source);source=util.computeSourceURL(this.sourceRoot,source,this._sourceMapURL)}var name=util.getArg(mapping,\"name\",null);if(name!==null){name=this._names.at(name)}return{source,line:util.getArg(mapping,\"originalLine\",null),column:util.getArg(mapping,\"originalColumn\",null),name}}}return{source:null,line:null,column:null,name:null}},\"SourceMapConsumer_originalPositionFor\");BasicSourceMapConsumer.prototype.hasContentsOfAllSources=__name(function BasicSourceMapConsumer_hasContentsOfAllSources(){if(!this.sourcesContent){return false}return this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some(function(sc){return sc==null})},\"BasicSourceMapConsumer_hasContentsOfAllSources\");BasicSourceMapConsumer.prototype.sourceContentFor=__name(function SourceMapConsumer_sourceContentFor(aSource,nullOnMissing){if(!this.sourcesContent){return null}var index=this._findSourceIndex(aSource);if(index>=0){return this.sourcesContent[index]}var relativeSource=aSource;if(this.sourceRoot!=null){relativeSource=util.relative(this.sourceRoot,relativeSource)}var url;if(this.sourceRoot!=null&&(url=util.urlParse(this.sourceRoot))){var fileUriAbsPath=relativeSource.replace(/^file:\\/\\//,\"\");if(url.scheme==\"file\"&&this._sources.has(fileUriAbsPath)){return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]}if((!url.path||url.path==\"/\")&&this._sources.has(\"/\"+relativeSource)){return this.sourcesContent[this._sources.indexOf(\"/\"+relativeSource)]}}if(nullOnMissing){return null}else{throw new Error('\"'+relativeSource+'\" is not in the SourceMap.')}},\"SourceMapConsumer_sourceContentFor\");BasicSourceMapConsumer.prototype.generatedPositionFor=__name(function SourceMapConsumer_generatedPositionFor(aArgs){var source=util.getArg(aArgs,\"source\");source=this._findSourceIndex(source);if(source<0){return{line:null,column:null,lastColumn:null}}var needle={source,originalLine:util.getArg(aArgs,\"line\"),originalColumn:util.getArg(aArgs,\"column\")};var index=this._findMapping(needle,this._originalMappings,\"originalLine\",\"originalColumn\",util.compareByOriginalPositions,util.getArg(aArgs,\"bias\",SourceMapConsumer.GREATEST_LOWER_BOUND));if(index>=0){var mapping=this._originalMappings[index];if(mapping.source===needle.source){return{line:util.getArg(mapping,\"generatedLine\",null),column:util.getArg(mapping,\"generatedColumn\",null),lastColumn:util.getArg(mapping,\"lastGeneratedColumn\",null)}}}return{line:null,column:null,lastColumn:null}},\"SourceMapConsumer_generatedPositionFor\");exports.BasicSourceMapConsumer=BasicSourceMapConsumer;function IndexedSourceMapConsumer(aSourceMap,aSourceMapURL){var sourceMap=aSourceMap;if(typeof aSourceMap===\"string\"){sourceMap=util.parseSourceMapInput(aSourceMap)}var version=util.getArg(sourceMap,\"version\");var sections=util.getArg(sourceMap,\"sections\");if(version!=this._version){throw new Error(\"Unsupported version: \"+version)}this._sources=new ArraySet;this._names=new ArraySet;var lastOffset={line:-1,column:0};this._sections=sections.map(function(s){if(s.url){throw new Error(\"Support for url field in sections not implemented.\")}var offset=util.getArg(s,\"offset\");var offsetLine=util.getArg(offset,\"line\");var offsetColumn=util.getArg(offset,\"column\");if(offsetLine<lastOffset.line||offsetLine===lastOffset.line&&offsetColumn<lastOffset.column){throw new Error(\"Section offsets must be ordered and non-overlapping.\")}lastOffset=offset;return{generatedOffset:{generatedLine:offsetLine+1,generatedColumn:offsetColumn+1},consumer:new SourceMapConsumer(util.getArg(s,\"map\"),aSourceMapURL)}})}__name(IndexedSourceMapConsumer,\"IndexedSourceMapConsumer\");IndexedSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype);IndexedSourceMapConsumer.prototype.constructor=SourceMapConsumer;IndexedSourceMapConsumer.prototype._version=3;Object.defineProperty(IndexedSourceMapConsumer.prototype,\"sources\",{get:function(){var sources=[];for(var i=0;i<this._sections.length;i++){for(var j=0;j<this._sections[i].consumer.sources.length;j++){sources.push(this._sections[i].consumer.sources[j])}}return sources}});IndexedSourceMapConsumer.prototype.originalPositionFor=__name(function IndexedSourceMapConsumer_originalPositionFor(aArgs){var needle={generatedLine:util.getArg(aArgs,\"line\"),generatedColumn:util.getArg(aArgs,\"column\")};var sectionIndex=binarySearch.search(needle,this._sections,function(needle2,section2){var cmp=needle2.generatedLine-section2.generatedOffset.generatedLine;if(cmp){return cmp}return needle2.generatedColumn-section2.generatedOffset.generatedColumn});var section=this._sections[sectionIndex];if(!section){return{source:null,line:null,column:null,name:null}}return section.consumer.originalPositionFor({line:needle.generatedLine-(section.generatedOffset.generatedLine-1),column:needle.generatedColumn-(section.generatedOffset.generatedLine===needle.generatedLine?section.generatedOffset.generatedColumn-1:0),bias:aArgs.bias})},\"IndexedSourceMapConsumer_originalPositionFor\");IndexedSourceMapConsumer.prototype.hasContentsOfAllSources=__name(function IndexedSourceMapConsumer_hasContentsOfAllSources(){return this._sections.every(function(s){return s.consumer.hasContentsOfAllSources()})},\"IndexedSourceMapConsumer_hasContentsOfAllSources\");IndexedSourceMapConsumer.prototype.sourceContentFor=__name(function IndexedSourceMapConsumer_sourceContentFor(aSource,nullOnMissing){for(var i=0;i<this._sections.length;i++){var section=this._sections[i];var content=section.consumer.sourceContentFor(aSource,true);if(content){return content}}if(nullOnMissing){return null}else{throw new Error('\"'+aSource+'\" is not in the SourceMap.')}},\"IndexedSourceMapConsumer_sourceContentFor\");IndexedSourceMapConsumer.prototype.generatedPositionFor=__name(function IndexedSourceMapConsumer_generatedPositionFor(aArgs){for(var i=0;i<this._sections.length;i++){var section=this._sections[i];if(section.consumer._findSourceIndex(util.getArg(aArgs,\"source\"))===-1){continue}var generatedPosition=section.consumer.generatedPositionFor(aArgs);if(generatedPosition){var ret={line:generatedPosition.line+(section.generatedOffset.generatedLine-1),column:generatedPosition.column+(section.generatedOffset.generatedLine===generatedPosition.line?section.generatedOffset.generatedColumn-1:0)};return ret}}return{line:null,column:null}},\"IndexedSourceMapConsumer_generatedPositionFor\");IndexedSourceMapConsumer.prototype._parseMappings=__name(function IndexedSourceMapConsumer_parseMappings(aStr,aSourceRoot){this.__generatedMappings=[];this.__originalMappings=[];for(var i=0;i<this._sections.length;i++){var section=this._sections[i];var sectionMappings=section.consumer._generatedMappings;for(var j=0;j<sectionMappings.length;j++){var mapping=sectionMappings[j];var source=section.consumer._sources.at(mapping.source);source=util.computeSourceURL(section.consumer.sourceRoot,source,this._sourceMapURL);this._sources.add(source);source=this._sources.indexOf(source);var name=null;if(mapping.name){name=section.consumer._names.at(mapping.name);this._names.add(name);name=this._names.indexOf(name)}var adjustedMapping={source,generatedLine:mapping.generatedLine+(section.generatedOffset.generatedLine-1),generatedColumn:mapping.generatedColumn+(section.generatedOffset.generatedLine===mapping.generatedLine?section.generatedOffset.generatedColumn-1:0),originalLine:mapping.originalLine,originalColumn:mapping.originalColumn,name};this.__generatedMappings.push(adjustedMapping);if(typeof adjustedMapping.originalLine===\"number\"){this.__originalMappings.push(adjustedMapping)}}}quickSort(this.__generatedMappings,util.compareByGeneratedPositionsDeflated);quickSort(this.__originalMappings,util.compareByOriginalPositions)},\"IndexedSourceMapConsumer_parseMappings\");exports.IndexedSourceMapConsumer=IndexedSourceMapConsumer;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["SourceMapConsumer_parseMappings","needle","section"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/source-map-js@1.0.2/node_modules/source-map-js/lib/source-map-consumer.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    var boundCallback = aCallback.bind(context);\n    var names = this._names;\n    var sources = this._sources;\n    var sourceMapURL = this._sourceMapURL;\n\n    for (var i = 0, n = mappings.length; i < n; i++) {\n      var mapping = mappings[i];\n      var source = mapping.source === null ? null : sources.at(mapping.source);\n      source = util.computeSourceURL(sourceRoot, source, sourceMapURL);\n      boundCallback({\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : names.at(mapping.name)\n      });\n    }\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  if (sourceRoot) {\n    sourceRoot = util.normalize(sourceRoot);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this._absoluteSources = this._sources.toArray().map(function (s) {\n    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n  });\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this._sourceMapURL = aSourceMapURL;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */\nBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n  var relativeSource = aSource;\n  if (this.sourceRoot != null) {\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\n  }\n\n  if (this._sources.has(relativeSource)) {\n    return this._sources.indexOf(relativeSource);\n  }\n\n  // Maybe aSource is an absolute URL as returned by |sources|.  In\n  // this case we can't simply undo the transform.\n  var i;\n  for (i = 0; i < this._absoluteSources.length; ++i) {\n    if (this._absoluteSources[i] == aSource) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function (s) {\n      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._absoluteSources.slice();\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\n\nconst compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;\nfunction sortGenerated(array, start) {\n  let l = array.length;\n  let n = array.length - start;\n  if (n <= 1) {\n    return;\n  } else if (n == 2) {\n    let a = array[start];\n    let b = array[start + 1];\n    if (compareGenerated(a, b) > 0) {\n      array[start] = b;\n      array[start + 1] = a;\n    }\n  } else if (n < 20) {\n    for (let i = start; i < l; i++) {\n      for (let j = i; j > start; j--) {\n        let a = array[j - 1];\n        let b = array[j];\n        if (compareGenerated(a, b) <= 0) {\n          break;\n        }\n        array[j - 1] = b;\n        array[j] = a;\n      }\n    }\n  } else {\n    quickSort(array, compareGenerated, start);\n  }\n}\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    let subarrayStart = 0;\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n\n        sortGenerated(generatedMappings, subarrayStart);\n        subarrayStart = generatedMappings.length;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = [];\n        while (index < end) {\n          base64VLQ.decode(aStr, index, temp);\n          value = temp.value;\n          index = temp.rest;\n          segment.push(value);\n        }\n\n        if (segment.length === 2) {\n          throw new Error('Found a source, but no line and column');\n        }\n\n        if (segment.length === 3) {\n          throw new Error('Found a source and line, but no column');\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          let currentSource = mapping.source;\n          while (originalMappings.length <= currentSource) {\n            originalMappings.push(null);\n          }\n          if (originalMappings[currentSource] === null) {\n            originalMappings[currentSource] = [];\n          }\n          originalMappings[currentSource].push(mapping);\n        }\n      }\n    }\n\n    sortGenerated(generatedMappings, subarrayStart);\n    this.__generatedMappings = generatedMappings;\n\n    for (var i = 0; i < originalMappings.length; i++) {\n      if (originalMappings[i] != null) {\n        quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);\n      }\n    }\n    this.__originalMappings = [].concat(...originalMappings);\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = null;\n        if (mapping.name) {\n          name = section.consumer._names.at(mapping.name);\n          this._names.add(name);\n          name = this._names.indexOf(name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n"]}}