{"code":"(()=>{\nvar __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});(function(global,factory){typeof exports===\"object\"&&typeof module!==\"undefined\"?factory(exports,require(\"@jridgewell/sourcemap-codec\"),require(\"@jridgewell/resolve-uri\")):typeof define===\"function\"&&define.amd?define([\"exports\",\"@jridgewell/sourcemap-codec\",\"@jridgewell/resolve-uri\"],factory):(global=typeof globalThis!==\"undefined\"?globalThis:global||self,factory(global.traceMapping={},global.sourcemapCodec,global.resolveURI))})(exports,function(exports2,sourcemapCodec,resolveUri){\"use strict\";function _interopDefaultLegacy(e){return e&&typeof e===\"object\"&&\"default\"in e?e:{\"default\":e}}__name(_interopDefaultLegacy,\"_interopDefaultLegacy\");var resolveUri__default=_interopDefaultLegacy(resolveUri);function resolve(input,base){if(base&&!base.endsWith(\"/\"))base+=\"/\";return resolveUri__default[\"default\"](input,base)}__name(resolve,\"resolve\");function stripFilename(path){if(!path)return\"\";const index=path.lastIndexOf(\"/\");return path.slice(0,index+1)}__name(stripFilename,\"stripFilename\");const COLUMN=0;const SOURCES_INDEX=1;const SOURCE_LINE=2;const SOURCE_COLUMN=3;const NAMES_INDEX=4;const REV_GENERATED_LINE=1;const REV_GENERATED_COLUMN=2;function maybeSort(mappings,owned){const unsortedIndex=nextUnsortedSegmentLine(mappings,0);if(unsortedIndex===mappings.length)return mappings;if(!owned)mappings=mappings.slice();for(let i=unsortedIndex;i<mappings.length;i=nextUnsortedSegmentLine(mappings,i+1)){mappings[i]=sortSegments(mappings[i],owned)}return mappings}__name(maybeSort,\"maybeSort\");function nextUnsortedSegmentLine(mappings,start){for(let i=start;i<mappings.length;i++){if(!isSorted(mappings[i]))return i}return mappings.length}__name(nextUnsortedSegmentLine,\"nextUnsortedSegmentLine\");function isSorted(line){for(let j=1;j<line.length;j++){if(line[j][COLUMN]<line[j-1][COLUMN]){return false}}return true}__name(isSorted,\"isSorted\");function sortSegments(line,owned){if(!owned)line=line.slice();return line.sort(sortComparator)}__name(sortSegments,\"sortSegments\");function sortComparator(a,b){return a[COLUMN]-b[COLUMN]}__name(sortComparator,\"sortComparator\");let found=false;function binarySearch(haystack,needle,low,high){while(low<=high){const mid=low+(high-low>>1);const cmp=haystack[mid][COLUMN]-needle;if(cmp===0){found=true;return mid}if(cmp<0){low=mid+1}else{high=mid-1}}found=false;return low-1}__name(binarySearch,\"binarySearch\");function upperBound(haystack,needle,index){for(let i=index+1;i<haystack.length;index=i++){if(haystack[i][COLUMN]!==needle)break}return index}__name(upperBound,\"upperBound\");function lowerBound(haystack,needle,index){for(let i=index-1;i>=0;index=i--){if(haystack[i][COLUMN]!==needle)break}return index}__name(lowerBound,\"lowerBound\");function memoizedState(){return{lastKey:-1,lastNeedle:-1,lastIndex:-1}}__name(memoizedState,\"memoizedState\");function memoizedBinarySearch(haystack,needle,state,key){const{lastKey,lastNeedle,lastIndex}=state;let low=0;let high=haystack.length-1;if(key===lastKey){if(needle===lastNeedle){found=lastIndex!==-1&&haystack[lastIndex][COLUMN]===needle;return lastIndex}if(needle>=lastNeedle){low=lastIndex===-1?0:lastIndex}else{high=lastIndex}}state.lastKey=key;state.lastNeedle=needle;return state.lastIndex=binarySearch(haystack,needle,low,high)}__name(memoizedBinarySearch,\"memoizedBinarySearch\");function buildBySources(decoded,memos){const sources=memos.map(buildNullArray);for(let i=0;i<decoded.length;i++){const line=decoded[i];for(let j=0;j<line.length;j++){const seg=line[j];if(seg.length===1)continue;const sourceIndex=seg[SOURCES_INDEX];const sourceLine=seg[SOURCE_LINE];const sourceColumn=seg[SOURCE_COLUMN];const originalSource=sources[sourceIndex];const originalLine=originalSource[sourceLine]||(originalSource[sourceLine]=[]);const memo=memos[sourceIndex];const index=upperBound(originalLine,sourceColumn,memoizedBinarySearch(originalLine,sourceColumn,memo,sourceLine));insert(originalLine,memo.lastIndex=index+1,[sourceColumn,i,seg[COLUMN]])}}return sources}__name(buildBySources,\"buildBySources\");function insert(array,index,value){for(let i=array.length;i>index;i--){array[i]=array[i-1]}array[index]=value}__name(insert,\"insert\");function buildNullArray(){return{__proto__:null}}__name(buildNullArray,\"buildNullArray\");const AnyMap=__name(function(map,mapUrl){const parsed=typeof map===\"string\"?JSON.parse(map):map;if(!(\"sections\"in parsed))return new TraceMap(parsed,mapUrl);const mappings=[];const sources=[];const sourcesContent=[];const names=[];recurse(parsed,mapUrl,mappings,sources,sourcesContent,names,0,0,Infinity,Infinity);const joined={version:3,file:parsed.file,names,sources,sourcesContent,mappings};return exports2.presortedDecodedMap(joined)},\"AnyMap\");function recurse(input,mapUrl,mappings,sources,sourcesContent,names,lineOffset,columnOffset,stopLine,stopColumn){const{sections}=input;for(let i=0;i<sections.length;i++){const{map,offset}=sections[i];let sl=stopLine;let sc=stopColumn;if(i+1<sections.length){const nextOffset=sections[i+1].offset;sl=Math.min(stopLine,lineOffset+nextOffset.line);if(sl===stopLine){sc=Math.min(stopColumn,columnOffset+nextOffset.column)}else if(sl<stopLine){sc=columnOffset+nextOffset.column}}addSection(map,mapUrl,mappings,sources,sourcesContent,names,lineOffset+offset.line,columnOffset+offset.column,sl,sc)}}__name(recurse,\"recurse\");function addSection(input,mapUrl,mappings,sources,sourcesContent,names,lineOffset,columnOffset,stopLine,stopColumn){if(\"sections\"in input)return recurse(...arguments);const map=new TraceMap(input,mapUrl);const sourcesOffset=sources.length;const namesOffset=names.length;const decoded=exports2.decodedMappings(map);const{resolvedSources,sourcesContent:contents}=map;append(sources,resolvedSources);append(names,map.names);if(contents)append(sourcesContent,contents);else for(let i=0;i<resolvedSources.length;i++)sourcesContent.push(null);for(let i=0;i<decoded.length;i++){const lineI=lineOffset+i;if(lineI>stopLine)return;const out=getLine(mappings,lineI);const cOffset=i===0?columnOffset:0;const line=decoded[i];for(let j=0;j<line.length;j++){const seg=line[j];const column=cOffset+seg[COLUMN];if(lineI===stopLine&&column>=stopColumn)return;if(seg.length===1){out.push([column]);continue}const sourcesIndex=sourcesOffset+seg[SOURCES_INDEX];const sourceLine=seg[SOURCE_LINE];const sourceColumn=seg[SOURCE_COLUMN];out.push(seg.length===4?[column,sourcesIndex,sourceLine,sourceColumn]:[column,sourcesIndex,sourceLine,sourceColumn,namesOffset+seg[NAMES_INDEX]])}}}__name(addSection,\"addSection\");function append(arr,other){for(let i=0;i<other.length;i++)arr.push(other[i])}__name(append,\"append\");function getLine(arr,index){for(let i=arr.length;i<=index;i++)arr[i]=[];return arr[index]}__name(getLine,\"getLine\");const LINE_GTR_ZERO=\"`line` must be greater than 0 (lines start at line 1)\";const COL_GTR_EQ_ZERO=\"`column` must be greater than or equal to 0 (columns start at column 0)\";const LEAST_UPPER_BOUND=-1;const GREATEST_LOWER_BOUND=1;exports2.encodedMappings=void 0;exports2.decodedMappings=void 0;exports2.traceSegment=void 0;exports2.originalPositionFor=void 0;exports2.generatedPositionFor=void 0;exports2.allGeneratedPositionsFor=void 0;exports2.eachMapping=void 0;exports2.sourceContentFor=void 0;exports2.presortedDecodedMap=void 0;exports2.decodedMap=void 0;exports2.encodedMap=void 0;class TraceMap{constructor(map,mapUrl){const isString=typeof map===\"string\";if(!isString&&map._decodedMemo)return map;const parsed=isString?JSON.parse(map):map;const{version,file,names,sourceRoot,sources,sourcesContent}=parsed;this.version=version;this.file=file;this.names=names;this.sourceRoot=sourceRoot;this.sources=sources;this.sourcesContent=sourcesContent;const from=resolve(sourceRoot||\"\",stripFilename(mapUrl));this.resolvedSources=sources.map(s=>resolve(s||\"\",from));const{mappings}=parsed;if(typeof mappings===\"string\"){this._encoded=mappings;this._decoded=void 0}else{this._encoded=void 0;this._decoded=maybeSort(mappings,isString)}this._decodedMemo=memoizedState();this._bySources=void 0;this._bySourceMemos=void 0}}__name(TraceMap,\"TraceMap\");(()=>{exports2.encodedMappings=map=>{var _a;return(_a=map._encoded)!==null&&_a!==void 0?_a:map._encoded=sourcemapCodec.encode(map._decoded)};exports2.decodedMappings=map=>{return map._decoded||(map._decoded=sourcemapCodec.decode(map._encoded))};exports2.traceSegment=(map,line,column)=>{const decoded=exports2.decodedMappings(map);if(line>=decoded.length)return null;const segments=decoded[line];const index=traceSegmentInternal(segments,map._decodedMemo,line,column,GREATEST_LOWER_BOUND);return index===-1?null:segments[index]};exports2.originalPositionFor=(map,{line,column,bias})=>{line--;if(line<0)throw new Error(LINE_GTR_ZERO);if(column<0)throw new Error(COL_GTR_EQ_ZERO);const decoded=exports2.decodedMappings(map);if(line>=decoded.length)return OMapping(null,null,null,null);const segments=decoded[line];const index=traceSegmentInternal(segments,map._decodedMemo,line,column,bias||GREATEST_LOWER_BOUND);if(index===-1)return OMapping(null,null,null,null);const segment=segments[index];if(segment.length===1)return OMapping(null,null,null,null);const{names,resolvedSources}=map;return OMapping(resolvedSources[segment[SOURCES_INDEX]],segment[SOURCE_LINE]+1,segment[SOURCE_COLUMN],segment.length===5?names[segment[NAMES_INDEX]]:null)};exports2.allGeneratedPositionsFor=(map,{source,line,column,bias})=>{return generatedPosition(map,source,line,column,bias||LEAST_UPPER_BOUND,true)};exports2.generatedPositionFor=(map,{source,line,column,bias})=>{return generatedPosition(map,source,line,column,bias||GREATEST_LOWER_BOUND,false)};exports2.eachMapping=(map,cb)=>{const decoded=exports2.decodedMappings(map);const{names,resolvedSources}=map;for(let i=0;i<decoded.length;i++){const line=decoded[i];for(let j=0;j<line.length;j++){const seg=line[j];const generatedLine=i+1;const generatedColumn=seg[0];let source=null;let originalLine=null;let originalColumn=null;let name=null;if(seg.length!==1){source=resolvedSources[seg[1]];originalLine=seg[2]+1;originalColumn=seg[3]}if(seg.length===5)name=names[seg[4]];cb({generatedLine,generatedColumn,source,originalLine,originalColumn,name})}}};exports2.sourceContentFor=(map,source)=>{const{sources,resolvedSources,sourcesContent}=map;if(sourcesContent==null)return null;let index=sources.indexOf(source);if(index===-1)index=resolvedSources.indexOf(source);return index===-1?null:sourcesContent[index]};exports2.presortedDecodedMap=(map,mapUrl)=>{const tracer=new TraceMap(clone(map,[]),mapUrl);tracer._decoded=map.mappings;return tracer};exports2.decodedMap=map=>{return clone(map,exports2.decodedMappings(map))};exports2.encodedMap=map=>{return clone(map,exports2.encodedMappings(map))};function generatedPosition(map,source,line,column,bias,all){line--;if(line<0)throw new Error(LINE_GTR_ZERO);if(column<0)throw new Error(COL_GTR_EQ_ZERO);const{sources,resolvedSources}=map;let sourceIndex=sources.indexOf(source);if(sourceIndex===-1)sourceIndex=resolvedSources.indexOf(source);if(sourceIndex===-1)return all?[]:GMapping(null,null);const generated=map._bySources||(map._bySources=buildBySources(exports2.decodedMappings(map),map._bySourceMemos=sources.map(memoizedState)));const segments=generated[sourceIndex][line];if(segments==null)return all?[]:GMapping(null,null);const memo=map._bySourceMemos[sourceIndex];if(all)return sliceGeneratedPositions(segments,memo,line,column,bias);const index=traceSegmentInternal(segments,memo,line,column,bias);if(index===-1)return GMapping(null,null);const segment=segments[index];return GMapping(segment[REV_GENERATED_LINE]+1,segment[REV_GENERATED_COLUMN])}__name(generatedPosition,\"generatedPosition\")})();function clone(map,mappings){return{version:map.version,file:map.file,names:map.names,sourceRoot:map.sourceRoot,sources:map.sources,sourcesContent:map.sourcesContent,mappings}}__name(clone,\"clone\");function OMapping(source,line,column,name){return{source,line,column,name}}__name(OMapping,\"OMapping\");function GMapping(line,column){return{line,column}}__name(GMapping,\"GMapping\");function traceSegmentInternal(segments,memo,line,column,bias){let index=memoizedBinarySearch(segments,column,memo,line);if(found){index=(bias===LEAST_UPPER_BOUND?upperBound:lowerBound)(segments,column,index)}else if(bias===LEAST_UPPER_BOUND)index++;if(index===-1||index===segments.length)return-1;return index}__name(traceSegmentInternal,\"traceSegmentInternal\");function sliceGeneratedPositions(segments,memo,line,column,bias){let min=traceSegmentInternal(segments,memo,line,column,GREATEST_LOWER_BOUND);if(!found&&bias===LEAST_UPPER_BOUND)min++;if(min===-1||min===segments.length)return[];const matchedColumn=found?column:segments[min][COLUMN];if(!found)min=lowerBound(segments,matchedColumn,min);const max=upperBound(segments,matchedColumn,min);const result=[];for(;min<=max;min++){const segment=segments[min];result.push(GMapping(segment[REV_GENERATED_LINE]+1,segment[REV_GENERATED_COLUMN]))}return result}__name(sliceGeneratedPositions,\"sliceGeneratedPositions\");exports2.AnyMap=AnyMap;exports2.GREATEST_LOWER_BOUND=GREATEST_LOWER_BOUND;exports2.LEAST_UPPER_BOUND=LEAST_UPPER_BOUND;exports2.TraceMap=TraceMap;Object.defineProperty(exports2,\"__esModule\",{value:true})});\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["exports"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/@jridgewell+trace-mapping@0.3.18/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/sourcemap-codec'), require('@jridgewell/resolve-uri')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/sourcemap-codec', '@jridgewell/resolve-uri'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.traceMapping = {}, global.sourcemapCodec, global.resolveURI));\n})(this, (function (exports, sourcemapCodec, resolveUri) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var resolveUri__default = /*#__PURE__*/_interopDefaultLegacy(resolveUri);\n\n    function resolve(input, base) {\n        // The base is always treated as a directory, if it's not empty.\n        // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n        // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n        if (base && !base.endsWith('/'))\n            base += '/';\n        return resolveUri__default[\"default\"](input, base);\n    }\n\n    /**\n     * Removes everything after the last \"/\", but leaves the slash.\n     */\n    function stripFilename(path) {\n        if (!path)\n            return '';\n        const index = path.lastIndexOf('/');\n        return path.slice(0, index + 1);\n    }\n\n    const COLUMN = 0;\n    const SOURCES_INDEX = 1;\n    const SOURCE_LINE = 2;\n    const SOURCE_COLUMN = 3;\n    const NAMES_INDEX = 4;\n    const REV_GENERATED_LINE = 1;\n    const REV_GENERATED_COLUMN = 2;\n\n    function maybeSort(mappings, owned) {\n        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n        if (unsortedIndex === mappings.length)\n            return mappings;\n        // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n        // not, we do not want to modify the consumer's input array.\n        if (!owned)\n            mappings = mappings.slice();\n        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n            mappings[i] = sortSegments(mappings[i], owned);\n        }\n        return mappings;\n    }\n    function nextUnsortedSegmentLine(mappings, start) {\n        for (let i = start; i < mappings.length; i++) {\n            if (!isSorted(mappings[i]))\n                return i;\n        }\n        return mappings.length;\n    }\n    function isSorted(line) {\n        for (let j = 1; j < line.length; j++) {\n            if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function sortSegments(line, owned) {\n        if (!owned)\n            line = line.slice();\n        return line.sort(sortComparator);\n    }\n    function sortComparator(a, b) {\n        return a[COLUMN] - b[COLUMN];\n    }\n\n    let found = false;\n    /**\n     * A binary search implementation that returns the index if a match is found.\n     * If no match is found, then the left-index (the index associated with the item that comes just\n     * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n     * the next index:\n     *\n     * ```js\n     * const array = [1, 3];\n     * const needle = 2;\n     * const index = binarySearch(array, needle, (item, needle) => item - needle);\n     *\n     * assert.equal(index, 0);\n     * array.splice(index + 1, 0, needle);\n     * assert.deepEqual(array, [1, 2, 3]);\n     * ```\n     */\n    function binarySearch(haystack, needle, low, high) {\n        while (low <= high) {\n            const mid = low + ((high - low) >> 1);\n            const cmp = haystack[mid][COLUMN] - needle;\n            if (cmp === 0) {\n                found = true;\n                return mid;\n            }\n            if (cmp < 0) {\n                low = mid + 1;\n            }\n            else {\n                high = mid - 1;\n            }\n        }\n        found = false;\n        return low - 1;\n    }\n    function upperBound(haystack, needle, index) {\n        for (let i = index + 1; i < haystack.length; index = i++) {\n            if (haystack[i][COLUMN] !== needle)\n                break;\n        }\n        return index;\n    }\n    function lowerBound(haystack, needle, index) {\n        for (let i = index - 1; i >= 0; index = i--) {\n            if (haystack[i][COLUMN] !== needle)\n                break;\n        }\n        return index;\n    }\n    function memoizedState() {\n        return {\n            lastKey: -1,\n            lastNeedle: -1,\n            lastIndex: -1,\n        };\n    }\n    /**\n     * This overly complicated beast is just to record the last tested line/column and the resulting\n     * index, allowing us to skip a few tests if mappings are monotonically increasing.\n     */\n    function memoizedBinarySearch(haystack, needle, state, key) {\n        const { lastKey, lastNeedle, lastIndex } = state;\n        let low = 0;\n        let high = haystack.length - 1;\n        if (key === lastKey) {\n            if (needle === lastNeedle) {\n                found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n                return lastIndex;\n            }\n            if (needle >= lastNeedle) {\n                // lastIndex may be -1 if the previous needle was not found.\n                low = lastIndex === -1 ? 0 : lastIndex;\n            }\n            else {\n                high = lastIndex;\n            }\n        }\n        state.lastKey = key;\n        state.lastNeedle = needle;\n        return (state.lastIndex = binarySearch(haystack, needle, low, high));\n    }\n\n    // Rebuilds the original source files, with mappings that are ordered by source line/column instead\n    // of generated line/column.\n    function buildBySources(decoded, memos) {\n        const sources = memos.map(buildNullArray);\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                if (seg.length === 1)\n                    continue;\n                const sourceIndex = seg[SOURCES_INDEX];\n                const sourceLine = seg[SOURCE_LINE];\n                const sourceColumn = seg[SOURCE_COLUMN];\n                const originalSource = sources[sourceIndex];\n                const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));\n                const memo = memos[sourceIndex];\n                // The binary search either found a match, or it found the left-index just before where the\n                // segment should go. Either way, we want to insert after that. And there may be multiple\n                // generated segments associated with an original location, so there may need to move several\n                // indexes before we find where we need to insert.\n                const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n                insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);\n            }\n        }\n        return sources;\n    }\n    function insert(array, index, value) {\n        for (let i = array.length; i > index; i--) {\n            array[i] = array[i - 1];\n        }\n        array[index] = value;\n    }\n    // Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n    // a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n    // Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n    // the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n    // order when iterating with for-in.\n    function buildNullArray() {\n        return { __proto__: null };\n    }\n\n    const AnyMap = function (map, mapUrl) {\n        const parsed = typeof map === 'string' ? JSON.parse(map) : map;\n        if (!('sections' in parsed))\n            return new TraceMap(parsed, mapUrl);\n        const mappings = [];\n        const sources = [];\n        const sourcesContent = [];\n        const names = [];\n        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\n        const joined = {\n            version: 3,\n            file: parsed.file,\n            names,\n            sources,\n            sourcesContent,\n            mappings,\n        };\n        return exports.presortedDecodedMap(joined);\n    };\n    function recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n        const { sections } = input;\n        for (let i = 0; i < sections.length; i++) {\n            const { map, offset } = sections[i];\n            let sl = stopLine;\n            let sc = stopColumn;\n            if (i + 1 < sections.length) {\n                const nextOffset = sections[i + 1].offset;\n                sl = Math.min(stopLine, lineOffset + nextOffset.line);\n                if (sl === stopLine) {\n                    sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n                }\n                else if (sl < stopLine) {\n                    sc = columnOffset + nextOffset.column;\n                }\n            }\n            addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n        }\n    }\n    function addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n        if ('sections' in input)\n            return recurse(...arguments);\n        const map = new TraceMap(input, mapUrl);\n        const sourcesOffset = sources.length;\n        const namesOffset = names.length;\n        const decoded = exports.decodedMappings(map);\n        const { resolvedSources, sourcesContent: contents } = map;\n        append(sources, resolvedSources);\n        append(names, map.names);\n        if (contents)\n            append(sourcesContent, contents);\n        else\n            for (let i = 0; i < resolvedSources.length; i++)\n                sourcesContent.push(null);\n        for (let i = 0; i < decoded.length; i++) {\n            const lineI = lineOffset + i;\n            // We can only add so many lines before we step into the range that the next section's map\n            // controls. When we get to the last line, then we'll start checking the segments to see if\n            // they've crossed into the column range. But it may not have any columns that overstep, so we\n            // still need to check that we don't overstep lines, too.\n            if (lineI > stopLine)\n                return;\n            // The out line may already exist in mappings (if we're continuing the line started by a\n            // previous section). Or, we may have jumped ahead several lines to start this section.\n            const out = getLine(mappings, lineI);\n            // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n            // map can be multiple lines), it doesn't.\n            const cOffset = i === 0 ? columnOffset : 0;\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const column = cOffset + seg[COLUMN];\n                // If this segment steps into the column range that the next section's map controls, we need\n                // to stop early.\n                if (lineI === stopLine && column >= stopColumn)\n                    return;\n                if (seg.length === 1) {\n                    out.push([column]);\n                    continue;\n                }\n                const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n                const sourceLine = seg[SOURCE_LINE];\n                const sourceColumn = seg[SOURCE_COLUMN];\n                out.push(seg.length === 4\n                    ? [column, sourcesIndex, sourceLine, sourceColumn]\n                    : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n            }\n        }\n    }\n    function append(arr, other) {\n        for (let i = 0; i < other.length; i++)\n            arr.push(other[i]);\n    }\n    function getLine(arr, index) {\n        for (let i = arr.length; i <= index; i++)\n            arr[i] = [];\n        return arr[index];\n    }\n\n    const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\n    const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n    const LEAST_UPPER_BOUND = -1;\n    const GREATEST_LOWER_BOUND = 1;\n    /**\n     * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n     */\n    exports.encodedMappings = void 0;\n    /**\n     * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n     */\n    exports.decodedMappings = void 0;\n    /**\n     * A low-level API to find the segment associated with a generated line/column (think, from a\n     * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n     */\n    exports.traceSegment = void 0;\n    /**\n     * A higher-level API to find the source/line/column associated with a generated line/column\n     * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n     * `source-map` library.\n     */\n    exports.originalPositionFor = void 0;\n    /**\n     * Finds the generated line/column position of the provided source/line/column source position.\n     */\n    exports.generatedPositionFor = void 0;\n    /**\n     * Finds all generated line/column positions of the provided source/line/column source position.\n     */\n    exports.allGeneratedPositionsFor = void 0;\n    /**\n     * Iterates each mapping in generated position order.\n     */\n    exports.eachMapping = void 0;\n    /**\n     * Retrieves the source content for a particular source, if its found. Returns null if not.\n     */\n    exports.sourceContentFor = void 0;\n    /**\n     * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n     * maps.\n     */\n    exports.presortedDecodedMap = void 0;\n    /**\n     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    exports.decodedMap = void 0;\n    /**\n     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    exports.encodedMap = void 0;\n    class TraceMap {\n        constructor(map, mapUrl) {\n            const isString = typeof map === 'string';\n            if (!isString && map._decodedMemo)\n                return map;\n            const parsed = (isString ? JSON.parse(map) : map);\n            const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n            this.version = version;\n            this.file = file;\n            this.names = names;\n            this.sourceRoot = sourceRoot;\n            this.sources = sources;\n            this.sourcesContent = sourcesContent;\n            const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n            this.resolvedSources = sources.map((s) => resolve(s || '', from));\n            const { mappings } = parsed;\n            if (typeof mappings === 'string') {\n                this._encoded = mappings;\n                this._decoded = undefined;\n            }\n            else {\n                this._encoded = undefined;\n                this._decoded = maybeSort(mappings, isString);\n            }\n            this._decodedMemo = memoizedState();\n            this._bySources = undefined;\n            this._bySourceMemos = undefined;\n        }\n    }\n    (() => {\n        exports.encodedMappings = (map) => {\n            var _a;\n            return ((_a = map._encoded) !== null && _a !== void 0 ? _a : (map._encoded = sourcemapCodec.encode(map._decoded)));\n        };\n        exports.decodedMappings = (map) => {\n            return (map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded)));\n        };\n        exports.traceSegment = (map, line, column) => {\n            const decoded = exports.decodedMappings(map);\n            // It's common for parent source maps to have pointers to lines that have no\n            // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n            if (line >= decoded.length)\n                return null;\n            const segments = decoded[line];\n            const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n            return index === -1 ? null : segments[index];\n        };\n        exports.originalPositionFor = (map, { line, column, bias }) => {\n            line--;\n            if (line < 0)\n                throw new Error(LINE_GTR_ZERO);\n            if (column < 0)\n                throw new Error(COL_GTR_EQ_ZERO);\n            const decoded = exports.decodedMappings(map);\n            // It's common for parent source maps to have pointers to lines that have no\n            // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n            if (line >= decoded.length)\n                return OMapping(null, null, null, null);\n            const segments = decoded[line];\n            const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n            if (index === -1)\n                return OMapping(null, null, null, null);\n            const segment = segments[index];\n            if (segment.length === 1)\n                return OMapping(null, null, null, null);\n            const { names, resolvedSources } = map;\n            return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n        };\n        exports.allGeneratedPositionsFor = (map, { source, line, column, bias }) => {\n            // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n            return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n        };\n        exports.generatedPositionFor = (map, { source, line, column, bias }) => {\n            return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n        };\n        exports.eachMapping = (map, cb) => {\n            const decoded = exports.decodedMappings(map);\n            const { names, resolvedSources } = map;\n            for (let i = 0; i < decoded.length; i++) {\n                const line = decoded[i];\n                for (let j = 0; j < line.length; j++) {\n                    const seg = line[j];\n                    const generatedLine = i + 1;\n                    const generatedColumn = seg[0];\n                    let source = null;\n                    let originalLine = null;\n                    let originalColumn = null;\n                    let name = null;\n                    if (seg.length !== 1) {\n                        source = resolvedSources[seg[1]];\n                        originalLine = seg[2] + 1;\n                        originalColumn = seg[3];\n                    }\n                    if (seg.length === 5)\n                        name = names[seg[4]];\n                    cb({\n                        generatedLine,\n                        generatedColumn,\n                        source,\n                        originalLine,\n                        originalColumn,\n                        name,\n                    });\n                }\n            }\n        };\n        exports.sourceContentFor = (map, source) => {\n            const { sources, resolvedSources, sourcesContent } = map;\n            if (sourcesContent == null)\n                return null;\n            let index = sources.indexOf(source);\n            if (index === -1)\n                index = resolvedSources.indexOf(source);\n            return index === -1 ? null : sourcesContent[index];\n        };\n        exports.presortedDecodedMap = (map, mapUrl) => {\n            const tracer = new TraceMap(clone(map, []), mapUrl);\n            tracer._decoded = map.mappings;\n            return tracer;\n        };\n        exports.decodedMap = (map) => {\n            return clone(map, exports.decodedMappings(map));\n        };\n        exports.encodedMap = (map) => {\n            return clone(map, exports.encodedMappings(map));\n        };\n        function generatedPosition(map, source, line, column, bias, all) {\n            line--;\n            if (line < 0)\n                throw new Error(LINE_GTR_ZERO);\n            if (column < 0)\n                throw new Error(COL_GTR_EQ_ZERO);\n            const { sources, resolvedSources } = map;\n            let sourceIndex = sources.indexOf(source);\n            if (sourceIndex === -1)\n                sourceIndex = resolvedSources.indexOf(source);\n            if (sourceIndex === -1)\n                return all ? [] : GMapping(null, null);\n            const generated = (map._bySources || (map._bySources = buildBySources(exports.decodedMappings(map), (map._bySourceMemos = sources.map(memoizedState)))));\n            const segments = generated[sourceIndex][line];\n            if (segments == null)\n                return all ? [] : GMapping(null, null);\n            const memo = map._bySourceMemos[sourceIndex];\n            if (all)\n                return sliceGeneratedPositions(segments, memo, line, column, bias);\n            const index = traceSegmentInternal(segments, memo, line, column, bias);\n            if (index === -1)\n                return GMapping(null, null);\n            const segment = segments[index];\n            return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n        }\n    })();\n    function clone(map, mappings) {\n        return {\n            version: map.version,\n            file: map.file,\n            names: map.names,\n            sourceRoot: map.sourceRoot,\n            sources: map.sources,\n            sourcesContent: map.sourcesContent,\n            mappings,\n        };\n    }\n    function OMapping(source, line, column, name) {\n        return { source, line, column, name };\n    }\n    function GMapping(line, column) {\n        return { line, column };\n    }\n    function traceSegmentInternal(segments, memo, line, column, bias) {\n        let index = memoizedBinarySearch(segments, column, memo, line);\n        if (found) {\n            index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n        }\n        else if (bias === LEAST_UPPER_BOUND)\n            index++;\n        if (index === -1 || index === segments.length)\n            return -1;\n        return index;\n    }\n    function sliceGeneratedPositions(segments, memo, line, column, bias) {\n        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n        // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n        // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n        // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n        // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n        // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n        // match LEAST_UPPER_BOUND.\n        if (!found && bias === LEAST_UPPER_BOUND)\n            min++;\n        if (min === -1 || min === segments.length)\n            return [];\n        // We may have found the segment that started at an earlier column. If this is the case, then we\n        // need to slice all generated segments that match _that_ column, because all such segments span\n        // to our desired column.\n        const matchedColumn = found ? column : segments[min][COLUMN];\n        // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n        if (!found)\n            min = lowerBound(segments, matchedColumn, min);\n        const max = upperBound(segments, matchedColumn, min);\n        const result = [];\n        for (; min <= max; min++) {\n            const segment = segments[min];\n            result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n        }\n        return result;\n    }\n\n    exports.AnyMap = AnyMap;\n    exports.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;\n    exports.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;\n    exports.TraceMap = TraceMap;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=trace-mapping.umd.js.map\n"]}}