{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});Object.defineProperty(exports,\"remapBitfield\",{enumerable:true,get:function(){return remapBitfield}});function remapBitfield(num,mapping){let oldMask=0n;let newMask=0n;for(let[oldBit,newBit]of mapping){if(num&oldBit){oldMask=oldMask|oldBit;newMask=newMask|newBit}}return num&~oldMask|newMask}__name(remapBitfield,\"remapBitfield\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAkEA,OAAO,eAAe,QAAS,aAAc,CACzC,MAAO,IACX,CAAC,EACD,OAAO,eAAe,QAAS,gBAAiB,CAC5C,WAAY,KACZ,IAAK,UAAW,CACZ,OAAO,aACX,CACJ,CAAC,EACD,SAAS,cAAc,IAAK,QAAS,CAEjC,IAAI,QAAU,GACd,IAAI,QAAU,GACd,OAAS,CAAC,OAAQ,MAAM,IAAK,QAAQ,CACjC,GAAI,IAAM,OAAQ,CACd,QAAU,QAAU,OACpB,QAAU,QAAU,MACxB,CACJ,CAGA,OAAO,IAAM,CAAC,QAAU,OAC5B,CAbS","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/lib/remap-bitfield.js"],"sourcesContent":["// @ts-check\n/**\n * We must remap all the old bits to new bits for each set variant\n * Only arbitrary variants are considered as those are the only\n * ones that need to be re-sorted at this time\n *\n * An iterated process that removes and sets individual bits simultaneously\n * will not work because we may have a new bit that is also a later old bit\n * This means that we would be removing a previously set bit which we don't\n * want to do\n *\n * For example (assume `bN` = `1<<N`)\n * Given the \"total\" mapping `[[b1, b3], [b2, b4], [b3, b1], [b4, b2]]`\n * The mapping is \"total\" because:\n * 1. Every input and output is accounted for\n * 2. All combinations are unique\n * 3. No one input maps to multiple outputs and vice versa\n * And, given an offset with all bits set:\n * V = b1 | b2 | b3 | b4\n *\n * Let's explore the issue with removing and setting bits simultaneously:\n * V & ~b1 | b3 = b2 | b3 | b4\n * V & ~b2 | b4 = b3 | b4\n * V & ~b3 | b1 = b1 | b4\n * V & ~b4 | b2 = b1 | b2\n *\n * As you can see, we end up with the wrong result.\n * This is because we're removing a bit that was previously set.\n * And, thus the final result is missing b3 and b4.\n *\n * Now, let's explore the issue with removing the bits first:\n * V & ~b1 = b2 | b3 | b4\n * V & ~b2 = b3 | b4\n * V & ~b3 = b4\n * V & ~b4 = 0\n *\n * And then setting the bits:\n * V | b3 = b3\n * V | b4 = b3 | b4\n * V | b1 = b1 | b3 | b4\n * V | b2 = b1 | b2 | b3 | b4\n *\n * We get the correct result because we're not removing any bits that were\n * previously set thus properly remapping the bits to the new order\n *\n * To collect this into a single operation that can be done simultaneously\n * we must first create a mask for the old bits that are set and a mask for\n * the new bits that are set. Then we can remove the old bits and set the new\n * bits simultaneously in a \"single\" operation like so:\n * OldMask = b1 | b2 | b3 | b4\n * NewMask = b3 | b4 | b1 | b2\n *\n * So this:\n * V & ~oldMask | newMask\n *\n * Expands to this:\n * V & ~b1 & ~b2 & ~b3 & ~b4 | b3 | b4 | b1 | b2\n *\n * Which becomes this:\n * b1 | b2 | b3 | b4\n *\n * Which is the correct result!\n *\n * @param {bigint} num\n * @param {[bigint, bigint][]} mapping\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"remapBitfield\", {\n    enumerable: true,\n    get: function() {\n        return remapBitfield;\n    }\n});\nfunction remapBitfield(num, mapping) {\n    // Create masks for the old and new bits that are set\n    let oldMask = 0n;\n    let newMask = 0n;\n    for (let [oldBit, newBit] of mapping){\n        if (num & oldBit) {\n            oldMask = oldMask | oldBit;\n            newMask = newMask | newBit;\n        }\n    }\n    // Remove all old bits\n    // Set all new bits\n    return num & ~oldMask | newMask;\n}\n"]}}