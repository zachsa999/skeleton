{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _index=require(\"../tokenizer/index\");var _types=require(\"../tokenizer/types\");var _charcodes=require(\"../util/charcodes\");var _base=require(\"./base\");function isContextual(contextualKeyword){return _base.state.contextualKeyword===contextualKeyword}__name(isContextual,\"isContextual\");exports.isContextual=isContextual;function isLookaheadContextual(contextualKeyword){const l=_index.lookaheadTypeAndKeyword.call(void 0);return l.type===_types.TokenType.name&&l.contextualKeyword===contextualKeyword}__name(isLookaheadContextual,\"isLookaheadContextual\");exports.isLookaheadContextual=isLookaheadContextual;function eatContextual(contextualKeyword){return _base.state.contextualKeyword===contextualKeyword&&_index.eat.call(void 0,_types.TokenType.name)}__name(eatContextual,\"eatContextual\");exports.eatContextual=eatContextual;function expectContextual(contextualKeyword){if(!eatContextual(contextualKeyword)){unexpected()}}__name(expectContextual,\"expectContextual\");exports.expectContextual=expectContextual;function canInsertSemicolon(){return _index.match.call(void 0,_types.TokenType.eof)||_index.match.call(void 0,_types.TokenType.braceR)||hasPrecedingLineBreak()}__name(canInsertSemicolon,\"canInsertSemicolon\");exports.canInsertSemicolon=canInsertSemicolon;function hasPrecedingLineBreak(){const prevToken=_base.state.tokens[_base.state.tokens.length-1];const lastTokEnd=prevToken?prevToken.end:0;for(let i=lastTokEnd;i<_base.state.start;i++){const code=_base.input.charCodeAt(i);if(code===_charcodes.charCodes.lineFeed||code===_charcodes.charCodes.carriageReturn||code===8232||code===8233){return true}}return false}__name(hasPrecedingLineBreak,\"hasPrecedingLineBreak\");exports.hasPrecedingLineBreak=hasPrecedingLineBreak;function hasFollowingLineBreak(){const nextStart=_index.nextTokenStart.call(void 0);for(let i=_base.state.end;i<nextStart;i++){const code=_base.input.charCodeAt(i);if(code===_charcodes.charCodes.lineFeed||code===_charcodes.charCodes.carriageReturn||code===8232||code===8233){return true}}return false}__name(hasFollowingLineBreak,\"hasFollowingLineBreak\");exports.hasFollowingLineBreak=hasFollowingLineBreak;function isLineTerminator(){return _index.eat.call(void 0,_types.TokenType.semi)||canInsertSemicolon()}__name(isLineTerminator,\"isLineTerminator\");exports.isLineTerminator=isLineTerminator;function semicolon(){if(!isLineTerminator()){unexpected('Unexpected token, expected \";\"')}}__name(semicolon,\"semicolon\");exports.semicolon=semicolon;function expect(type){const matched=_index.eat.call(void 0,type);if(!matched){unexpected(`Unexpected token, expected \"${_types.formatTokenType.call(void 0,type)}\"`)}}__name(expect,\"expect\");exports.expect=expect;function unexpected(message=\"Unexpected token\",pos=_base.state.start){if(_base.state.error){return}const err=new SyntaxError(message);err.pos=pos;_base.state.error=err;_base.state.pos=_base.input.length;_index.finishToken.call(void 0,_types.TokenType.eof)}__name(unexpected,\"unexpected\");exports.unexpected=unexpected;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAE,IAAI,OAAS,QAAQ,oBAAoB,EAElH,IAAI,OAAS,QAAQ,oBAAoB,EACzC,IAAI,WAAa,QAAQ,mBAAmB,EAC5C,IAAI,MAAQ,QAAQ,QAAQ,EAK3B,SAAS,aAAa,kBAAmB,CACxC,OAAO,MAAM,MAAM,oBAAsB,iBAC3C,CAFU,oCAER,QAAQ,aAAe,aAExB,SAAS,sBAAsB,kBAAmB,CACjD,MAAM,EAAI,OAAO,wBAAwB,KAAK,MAAQ,EACtD,OAAO,EAAE,OAAS,OAAO,UAAU,MAAQ,EAAE,oBAAsB,iBACrE,CAHU,sDAGR,QAAQ,sBAAwB,sBAGjC,SAAS,cAAc,kBAAmB,CACzC,OAAO,MAAM,MAAM,oBAAsB,mBAAqB,OAAO,IAAI,KAAK,OAAQ,OAAO,UAAU,IAAI,CAC7G,CAFU,sCAER,QAAQ,cAAgB,cAGzB,SAAS,iBAAiB,kBAAmB,CAC5C,GAAI,CAAC,cAAc,iBAAiB,EAAG,CACrC,WAAW,CACb,CACF,CAJU,4CAIR,QAAQ,iBAAmB,iBAG5B,SAAS,oBAAqB,CAC7B,OAAO,OAAO,MAAM,KAAK,OAAQ,OAAO,UAAU,GAAG,GAAK,OAAO,MAAM,KAAK,OAAQ,OAAO,UAAU,MAAM,GAAK,sBAAsB,CACxI,CAFU,gDAER,QAAQ,mBAAqB,mBAE9B,SAAS,uBAAwB,CAChC,MAAM,UAAY,MAAM,MAAM,OAAO,MAAM,MAAM,OAAO,OAAS,CAAC,EAClE,MAAM,WAAa,UAAY,UAAU,IAAM,EAC/C,QAAS,EAAI,WAAY,EAAI,MAAM,MAAM,MAAO,IAAK,CACnD,MAAM,KAAO,MAAM,MAAM,WAAW,CAAC,EACrC,GACE,OAAS,WAAW,UAAU,UAC9B,OAAS,WAAW,UAAU,gBAC9B,OAAS,MACT,OAAS,KACT,CACA,MAAO,KACT,CACF,CACA,MAAO,MACT,CAfU,sDAeR,QAAQ,sBAAwB,sBAEjC,SAAS,uBAAwB,CAChC,MAAM,UAAY,OAAO,eAAe,KAAK,MAAQ,EACrD,QAAS,EAAI,MAAM,MAAM,IAAK,EAAI,UAAW,IAAK,CAChD,MAAM,KAAO,MAAM,MAAM,WAAW,CAAC,EACrC,GACE,OAAS,WAAW,UAAU,UAC9B,OAAS,WAAW,UAAU,gBAC9B,OAAS,MACT,OAAS,KACT,CACA,MAAO,KACT,CACF,CACA,MAAO,MACT,CAdU,sDAcR,QAAQ,sBAAwB,sBAEjC,SAAS,kBAAmB,CAC3B,OAAO,OAAO,IAAI,KAAK,OAAQ,OAAO,UAAU,IAAI,GAAK,mBAAmB,CAC9E,CAFU,4CAER,QAAQ,iBAAmB,iBAI5B,SAAS,WAAY,CACpB,GAAI,CAAC,iBAAiB,EAAG,CACvB,WAAW,gCAAgC,CAC7C,CACF,CAJU,8BAIR,QAAQ,UAAY,UAIrB,SAAS,OAAO,KAAM,CACrB,MAAM,QAAU,OAAO,IAAI,KAAK,OAAQ,IAAI,EAC5C,GAAI,CAAC,QAAS,CACZ,WAAW,+BAA+B,OAAO,gBAAgB,KAAK,OAAQ,IAAI,IAAI,CACxF,CACF,CALU,wBAKR,QAAQ,OAAS,OAMlB,SAAS,WAAW,QAAU,mBAAoB,IAAM,MAAM,MAAM,MAAO,CAC1E,GAAI,MAAM,MAAM,MAAO,CACrB,MACF,CAEA,MAAM,IAAM,IAAI,YAAY,OAAO,EACnC,IAAI,IAAM,IACV,MAAM,MAAM,MAAQ,IACpB,MAAM,MAAM,IAAM,MAAM,MAAM,OAC9B,OAAO,YAAY,KAAK,OAAQ,OAAO,UAAU,GAAG,CACtD,CAVU,gCAUR,QAAQ,WAAa","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/parser/traverser/util.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});var _index = require('../tokenizer/index');\n\nvar _types = require('../tokenizer/types');\nvar _charcodes = require('../util/charcodes');\nvar _base = require('./base');\n\n// ## Parser utilities\n\n// Tests whether parsed token is a contextual keyword.\n function isContextual(contextualKeyword) {\n  return _base.state.contextualKeyword === contextualKeyword;\n} exports.isContextual = isContextual;\n\n function isLookaheadContextual(contextualKeyword) {\n  const l = _index.lookaheadTypeAndKeyword.call(void 0, );\n  return l.type === _types.TokenType.name && l.contextualKeyword === contextualKeyword;\n} exports.isLookaheadContextual = isLookaheadContextual;\n\n// Consumes contextual keyword if possible.\n function eatContextual(contextualKeyword) {\n  return _base.state.contextualKeyword === contextualKeyword && _index.eat.call(void 0, _types.TokenType.name);\n} exports.eatContextual = eatContextual;\n\n// Asserts that following token is given contextual keyword.\n function expectContextual(contextualKeyword) {\n  if (!eatContextual(contextualKeyword)) {\n    unexpected();\n  }\n} exports.expectContextual = expectContextual;\n\n// Test whether a semicolon can be inserted at the current position.\n function canInsertSemicolon() {\n  return _index.match.call(void 0, _types.TokenType.eof) || _index.match.call(void 0, _types.TokenType.braceR) || hasPrecedingLineBreak();\n} exports.canInsertSemicolon = canInsertSemicolon;\n\n function hasPrecedingLineBreak() {\n  const prevToken = _base.state.tokens[_base.state.tokens.length - 1];\n  const lastTokEnd = prevToken ? prevToken.end : 0;\n  for (let i = lastTokEnd; i < _base.state.start; i++) {\n    const code = _base.input.charCodeAt(i);\n    if (\n      code === _charcodes.charCodes.lineFeed ||\n      code === _charcodes.charCodes.carriageReturn ||\n      code === 0x2028 ||\n      code === 0x2029\n    ) {\n      return true;\n    }\n  }\n  return false;\n} exports.hasPrecedingLineBreak = hasPrecedingLineBreak;\n\n function hasFollowingLineBreak() {\n  const nextStart = _index.nextTokenStart.call(void 0, );\n  for (let i = _base.state.end; i < nextStart; i++) {\n    const code = _base.input.charCodeAt(i);\n    if (\n      code === _charcodes.charCodes.lineFeed ||\n      code === _charcodes.charCodes.carriageReturn ||\n      code === 0x2028 ||\n      code === 0x2029\n    ) {\n      return true;\n    }\n  }\n  return false;\n} exports.hasFollowingLineBreak = hasFollowingLineBreak;\n\n function isLineTerminator() {\n  return _index.eat.call(void 0, _types.TokenType.semi) || canInsertSemicolon();\n} exports.isLineTerminator = isLineTerminator;\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n function semicolon() {\n  if (!isLineTerminator()) {\n    unexpected('Unexpected token, expected \";\"');\n  }\n} exports.semicolon = semicolon;\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error at given pos.\n function expect(type) {\n  const matched = _index.eat.call(void 0, type);\n  if (!matched) {\n    unexpected(`Unexpected token, expected \"${_types.formatTokenType.call(void 0, type)}\"`);\n  }\n} exports.expect = expect;\n\n/**\n * Transition the parser to an error state. All code needs to be written to naturally unwind in this\n * state, which allows us to backtrack without exceptions and without error plumbing everywhere.\n */\n function unexpected(message = \"Unexpected token\", pos = _base.state.start) {\n  if (_base.state.error) {\n    return;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const err = new SyntaxError(message);\n  err.pos = pos;\n  _base.state.error = err;\n  _base.state.pos = _base.input.length;\n  _index.finishToken.call(void 0, _types.TokenType.eof);\n} exports.unexpected = unexpected;\n"]}}