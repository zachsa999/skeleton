{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});let Declaration=require(\"./declaration\");let tokenizer=require(\"./tokenize\");let Comment=require(\"./comment\");let AtRule=require(\"./at-rule\");let Root=require(\"./root\");let Rule=require(\"./rule\");const SAFE_COMMENT_NEIGHBOR={empty:true,space:true};function findLastWithPosition(tokens){for(let i=tokens.length-1;i>=0;i--){let token=tokens[i];let pos=token[3]||token[2];if(pos)return pos}}__name(findLastWithPosition,\"findLastWithPosition\");class Parser{constructor(input){this.input=input;this.root=new Root;this.current=this.root;this.spaces=\"\";this.semicolon=false;this.customProperty=false;this.createTokenizer();this.root.source={input,start:{offset:0,line:1,column:1}}}createTokenizer(){this.tokenizer=tokenizer(this.input)}parse(){let token;while(!this.tokenizer.endOfFile()){token=this.tokenizer.nextToken();switch(token[0]){case\"space\":this.spaces+=token[1];break;case\";\":this.freeSemicolon(token);break;case\"}\":this.end(token);break;case\"comment\":this.comment(token);break;case\"at-word\":this.atrule(token);break;case\"{\":this.emptyRule(token);break;default:this.other(token);break}}this.endFile()}comment(token){let node=new Comment;this.init(node,token[2]);node.source.end=this.getPosition(token[3]||token[2]);let text=token[1].slice(2,-2);if(/^\\s*$/.test(text)){node.text=\"\";node.raws.left=text;node.raws.right=\"\"}else{let match=text.match(/^(\\s*)([^]*\\S)(\\s*)$/);node.text=match[2];node.raws.left=match[1];node.raws.right=match[3]}}emptyRule(token){let node=new Rule;this.init(node,token[2]);node.selector=\"\";node.raws.between=\"\";this.current=node}other(start){let end=false;let type=null;let colon=false;let bracket=null;let brackets=[];let customProperty=start[1].startsWith(\"--\");let tokens=[];let token=start;while(token){type=token[0];tokens.push(token);if(type===\"(\"||type===\"[\"){if(!bracket)bracket=token;brackets.push(type===\"(\"?\")\":\"]\")}else if(customProperty&&colon&&type===\"{\"){if(!bracket)bracket=token;brackets.push(\"}\")}else if(brackets.length===0){if(type===\";\"){if(colon){this.decl(tokens,customProperty);return}else{break}}else if(type===\"{\"){this.rule(tokens);return}else if(type===\"}\"){this.tokenizer.back(tokens.pop());end=true;break}else if(type===\":\"){colon=true}}else if(type===brackets[brackets.length-1]){brackets.pop();if(brackets.length===0)bracket=null}token=this.tokenizer.nextToken()}if(this.tokenizer.endOfFile())end=true;if(brackets.length>0)this.unclosedBracket(bracket);if(end&&colon){if(!customProperty){while(tokens.length){token=tokens[tokens.length-1][0];if(token!==\"space\"&&token!==\"comment\")break;this.tokenizer.back(tokens.pop())}}this.decl(tokens,customProperty)}else{this.unknownWord(tokens)}}rule(tokens){tokens.pop();let node=new Rule;this.init(node,tokens[0][2]);node.raws.between=this.spacesAndCommentsFromEnd(tokens);this.raw(node,\"selector\",tokens);this.current=node}decl(tokens,customProperty){let node=new Declaration;this.init(node,tokens[0][2]);let last=tokens[tokens.length-1];if(last[0]===\";\"){this.semicolon=true;tokens.pop()}node.source.end=this.getPosition(last[3]||last[2]||findLastWithPosition(tokens));while(tokens[0][0]!==\"word\"){if(tokens.length===1)this.unknownWord(tokens);node.raws.before+=tokens.shift()[1]}node.source.start=this.getPosition(tokens[0][2]);node.prop=\"\";while(tokens.length){let type=tokens[0][0];if(type===\":\"||type===\"space\"||type===\"comment\"){break}node.prop+=tokens.shift()[1]}node.raws.between=\"\";let token;while(tokens.length){token=tokens.shift();if(token[0]===\":\"){node.raws.between+=token[1];break}else{if(token[0]===\"word\"&&/\\w/.test(token[1])){this.unknownWord([token])}node.raws.between+=token[1]}}if(node.prop[0]===\"_\"||node.prop[0]===\"*\"){node.raws.before+=node.prop[0];node.prop=node.prop.slice(1)}let firstSpaces=[];let next;while(tokens.length){next=tokens[0][0];if(next!==\"space\"&&next!==\"comment\")break;firstSpaces.push(tokens.shift())}this.precheckMissedSemicolon(tokens);for(let i=tokens.length-1;i>=0;i--){token=tokens[i];if(token[1].toLowerCase()===\"!important\"){node.important=true;let string=this.stringFrom(tokens,i);string=this.spacesFromEnd(tokens)+string;if(string!==\" !important\")node.raws.important=string;break}else if(token[1].toLowerCase()===\"important\"){let cache=tokens.slice(0);let str=\"\";for(let j=i;j>0;j--){let type=cache[j][0];if(str.trim().indexOf(\"!\")===0&&type!==\"space\"){break}str=cache.pop()[1]+str}if(str.trim().indexOf(\"!\")===0){node.important=true;node.raws.important=str;tokens=cache}}if(token[0]!==\"space\"&&token[0]!==\"comment\"){break}}let hasWord=tokens.some(i=>i[0]!==\"space\"&&i[0]!==\"comment\");if(hasWord){node.raws.between+=firstSpaces.map(i=>i[1]).join(\"\");firstSpaces=[]}this.raw(node,\"value\",firstSpaces.concat(tokens),customProperty);if(node.value.includes(\":\")&&!customProperty){this.checkMissedSemicolon(tokens)}}atrule(token){let node=new AtRule;node.name=token[1].slice(1);if(node.name===\"\"){this.unnamedAtrule(node,token)}this.init(node,token[2]);let type;let prev;let shift;let last=false;let open=false;let params=[];let brackets=[];while(!this.tokenizer.endOfFile()){token=this.tokenizer.nextToken();type=token[0];if(type===\"(\"||type===\"[\"){brackets.push(type===\"(\"?\")\":\"]\")}else if(type===\"{\"&&brackets.length>0){brackets.push(\"}\")}else if(type===brackets[brackets.length-1]){brackets.pop()}if(brackets.length===0){if(type===\";\"){node.source.end=this.getPosition(token[2]);this.semicolon=true;break}else if(type===\"{\"){open=true;break}else if(type===\"}\"){if(params.length>0){shift=params.length-1;prev=params[shift];while(prev&&prev[0]===\"space\"){prev=params[--shift]}if(prev){node.source.end=this.getPosition(prev[3]||prev[2])}}this.end(token);break}else{params.push(token)}}else{params.push(token)}if(this.tokenizer.endOfFile()){last=true;break}}node.raws.between=this.spacesAndCommentsFromEnd(params);if(params.length){node.raws.afterName=this.spacesAndCommentsFromStart(params);this.raw(node,\"params\",params);if(last){token=params[params.length-1];node.source.end=this.getPosition(token[3]||token[2]);this.spaces=node.raws.between;node.raws.between=\"\"}}else{node.raws.afterName=\"\";node.params=\"\"}if(open){node.nodes=[];this.current=node}}end(token){if(this.current.nodes&&this.current.nodes.length){this.current.raws.semicolon=this.semicolon}this.semicolon=false;this.current.raws.after=(this.current.raws.after||\"\")+this.spaces;this.spaces=\"\";if(this.current.parent){this.current.source.end=this.getPosition(token[2]);this.current=this.current.parent}else{this.unexpectedClose(token)}}endFile(){if(this.current.parent)this.unclosedBlock();if(this.current.nodes&&this.current.nodes.length){this.current.raws.semicolon=this.semicolon}this.current.raws.after=(this.current.raws.after||\"\")+this.spaces}freeSemicolon(token){this.spaces+=token[1];if(this.current.nodes){let prev=this.current.nodes[this.current.nodes.length-1];if(prev&&prev.type===\"rule\"&&!prev.raws.ownSemicolon){prev.raws.ownSemicolon=this.spaces;this.spaces=\"\"}}}getPosition(offset){let pos=this.input.fromOffset(offset);return{offset,line:pos.line,column:pos.col}}init(node,offset){this.current.push(node);node.source={start:this.getPosition(offset),input:this.input};node.raws.before=this.spaces;this.spaces=\"\";if(node.type!==\"comment\")this.semicolon=false}raw(node,prop,tokens,customProperty){let token,type;let length=tokens.length;let value=\"\";let clean=true;let next,prev;for(let i=0;i<length;i+=1){token=tokens[i];type=token[0];if(type===\"space\"&&i===length-1&&!customProperty){clean=false}else if(type===\"comment\"){prev=tokens[i-1]?tokens[i-1][0]:\"empty\";next=tokens[i+1]?tokens[i+1][0]:\"empty\";if(!SAFE_COMMENT_NEIGHBOR[prev]&&!SAFE_COMMENT_NEIGHBOR[next]){if(value.slice(-1)===\",\"){clean=false}else{value+=token[1]}}else{clean=false}}else{value+=token[1]}}if(!clean){let raw=tokens.reduce((all,i)=>all+i[1],\"\");node.raws[prop]={value,raw}}node[prop]=value}spacesAndCommentsFromEnd(tokens){let lastTokenType;let spaces=\"\";while(tokens.length){lastTokenType=tokens[tokens.length-1][0];if(lastTokenType!==\"space\"&&lastTokenType!==\"comment\")break;spaces=tokens.pop()[1]+spaces}return spaces}spacesAndCommentsFromStart(tokens){let next;let spaces=\"\";while(tokens.length){next=tokens[0][0];if(next!==\"space\"&&next!==\"comment\")break;spaces+=tokens.shift()[1]}return spaces}spacesFromEnd(tokens){let lastTokenType;let spaces=\"\";while(tokens.length){lastTokenType=tokens[tokens.length-1][0];if(lastTokenType!==\"space\")break;spaces=tokens.pop()[1]+spaces}return spaces}stringFrom(tokens,from){let result=\"\";for(let i=from;i<tokens.length;i++){result+=tokens[i][1]}tokens.splice(from,tokens.length-from);return result}colon(tokens){let brackets=0;let token,type,prev;for(let[i,element]of tokens.entries()){token=element;type=token[0];if(type===\"(\"){brackets+=1}if(type===\")\"){brackets-=1}if(brackets===0&&type===\":\"){if(!prev){this.doubleColon(token)}else if(prev[0]===\"word\"&&prev[1]===\"progid\"){continue}else{return i}}prev=token}return false}unclosedBracket(bracket){throw this.input.error(\"Unclosed bracket\",{offset:bracket[2]},{offset:bracket[2]+1})}unknownWord(tokens){throw this.input.error(\"Unknown word\",{offset:tokens[0][2]},{offset:tokens[0][2]+tokens[0][1].length})}unexpectedClose(token){throw this.input.error(\"Unexpected }\",{offset:token[2]},{offset:token[2]+1})}unclosedBlock(){let pos=this.current.source.start;throw this.input.error(\"Unclosed block\",pos.line,pos.column)}doubleColon(token){throw this.input.error(\"Double colon\",{offset:token[2]},{offset:token[2]+token[1].length})}unnamedAtrule(node,token){throw this.input.error(\"At-rule without name\",{offset:token[2]},{offset:token[2]+token[1].length})}precheckMissedSemicolon(){}checkMissedSemicolon(tokens){let colon=this.colon(tokens);if(colon===false)return;let founded=0;let token;for(let j=colon-1;j>=0;j--){token=tokens[j];if(token[0]!==\"space\"){founded+=1;if(founded===2)break}}throw this.input.error(\"Missed semicolon\",token[0]===\"word\"?token[3]+1:token[2])}}__name(Parser,\"Parser\");module.exports=Parser;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/postcss@8.4.24/node_modules/postcss/lib/parser.js"],"sourcesContent":["'use strict'\n\nlet Declaration = require('./declaration')\nlet tokenizer = require('./tokenize')\nlet Comment = require('./comment')\nlet AtRule = require('./at-rule')\nlet Root = require('./root')\nlet Rule = require('./rule')\n\nconst SAFE_COMMENT_NEIGHBOR = {\n  empty: true,\n  space: true\n}\n\nfunction findLastWithPosition(tokens) {\n  for (let i = tokens.length - 1; i >= 0; i--) {\n    let token = tokens[i]\n    let pos = token[3] || token[2]\n    if (pos) return pos\n  }\n}\n\nclass Parser {\n  constructor(input) {\n    this.input = input\n\n    this.root = new Root()\n    this.current = this.root\n    this.spaces = ''\n    this.semicolon = false\n    this.customProperty = false\n\n    this.createTokenizer()\n    this.root.source = { input, start: { offset: 0, line: 1, column: 1 } }\n  }\n\n  createTokenizer() {\n    this.tokenizer = tokenizer(this.input)\n  }\n\n  parse() {\n    let token\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1]\n          break\n\n        case ';':\n          this.freeSemicolon(token)\n          break\n\n        case '}':\n          this.end(token)\n          break\n\n        case 'comment':\n          this.comment(token)\n          break\n\n        case 'at-word':\n          this.atrule(token)\n          break\n\n        case '{':\n          this.emptyRule(token)\n          break\n\n        default:\n          this.other(token)\n          break\n      }\n    }\n    this.endFile()\n  }\n\n  comment(token) {\n    let node = new Comment()\n    this.init(node, token[2])\n    node.source.end = this.getPosition(token[3] || token[2])\n\n    let text = token[1].slice(2, -2)\n    if (/^\\s*$/.test(text)) {\n      node.text = ''\n      node.raws.left = text\n      node.raws.right = ''\n    } else {\n      let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/)\n      node.text = match[2]\n      node.raws.left = match[1]\n      node.raws.right = match[3]\n    }\n  }\n\n  emptyRule(token) {\n    let node = new Rule()\n    this.init(node, token[2])\n    node.selector = ''\n    node.raws.between = ''\n    this.current = node\n  }\n\n  other(start) {\n    let end = false\n    let type = null\n    let colon = false\n    let bracket = null\n    let brackets = []\n    let customProperty = start[1].startsWith('--')\n\n    let tokens = []\n    let token = start\n    while (token) {\n      type = token[0]\n      tokens.push(token)\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (customProperty && colon && type === '{') {\n        if (!bracket) bracket = token\n        brackets.push('}')\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens, customProperty)\n            return\n          } else {\n            break\n          }\n        } else if (type === '{') {\n          this.rule(tokens)\n          return\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop())\n          end = true\n          break\n        } else if (type === ':') {\n          colon = true\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n        if (brackets.length === 0) bracket = null\n      }\n\n      token = this.tokenizer.nextToken()\n    }\n\n    if (this.tokenizer.endOfFile()) end = true\n    if (brackets.length > 0) this.unclosedBracket(bracket)\n\n    if (end && colon) {\n      if (!customProperty) {\n        while (tokens.length) {\n          token = tokens[tokens.length - 1][0]\n          if (token !== 'space' && token !== 'comment') break\n          this.tokenizer.back(tokens.pop())\n        }\n      }\n      this.decl(tokens, customProperty)\n    } else {\n      this.unknownWord(tokens)\n    }\n  }\n\n  rule(tokens) {\n    tokens.pop()\n\n    let node = new Rule()\n    this.init(node, tokens[0][2])\n\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens)\n    this.raw(node, 'selector', tokens)\n    this.current = node\n  }\n\n  decl(tokens, customProperty) {\n    let node = new Declaration()\n    this.init(node, tokens[0][2])\n\n    let last = tokens[tokens.length - 1]\n    if (last[0] === ';') {\n      this.semicolon = true\n      tokens.pop()\n    }\n\n    node.source.end = this.getPosition(\n      last[3] || last[2] || findLastWithPosition(tokens)\n    )\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens)\n      node.raws.before += tokens.shift()[1]\n    }\n    node.source.start = this.getPosition(tokens[0][2])\n\n    node.prop = ''\n    while (tokens.length) {\n      let type = tokens[0][0]\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break\n      }\n      node.prop += tokens.shift()[1]\n    }\n\n    node.raws.between = ''\n\n    let token\n    while (tokens.length) {\n      token = tokens.shift()\n\n      if (token[0] === ':') {\n        node.raws.between += token[1]\n        break\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token])\n        }\n        node.raws.between += token[1]\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0]\n      node.prop = node.prop.slice(1)\n    }\n\n    let firstSpaces = []\n    let next\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      firstSpaces.push(tokens.shift())\n    }\n\n    this.precheckMissedSemicolon(tokens)\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i]\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true\n        let string = this.stringFrom(tokens, i)\n        string = this.spacesFromEnd(tokens) + string\n        if (string !== ' !important') node.raws.important = string\n        break\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0)\n        let str = ''\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0]\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\n            break\n          }\n          str = cache.pop()[1] + str\n        }\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true\n          node.raws.important = str\n          tokens = cache\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break\n      }\n    }\n\n    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')\n\n    if (hasWord) {\n      node.raws.between += firstSpaces.map(i => i[1]).join('')\n      firstSpaces = []\n    }\n    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)\n\n    if (node.value.includes(':') && !customProperty) {\n      this.checkMissedSemicolon(tokens)\n    }\n  }\n\n  atrule(token) {\n    let node = new AtRule()\n    node.name = token[1].slice(1)\n    if (node.name === '') {\n      this.unnamedAtrule(node, token)\n    }\n    this.init(node, token[2])\n\n    let type\n    let prev\n    let shift\n    let last = false\n    let open = false\n    let params = []\n    let brackets = []\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n      type = token[0]\n\n      if (type === '(' || type === '[') {\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (type === '{' && brackets.length > 0) {\n        brackets.push('}')\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n      }\n\n      if (brackets.length === 0) {\n        if (type === ';') {\n          node.source.end = this.getPosition(token[2])\n          this.semicolon = true\n          break\n        } else if (type === '{') {\n          open = true\n          break\n        } else if (type === '}') {\n          if (params.length > 0) {\n            shift = params.length - 1\n            prev = params[shift]\n            while (prev && prev[0] === 'space') {\n              prev = params[--shift]\n            }\n            if (prev) {\n              node.source.end = this.getPosition(prev[3] || prev[2])\n            }\n          }\n          this.end(token)\n          break\n        } else {\n          params.push(token)\n        }\n      } else {\n        params.push(token)\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true\n        break\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params)\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params)\n      this.raw(node, 'params', params)\n      if (last) {\n        token = params[params.length - 1]\n        node.source.end = this.getPosition(token[3] || token[2])\n        this.spaces = node.raws.between\n        node.raws.between = ''\n      }\n    } else {\n      node.raws.afterName = ''\n      node.params = ''\n    }\n\n    if (open) {\n      node.nodes = []\n      this.current = node\n    }\n  }\n\n  end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.semicolon = false\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n    this.spaces = ''\n\n    if (this.current.parent) {\n      this.current.source.end = this.getPosition(token[2])\n      this.current = this.current.parent\n    } else {\n      this.unexpectedClose(token)\n    }\n  }\n\n  endFile() {\n    if (this.current.parent) this.unclosedBlock()\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n  }\n\n  freeSemicolon(token) {\n    this.spaces += token[1]\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1]\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces\n        this.spaces = ''\n      }\n    }\n  }\n\n  // Helpers\n\n  getPosition(offset) {\n    let pos = this.input.fromOffset(offset)\n    return {\n      offset,\n      line: pos.line,\n      column: pos.col\n    }\n  }\n\n  init(node, offset) {\n    this.current.push(node)\n    node.source = {\n      start: this.getPosition(offset),\n      input: this.input\n    }\n    node.raws.before = this.spaces\n    this.spaces = ''\n    if (node.type !== 'comment') this.semicolon = false\n  }\n\n  raw(node, prop, tokens, customProperty) {\n    let token, type\n    let length = tokens.length\n    let value = ''\n    let clean = true\n    let next, prev\n\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i]\n      type = token[0]\n      if (type === 'space' && i === length - 1 && !customProperty) {\n        clean = false\n      } else if (type === 'comment') {\n        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty'\n        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty'\n        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n          if (value.slice(-1) === ',') {\n            clean = false\n          } else {\n            value += token[1]\n          }\n        } else {\n          clean = false\n        }\n      } else {\n        value += token[1]\n      }\n    }\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '')\n      node.raws[prop] = { value, raw }\n    }\n    node[prop] = value\n  }\n\n  spacesAndCommentsFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  spacesAndCommentsFromStart(tokens) {\n    let next\n    let spaces = ''\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      spaces += tokens.shift()[1]\n    }\n    return spaces\n  }\n\n  spacesFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  stringFrom(tokens, from) {\n    let result = ''\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1]\n    }\n    tokens.splice(from, tokens.length - from)\n    return result\n  }\n\n  colon(tokens) {\n    let brackets = 0\n    let token, type, prev\n    for (let [i, element] of tokens.entries()) {\n      token = element\n      type = token[0]\n\n      if (type === '(') {\n        brackets += 1\n      }\n      if (type === ')') {\n        brackets -= 1\n      }\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token)\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue\n        } else {\n          return i\n        }\n      }\n\n      prev = token\n    }\n    return false\n  }\n\n  // Errors\n\n  unclosedBracket(bracket) {\n    throw this.input.error(\n      'Unclosed bracket',\n      { offset: bracket[2] },\n      { offset: bracket[2] + 1 }\n    )\n  }\n\n  unknownWord(tokens) {\n    throw this.input.error(\n      'Unknown word',\n      { offset: tokens[0][2] },\n      { offset: tokens[0][2] + tokens[0][1].length }\n    )\n  }\n\n  unexpectedClose(token) {\n    throw this.input.error(\n      'Unexpected }',\n      { offset: token[2] },\n      { offset: token[2] + 1 }\n    )\n  }\n\n  unclosedBlock() {\n    let pos = this.current.source.start\n    throw this.input.error('Unclosed block', pos.line, pos.column)\n  }\n\n  doubleColon(token) {\n    throw this.input.error(\n      'Double colon',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n\n  unnamedAtrule(node, token) {\n    throw this.input.error(\n      'At-rule without name',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n\n  precheckMissedSemicolon(/* tokens */) {\n    // Hook for Safe Parser\n  }\n\n  checkMissedSemicolon(tokens) {\n    let colon = this.colon(tokens)\n    if (colon === false) return\n\n    let founded = 0\n    let token\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j]\n      if (token[0] !== 'space') {\n        founded += 1\n        if (founded === 2) break\n      }\n    }\n    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.\n    // Then we need to return the colon after that word token. [3] is the \"end\" colon of that word.\n    // And because we need it after that one we do +1 to get the next one.\n    throw this.input.error(\n      'Missed semicolon',\n      token[0] === 'word' ? token[3] + 1 : token[2]\n    )\n  }\n}\n\nmodule.exports = Parser\n"]}}