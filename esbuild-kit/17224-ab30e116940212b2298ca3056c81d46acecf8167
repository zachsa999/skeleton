{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _index=require(\"../tokenizer/index\");var _types=require(\"../tokenizer/types\");var _base=require(\"../traverser/base\");var _expression=require(\"../traverser/expression\");var _flow=require(\"./flow\");var _typescript=require(\"./typescript\");function typedParseConditional(noIn){if(_index.match.call(void 0,_types.TokenType.question)){const nextType=_index.lookaheadType.call(void 0);if(nextType===_types.TokenType.colon||nextType===_types.TokenType.comma||nextType===_types.TokenType.parenR){return}}_expression.baseParseConditional.call(void 0,noIn)}__name(typedParseConditional,\"typedParseConditional\");exports.typedParseConditional=typedParseConditional;function typedParseParenItem(){_index.eatTypeToken.call(void 0,_types.TokenType.question);if(_index.match.call(void 0,_types.TokenType.colon)){if(_base.isTypeScriptEnabled){_typescript.tsParseTypeAnnotation.call(void 0)}else if(_base.isFlowEnabled){_flow.flowParseTypeAnnotation.call(void 0)}}}__name(typedParseParenItem,\"typedParseParenItem\");exports.typedParseParenItem=typedParseParenItem;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAE,IAAI,OAAS,QAAQ,oBAAoB,EAClH,IAAI,OAAS,QAAQ,oBAAoB,EACzC,IAAI,MAAQ,QAAQ,mBAAmB,EACvC,IAAI,YAAc,QAAQ,yBAAyB,EACnD,IAAI,MAAQ,QAAQ,QAAQ,EAC5B,IAAI,YAAc,QAAQ,cAAc,EAOvC,SAAS,sBAAsB,KAAM,CAIpC,GAAI,OAAO,MAAM,KAAK,OAAQ,OAAO,UAAU,QAAQ,EAAG,CACxD,MAAM,SAAW,OAAO,cAAc,KAAK,MAAQ,EACnD,GAAI,WAAa,OAAO,UAAU,OAAS,WAAa,OAAO,UAAU,OAAS,WAAa,OAAO,UAAU,OAAQ,CACtH,MACF,CACF,CACA,YAAY,qBAAqB,KAAK,OAAQ,IAAI,CACpD,CAXU,sDAWR,QAAQ,sBAAwB,sBAIjC,SAAS,qBAAsB,CAC9B,OAAO,aAAa,KAAK,OAAQ,OAAO,UAAU,QAAQ,EAC1D,GAAI,OAAO,MAAM,KAAK,OAAQ,OAAO,UAAU,KAAK,EAAG,CACrD,GAAI,MAAM,oBAAqB,CAC7B,YAAY,sBAAsB,KAAK,MAAQ,CACjD,SAAW,MAAM,cAAe,CAC9B,MAAM,wBAAwB,KAAK,MAAQ,CAC7C,CACF,CACF,CATU,kDASR,QAAQ,oBAAsB","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/parser/plugins/types.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});var _index = require('../tokenizer/index');\nvar _types = require('../tokenizer/types');\nvar _base = require('../traverser/base');\nvar _expression = require('../traverser/expression');\nvar _flow = require('./flow');\nvar _typescript = require('./typescript');\n\n/**\n * Common parser code for TypeScript and Flow.\n */\n\n// An apparent conditional expression could actually be an optional parameter in an arrow function.\n function typedParseConditional(noIn) {\n  // If we see ?:, this can't possibly be a valid conditional. typedParseParenItem will be called\n  // later to finish off the arrow parameter. We also need to handle bare ? tokens for optional\n  // parameters without type annotations, i.e. ?, and ?) .\n  if (_index.match.call(void 0, _types.TokenType.question)) {\n    const nextType = _index.lookaheadType.call(void 0, );\n    if (nextType === _types.TokenType.colon || nextType === _types.TokenType.comma || nextType === _types.TokenType.parenR) {\n      return;\n    }\n  }\n  _expression.baseParseConditional.call(void 0, noIn);\n} exports.typedParseConditional = typedParseConditional;\n\n// Note: These \"type casts\" are *not* valid TS expressions.\n// But we parse them here and change them when completing the arrow function.\n function typedParseParenItem() {\n  _index.eatTypeToken.call(void 0, _types.TokenType.question);\n  if (_index.match.call(void 0, _types.TokenType.colon)) {\n    if (_base.isTypeScriptEnabled) {\n      _typescript.tsParseTypeAnnotation.call(void 0, );\n    } else if (_base.isFlowEnabled) {\n      _flow.flowParseTypeAnnotation.call(void 0, );\n    }\n  }\n} exports.typedParseParenItem = typedParseParenItem;\n"]}}