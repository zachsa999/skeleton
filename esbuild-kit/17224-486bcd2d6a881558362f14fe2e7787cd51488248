{"code":"(()=>{\nvar __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const{Rule,AtRule}=require(\"postcss\");let parser=require(\"postcss-selector-parser\");function parse(rawSelector,rule){let nodes;try{parser(parsed=>{nodes=parsed}).processSync(rawSelector)}catch(e){if(rawSelector.includes(\":\")){throw rule?rule.error(\"Missed semicolon\"):e}else{throw rule?rule.error(e.message):e}}return nodes.at(0)}__name(parse,\"parse\");function interpolateAmpInSelector(nodes,parent){let replaced=false;nodes.each(node=>{if(node.type===\"nesting\"){let clonedParent=parent.clone({});if(node.value!==\"&\"){node.replaceWith(parse(node.value.replace(\"&\",clonedParent.toString())))}else{node.replaceWith(clonedParent)}replaced=true}else if(\"nodes\"in node&&node.nodes){if(interpolateAmpInSelector(node,parent)){replaced=true}}});return replaced}__name(interpolateAmpInSelector,\"interpolateAmpInSelector\");function mergeSelectors(parent,child){let merged=[];parent.selectors.forEach(sel=>{let parentNode=parse(sel,parent);child.selectors.forEach(selector=>{if(!selector){return}let node=parse(selector,child);let replaced=interpolateAmpInSelector(node,parentNode);if(!replaced){node.prepend(parser.combinator({value:\" \"}));node.prepend(parentNode.clone({}))}merged.push(node.toString())})});return merged}__name(mergeSelectors,\"mergeSelectors\");function breakOut(child,after){let prev=child.prev();after.after(child);while(prev&&prev.type===\"comment\"){let nextPrev=prev.prev();after.after(prev);prev=nextPrev}return child}__name(breakOut,\"breakOut\");function createFnAtruleChilds(bubble){return __name(function atruleChilds(rule,atrule,bubbling,mergeSels=bubbling){let children=[];atrule.each(child=>{if(child.type===\"rule\"&&bubbling){if(mergeSels){child.selectors=mergeSelectors(rule,child)}}else if(child.type===\"atrule\"&&child.nodes){if(bubble[child.name]){atruleChilds(rule,child,mergeSels)}else if(atrule[rootRuleMergeSel]!==false){children.push(child)}}else{children.push(child)}});if(bubbling){if(children.length){let clone=rule.clone({nodes:[]});for(let child of children){clone.append(child)}atrule.prepend(clone)}}},\"atruleChilds\")}__name(createFnAtruleChilds,\"createFnAtruleChilds\");function pickDeclarations(selector,declarations,after){let parent=new Rule({selector,nodes:[]});parent.append(declarations);after.after(parent);return parent}__name(pickDeclarations,\"pickDeclarations\");function atruleNames(defaults,custom){let list={};for(let name of defaults){list[name]=true}if(custom){for(let name of custom){list[name.replace(/^@/,\"\")]=true}}return list}__name(atruleNames,\"atruleNames\");function parseRootRuleParams(params){params=params.trim();let braceBlock=params.match(/^\\((.*)\\)$/);if(!braceBlock){return{type:\"basic\",selector:params}}let bits=braceBlock[1].match(/^(with(?:out)?):(.+)$/);if(bits){let allowlist=bits[1]===\"with\";let rules=Object.fromEntries(bits[2].trim().split(/\\s+/).map(name=>[name,true]));if(allowlist&&rules.all){return{type:\"noop\"}}let escapes=__name(rule=>!!rules[rule],\"escapes\");if(rules.all){escapes=__name(()=>true,\"escapes\")}else if(allowlist){escapes=__name(rule=>rule===\"all\"?false:!rules[rule],\"escapes\")}return{type:\"withrules\",escapes}}return{type:\"unknown\"}}__name(parseRootRuleParams,\"parseRootRuleParams\");function getAncestorRules(leaf){let lineage=[];let parent=leaf.parent;while(parent&&parent instanceof AtRule){lineage.push(parent);parent=parent.parent}return lineage}__name(getAncestorRules,\"getAncestorRules\");function unwrapRootRule(rule){let escapes=rule[rootRuleEscapes];if(!escapes){rule.after(rule.nodes)}else{let nodes=rule.nodes;let topEscaped;let topEscapedIdx=-1;let breakoutLeaf;let breakoutRoot;let clone;let lineage=getAncestorRules(rule);lineage.forEach((parent,i)=>{if(escapes(parent.name)){topEscaped=parent;topEscapedIdx=i;breakoutRoot=clone}else{let oldClone=clone;clone=parent.clone({nodes:[]});oldClone&&clone.append(oldClone);breakoutLeaf=breakoutLeaf||clone}});if(!topEscaped){rule.after(nodes)}else if(!breakoutRoot){topEscaped.after(nodes)}else{let leaf=breakoutLeaf;leaf.append(nodes);topEscaped.after(breakoutRoot)}if(rule.next()&&topEscaped){let restRoot;lineage.slice(0,topEscapedIdx+1).forEach((parent,i,arr)=>{let oldRoot=restRoot;restRoot=parent.clone({nodes:[]});oldRoot&&restRoot.append(oldRoot);let nextSibs=[];let _child=arr[i-1]||rule;let next=_child.next();while(next){nextSibs.push(next);next=next.next()}restRoot.append(nextSibs)});restRoot&&(breakoutRoot||nodes[nodes.length-1]).after(restRoot)}}rule.remove()}__name(unwrapRootRule,\"unwrapRootRule\");const rootRuleMergeSel=Symbol(\"rootRuleMergeSel\");const rootRuleEscapes=Symbol(\"rootRuleEscapes\");function normalizeRootRule(rule){let{params}=rule;let{type,selector,escapes}=parseRootRuleParams(params);if(type===\"unknown\"){throw rule.error(`Unknown @${rule.name} parameter ${JSON.stringify(params)}`)}if(type===\"basic\"&&selector){let selectorBlock=new Rule({selector,nodes:rule.nodes});rule.removeAll();rule.append(selectorBlock)}rule[rootRuleEscapes]=escapes;rule[rootRuleMergeSel]=escapes?!escapes(\"all\"):type===\"noop\"}__name(normalizeRootRule,\"normalizeRootRule\");const hasRootRule=Symbol(\"hasRootRule\");module.exports=(opts={})=>{let bubble=atruleNames([\"media\",\"supports\",\"layer\",\"container\"],opts.bubble);let atruleChilds=createFnAtruleChilds(bubble);let unwrap=atruleNames([\"document\",\"font-face\",\"keyframes\",\"-webkit-keyframes\",\"-moz-keyframes\"],opts.unwrap);let rootRuleName=(opts.rootRuleName||\"at-root\").replace(/^@/,\"\");let preserveEmpty=opts.preserveEmpty;return{postcssPlugin:\"postcss-nested\",Once(root){root.walkAtRules(rootRuleName,node=>{normalizeRootRule(node);root[hasRootRule]=true})},Rule(rule){let unwrapped=false;let after=rule;let copyDeclarations=false;let declarations=[];rule.each(child=>{if(child.type===\"rule\"){if(declarations.length){after=pickDeclarations(rule.selector,declarations,after);declarations=[]}copyDeclarations=true;unwrapped=true;child.selectors=mergeSelectors(rule,child);after=breakOut(child,after)}else if(child.type===\"atrule\"){if(declarations.length){after=pickDeclarations(rule.selector,declarations,after);declarations=[]}if(child.name===rootRuleName){unwrapped=true;atruleChilds(rule,child,true,child[rootRuleMergeSel]);after=breakOut(child,after)}else if(bubble[child.name]){copyDeclarations=true;unwrapped=true;atruleChilds(rule,child,true);after=breakOut(child,after)}else if(unwrap[child.name]){copyDeclarations=true;unwrapped=true;atruleChilds(rule,child,false);after=breakOut(child,after)}else if(copyDeclarations){declarations.push(child)}}else if(child.type===\"decl\"&&copyDeclarations){declarations.push(child)}});if(declarations.length){after=pickDeclarations(rule.selector,declarations,after)}if(unwrapped&&preserveEmpty!==true){rule.raws.semicolon=true;if(rule.nodes.length===0)rule.remove()}},RootExit(root){if(root[hasRootRule]){root.walkAtRules(rootRuleName,unwrapRootRule);root[hasRootRule]=false}}}};module.exports.postcss=true;\n})()\n","warnings":[],"map":{"version":3,"mappings":";kHAAA,KAAM,CAAE,KAAM,MAAO,EAAI,QAAQ,SAAS,EAC1C,IAAI,OAAS,QAAQ,yBAAyB,EAK9C,SAAS,MAAM,YAAa,KAAM,CAChC,IAAI,MACJ,GAAI,CACF,OAAO,QAAU,CACf,MAAQ,MACV,CAAC,EAAE,YAAY,WAAW,CAC5B,OAAS,EAAP,CACA,GAAI,YAAY,SAAS,GAAG,EAAG,CAC7B,MAAM,KAAO,KAAK,MAAM,kBAAkB,EAAI,CAChD,KAAO,CACL,MAAM,KAAO,KAAK,MAAM,EAAE,OAAO,EAAI,CACvC,CACF,CACA,OAAO,MAAM,GAAG,CAAC,CACnB,CAdS,sBAsBT,SAAS,yBAAyB,MAAO,OAAQ,CAC/C,IAAI,SAAW,MACf,MAAM,KAAK,MAAQ,CACjB,GAAI,KAAK,OAAS,UAAW,CAC3B,IAAI,aAAe,OAAO,MAAM,CAAC,CAAC,EAClC,GAAI,KAAK,QAAU,IAAK,CACtB,KAAK,YACH,MAAM,KAAK,MAAM,QAAQ,IAAK,aAAa,SAAS,CAAC,CAAC,CACxD,CACF,KAAO,CACL,KAAK,YAAY,YAAY,CAC/B,CACA,SAAW,IACb,SAAW,UAAW,MAAQ,KAAK,MAAO,CACxC,GAAI,yBAAyB,KAAM,MAAM,EAAG,CAC1C,SAAW,IACb,CACF,CACF,CAAC,EACD,OAAO,QACT,CApBS,4DAyBT,SAAS,eAAe,OAAQ,MAAO,CACrC,IAAI,OAAS,CAAC,EACd,OAAO,UAAU,QAAQ,KAAO,CAC9B,IAAI,WAAa,MAAM,IAAK,MAAM,EAElC,MAAM,UAAU,QAAQ,UAAY,CAClC,GAAI,CAAC,SAAU,CACb,MACF,CACA,IAAI,KAAO,MAAM,SAAU,KAAK,EAChC,IAAI,SAAW,yBAAyB,KAAM,UAAU,EACxD,GAAI,CAAC,SAAU,CACb,KAAK,QAAQ,OAAO,WAAW,CAAE,MAAO,GAAI,CAAC,CAAC,EAC9C,KAAK,QAAQ,WAAW,MAAM,CAAC,CAAC,CAAC,CACnC,CACA,OAAO,KAAK,KAAK,SAAS,CAAC,CAC7B,CAAC,CACH,CAAC,EACD,OAAO,MACT,CAnBS,wCAwBT,SAAS,SAAS,MAAO,MAAO,CAC9B,IAAI,KAAO,MAAM,KAAK,EACtB,MAAM,MAAM,KAAK,EACjB,MAAO,MAAQ,KAAK,OAAS,UAAW,CACtC,IAAI,SAAW,KAAK,KAAK,EACzB,MAAM,MAAM,IAAI,EAChB,KAAO,QACT,CACA,OAAO,KACT,CATS,4BAWT,SAAS,qBAAqB,OAAQ,CACpC,OAAO,gBAAS,aAAa,KAAM,OAAQ,SAAU,UAAY,SAAU,CACzE,IAAI,SAAW,CAAC,EAChB,OAAO,KAAK,OAAS,CACnB,GAAI,MAAM,OAAS,QAAU,SAAU,CACrC,GAAI,UAAW,CACb,MAAM,UAAY,eAAe,KAAM,KAAK,CAC9C,CACF,SAAW,MAAM,OAAS,UAAY,MAAM,MAAO,CACjD,GAAI,OAAO,MAAM,IAAI,EAAG,CACtB,aAAa,KAAM,MAAO,SAAS,CACrC,SAAW,OAAO,gBAAgB,IAAM,MAAO,CAC7C,SAAS,KAAK,KAAK,CACrB,CACF,KAAO,CACL,SAAS,KAAK,KAAK,CACrB,CACF,CAAC,EACD,GAAI,SAAU,CACZ,GAAI,SAAS,OAAQ,CACnB,IAAI,MAAQ,KAAK,MAAM,CAAE,MAAO,CAAC,CAAE,CAAC,EACpC,QAAS,SAAS,SAAU,CAC1B,MAAM,OAAO,KAAK,CACpB,CACA,OAAO,QAAQ,KAAK,CACtB,CACF,CACF,EA1BO,eA2BT,CA5BS,oDA8BT,SAAS,iBAAiB,SAAU,aAAc,MAAO,CACvD,IAAI,OAAS,IAAI,KAAK,CACpB,SACA,MAAO,CAAC,CACV,CAAC,EACD,OAAO,OAAO,YAAY,EAC1B,MAAM,MAAM,MAAM,EAClB,OAAO,MACT,CARS,4CAUT,SAAS,YAAY,SAAU,OAAQ,CACrC,IAAI,KAAO,CAAC,EACZ,QAAS,QAAQ,SAAU,CACzB,KAAK,IAAI,EAAI,IACf,CACA,GAAI,OAAQ,CACV,QAAS,QAAQ,OAAQ,CACvB,KAAK,KAAK,QAAQ,KAAM,EAAE,CAAC,EAAI,IACjC,CACF,CACA,OAAO,IACT,CAXS,kCAaT,SAAS,oBAAoB,OAAQ,CACnC,OAAS,OAAO,KAAK,EACrB,IAAI,WAAa,OAAO,MAAM,YAAY,EAC1C,GAAI,CAAC,WAAY,CACf,MAAO,CAAE,KAAM,QAAS,SAAU,MAAO,CAC3C,CACA,IAAI,KAAO,WAAW,CAAC,EAAE,MAAM,uBAAuB,EACtD,GAAI,KAAM,CACR,IAAI,UAAY,KAAK,CAAC,IAAM,OAC5B,IAAI,MAAQ,OAAO,YACjB,KAAK,CAAC,EACH,KAAK,EACL,MAAM,KAAK,EACX,IAAI,MAAQ,CAAC,KAAM,IAAI,CAAC,CAC7B,EACA,GAAI,WAAa,MAAM,IAAK,CAC1B,MAAO,CAAE,KAAM,MAAO,CACxB,CACA,IAAI,QAAU,aAAQ,CAAC,CAAC,MAAM,IAAI,EAApB,WACd,GAAI,MAAM,IAAK,CACb,QAAU,WAAM,KAAN,UACZ,SAAW,UAAW,CACpB,QAAU,aAAS,OAAS,MAAQ,MAAQ,CAAC,MAAM,IAAI,EAA7C,UACZ,CAEA,MAAO,CACL,KAAM,YACN,OACF,CACF,CAEA,MAAO,CAAE,KAAM,SAAU,CAC3B,CAhCS,kDAkCT,SAAS,iBAAiB,KAAM,CAC9B,IAAI,QAAU,CAAC,EACf,IAAI,OAAS,KAAK,OAElB,MAAO,QAAU,kBAAkB,OAAQ,CACzC,QAAQ,KAAK,MAAM,EACnB,OAAS,OAAO,MAClB,CACA,OAAO,OACT,CATS,4CAWT,SAAS,eAAe,KAAM,CAC5B,IAAI,QAAU,KAAK,eAAe,EAElC,GAAI,CAAC,QAAS,CACZ,KAAK,MAAM,KAAK,KAAK,CACvB,KAAO,CACL,IAAI,MAAQ,KAAK,MAEjB,IAAI,WACJ,IAAI,cAAgB,GACpB,IAAI,aACJ,IAAI,aACJ,IAAI,MAEJ,IAAI,QAAU,iBAAiB,IAAI,EACnC,QAAQ,QAAQ,CAAC,OAAQ,IAAM,CAC7B,GAAI,QAAQ,OAAO,IAAI,EAAG,CACxB,WAAa,OACb,cAAgB,EAChB,aAAe,KACjB,KAAO,CACL,IAAI,SAAW,MACf,MAAQ,OAAO,MAAM,CAAE,MAAO,CAAC,CAAE,CAAC,EAClC,UAAY,MAAM,OAAO,QAAQ,EACjC,aAAe,cAAgB,KACjC,CACF,CAAC,EAED,GAAI,CAAC,WAAY,CACf,KAAK,MAAM,KAAK,CAClB,SAAW,CAAC,aAAc,CACxB,WAAW,MAAM,KAAK,CACxB,KAAO,CACL,IAAI,KAAO,aACX,KAAK,OAAO,KAAK,EACjB,WAAW,MAAM,YAAY,CAC/B,CAEA,GAAI,KAAK,KAAK,GAAK,WAAY,CAC7B,IAAI,SACJ,QAAQ,MAAM,EAAG,cAAgB,CAAC,EAAE,QAAQ,CAAC,OAAQ,EAAG,MAAQ,CAC9D,IAAI,QAAU,SACd,SAAW,OAAO,MAAM,CAAE,MAAO,CAAC,CAAE,CAAC,EACrC,SAAW,SAAS,OAAO,OAAO,EAElC,IAAI,SAAW,CAAC,EAChB,IAAI,OAAS,IAAI,EAAI,CAAC,GAAK,KAC3B,IAAI,KAAO,OAAO,KAAK,EACvB,MAAO,KAAM,CACX,SAAS,KAAK,IAAI,EAClB,KAAO,KAAK,KAAK,CACnB,CACA,SAAS,OAAO,QAAQ,CAC1B,CAAC,EACD,WAAa,cAAgB,MAAM,MAAM,OAAS,CAAC,GAAG,MAAM,QAAQ,CACtE,CACF,CAEA,KAAK,OAAO,CACd,CA3DS,wCA6DT,MAAM,iBAAmB,OAAO,kBAAkB,EAClD,MAAM,gBAAkB,OAAO,iBAAiB,EAEhD,SAAS,kBAAkB,KAAM,CAC/B,GAAI,CAAE,MAAO,EAAI,KACjB,GAAI,CAAE,KAAM,SAAU,OAAQ,EAAI,oBAAoB,MAAM,EAC5D,GAAI,OAAS,UAAW,CACtB,MAAM,KAAK,MACT,YAAY,KAAK,kBAAkB,KAAK,UAAU,MAAM,GAC1D,CACF,CACA,GAAI,OAAS,SAAW,SAAU,CAChC,IAAI,cAAgB,IAAI,KAAK,CAAE,SAAU,MAAO,KAAK,KAAM,CAAC,EAC5D,KAAK,UAAU,EACf,KAAK,OAAO,aAAa,CAC3B,CACA,KAAK,eAAe,EAAI,QACxB,KAAK,gBAAgB,EAAI,QAAU,CAAC,QAAQ,KAAK,EAAI,OAAS,MAChE,CAfS,8CAiBT,MAAM,YAAc,OAAO,aAAa,EAExC,OAAO,QAAU,CAAC,KAAO,CAAC,IAAM,CAC9B,IAAI,OAAS,YACX,CAAC,QAAS,WAAY,QAAS,WAAW,EAC1C,KAAK,MACP,EACA,IAAI,aAAe,qBAAqB,MAAM,EAC9C,IAAI,OAAS,YACX,CACE,WACA,YACA,YACA,oBACA,gBACF,EACA,KAAK,MACP,EACA,IAAI,cAAgB,KAAK,cAAgB,WAAW,QAAQ,KAAM,EAAE,EACpE,IAAI,cAAgB,KAAK,cAEzB,MAAO,CACL,cAAe,iBAEf,KAAK,KAAM,CACT,KAAK,YAAY,aAAc,MAAQ,CACrC,kBAAkB,IAAI,EACtB,KAAK,WAAW,EAAI,IACtB,CAAC,CACH,EAEA,KAAK,KAAM,CACT,IAAI,UAAY,MAChB,IAAI,MAAQ,KACZ,IAAI,iBAAmB,MACvB,IAAI,aAAe,CAAC,EAEpB,KAAK,KAAK,OAAS,CACjB,GAAI,MAAM,OAAS,OAAQ,CACzB,GAAI,aAAa,OAAQ,CACvB,MAAQ,iBAAiB,KAAK,SAAU,aAAc,KAAK,EAC3D,aAAe,CAAC,CAClB,CAEA,iBAAmB,KACnB,UAAY,KACZ,MAAM,UAAY,eAAe,KAAM,KAAK,EAC5C,MAAQ,SAAS,MAAO,KAAK,CAC/B,SAAW,MAAM,OAAS,SAAU,CAClC,GAAI,aAAa,OAAQ,CACvB,MAAQ,iBAAiB,KAAK,SAAU,aAAc,KAAK,EAC3D,aAAe,CAAC,CAClB,CACA,GAAI,MAAM,OAAS,aAAc,CAC/B,UAAY,KACZ,aAAa,KAAM,MAAO,KAAM,MAAM,gBAAgB,CAAC,EACvD,MAAQ,SAAS,MAAO,KAAK,CAC/B,SAAW,OAAO,MAAM,IAAI,EAAG,CAC7B,iBAAmB,KACnB,UAAY,KACZ,aAAa,KAAM,MAAO,IAAI,EAC9B,MAAQ,SAAS,MAAO,KAAK,CAC/B,SAAW,OAAO,MAAM,IAAI,EAAG,CAC7B,iBAAmB,KACnB,UAAY,KACZ,aAAa,KAAM,MAAO,KAAK,EAC/B,MAAQ,SAAS,MAAO,KAAK,CAC/B,SAAW,iBAAkB,CAC3B,aAAa,KAAK,KAAK,CACzB,CACF,SAAW,MAAM,OAAS,QAAU,iBAAkB,CACpD,aAAa,KAAK,KAAK,CACzB,CACF,CAAC,EAED,GAAI,aAAa,OAAQ,CACvB,MAAQ,iBAAiB,KAAK,SAAU,aAAc,KAAK,CAC7D,CAEA,GAAI,WAAa,gBAAkB,KAAM,CACvC,KAAK,KAAK,UAAY,KACtB,GAAI,KAAK,MAAM,SAAW,EAAG,KAAK,OAAO,CAC3C,CACF,EAEA,SAAS,KAAM,CACb,GAAI,KAAK,WAAW,EAAG,CACrB,KAAK,YAAY,aAAc,cAAc,EAC7C,KAAK,WAAW,EAAI,KACtB,CACF,CACF,CACF,EACA,OAAO,QAAQ,QAAU","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/postcss-nested@6.0.1_postcss@8.4.24/node_modules/postcss-nested/index.js"],"sourcesContent":["const { Rule, AtRule } = require('postcss')\nlet parser = require('postcss-selector-parser')\n\n/**\n * Run a selector string through postcss-selector-parser\n */\nfunction parse(rawSelector, rule) {\n  let nodes\n  try {\n    parser(parsed => {\n      nodes = parsed\n    }).processSync(rawSelector)\n  } catch (e) {\n    if (rawSelector.includes(':')) {\n      throw rule ? rule.error('Missed semicolon') : e\n    } else {\n      throw rule ? rule.error(e.message) : e\n    }\n  }\n  return nodes.at(0)\n}\n\n/**\n * Replaces the \"&\" token in a node's selector with the parent selector\n * similar to what SCSS does.\n *\n * Mutates the nodes list\n */\nfunction interpolateAmpInSelector(nodes, parent) {\n  let replaced = false\n  nodes.each(node => {\n    if (node.type === 'nesting') {\n      let clonedParent = parent.clone({})\n      if (node.value !== '&') {\n        node.replaceWith(\n          parse(node.value.replace('&', clonedParent.toString()))\n        )\n      } else {\n        node.replaceWith(clonedParent)\n      }\n      replaced = true\n    } else if ('nodes' in node && node.nodes) {\n      if (interpolateAmpInSelector(node, parent)) {\n        replaced = true\n      }\n    }\n  })\n  return replaced\n}\n\n/**\n * Combines parent and child selectors, in a SCSS-like way\n */\nfunction mergeSelectors(parent, child) {\n  let merged = []\n  parent.selectors.forEach(sel => {\n    let parentNode = parse(sel, parent)\n\n    child.selectors.forEach(selector => {\n      if (!selector) {\n        return\n      }\n      let node = parse(selector, child)\n      let replaced = interpolateAmpInSelector(node, parentNode)\n      if (!replaced) {\n        node.prepend(parser.combinator({ value: ' ' }))\n        node.prepend(parentNode.clone({}))\n      }\n      merged.push(node.toString())\n    })\n  })\n  return merged\n}\n\n/**\n * Move a child and its preceeding comment(s) to after \"after\"\n */\nfunction breakOut(child, after) {\n  let prev = child.prev()\n  after.after(child)\n  while (prev && prev.type === 'comment') {\n    let nextPrev = prev.prev()\n    after.after(prev)\n    prev = nextPrev\n  }\n  return child\n}\n\nfunction createFnAtruleChilds(bubble) {\n  return function atruleChilds(rule, atrule, bubbling, mergeSels = bubbling) {\n    let children = []\n    atrule.each(child => {\n      if (child.type === 'rule' && bubbling) {\n        if (mergeSels) {\n          child.selectors = mergeSelectors(rule, child)\n        }\n      } else if (child.type === 'atrule' && child.nodes) {\n        if (bubble[child.name]) {\n          atruleChilds(rule, child, mergeSels)\n        } else if (atrule[rootRuleMergeSel] !== false) {\n          children.push(child)\n        }\n      } else {\n        children.push(child)\n      }\n    })\n    if (bubbling) {\n      if (children.length) {\n        let clone = rule.clone({ nodes: [] })\n        for (let child of children) {\n          clone.append(child)\n        }\n        atrule.prepend(clone)\n      }\n    }\n  }\n}\n\nfunction pickDeclarations(selector, declarations, after) {\n  let parent = new Rule({\n    selector,\n    nodes: []\n  })\n  parent.append(declarations)\n  after.after(parent)\n  return parent\n}\n\nfunction atruleNames(defaults, custom) {\n  let list = {}\n  for (let name of defaults) {\n    list[name] = true\n  }\n  if (custom) {\n    for (let name of custom) {\n      list[name.replace(/^@/, '')] = true\n    }\n  }\n  return list\n}\n\nfunction parseRootRuleParams(params) {\n  params = params.trim()\n  let braceBlock = params.match(/^\\((.*)\\)$/)\n  if (!braceBlock) {\n    return { type: 'basic', selector: params }\n  }\n  let bits = braceBlock[1].match(/^(with(?:out)?):(.+)$/)\n  if (bits) {\n    let allowlist = bits[1] === 'with'\n    let rules = Object.fromEntries(\n      bits[2]\n        .trim()\n        .split(/\\s+/)\n        .map(name => [name, true])\n    )\n    if (allowlist && rules.all) {\n      return { type: 'noop' }\n    }\n    let escapes = rule => !!rules[rule]\n    if (rules.all) {\n      escapes = () => true\n    } else if (allowlist) {\n      escapes = rule => (rule === 'all' ? false : !rules[rule])\n    }\n\n    return {\n      type: 'withrules',\n      escapes\n    }\n  }\n  // Unrecognized brace block\n  return { type: 'unknown' }\n}\n\nfunction getAncestorRules(leaf) {\n  let lineage = []\n  let parent = leaf.parent\n\n  while (parent && parent instanceof AtRule) {\n    lineage.push(parent)\n    parent = parent.parent\n  }\n  return lineage\n}\n\nfunction unwrapRootRule(rule) {\n  let escapes = rule[rootRuleEscapes]\n\n  if (!escapes) {\n    rule.after(rule.nodes)\n  } else {\n    let nodes = rule.nodes\n\n    let topEscaped\n    let topEscapedIdx = -1\n    let breakoutLeaf\n    let breakoutRoot\n    let clone\n\n    let lineage = getAncestorRules(rule)\n    lineage.forEach((parent, i) => {\n      if (escapes(parent.name)) {\n        topEscaped = parent\n        topEscapedIdx = i\n        breakoutRoot = clone\n      } else {\n        let oldClone = clone\n        clone = parent.clone({ nodes: [] })\n        oldClone && clone.append(oldClone)\n        breakoutLeaf = breakoutLeaf || clone\n      }\n    })\n\n    if (!topEscaped) {\n      rule.after(nodes)\n    } else if (!breakoutRoot) {\n      topEscaped.after(nodes)\n    } else {\n      let leaf = breakoutLeaf\n      leaf.append(nodes)\n      topEscaped.after(breakoutRoot)\n    }\n\n    if (rule.next() && topEscaped) {\n      let restRoot\n      lineage.slice(0, topEscapedIdx + 1).forEach((parent, i, arr) => {\n        let oldRoot = restRoot\n        restRoot = parent.clone({ nodes: [] })\n        oldRoot && restRoot.append(oldRoot)\n\n        let nextSibs = []\n        let _child = arr[i - 1] || rule\n        let next = _child.next()\n        while (next) {\n          nextSibs.push(next)\n          next = next.next()\n        }\n        restRoot.append(nextSibs)\n      })\n      restRoot && (breakoutRoot || nodes[nodes.length - 1]).after(restRoot)\n    }\n  }\n\n  rule.remove()\n}\n\nconst rootRuleMergeSel = Symbol('rootRuleMergeSel')\nconst rootRuleEscapes = Symbol('rootRuleEscapes')\n\nfunction normalizeRootRule(rule) {\n  let { params } = rule\n  let { type, selector, escapes } = parseRootRuleParams(params)\n  if (type === 'unknown') {\n    throw rule.error(\n      `Unknown @${rule.name} parameter ${JSON.stringify(params)}`\n    )\n  }\n  if (type === 'basic' && selector) {\n    let selectorBlock = new Rule({ selector, nodes: rule.nodes })\n    rule.removeAll()\n    rule.append(selectorBlock)\n  }\n  rule[rootRuleEscapes] = escapes\n  rule[rootRuleMergeSel] = escapes ? !escapes('all') : type === 'noop'\n}\n\nconst hasRootRule = Symbol('hasRootRule')\n\nmodule.exports = (opts = {}) => {\n  let bubble = atruleNames(\n    ['media', 'supports', 'layer', 'container'],\n    opts.bubble\n  )\n  let atruleChilds = createFnAtruleChilds(bubble)\n  let unwrap = atruleNames(\n    [\n      'document',\n      'font-face',\n      'keyframes',\n      '-webkit-keyframes',\n      '-moz-keyframes'\n    ],\n    opts.unwrap\n  )\n  let rootRuleName = (opts.rootRuleName || 'at-root').replace(/^@/, '')\n  let preserveEmpty = opts.preserveEmpty\n\n  return {\n    postcssPlugin: 'postcss-nested',\n\n    Once(root) {\n      root.walkAtRules(rootRuleName, node => {\n        normalizeRootRule(node)\n        root[hasRootRule] = true\n      })\n    },\n\n    Rule(rule) {\n      let unwrapped = false\n      let after = rule\n      let copyDeclarations = false\n      let declarations = []\n\n      rule.each(child => {\n        if (child.type === 'rule') {\n          if (declarations.length) {\n            after = pickDeclarations(rule.selector, declarations, after)\n            declarations = []\n          }\n\n          copyDeclarations = true\n          unwrapped = true\n          child.selectors = mergeSelectors(rule, child)\n          after = breakOut(child, after)\n        } else if (child.type === 'atrule') {\n          if (declarations.length) {\n            after = pickDeclarations(rule.selector, declarations, after)\n            declarations = []\n          }\n          if (child.name === rootRuleName) {\n            unwrapped = true\n            atruleChilds(rule, child, true, child[rootRuleMergeSel])\n            after = breakOut(child, after)\n          } else if (bubble[child.name]) {\n            copyDeclarations = true\n            unwrapped = true\n            atruleChilds(rule, child, true)\n            after = breakOut(child, after)\n          } else if (unwrap[child.name]) {\n            copyDeclarations = true\n            unwrapped = true\n            atruleChilds(rule, child, false)\n            after = breakOut(child, after)\n          } else if (copyDeclarations) {\n            declarations.push(child)\n          }\n        } else if (child.type === 'decl' && copyDeclarations) {\n          declarations.push(child)\n        }\n      })\n\n      if (declarations.length) {\n        after = pickDeclarations(rule.selector, declarations, after)\n      }\n\n      if (unwrapped && preserveEmpty !== true) {\n        rule.raws.semicolon = true\n        if (rule.nodes.length === 0) rule.remove()\n      }\n    },\n\n    RootExit(root) {\n      if (root[hasRootRule]) {\n        root.walkAtRules(rootRuleName, unwrapRootRule)\n        root[hasRootRule] = false\n      }\n    }\n  }\n}\nmodule.exports.postcss = true\n"]}}