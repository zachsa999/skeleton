{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});const events_1=require(\"events\");const fsScandir=require(\"@nodelib/fs.scandir\");const fastq=require(\"fastq\");const common=require(\"./common\");const reader_1=require(\"./reader\");class AsyncReader extends reader_1.default{constructor(_root,_settings){super(_root,_settings);this._settings=_settings;this._scandir=fsScandir.scandir;this._emitter=new events_1.EventEmitter;this._queue=fastq(this._worker.bind(this),this._settings.concurrency);this._isFatalError=false;this._isDestroyed=false;this._queue.drain=()=>{if(!this._isFatalError){this._emitter.emit(\"end\")}}}read(){this._isFatalError=false;this._isDestroyed=false;setImmediate(()=>{this._pushToQueue(this._root,this._settings.basePath)});return this._emitter}get isDestroyed(){return this._isDestroyed}destroy(){if(this._isDestroyed){throw new Error(\"The reader is already destroyed\")}this._isDestroyed=true;this._queue.killAndDrain()}onEntry(callback){this._emitter.on(\"entry\",callback)}onError(callback){this._emitter.once(\"error\",callback)}onEnd(callback){this._emitter.once(\"end\",callback)}_pushToQueue(directory,base){const queueItem={directory,base};this._queue.push(queueItem,error=>{if(error!==null){this._handleError(error)}})}_worker(item,done){this._scandir(item.directory,this._settings.fsScandirSettings,(error,entries)=>{if(error!==null){done(error,void 0);return}for(const entry of entries){this._handleEntry(entry,item.base)}done(null,void 0)})}_handleError(error){if(this._isDestroyed||!common.isFatalError(this._settings,error)){return}this._isFatalError=true;this._isDestroyed=true;this._emitter.emit(\"error\",error)}_handleEntry(entry,base){if(this._isDestroyed||this._isFatalError){return}const fullpath=entry.path;if(base!==void 0){entry.path=common.joinPathSegments(base,entry.name,this._settings.pathSegmentSeparator)}if(common.isAppliedFilter(this._settings.entryFilter,entry)){this._emitEntry(entry)}if(entry.dirent.isDirectory()&&common.isAppliedFilter(this._settings.deepFilter,entry)){this._pushToQueue(fullpath,base===void 0?void 0:entry.path)}}_emitEntry(entry){this._emitter.emit(\"entry\",entry)}}__name(AsyncReader,\"AsyncReader\");exports.default=AsyncReader;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CAAE,MAAO,IAAK,CAAC,EAC5D,MAAM,SAAW,QAAQ,QAAQ,EACjC,MAAM,UAAY,QAAQ,qBAAqB,EAC/C,MAAM,MAAQ,QAAQ,OAAO,EAC7B,MAAM,OAAS,QAAQ,UAAU,EACjC,MAAM,SAAW,QAAQ,UAAU,EACnC,MAAM,oBAAoB,SAAS,OAAQ,CACvC,YAAY,MAAO,UAAW,CAC1B,MAAM,MAAO,SAAS,EACtB,KAAK,UAAY,UACjB,KAAK,SAAW,UAAU,QAC1B,KAAK,SAAW,IAAI,SAAS,aAC7B,KAAK,OAAS,MAAM,KAAK,QAAQ,KAAK,IAAI,EAAG,KAAK,UAAU,WAAW,EACvE,KAAK,cAAgB,MACrB,KAAK,aAAe,MACpB,KAAK,OAAO,MAAQ,IAAM,CACtB,GAAI,CAAC,KAAK,cAAe,CACrB,KAAK,SAAS,KAAK,KAAK,CAC5B,CACJ,CACJ,CACA,MAAO,CACH,KAAK,cAAgB,MACrB,KAAK,aAAe,MACpB,aAAa,IAAM,CACf,KAAK,aAAa,KAAK,MAAO,KAAK,UAAU,QAAQ,CACzD,CAAC,EACD,OAAO,KAAK,QAChB,CACA,IAAI,aAAc,CACd,OAAO,KAAK,YAChB,CACA,SAAU,CACN,GAAI,KAAK,aAAc,CACnB,MAAM,IAAI,MAAM,iCAAiC,CACrD,CACA,KAAK,aAAe,KACpB,KAAK,OAAO,aAAa,CAC7B,CACA,QAAQ,SAAU,CACd,KAAK,SAAS,GAAG,QAAS,QAAQ,CACtC,CACA,QAAQ,SAAU,CACd,KAAK,SAAS,KAAK,QAAS,QAAQ,CACxC,CACA,MAAM,SAAU,CACZ,KAAK,SAAS,KAAK,MAAO,QAAQ,CACtC,CACA,aAAa,UAAW,KAAM,CAC1B,MAAM,UAAY,CAAE,UAAW,IAAK,EACpC,KAAK,OAAO,KAAK,UAAY,OAAU,CACnC,GAAI,QAAU,KAAM,CAChB,KAAK,aAAa,KAAK,CAC3B,CACJ,CAAC,CACL,CACA,QAAQ,KAAM,KAAM,CAChB,KAAK,SAAS,KAAK,UAAW,KAAK,UAAU,kBAAmB,CAAC,MAAO,UAAY,CAChF,GAAI,QAAU,KAAM,CAChB,KAAK,MAAO,MAAS,EACrB,MACJ,CACA,UAAW,SAAS,QAAS,CACzB,KAAK,aAAa,MAAO,KAAK,IAAI,CACtC,CACA,KAAK,KAAM,MAAS,CACxB,CAAC,CACL,CACA,aAAa,MAAO,CAChB,GAAI,KAAK,cAAgB,CAAC,OAAO,aAAa,KAAK,UAAW,KAAK,EAAG,CAClE,MACJ,CACA,KAAK,cAAgB,KACrB,KAAK,aAAe,KACpB,KAAK,SAAS,KAAK,QAAS,KAAK,CACrC,CACA,aAAa,MAAO,KAAM,CACtB,GAAI,KAAK,cAAgB,KAAK,cAAe,CACzC,MACJ,CACA,MAAM,SAAW,MAAM,KACvB,GAAI,OAAS,OAAW,CACpB,MAAM,KAAO,OAAO,iBAAiB,KAAM,MAAM,KAAM,KAAK,UAAU,oBAAoB,CAC9F,CACA,GAAI,OAAO,gBAAgB,KAAK,UAAU,YAAa,KAAK,EAAG,CAC3D,KAAK,WAAW,KAAK,CACzB,CACA,GAAI,MAAM,OAAO,YAAY,GAAK,OAAO,gBAAgB,KAAK,UAAU,WAAY,KAAK,EAAG,CACxF,KAAK,aAAa,SAAU,OAAS,OAAY,OAAY,MAAM,IAAI,CAC3E,CACJ,CACA,WAAW,MAAO,CACd,KAAK,SAAS,KAAK,QAAS,KAAK,CACrC,CACJ,CAxFM,kCAyFN,QAAQ,QAAU","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/async.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst fsScandir = require(\"@nodelib/fs.scandir\");\nconst fastq = require(\"fastq\");\nconst common = require(\"./common\");\nconst reader_1 = require(\"./reader\");\nclass AsyncReader extends reader_1.default {\n    constructor(_root, _settings) {\n        super(_root, _settings);\n        this._settings = _settings;\n        this._scandir = fsScandir.scandir;\n        this._emitter = new events_1.EventEmitter();\n        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);\n        this._isFatalError = false;\n        this._isDestroyed = false;\n        this._queue.drain = () => {\n            if (!this._isFatalError) {\n                this._emitter.emit('end');\n            }\n        };\n    }\n    read() {\n        this._isFatalError = false;\n        this._isDestroyed = false;\n        setImmediate(() => {\n            this._pushToQueue(this._root, this._settings.basePath);\n        });\n        return this._emitter;\n    }\n    get isDestroyed() {\n        return this._isDestroyed;\n    }\n    destroy() {\n        if (this._isDestroyed) {\n            throw new Error('The reader is already destroyed');\n        }\n        this._isDestroyed = true;\n        this._queue.killAndDrain();\n    }\n    onEntry(callback) {\n        this._emitter.on('entry', callback);\n    }\n    onError(callback) {\n        this._emitter.once('error', callback);\n    }\n    onEnd(callback) {\n        this._emitter.once('end', callback);\n    }\n    _pushToQueue(directory, base) {\n        const queueItem = { directory, base };\n        this._queue.push(queueItem, (error) => {\n            if (error !== null) {\n                this._handleError(error);\n            }\n        });\n    }\n    _worker(item, done) {\n        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {\n            if (error !== null) {\n                done(error, undefined);\n                return;\n            }\n            for (const entry of entries) {\n                this._handleEntry(entry, item.base);\n            }\n            done(null, undefined);\n        });\n    }\n    _handleError(error) {\n        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {\n            return;\n        }\n        this._isFatalError = true;\n        this._isDestroyed = true;\n        this._emitter.emit('error', error);\n    }\n    _handleEntry(entry, base) {\n        if (this._isDestroyed || this._isFatalError) {\n            return;\n        }\n        const fullpath = entry.path;\n        if (base !== undefined) {\n            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\n        }\n        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {\n            this._emitEntry(entry);\n        }\n        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {\n            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);\n        }\n    }\n    _emitEntry(entry) {\n        this._emitter.emit('entry', entry);\n    }\n}\nexports.default = AsyncReader;\n"]}}