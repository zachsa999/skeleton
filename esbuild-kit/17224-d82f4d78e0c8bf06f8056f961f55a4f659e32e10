{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});Object.defineProperty(exports,\"Offsets\",{enumerable:true,get:function(){return Offsets}});const _bigSign=_interop_require_default(require(\"../util/bigSign\"));const _remapbitfield=require(\"./remap-bitfield.js\");function _interop_require_default(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interop_require_default,\"_interop_require_default\");class Offsets{constructor(){this.offsets={defaults:0n,base:0n,components:0n,utilities:0n,variants:0n,user:0n};this.layerPositions={defaults:0n,base:1n,components:2n,utilities:3n,user:4n,variants:5n};this.reservedVariantBits=0n;this.variantOffsets=new Map}create(layer){return{layer,parentLayer:layer,arbitrary:0n,variants:0n,parallelIndex:0n,index:this.offsets[layer]++,options:[]}}arbitraryProperty(){return{...this.create(\"utilities\"),arbitrary:1n}}forVariant(variant,index=0){let offset=this.variantOffsets.get(variant);if(offset===void 0){throw new Error(`Cannot find offset for unknown variant ${variant}`)}return{...this.create(\"variants\"),variants:offset<<BigInt(index)}}applyVariantOffset(rule,variant,options){options.variant=variant.variants;return{...rule,layer:\"variants\",parentLayer:rule.layer===\"variants\"?rule.parentLayer:rule.layer,variants:rule.variants|variant.variants,options:options.sort?[].concat(options,rule.options):rule.options,parallelIndex:max([rule.parallelIndex,variant.parallelIndex])}}applyParallelOffset(offset,parallelIndex){return{...offset,parallelIndex:BigInt(parallelIndex)}}recordVariants(variants,getLength){for(let variant of variants){this.recordVariant(variant,getLength(variant))}}recordVariant(variant,fnCount=1){this.variantOffsets.set(variant,1n<<this.reservedVariantBits);this.reservedVariantBits+=BigInt(fnCount);return{...this.create(\"variants\"),variants:this.variantOffsets.get(variant)}}compare(a,b){if(a.layer!==b.layer){return this.layerPositions[a.layer]-this.layerPositions[b.layer]}if(a.parentLayer!==b.parentLayer){return this.layerPositions[a.parentLayer]-this.layerPositions[b.parentLayer]}for(let aOptions of a.options){for(let bOptions of b.options){if(aOptions.id!==bOptions.id)continue;if(!aOptions.sort||!bOptions.sort)continue;var _max;let maxFnVariant=(_max=max([aOptions.variant,bOptions.variant]))!==null&&_max!==void 0?_max:0n;let mask=~(maxFnVariant|maxFnVariant-1n);let aVariantsAfterFn=a.variants&mask;let bVariantsAfterFn=b.variants&mask;if(aVariantsAfterFn!==bVariantsAfterFn){continue}let result=aOptions.sort({value:aOptions.value,modifier:aOptions.modifier},{value:bOptions.value,modifier:bOptions.modifier});if(result!==0)return result}}if(a.variants!==b.variants){return a.variants-b.variants}if(a.parallelIndex!==b.parallelIndex){return a.parallelIndex-b.parallelIndex}if(a.arbitrary!==b.arbitrary){return a.arbitrary-b.arbitrary}return a.index-b.index}recalculateVariantOffsets(){let variants=Array.from(this.variantOffsets.entries()).filter(([v])=>v.startsWith(\"[\")).sort(([a],[z])=>fastCompare(a,z));let newOffsets=variants.map(([,offset])=>offset).sort((a,z)=>(0,_bigSign.default)(a-z));let mapping=variants.map(([,oldOffset],i)=>[oldOffset,newOffsets[i]]);return mapping.filter(([a,z])=>a!==z)}remapArbitraryVariantOffsets(list){let mapping=this.recalculateVariantOffsets();if(mapping.length===0){return list}return list.map(item=>{let[offset,rule]=item;offset={...offset,variants:(0,_remapbitfield.remapBitfield)(offset.variants,mapping)};return[offset,rule]})}sort(list){list=this.remapArbitraryVariantOffsets(list);return list.sort(([a],[b])=>(0,_bigSign.default)(this.compare(a,b)))}}__name(Offsets,\"Offsets\");function max(nums){let max2=null;for(const num of nums){max2=max2!==null&&max2!==void 0?max2:num;max2=max2>num?max2:num}return max2}__name(max,\"max\");function fastCompare(a,b){let aLen=a.length;let bLen=b.length;let minLen=aLen<bLen?aLen:bLen;for(let i=0;i<minLen;i++){let cmp=a.charCodeAt(i)-b.charCodeAt(i);if(cmp!==0)return cmp}return aLen-bLen}__name(fastCompare,\"fastCompare\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAEA,OAAO,eAAe,QAAS,aAAc,CACzC,MAAO,IACX,CAAC,EACD,OAAO,eAAe,QAAS,UAAW,CACtC,WAAY,KACZ,IAAK,UAAW,CACZ,OAAO,OACX,CACJ,CAAC,EACD,MAAM,SAAyB,yBAAyB,QAAQ,iBAAiB,CAAC,EAClF,MAAM,eAAiB,QAAQ,qBAAqB,EACpD,SAAS,yBAAyB,IAAK,CACnC,OAAO,KAAO,IAAI,WAAa,IAAM,CACjC,QAAS,GACb,CACJ,CAJS,4DAKT,MAAM,OAAQ,CACV,aAAa,CAKT,KAAK,QAAU,CACX,SAAU,GACV,KAAM,GACN,WAAY,GACZ,UAAW,GACX,SAAU,GACV,KAAM,EACV,EAKA,KAAK,eAAiB,CAClB,SAAU,GACV,KAAM,GACN,WAAY,GACZ,UAAW,GAGX,KAAM,GACN,SAAU,EACd,EAKA,KAAK,oBAAsB,GAK3B,KAAK,eAAiB,IAAI,GAC9B,CAIE,OAAO,MAAO,CACZ,MAAO,CACH,MACA,YAAa,MACb,UAAW,GACX,SAAU,GACV,cAAe,GACf,MAAO,KAAK,QAAQ,KAAK,IACzB,QAAS,CAAC,CACd,CACJ,CAGE,mBAAoB,CAClB,MAAO,CACH,GAAG,KAAK,OAAO,WAAW,EAC1B,UAAW,EACf,CACJ,CAOE,WAAW,QAAS,MAAQ,EAAG,CAC7B,IAAI,OAAS,KAAK,eAAe,IAAI,OAAO,EAC5C,GAAI,SAAW,OAAW,CACtB,MAAM,IAAI,MAAM,0CAA0C,SAAS,CACvE,CACA,MAAO,CACH,GAAG,KAAK,OAAO,UAAU,EACzB,SAAU,QAAU,OAAO,KAAK,CACpC,CACJ,CAME,mBAAmB,KAAM,QAAS,QAAS,CACzC,QAAQ,QAAU,QAAQ,SAC1B,MAAO,CACH,GAAG,KACH,MAAO,WACP,YAAa,KAAK,QAAU,WAAa,KAAK,YAAc,KAAK,MACjE,SAAU,KAAK,SAAW,QAAQ,SAClC,QAAS,QAAQ,KAAO,CAAC,EAAE,OAAO,QAAS,KAAK,OAAO,EAAI,KAAK,QAIhE,cAAe,IAAI,CACf,KAAK,cACL,QAAQ,aACZ,CAAC,CACL,CACJ,CAKE,oBAAoB,OAAQ,cAAe,CACzC,MAAO,CACH,GAAG,OACH,cAAe,OAAO,aAAa,CACvC,CACJ,CAUE,eAAe,SAAU,UAAW,CAClC,QAAS,WAAW,SAAS,CACzB,KAAK,cAAc,QAAS,UAAU,OAAO,CAAC,CAClD,CACJ,CAOE,cAAc,QAAS,QAAU,EAAG,CAClC,KAAK,eAAe,IAAI,QAAS,IAAM,KAAK,mBAAmB,EAQ/D,KAAK,qBAAuB,OAAO,OAAO,EAC1C,MAAO,CACH,GAAG,KAAK,OAAO,UAAU,EACzB,SAAU,KAAK,eAAe,IAAI,OAAO,CAC7C,CACJ,CAKE,QAAQ,EAAG,EAAG,CAEZ,GAAI,EAAE,QAAU,EAAE,MAAO,CACrB,OAAO,KAAK,eAAe,EAAE,KAAK,EAAI,KAAK,eAAe,EAAE,KAAK,CACrE,CAGA,GAAI,EAAE,cAAgB,EAAE,YAAa,CACjC,OAAO,KAAK,eAAe,EAAE,WAAW,EAAI,KAAK,eAAe,EAAE,WAAW,CACjF,CAEA,QAAS,YAAY,EAAE,QAAQ,CAC3B,QAAS,YAAY,EAAE,QAAQ,CAC3B,GAAI,SAAS,KAAO,SAAS,GAAI,SACjC,GAAI,CAAC,SAAS,MAAQ,CAAC,SAAS,KAAM,SACtC,IAAI,KACJ,IAAI,cAAgB,KAAO,IAAI,CAC3B,SAAS,QACT,SAAS,OACb,CAAC,KAAO,MAAQ,OAAS,OAAS,KAAO,GAEzC,IAAI,KAAO,EAAE,aAAe,aAAe,IAC3C,IAAI,iBAAmB,EAAE,SAAW,KACpC,IAAI,iBAAmB,EAAE,SAAW,KAEpC,GAAI,mBAAqB,iBAAkB,CACvC,QACJ,CACA,IAAI,OAAS,SAAS,KAAK,CACvB,MAAO,SAAS,MAChB,SAAU,SAAS,QACvB,EAAG,CACC,MAAO,SAAS,MAChB,SAAU,SAAS,QACvB,CAAC,EACD,GAAI,SAAW,EAAG,OAAO,MAC7B,CACJ,CAEA,GAAI,EAAE,WAAa,EAAE,SAAU,CAC3B,OAAO,EAAE,SAAW,EAAE,QAC1B,CAEA,GAAI,EAAE,gBAAkB,EAAE,cAAe,CACrC,OAAO,EAAE,cAAgB,EAAE,aAC/B,CAEA,GAAI,EAAE,YAAc,EAAE,UAAW,CAC7B,OAAO,EAAE,UAAY,EAAE,SAC3B,CAEA,OAAO,EAAE,MAAQ,EAAE,KACvB,CAOE,2BAA4B,CAE1B,IAAI,SAAW,MAAM,KAAK,KAAK,eAAe,QAAQ,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE,WAAW,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,EAAG,CAAC,CAAC,IAAI,YAAY,EAAG,CAAC,CAAC,EAI5H,IAAI,WAAa,SAAS,IAAI,CAAC,CAAC,CAAE,MAAM,IAAI,MAAM,EAAE,KAAK,CAAC,EAAG,KAAK,EAAG,SAAS,SAAS,EAAI,CAAC,CAAC,EAE3D,IAAI,QAAU,SAAS,IAAI,CAAC,CAAC,CAAE,SAAS,EAAG,IAAI,CACzE,UACA,WAAW,CAAC,CAChB,CAAC,EAGL,OAAO,QAAQ,OAAO,CAAC,CAAC,EAAG,CAAC,IAAI,IAAM,CAAC,CAC3C,CAKE,6BAA6B,KAAM,CACjC,IAAI,QAAU,KAAK,0BAA0B,EAG7C,GAAI,QAAQ,SAAW,EAAG,CACtB,OAAO,IACX,CAEA,OAAO,KAAK,IAAK,MAAO,CACpB,GAAI,CAAC,OAAQ,IAAI,EAAI,KACrB,OAAS,CACL,GAAG,OACH,UAAW,EAAG,eAAe,eAAe,OAAO,SAAU,OAAO,CACxE,EACA,MAAO,CACH,OACA,IACJ,CACJ,CAAC,CACL,CAKE,KAAK,KAAM,CACT,KAAO,KAAK,6BAA6B,IAAI,EAC7C,OAAO,KAAK,KAAK,CAAC,CAAC,CAAC,EAAG,CAAC,CAAC,KAAK,EAAG,SAAS,SAAS,KAAK,QAAQ,EAAG,CAAC,CAAC,CAAC,CAC1E,CACJ,CA/PM,0BAoQF,SAAS,IAAI,KAAM,CACnB,IAAIA,KAAM,KACV,UAAW,OAAO,KAAK,CACnBA,KAAMA,OAAQ,MAAQA,OAAQ,OAASA,KAAM,IAC7CA,KAAMA,KAAM,IAAMA,KAAM,GAC5B,CACA,OAAOA,IACX,CAPa,kBAkBT,SAAS,YAAY,EAAG,EAAG,CAC3B,IAAI,KAAO,EAAE,OACb,IAAI,KAAO,EAAE,OACb,IAAI,OAAS,KAAO,KAAO,KAAO,KAClC,QAAQ,EAAI,EAAG,EAAI,OAAQ,IAAI,CAC3B,IAAI,IAAM,EAAE,WAAW,CAAC,EAAI,EAAE,WAAW,CAAC,EAC1C,GAAI,MAAQ,EAAG,OAAO,GAC1B,CACA,OAAO,KAAO,IAClB,CATa","names":["max"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/lib/offsets.js"],"sourcesContent":["// @ts-check\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"Offsets\", {\n    enumerable: true,\n    get: function() {\n        return Offsets;\n    }\n});\nconst _bigSign = /*#__PURE__*/ _interop_require_default(require(\"../util/bigSign\"));\nconst _remapbitfield = require(\"./remap-bitfield.js\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nclass Offsets {\n    constructor(){\n        /**\n     * Offsets for the next rule in a given layer\n     *\n     * @type {Record<Layer, bigint>}\n     */ this.offsets = {\n            defaults: 0n,\n            base: 0n,\n            components: 0n,\n            utilities: 0n,\n            variants: 0n,\n            user: 0n\n        };\n        /**\n     * Positions for a given layer\n     *\n     * @type {Record<Layer, bigint>}\n     */ this.layerPositions = {\n            defaults: 0n,\n            base: 1n,\n            components: 2n,\n            utilities: 3n,\n            // There isn't technically a \"user\" layer, but we need to give it a position\n            // Because it's used for ordering user-css from @apply\n            user: 4n,\n            variants: 5n\n        };\n        /**\n     * The total number of functions currently registered across all variants (including arbitrary variants)\n     *\n     * @type {bigint}\n     */ this.reservedVariantBits = 0n;\n        /**\n     * Positions for a given variant\n     *\n     * @type {Map<string, bigint>}\n     */ this.variantOffsets = new Map();\n    }\n    /**\n   * @param {Layer} layer\n   * @returns {RuleOffset}\n   */ create(layer) {\n        return {\n            layer,\n            parentLayer: layer,\n            arbitrary: 0n,\n            variants: 0n,\n            parallelIndex: 0n,\n            index: this.offsets[layer]++,\n            options: []\n        };\n    }\n    /**\n   * @returns {RuleOffset}\n   */ arbitraryProperty() {\n        return {\n            ...this.create(\"utilities\"),\n            arbitrary: 1n\n        };\n    }\n    /**\n   * Get the offset for a variant\n   *\n   * @param {string} variant\n   * @param {number} index\n   * @returns {RuleOffset}\n   */ forVariant(variant, index = 0) {\n        let offset = this.variantOffsets.get(variant);\n        if (offset === undefined) {\n            throw new Error(`Cannot find offset for unknown variant ${variant}`);\n        }\n        return {\n            ...this.create(\"variants\"),\n            variants: offset << BigInt(index)\n        };\n    }\n    /**\n   * @param {RuleOffset} rule\n   * @param {RuleOffset} variant\n   * @param {VariantOption} options\n   * @returns {RuleOffset}\n   */ applyVariantOffset(rule, variant, options) {\n        options.variant = variant.variants;\n        return {\n            ...rule,\n            layer: \"variants\",\n            parentLayer: rule.layer === \"variants\" ? rule.parentLayer : rule.layer,\n            variants: rule.variants | variant.variants,\n            options: options.sort ? [].concat(options, rule.options) : rule.options,\n            // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.\n            // We'll take the max of all the parallel indexes for now.\n            // @ts-ignore\n            parallelIndex: max([\n                rule.parallelIndex,\n                variant.parallelIndex\n            ])\n        };\n    }\n    /**\n   * @param {RuleOffset} offset\n   * @param {number} parallelIndex\n   * @returns {RuleOffset}\n   */ applyParallelOffset(offset, parallelIndex) {\n        return {\n            ...offset,\n            parallelIndex: BigInt(parallelIndex)\n        };\n    }\n    /**\n   * Each variant gets 1 bit per function / rule registered.\n   * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.\n   * Additionally, every unique group of variants is grouped together in the stylesheet.\n   *\n   * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.\n   *\n   * @param {string[]} variants\n   * @param {(name: string) => number} getLength\n   */ recordVariants(variants, getLength) {\n        for (let variant of variants){\n            this.recordVariant(variant, getLength(variant));\n        }\n    }\n    /**\n   * The same as `recordVariants` but for a single arbitrary variant at runtime.\n   * @param {string} variant\n   * @param {number} fnCount\n   *\n   * @returns {RuleOffset} The highest offset for this variant\n   */ recordVariant(variant, fnCount = 1) {\n        this.variantOffsets.set(variant, 1n << this.reservedVariantBits);\n        // Ensure space is reserved for each \"function\" in the parallel variant\n        // by offsetting the next variant by the number of parallel variants\n        // in the one we just added.\n        // Single functions that return parallel variants are NOT handled separately here\n        // They're offset by 1 (or the number of functions) as usual\n        // And each rule returned is tracked separately since the functions are evaluated lazily.\n        // @see `RuleOffset.parallelIndex`\n        this.reservedVariantBits += BigInt(fnCount);\n        return {\n            ...this.create(\"variants\"),\n            variants: this.variantOffsets.get(variant)\n        };\n    }\n    /**\n   * @param {RuleOffset} a\n   * @param {RuleOffset} b\n   * @returns {bigint}\n   */ compare(a, b) {\n        // Sort layers together\n        if (a.layer !== b.layer) {\n            return this.layerPositions[a.layer] - this.layerPositions[b.layer];\n        }\n        // When sorting the `variants` layer, we need to sort based on the parent layer as well within\n        // this variants layer.\n        if (a.parentLayer !== b.parentLayer) {\n            return this.layerPositions[a.parentLayer] - this.layerPositions[b.parentLayer];\n        }\n        // Sort based on the sorting function\n        for (let aOptions of a.options){\n            for (let bOptions of b.options){\n                if (aOptions.id !== bOptions.id) continue;\n                if (!aOptions.sort || !bOptions.sort) continue;\n                var _max;\n                let maxFnVariant = (_max = max([\n                    aOptions.variant,\n                    bOptions.variant\n                ])) !== null && _max !== void 0 ? _max : 0n;\n                // Create a mask of 0s from bits 1..N where N represents the mask of the Nth bit\n                let mask = ~(maxFnVariant | maxFnVariant - 1n);\n                let aVariantsAfterFn = a.variants & mask;\n                let bVariantsAfterFn = b.variants & mask;\n                // If the variants the same, we _can_ sort them\n                if (aVariantsAfterFn !== bVariantsAfterFn) {\n                    continue;\n                }\n                let result = aOptions.sort({\n                    value: aOptions.value,\n                    modifier: aOptions.modifier\n                }, {\n                    value: bOptions.value,\n                    modifier: bOptions.modifier\n                });\n                if (result !== 0) return result;\n            }\n        }\n        // Sort variants in the order they were registered\n        if (a.variants !== b.variants) {\n            return a.variants - b.variants;\n        }\n        // Make sure each rule returned by a parallel variant is sorted in ascending order\n        if (a.parallelIndex !== b.parallelIndex) {\n            return a.parallelIndex - b.parallelIndex;\n        }\n        // Always sort arbitrary properties after other utilities\n        if (a.arbitrary !== b.arbitrary) {\n            return a.arbitrary - b.arbitrary;\n        }\n        // Sort utilities, components, etc… in the order they were registered\n        return a.index - b.index;\n    }\n    /**\n   * Arbitrary variants are recorded in the order they're encountered.\n   * This means that the order is not stable between environments and sets of content files.\n   *\n   * In order to make the order stable, we need to remap the arbitrary variant offsets to\n   * be in alphabetical order starting from the offset of the first arbitrary variant.\n   */ recalculateVariantOffsets() {\n        // Sort the variants by their name\n        let variants = Array.from(this.variantOffsets.entries()).filter(([v])=>v.startsWith(\"[\")).sort(([a], [z])=>fastCompare(a, z));\n        // Sort the list of offsets\n        // This is not necessarily a discrete range of numbers which is why\n        // we're using sort instead of creating a range from min/max\n        let newOffsets = variants.map(([, offset])=>offset).sort((a, z)=>(0, _bigSign.default)(a - z));\n        // Create a map from the old offsets to the new offsets in the new sort order\n        /** @type {[bigint, bigint][]} */ let mapping = variants.map(([, oldOffset], i)=>[\n                oldOffset,\n                newOffsets[i]\n            ]);\n        // Remove any variants that will not move letting us skip\n        // remapping if everything happens to be in order\n        return mapping.filter(([a, z])=>a !== z);\n    }\n    /**\n   * @template T\n   * @param {[RuleOffset, T][]} list\n   * @returns {[RuleOffset, T][]}\n   */ remapArbitraryVariantOffsets(list) {\n        let mapping = this.recalculateVariantOffsets();\n        // No arbitrary variants? Nothing to do.\n        // Everyhing already in order? Nothing to do.\n        if (mapping.length === 0) {\n            return list;\n        }\n        // Remap every variant offset in the list\n        return list.map((item)=>{\n            let [offset, rule] = item;\n            offset = {\n                ...offset,\n                variants: (0, _remapbitfield.remapBitfield)(offset.variants, mapping)\n            };\n            return [\n                offset,\n                rule\n            ];\n        });\n    }\n    /**\n   * @template T\n   * @param {[RuleOffset, T][]} list\n   * @returns {[RuleOffset, T][]}\n   */ sort(list) {\n        list = this.remapArbitraryVariantOffsets(list);\n        return list.sort(([a], [b])=>(0, _bigSign.default)(this.compare(a, b)));\n    }\n}\n/**\n *\n * @param {bigint[]} nums\n * @returns {bigint|null}\n */ function max(nums) {\n    let max = null;\n    for (const num of nums){\n        max = max !== null && max !== void 0 ? max : num;\n        max = max > num ? max : num;\n    }\n    return max;\n}\n/**\n * A fast ASCII order string comparison function.\n *\n * Using `.sort()` without a custom compare function is faster\n * But you can only use that if you're sorting an array of\n * only strings. If you're sorting strings inside objects\n * or arrays, you need must use a custom compare function.\n *\n * @param {string} a\n * @param {string} b\n */ function fastCompare(a, b) {\n    let aLen = a.length;\n    let bLen = b.length;\n    let minLen = aLen < bLen ? aLen : bLen;\n    for(let i = 0; i < minLen; i++){\n        let cmp = a.charCodeAt(i) - b.charCodeAt(i);\n        if (cmp !== 0) return cmp;\n    }\n    return aLen - bLen;\n}\n"]}}