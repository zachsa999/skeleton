{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});exports.matchAny=exports.convertPatternsToRe=exports.makeRe=exports.getPatternParts=exports.expandBraceExpansion=exports.expandPatternsWithBraceExpansion=exports.isAffectDepthOfReadingPattern=exports.endsWithSlashGlobStar=exports.hasGlobStar=exports.getBaseDirectory=exports.isPatternRelatedToParentDirectory=exports.getPatternsOutsideCurrentDirectory=exports.getPatternsInsideCurrentDirectory=exports.getPositivePatterns=exports.getNegativePatterns=exports.isPositivePattern=exports.isNegativePattern=exports.convertToNegativePattern=exports.convertToPositivePattern=exports.isDynamicPattern=exports.isStaticPattern=void 0;const path=require(\"path\");const globParent=require(\"glob-parent\");const micromatch=require(\"micromatch\");const GLOBSTAR=\"**\";const ESCAPE_SYMBOL=\"\\\\\";const COMMON_GLOB_SYMBOLS_RE=/[*?]|^!/;const REGEX_CHARACTER_CLASS_SYMBOLS_RE=/\\[[^[]*]/;const REGEX_GROUP_SYMBOLS_RE=/(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;const GLOB_EXTENSION_SYMBOLS_RE=/[!*+?@]\\([^(]*\\)/;const BRACE_EXPANSION_SEPARATORS_RE=/,|\\.\\./;function isStaticPattern(pattern,options={}){return!isDynamicPattern(pattern,options)}__name(isStaticPattern,\"isStaticPattern\");exports.isStaticPattern=isStaticPattern;function isDynamicPattern(pattern,options={}){if(pattern===\"\"){return false}if(options.caseSensitiveMatch===false||pattern.includes(ESCAPE_SYMBOL)){return true}if(COMMON_GLOB_SYMBOLS_RE.test(pattern)||REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern)||REGEX_GROUP_SYMBOLS_RE.test(pattern)){return true}if(options.extglob!==false&&GLOB_EXTENSION_SYMBOLS_RE.test(pattern)){return true}if(options.braceExpansion!==false&&hasBraceExpansion(pattern)){return true}return false}__name(isDynamicPattern,\"isDynamicPattern\");exports.isDynamicPattern=isDynamicPattern;function hasBraceExpansion(pattern){const openingBraceIndex=pattern.indexOf(\"{\");if(openingBraceIndex===-1){return false}const closingBraceIndex=pattern.indexOf(\"}\",openingBraceIndex+1);if(closingBraceIndex===-1){return false}const braceContent=pattern.slice(openingBraceIndex,closingBraceIndex);return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent)}__name(hasBraceExpansion,\"hasBraceExpansion\");function convertToPositivePattern(pattern){return isNegativePattern(pattern)?pattern.slice(1):pattern}__name(convertToPositivePattern,\"convertToPositivePattern\");exports.convertToPositivePattern=convertToPositivePattern;function convertToNegativePattern(pattern){return\"!\"+pattern}__name(convertToNegativePattern,\"convertToNegativePattern\");exports.convertToNegativePattern=convertToNegativePattern;function isNegativePattern(pattern){return pattern.startsWith(\"!\")&&pattern[1]!==\"(\"}__name(isNegativePattern,\"isNegativePattern\");exports.isNegativePattern=isNegativePattern;function isPositivePattern(pattern){return!isNegativePattern(pattern)}__name(isPositivePattern,\"isPositivePattern\");exports.isPositivePattern=isPositivePattern;function getNegativePatterns(patterns){return patterns.filter(isNegativePattern)}__name(getNegativePatterns,\"getNegativePatterns\");exports.getNegativePatterns=getNegativePatterns;function getPositivePatterns(patterns){return patterns.filter(isPositivePattern)}__name(getPositivePatterns,\"getPositivePatterns\");exports.getPositivePatterns=getPositivePatterns;function getPatternsInsideCurrentDirectory(patterns){return patterns.filter(pattern=>!isPatternRelatedToParentDirectory(pattern))}__name(getPatternsInsideCurrentDirectory,\"getPatternsInsideCurrentDirectory\");exports.getPatternsInsideCurrentDirectory=getPatternsInsideCurrentDirectory;function getPatternsOutsideCurrentDirectory(patterns){return patterns.filter(isPatternRelatedToParentDirectory)}__name(getPatternsOutsideCurrentDirectory,\"getPatternsOutsideCurrentDirectory\");exports.getPatternsOutsideCurrentDirectory=getPatternsOutsideCurrentDirectory;function isPatternRelatedToParentDirectory(pattern){return pattern.startsWith(\"..\")||pattern.startsWith(\"./..\")}__name(isPatternRelatedToParentDirectory,\"isPatternRelatedToParentDirectory\");exports.isPatternRelatedToParentDirectory=isPatternRelatedToParentDirectory;function getBaseDirectory(pattern){return globParent(pattern,{flipBackslashes:false})}__name(getBaseDirectory,\"getBaseDirectory\");exports.getBaseDirectory=getBaseDirectory;function hasGlobStar(pattern){return pattern.includes(GLOBSTAR)}__name(hasGlobStar,\"hasGlobStar\");exports.hasGlobStar=hasGlobStar;function endsWithSlashGlobStar(pattern){return pattern.endsWith(\"/\"+GLOBSTAR)}__name(endsWithSlashGlobStar,\"endsWithSlashGlobStar\");exports.endsWithSlashGlobStar=endsWithSlashGlobStar;function isAffectDepthOfReadingPattern(pattern){const basename=path.basename(pattern);return endsWithSlashGlobStar(pattern)||isStaticPattern(basename)}__name(isAffectDepthOfReadingPattern,\"isAffectDepthOfReadingPattern\");exports.isAffectDepthOfReadingPattern=isAffectDepthOfReadingPattern;function expandPatternsWithBraceExpansion(patterns){return patterns.reduce((collection,pattern)=>{return collection.concat(expandBraceExpansion(pattern))},[])}__name(expandPatternsWithBraceExpansion,\"expandPatternsWithBraceExpansion\");exports.expandPatternsWithBraceExpansion=expandPatternsWithBraceExpansion;function expandBraceExpansion(pattern){return micromatch.braces(pattern,{expand:true,nodupes:true})}__name(expandBraceExpansion,\"expandBraceExpansion\");exports.expandBraceExpansion=expandBraceExpansion;function getPatternParts(pattern,options){let{parts}=micromatch.scan(pattern,Object.assign(Object.assign({},options),{parts:true}));if(parts.length===0){parts=[pattern]}if(parts[0].startsWith(\"/\")){parts[0]=parts[0].slice(1);parts.unshift(\"\")}return parts}__name(getPatternParts,\"getPatternParts\");exports.getPatternParts=getPatternParts;function makeRe(pattern,options){return micromatch.makeRe(pattern,options)}__name(makeRe,\"makeRe\");exports.makeRe=makeRe;function convertPatternsToRe(patterns,options){return patterns.map(pattern=>makeRe(pattern,options))}__name(convertPatternsToRe,\"convertPatternsToRe\");exports.convertPatternsToRe=convertPatternsToRe;function matchAny(entry,patternsRe){return patternsRe.some(patternRe=>patternRe.test(entry))}__name(matchAny,\"matchAny\");exports.matchAny=matchAny;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/pattern.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\r\nconst path = require(\"path\");\r\nconst globParent = require(\"glob-parent\");\r\nconst micromatch = require(\"micromatch\");\r\nconst GLOBSTAR = '**';\r\nconst ESCAPE_SYMBOL = '\\\\';\r\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\r\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\r\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\r\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\r\nconst BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\r\nfunction isStaticPattern(pattern, options = {}) {\r\n    return !isDynamicPattern(pattern, options);\r\n}\r\nexports.isStaticPattern = isStaticPattern;\r\nfunction isDynamicPattern(pattern, options = {}) {\r\n    /**\r\n     * A special case with an empty string is necessary for matching patterns that start with a forward slash.\r\n     * An empty string cannot be a dynamic pattern.\r\n     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\r\n     */\r\n    if (pattern === '') {\r\n        return false;\r\n    }\r\n    /**\r\n     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\r\n     * filepath directly (without read directory).\r\n     */\r\n    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\r\n        return true;\r\n    }\r\n    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\r\n        return true;\r\n    }\r\n    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\r\n        return true;\r\n    }\r\n    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.isDynamicPattern = isDynamicPattern;\r\nfunction hasBraceExpansion(pattern) {\r\n    const openingBraceIndex = pattern.indexOf('{');\r\n    if (openingBraceIndex === -1) {\r\n        return false;\r\n    }\r\n    const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);\r\n    if (closingBraceIndex === -1) {\r\n        return false;\r\n    }\r\n    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\r\n    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\r\n}\r\nfunction convertToPositivePattern(pattern) {\r\n    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\r\n}\r\nexports.convertToPositivePattern = convertToPositivePattern;\r\nfunction convertToNegativePattern(pattern) {\r\n    return '!' + pattern;\r\n}\r\nexports.convertToNegativePattern = convertToNegativePattern;\r\nfunction isNegativePattern(pattern) {\r\n    return pattern.startsWith('!') && pattern[1] !== '(';\r\n}\r\nexports.isNegativePattern = isNegativePattern;\r\nfunction isPositivePattern(pattern) {\r\n    return !isNegativePattern(pattern);\r\n}\r\nexports.isPositivePattern = isPositivePattern;\r\nfunction getNegativePatterns(patterns) {\r\n    return patterns.filter(isNegativePattern);\r\n}\r\nexports.getNegativePatterns = getNegativePatterns;\r\nfunction getPositivePatterns(patterns) {\r\n    return patterns.filter(isPositivePattern);\r\n}\r\nexports.getPositivePatterns = getPositivePatterns;\r\n/**\r\n * Returns patterns that can be applied inside the current directory.\r\n *\r\n * @example\r\n * // ['./*', '*', 'a/*']\r\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\r\n */\r\nfunction getPatternsInsideCurrentDirectory(patterns) {\r\n    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));\r\n}\r\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\r\n/**\r\n * Returns patterns to be expanded relative to (outside) the current directory.\r\n *\r\n * @example\r\n * // ['../*', './../*']\r\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\r\n */\r\nfunction getPatternsOutsideCurrentDirectory(patterns) {\r\n    return patterns.filter(isPatternRelatedToParentDirectory);\r\n}\r\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\r\nfunction isPatternRelatedToParentDirectory(pattern) {\r\n    return pattern.startsWith('..') || pattern.startsWith('./..');\r\n}\r\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\r\nfunction getBaseDirectory(pattern) {\r\n    return globParent(pattern, { flipBackslashes: false });\r\n}\r\nexports.getBaseDirectory = getBaseDirectory;\r\nfunction hasGlobStar(pattern) {\r\n    return pattern.includes(GLOBSTAR);\r\n}\r\nexports.hasGlobStar = hasGlobStar;\r\nfunction endsWithSlashGlobStar(pattern) {\r\n    return pattern.endsWith('/' + GLOBSTAR);\r\n}\r\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\r\nfunction isAffectDepthOfReadingPattern(pattern) {\r\n    const basename = path.basename(pattern);\r\n    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\r\n}\r\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\r\nfunction expandPatternsWithBraceExpansion(patterns) {\r\n    return patterns.reduce((collection, pattern) => {\r\n        return collection.concat(expandBraceExpansion(pattern));\r\n    }, []);\r\n}\r\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\r\nfunction expandBraceExpansion(pattern) {\r\n    return micromatch.braces(pattern, {\r\n        expand: true,\r\n        nodupes: true\r\n    });\r\n}\r\nexports.expandBraceExpansion = expandBraceExpansion;\r\nfunction getPatternParts(pattern, options) {\r\n    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));\r\n    /**\r\n     * The scan method returns an empty array in some cases.\r\n     * See micromatch/picomatch#58 for more details.\r\n     */\r\n    if (parts.length === 0) {\r\n        parts = [pattern];\r\n    }\r\n    /**\r\n     * The scan method does not return an empty part for the pattern with a forward slash.\r\n     * This is another part of micromatch/picomatch#58.\r\n     */\r\n    if (parts[0].startsWith('/')) {\r\n        parts[0] = parts[0].slice(1);\r\n        parts.unshift('');\r\n    }\r\n    return parts;\r\n}\r\nexports.getPatternParts = getPatternParts;\r\nfunction makeRe(pattern, options) {\r\n    return micromatch.makeRe(pattern, options);\r\n}\r\nexports.makeRe = makeRe;\r\nfunction convertPatternsToRe(patterns, options) {\r\n    return patterns.map((pattern) => makeRe(pattern, options));\r\n}\r\nexports.convertPatternsToRe = convertPatternsToRe;\r\nfunction matchAny(entry, patternsRe) {\r\n    return patternsRe.some((patternRe) => patternRe.test(entry));\r\n}\r\nexports.matchAny = matchAny;\r\n"]}}