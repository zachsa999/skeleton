{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _charcodes=require(\"./charcodes\");var _whitespace=require(\"./whitespace\");function computeIsIdentifierChar(code){if(code<48)return code===36;if(code<58)return true;if(code<65)return false;if(code<91)return true;if(code<97)return code===95;if(code<123)return true;if(code<128)return false;throw new Error(\"Should not be called with non-ASCII char code.\")}__name(computeIsIdentifierChar,\"computeIsIdentifierChar\");const IS_IDENTIFIER_CHAR=new Uint8Array(65536);exports.IS_IDENTIFIER_CHAR=IS_IDENTIFIER_CHAR;for(let i=0;i<128;i++){exports.IS_IDENTIFIER_CHAR[i]=computeIsIdentifierChar(i)?1:0}for(let i=128;i<65536;i++){exports.IS_IDENTIFIER_CHAR[i]=1}for(const whitespaceChar of _whitespace.WHITESPACE_CHARS){exports.IS_IDENTIFIER_CHAR[whitespaceChar]=0}exports.IS_IDENTIFIER_CHAR[8232]=0;exports.IS_IDENTIFIER_CHAR[8233]=0;const IS_IDENTIFIER_START=exports.IS_IDENTIFIER_CHAR.slice();exports.IS_IDENTIFIER_START=IS_IDENTIFIER_START;for(let numChar=_charcodes.charCodes.digit0;numChar<=_charcodes.charCodes.digit9;numChar++){exports.IS_IDENTIFIER_START[numChar]=0}\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAE,IAAI,WAAa,QAAQ,aAAa,EAC/G,IAAI,YAAc,QAAQ,cAAc,EAExC,SAAS,wBAAwB,KAAM,CACrC,GAAI,KAAO,GAAI,OAAO,OAAS,GAC/B,GAAI,KAAO,GAAI,MAAO,MACtB,GAAI,KAAO,GAAI,MAAO,OACtB,GAAI,KAAO,GAAI,MAAO,MACtB,GAAI,KAAO,GAAI,OAAO,OAAS,GAC/B,GAAI,KAAO,IAAK,MAAO,MACvB,GAAI,KAAO,IAAK,MAAO,OACvB,MAAM,IAAI,MAAM,gDAAgD,CAClE,CATS,0DAWR,MAAM,mBAAqB,IAAI,WAAW,KAAK,EAAG,QAAQ,mBAAqB,mBAChF,QAAS,EAAI,EAAG,EAAI,IAAK,IAAK,CAC5B,QAAQ,mBAAmB,CAAC,EAAI,wBAAwB,CAAC,EAAI,EAAI,CACnE,CACA,QAAS,EAAI,IAAK,EAAI,MAAO,IAAK,CAChC,QAAQ,mBAAmB,CAAC,EAAI,CAClC,CAIA,UAAW,kBAAkB,YAAY,iBAAkB,CACzD,QAAQ,mBAAmB,cAAc,EAAI,CAC/C,CACA,QAAQ,mBAAmB,IAAM,EAAI,EACrC,QAAQ,mBAAmB,IAAM,EAAI,EAEpC,MAAM,oBAAsB,QAAQ,mBAAmB,MAAM,EAAG,QAAQ,oBAAsB,oBAC/F,QAAS,QAAU,WAAW,UAAU,OAAQ,SAAW,WAAW,UAAU,OAAQ,UAAW,CACjG,QAAQ,oBAAoB,OAAO,EAAI,CACzC","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/parser/util/identifier.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});var _charcodes = require('./charcodes');\nvar _whitespace = require('./whitespace');\n\nfunction computeIsIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code < 91) return true;\n  if (code < 97) return code === 95;\n  if (code < 123) return true;\n  if (code < 128) return false;\n  throw new Error(\"Should not be called with non-ASCII char code.\");\n}\n\n const IS_IDENTIFIER_CHAR = new Uint8Array(65536); exports.IS_IDENTIFIER_CHAR = IS_IDENTIFIER_CHAR;\nfor (let i = 0; i < 128; i++) {\n  exports.IS_IDENTIFIER_CHAR[i] = computeIsIdentifierChar(i) ? 1 : 0;\n}\nfor (let i = 128; i < 65536; i++) {\n  exports.IS_IDENTIFIER_CHAR[i] = 1;\n}\n// Aside from whitespace and newlines, all characters outside the ASCII space are either\n// identifier characters or invalid. Since we're not performing code validation, we can just\n// treat all invalid characters as identifier characters.\nfor (const whitespaceChar of _whitespace.WHITESPACE_CHARS) {\n  exports.IS_IDENTIFIER_CHAR[whitespaceChar] = 0;\n}\nexports.IS_IDENTIFIER_CHAR[0x2028] = 0;\nexports.IS_IDENTIFIER_CHAR[0x2029] = 0;\n\n const IS_IDENTIFIER_START = exports.IS_IDENTIFIER_CHAR.slice(); exports.IS_IDENTIFIER_START = IS_IDENTIFIER_START;\nfor (let numChar = _charcodes.charCodes.digit0; numChar <= _charcodes.charCodes.digit9; numChar++) {\n  exports.IS_IDENTIFIER_START[numChar] = 0;\n}\n"]}}