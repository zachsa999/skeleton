{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interopRequireDefault,\"_interopRequireDefault\");var _base=require(\"../traverser/base\");var _util=require(\"../traverser/util\");var _charcodes=require(\"../util/charcodes\");var _identifier=require(\"../util/identifier\");var _whitespace=require(\"../util/whitespace\");var _keywords=require(\"./keywords\");var _readWord=require(\"./readWord\");var _readWord2=_interopRequireDefault(_readWord);var _types=require(\"./types\");var IdentifierRole;(function(IdentifierRole2){const Access=0;IdentifierRole2[IdentifierRole2[\"Access\"]=Access]=\"Access\";const ExportAccess=Access+1;IdentifierRole2[IdentifierRole2[\"ExportAccess\"]=ExportAccess]=\"ExportAccess\";const TopLevelDeclaration=ExportAccess+1;IdentifierRole2[IdentifierRole2[\"TopLevelDeclaration\"]=TopLevelDeclaration]=\"TopLevelDeclaration\";const FunctionScopedDeclaration=TopLevelDeclaration+1;IdentifierRole2[IdentifierRole2[\"FunctionScopedDeclaration\"]=FunctionScopedDeclaration]=\"FunctionScopedDeclaration\";const BlockScopedDeclaration=FunctionScopedDeclaration+1;IdentifierRole2[IdentifierRole2[\"BlockScopedDeclaration\"]=BlockScopedDeclaration]=\"BlockScopedDeclaration\";const ObjectShorthandTopLevelDeclaration=BlockScopedDeclaration+1;IdentifierRole2[IdentifierRole2[\"ObjectShorthandTopLevelDeclaration\"]=ObjectShorthandTopLevelDeclaration]=\"ObjectShorthandTopLevelDeclaration\";const ObjectShorthandFunctionScopedDeclaration=ObjectShorthandTopLevelDeclaration+1;IdentifierRole2[IdentifierRole2[\"ObjectShorthandFunctionScopedDeclaration\"]=ObjectShorthandFunctionScopedDeclaration]=\"ObjectShorthandFunctionScopedDeclaration\";const ObjectShorthandBlockScopedDeclaration=ObjectShorthandFunctionScopedDeclaration+1;IdentifierRole2[IdentifierRole2[\"ObjectShorthandBlockScopedDeclaration\"]=ObjectShorthandBlockScopedDeclaration]=\"ObjectShorthandBlockScopedDeclaration\";const ObjectShorthand=ObjectShorthandBlockScopedDeclaration+1;IdentifierRole2[IdentifierRole2[\"ObjectShorthand\"]=ObjectShorthand]=\"ObjectShorthand\";const ImportDeclaration=ObjectShorthand+1;IdentifierRole2[IdentifierRole2[\"ImportDeclaration\"]=ImportDeclaration]=\"ImportDeclaration\";const ObjectKey=ImportDeclaration+1;IdentifierRole2[IdentifierRole2[\"ObjectKey\"]=ObjectKey]=\"ObjectKey\";const ImportAccess=ObjectKey+1;IdentifierRole2[IdentifierRole2[\"ImportAccess\"]=ImportAccess]=\"ImportAccess\"})(IdentifierRole||(exports.IdentifierRole=IdentifierRole={}));var JSXRole;(function(JSXRole2){const NoChildren=0;JSXRole2[JSXRole2[\"NoChildren\"]=NoChildren]=\"NoChildren\";const OneChild=NoChildren+1;JSXRole2[JSXRole2[\"OneChild\"]=OneChild]=\"OneChild\";const StaticChildren=OneChild+1;JSXRole2[JSXRole2[\"StaticChildren\"]=StaticChildren]=\"StaticChildren\";const KeyAfterPropSpread=StaticChildren+1;JSXRole2[JSXRole2[\"KeyAfterPropSpread\"]=KeyAfterPropSpread]=\"KeyAfterPropSpread\"})(JSXRole||(exports.JSXRole=JSXRole={}));function isDeclaration(token){const role=token.identifierRole;return role===IdentifierRole.TopLevelDeclaration||role===IdentifierRole.FunctionScopedDeclaration||role===IdentifierRole.BlockScopedDeclaration||role===IdentifierRole.ObjectShorthandTopLevelDeclaration||role===IdentifierRole.ObjectShorthandFunctionScopedDeclaration||role===IdentifierRole.ObjectShorthandBlockScopedDeclaration}__name(isDeclaration,\"isDeclaration\");exports.isDeclaration=isDeclaration;function isNonTopLevelDeclaration(token){const role=token.identifierRole;return role===IdentifierRole.FunctionScopedDeclaration||role===IdentifierRole.BlockScopedDeclaration||role===IdentifierRole.ObjectShorthandFunctionScopedDeclaration||role===IdentifierRole.ObjectShorthandBlockScopedDeclaration}__name(isNonTopLevelDeclaration,\"isNonTopLevelDeclaration\");exports.isNonTopLevelDeclaration=isNonTopLevelDeclaration;function isTopLevelDeclaration(token){const role=token.identifierRole;return role===IdentifierRole.TopLevelDeclaration||role===IdentifierRole.ObjectShorthandTopLevelDeclaration||role===IdentifierRole.ImportDeclaration}__name(isTopLevelDeclaration,\"isTopLevelDeclaration\");exports.isTopLevelDeclaration=isTopLevelDeclaration;function isBlockScopedDeclaration(token){const role=token.identifierRole;return role===IdentifierRole.TopLevelDeclaration||role===IdentifierRole.BlockScopedDeclaration||role===IdentifierRole.ObjectShorthandTopLevelDeclaration||role===IdentifierRole.ObjectShorthandBlockScopedDeclaration}__name(isBlockScopedDeclaration,\"isBlockScopedDeclaration\");exports.isBlockScopedDeclaration=isBlockScopedDeclaration;function isFunctionScopedDeclaration(token){const role=token.identifierRole;return role===IdentifierRole.FunctionScopedDeclaration||role===IdentifierRole.ObjectShorthandFunctionScopedDeclaration}__name(isFunctionScopedDeclaration,\"isFunctionScopedDeclaration\");exports.isFunctionScopedDeclaration=isFunctionScopedDeclaration;function isObjectShorthandDeclaration(token){return token.identifierRole===IdentifierRole.ObjectShorthandTopLevelDeclaration||token.identifierRole===IdentifierRole.ObjectShorthandBlockScopedDeclaration||token.identifierRole===IdentifierRole.ObjectShorthandFunctionScopedDeclaration}__name(isObjectShorthandDeclaration,\"isObjectShorthandDeclaration\");exports.isObjectShorthandDeclaration=isObjectShorthandDeclaration;class Token{constructor(){this.type=_base.state.type;this.contextualKeyword=_base.state.contextualKeyword;this.start=_base.state.start;this.end=_base.state.end;this.scopeDepth=_base.state.scopeDepth;this.isType=_base.state.isType;this.identifierRole=null;this.jsxRole=null;this.shadowsGlobal=false;this.isAsyncOperation=false;this.contextId=null;this.rhsEndIndex=null;this.isExpression=false;this.numNullishCoalesceStarts=0;this.numNullishCoalesceEnds=0;this.isOptionalChainStart=false;this.isOptionalChainEnd=false;this.subscriptStartIndex=null;this.nullishStartIndex=null}}__name(Token,\"Token\");exports.Token=Token;function next(){_base.state.tokens.push(new Token);nextToken()}__name(next,\"next\");exports.next=next;function nextTemplateToken(){_base.state.tokens.push(new Token);_base.state.start=_base.state.pos;readTmplToken()}__name(nextTemplateToken,\"nextTemplateToken\");exports.nextTemplateToken=nextTemplateToken;function retokenizeSlashAsRegex(){if(_base.state.type===_types.TokenType.assign){--_base.state.pos}readRegexp()}__name(retokenizeSlashAsRegex,\"retokenizeSlashAsRegex\");exports.retokenizeSlashAsRegex=retokenizeSlashAsRegex;function pushTypeContext(existingTokensInType){for(let i=_base.state.tokens.length-existingTokensInType;i<_base.state.tokens.length;i++){_base.state.tokens[i].isType=true}const oldIsType=_base.state.isType;_base.state.isType=true;return oldIsType}__name(pushTypeContext,\"pushTypeContext\");exports.pushTypeContext=pushTypeContext;function popTypeContext(oldIsType){_base.state.isType=oldIsType}__name(popTypeContext,\"popTypeContext\");exports.popTypeContext=popTypeContext;function eat(type){if(match(type)){next();return true}else{return false}}__name(eat,\"eat\");exports.eat=eat;function eatTypeToken(tokenType){const oldIsType=_base.state.isType;_base.state.isType=true;eat(tokenType);_base.state.isType=oldIsType}__name(eatTypeToken,\"eatTypeToken\");exports.eatTypeToken=eatTypeToken;function match(type){return _base.state.type===type}__name(match,\"match\");exports.match=match;function lookaheadType(){const snapshot=_base.state.snapshot();next();const type=_base.state.type;_base.state.restoreFromSnapshot(snapshot);return type}__name(lookaheadType,\"lookaheadType\");exports.lookaheadType=lookaheadType;class TypeAndKeyword{constructor(type,contextualKeyword){this.type=type;this.contextualKeyword=contextualKeyword}}__name(TypeAndKeyword,\"TypeAndKeyword\");exports.TypeAndKeyword=TypeAndKeyword;function lookaheadTypeAndKeyword(){const snapshot=_base.state.snapshot();next();const type=_base.state.type;const contextualKeyword=_base.state.contextualKeyword;_base.state.restoreFromSnapshot(snapshot);return new TypeAndKeyword(type,contextualKeyword)}__name(lookaheadTypeAndKeyword,\"lookaheadTypeAndKeyword\");exports.lookaheadTypeAndKeyword=lookaheadTypeAndKeyword;function nextTokenStart(){return nextTokenStartSince(_base.state.pos)}__name(nextTokenStart,\"nextTokenStart\");exports.nextTokenStart=nextTokenStart;function nextTokenStartSince(pos){_whitespace.skipWhiteSpace.lastIndex=pos;const skip=_whitespace.skipWhiteSpace.exec(_base.input);return pos+skip[0].length}__name(nextTokenStartSince,\"nextTokenStartSince\");exports.nextTokenStartSince=nextTokenStartSince;function lookaheadCharCode(){return _base.input.charCodeAt(nextTokenStart())}__name(lookaheadCharCode,\"lookaheadCharCode\");exports.lookaheadCharCode=lookaheadCharCode;function nextToken(){skipSpace();_base.state.start=_base.state.pos;if(_base.state.pos>=_base.input.length){const tokens=_base.state.tokens;if(tokens.length>=2&&tokens[tokens.length-1].start>=_base.input.length&&tokens[tokens.length-2].start>=_base.input.length){_util.unexpected.call(void 0,\"Unexpectedly reached the end of input.\")}finishToken(_types.TokenType.eof);return}readToken(_base.input.charCodeAt(_base.state.pos))}__name(nextToken,\"nextToken\");exports.nextToken=nextToken;function readToken(code){if(_identifier.IS_IDENTIFIER_START[code]||code===_charcodes.charCodes.backslash||code===_charcodes.charCodes.atSign&&_base.input.charCodeAt(_base.state.pos+1)===_charcodes.charCodes.atSign){_readWord2.default.call(void 0)}else{getTokenFromCode(code)}}__name(readToken,\"readToken\");function skipBlockComment(){while(_base.input.charCodeAt(_base.state.pos)!==_charcodes.charCodes.asterisk||_base.input.charCodeAt(_base.state.pos+1)!==_charcodes.charCodes.slash){_base.state.pos++;if(_base.state.pos>_base.input.length){_util.unexpected.call(void 0,\"Unterminated comment\",_base.state.pos-2);return}}_base.state.pos+=2}__name(skipBlockComment,\"skipBlockComment\");function skipLineComment(startSkip){let ch=_base.input.charCodeAt(_base.state.pos+=startSkip);if(_base.state.pos<_base.input.length){while(ch!==_charcodes.charCodes.lineFeed&&ch!==_charcodes.charCodes.carriageReturn&&ch!==_charcodes.charCodes.lineSeparator&&ch!==_charcodes.charCodes.paragraphSeparator&&++_base.state.pos<_base.input.length){ch=_base.input.charCodeAt(_base.state.pos)}}}__name(skipLineComment,\"skipLineComment\");exports.skipLineComment=skipLineComment;function skipSpace(){while(_base.state.pos<_base.input.length){const ch=_base.input.charCodeAt(_base.state.pos);switch(ch){case _charcodes.charCodes.carriageReturn:if(_base.input.charCodeAt(_base.state.pos+1)===_charcodes.charCodes.lineFeed){++_base.state.pos}case _charcodes.charCodes.lineFeed:case _charcodes.charCodes.lineSeparator:case _charcodes.charCodes.paragraphSeparator:++_base.state.pos;break;case _charcodes.charCodes.slash:switch(_base.input.charCodeAt(_base.state.pos+1)){case _charcodes.charCodes.asterisk:_base.state.pos+=2;skipBlockComment();break;case _charcodes.charCodes.slash:skipLineComment(2);break;default:return}break;default:if(_whitespace.IS_WHITESPACE[ch]){++_base.state.pos}else{return}}}}__name(skipSpace,\"skipSpace\");exports.skipSpace=skipSpace;function finishToken(type,contextualKeyword=_keywords.ContextualKeyword.NONE){_base.state.end=_base.state.pos;_base.state.type=type;_base.state.contextualKeyword=contextualKeyword}__name(finishToken,\"finishToken\");exports.finishToken=finishToken;function readToken_dot(){const nextChar=_base.input.charCodeAt(_base.state.pos+1);if(nextChar>=_charcodes.charCodes.digit0&&nextChar<=_charcodes.charCodes.digit9){readNumber(true);return}if(nextChar===_charcodes.charCodes.dot&&_base.input.charCodeAt(_base.state.pos+2)===_charcodes.charCodes.dot){_base.state.pos+=3;finishToken(_types.TokenType.ellipsis)}else{++_base.state.pos;finishToken(_types.TokenType.dot)}}__name(readToken_dot,\"readToken_dot\");function readToken_slash(){const nextChar=_base.input.charCodeAt(_base.state.pos+1);if(nextChar===_charcodes.charCodes.equalsTo){finishOp(_types.TokenType.assign,2)}else{finishOp(_types.TokenType.slash,1)}}__name(readToken_slash,\"readToken_slash\");function readToken_mult_modulo(code){let tokenType=code===_charcodes.charCodes.asterisk?_types.TokenType.star:_types.TokenType.modulo;let width=1;let nextChar=_base.input.charCodeAt(_base.state.pos+1);if(code===_charcodes.charCodes.asterisk&&nextChar===_charcodes.charCodes.asterisk){width++;nextChar=_base.input.charCodeAt(_base.state.pos+2);tokenType=_types.TokenType.exponent}if(nextChar===_charcodes.charCodes.equalsTo&&_base.input.charCodeAt(_base.state.pos+2)!==_charcodes.charCodes.greaterThan){width++;tokenType=_types.TokenType.assign}finishOp(tokenType,width)}__name(readToken_mult_modulo,\"readToken_mult_modulo\");function readToken_pipe_amp(code){const nextChar=_base.input.charCodeAt(_base.state.pos+1);if(nextChar===code){if(_base.input.charCodeAt(_base.state.pos+2)===_charcodes.charCodes.equalsTo){finishOp(_types.TokenType.assign,3)}else{finishOp(code===_charcodes.charCodes.verticalBar?_types.TokenType.logicalOR:_types.TokenType.logicalAND,2)}return}if(code===_charcodes.charCodes.verticalBar){if(nextChar===_charcodes.charCodes.greaterThan){finishOp(_types.TokenType.pipeline,2);return}else if(nextChar===_charcodes.charCodes.rightCurlyBrace&&_base.isFlowEnabled){finishOp(_types.TokenType.braceBarR,2);return}}if(nextChar===_charcodes.charCodes.equalsTo){finishOp(_types.TokenType.assign,2);return}finishOp(code===_charcodes.charCodes.verticalBar?_types.TokenType.bitwiseOR:_types.TokenType.bitwiseAND,1)}__name(readToken_pipe_amp,\"readToken_pipe_amp\");function readToken_caret(){const nextChar=_base.input.charCodeAt(_base.state.pos+1);if(nextChar===_charcodes.charCodes.equalsTo){finishOp(_types.TokenType.assign,2)}else{finishOp(_types.TokenType.bitwiseXOR,1)}}__name(readToken_caret,\"readToken_caret\");function readToken_plus_min(code){const nextChar=_base.input.charCodeAt(_base.state.pos+1);if(nextChar===code){finishOp(_types.TokenType.preIncDec,2);return}if(nextChar===_charcodes.charCodes.equalsTo){finishOp(_types.TokenType.assign,2)}else if(code===_charcodes.charCodes.plusSign){finishOp(_types.TokenType.plus,1)}else{finishOp(_types.TokenType.minus,1)}}__name(readToken_plus_min,\"readToken_plus_min\");function readToken_lt(){const nextChar=_base.input.charCodeAt(_base.state.pos+1);if(nextChar===_charcodes.charCodes.lessThan){if(_base.input.charCodeAt(_base.state.pos+2)===_charcodes.charCodes.equalsTo){finishOp(_types.TokenType.assign,3);return}if(_base.state.isType){finishOp(_types.TokenType.lessThan,1)}else{finishOp(_types.TokenType.bitShiftL,2)}return}if(nextChar===_charcodes.charCodes.equalsTo){finishOp(_types.TokenType.relationalOrEqual,2)}else{finishOp(_types.TokenType.lessThan,1)}}__name(readToken_lt,\"readToken_lt\");function readToken_gt(){if(_base.state.isType){finishOp(_types.TokenType.greaterThan,1);return}const nextChar=_base.input.charCodeAt(_base.state.pos+1);if(nextChar===_charcodes.charCodes.greaterThan){const size=_base.input.charCodeAt(_base.state.pos+2)===_charcodes.charCodes.greaterThan?3:2;if(_base.input.charCodeAt(_base.state.pos+size)===_charcodes.charCodes.equalsTo){finishOp(_types.TokenType.assign,size+1);return}finishOp(_types.TokenType.bitShiftR,size);return}if(nextChar===_charcodes.charCodes.equalsTo){finishOp(_types.TokenType.relationalOrEqual,2)}else{finishOp(_types.TokenType.greaterThan,1)}}__name(readToken_gt,\"readToken_gt\");function rescan_gt(){if(_base.state.type===_types.TokenType.greaterThan){_base.state.pos-=1;readToken_gt()}}__name(rescan_gt,\"rescan_gt\");exports.rescan_gt=rescan_gt;function readToken_eq_excl(code){const nextChar=_base.input.charCodeAt(_base.state.pos+1);if(nextChar===_charcodes.charCodes.equalsTo){finishOp(_types.TokenType.equality,_base.input.charCodeAt(_base.state.pos+2)===_charcodes.charCodes.equalsTo?3:2);return}if(code===_charcodes.charCodes.equalsTo&&nextChar===_charcodes.charCodes.greaterThan){_base.state.pos+=2;finishToken(_types.TokenType.arrow);return}finishOp(code===_charcodes.charCodes.equalsTo?_types.TokenType.eq:_types.TokenType.bang,1)}__name(readToken_eq_excl,\"readToken_eq_excl\");function readToken_question(){const nextChar=_base.input.charCodeAt(_base.state.pos+1);const nextChar2=_base.input.charCodeAt(_base.state.pos+2);if(nextChar===_charcodes.charCodes.questionMark&&!(_base.isFlowEnabled&&_base.state.isType)){if(nextChar2===_charcodes.charCodes.equalsTo){finishOp(_types.TokenType.assign,3)}else{finishOp(_types.TokenType.nullishCoalescing,2)}}else if(nextChar===_charcodes.charCodes.dot&&!(nextChar2>=_charcodes.charCodes.digit0&&nextChar2<=_charcodes.charCodes.digit9)){_base.state.pos+=2;finishToken(_types.TokenType.questionDot)}else{++_base.state.pos;finishToken(_types.TokenType.question)}}__name(readToken_question,\"readToken_question\");function getTokenFromCode(code){switch(code){case _charcodes.charCodes.numberSign:++_base.state.pos;finishToken(_types.TokenType.hash);return;case _charcodes.charCodes.dot:readToken_dot();return;case _charcodes.charCodes.leftParenthesis:++_base.state.pos;finishToken(_types.TokenType.parenL);return;case _charcodes.charCodes.rightParenthesis:++_base.state.pos;finishToken(_types.TokenType.parenR);return;case _charcodes.charCodes.semicolon:++_base.state.pos;finishToken(_types.TokenType.semi);return;case _charcodes.charCodes.comma:++_base.state.pos;finishToken(_types.TokenType.comma);return;case _charcodes.charCodes.leftSquareBracket:++_base.state.pos;finishToken(_types.TokenType.bracketL);return;case _charcodes.charCodes.rightSquareBracket:++_base.state.pos;finishToken(_types.TokenType.bracketR);return;case _charcodes.charCodes.leftCurlyBrace:if(_base.isFlowEnabled&&_base.input.charCodeAt(_base.state.pos+1)===_charcodes.charCodes.verticalBar){finishOp(_types.TokenType.braceBarL,2)}else{++_base.state.pos;finishToken(_types.TokenType.braceL)}return;case _charcodes.charCodes.rightCurlyBrace:++_base.state.pos;finishToken(_types.TokenType.braceR);return;case _charcodes.charCodes.colon:if(_base.input.charCodeAt(_base.state.pos+1)===_charcodes.charCodes.colon){finishOp(_types.TokenType.doubleColon,2)}else{++_base.state.pos;finishToken(_types.TokenType.colon)}return;case _charcodes.charCodes.questionMark:readToken_question();return;case _charcodes.charCodes.atSign:++_base.state.pos;finishToken(_types.TokenType.at);return;case _charcodes.charCodes.graveAccent:++_base.state.pos;finishToken(_types.TokenType.backQuote);return;case _charcodes.charCodes.digit0:{const nextChar=_base.input.charCodeAt(_base.state.pos+1);if(nextChar===_charcodes.charCodes.lowercaseX||nextChar===_charcodes.charCodes.uppercaseX||nextChar===_charcodes.charCodes.lowercaseO||nextChar===_charcodes.charCodes.uppercaseO||nextChar===_charcodes.charCodes.lowercaseB||nextChar===_charcodes.charCodes.uppercaseB){readRadixNumber();return}}case _charcodes.charCodes.digit1:case _charcodes.charCodes.digit2:case _charcodes.charCodes.digit3:case _charcodes.charCodes.digit4:case _charcodes.charCodes.digit5:case _charcodes.charCodes.digit6:case _charcodes.charCodes.digit7:case _charcodes.charCodes.digit8:case _charcodes.charCodes.digit9:readNumber(false);return;case _charcodes.charCodes.quotationMark:case _charcodes.charCodes.apostrophe:readString(code);return;case _charcodes.charCodes.slash:readToken_slash();return;case _charcodes.charCodes.percentSign:case _charcodes.charCodes.asterisk:readToken_mult_modulo(code);return;case _charcodes.charCodes.verticalBar:case _charcodes.charCodes.ampersand:readToken_pipe_amp(code);return;case _charcodes.charCodes.caret:readToken_caret();return;case _charcodes.charCodes.plusSign:case _charcodes.charCodes.dash:readToken_plus_min(code);return;case _charcodes.charCodes.lessThan:readToken_lt();return;case _charcodes.charCodes.greaterThan:readToken_gt();return;case _charcodes.charCodes.equalsTo:case _charcodes.charCodes.exclamationMark:readToken_eq_excl(code);return;case _charcodes.charCodes.tilde:finishOp(_types.TokenType.tilde,1);return;default:break}_util.unexpected.call(void 0,`Unexpected character '${String.fromCharCode(code)}'`,_base.state.pos)}__name(getTokenFromCode,\"getTokenFromCode\");exports.getTokenFromCode=getTokenFromCode;function finishOp(type,size){_base.state.pos+=size;finishToken(type)}__name(finishOp,\"finishOp\");function readRegexp(){const start=_base.state.pos;let escaped=false;let inClass=false;for(;;){if(_base.state.pos>=_base.input.length){_util.unexpected.call(void 0,\"Unterminated regular expression\",start);return}const code=_base.input.charCodeAt(_base.state.pos);if(escaped){escaped=false}else{if(code===_charcodes.charCodes.leftSquareBracket){inClass=true}else if(code===_charcodes.charCodes.rightSquareBracket&&inClass){inClass=false}else if(code===_charcodes.charCodes.slash&&!inClass){break}escaped=code===_charcodes.charCodes.backslash}++_base.state.pos}++_base.state.pos;skipWord();finishToken(_types.TokenType.regexp)}__name(readRegexp,\"readRegexp\");function readInt(){while(true){const code=_base.input.charCodeAt(_base.state.pos);if(code>=_charcodes.charCodes.digit0&&code<=_charcodes.charCodes.digit9||code===_charcodes.charCodes.underscore){_base.state.pos++}else{break}}}__name(readInt,\"readInt\");function readRadixNumber(){_base.state.pos+=2;while(true){const code=_base.input.charCodeAt(_base.state.pos);if(code>=_charcodes.charCodes.digit0&&code<=_charcodes.charCodes.digit9||code>=_charcodes.charCodes.lowercaseA&&code<=_charcodes.charCodes.lowercaseF||code>=_charcodes.charCodes.uppercaseA&&code<=_charcodes.charCodes.uppercaseF||code===_charcodes.charCodes.underscore){_base.state.pos++}else{break}}const nextChar=_base.input.charCodeAt(_base.state.pos);if(nextChar===_charcodes.charCodes.lowercaseN){++_base.state.pos;finishToken(_types.TokenType.bigint)}else{finishToken(_types.TokenType.num)}}__name(readRadixNumber,\"readRadixNumber\");function readNumber(startsWithDot){let isBigInt=false;let isDecimal=false;if(!startsWithDot){readInt()}let nextChar=_base.input.charCodeAt(_base.state.pos);if(nextChar===_charcodes.charCodes.dot){++_base.state.pos;readInt();nextChar=_base.input.charCodeAt(_base.state.pos)}if(nextChar===_charcodes.charCodes.uppercaseE||nextChar===_charcodes.charCodes.lowercaseE){nextChar=_base.input.charCodeAt(++_base.state.pos);if(nextChar===_charcodes.charCodes.plusSign||nextChar===_charcodes.charCodes.dash){++_base.state.pos}readInt();nextChar=_base.input.charCodeAt(_base.state.pos)}if(nextChar===_charcodes.charCodes.lowercaseN){++_base.state.pos;isBigInt=true}else if(nextChar===_charcodes.charCodes.lowercaseM){++_base.state.pos;isDecimal=true}if(isBigInt){finishToken(_types.TokenType.bigint);return}if(isDecimal){finishToken(_types.TokenType.decimal);return}finishToken(_types.TokenType.num)}__name(readNumber,\"readNumber\");function readString(quote){_base.state.pos++;for(;;){if(_base.state.pos>=_base.input.length){_util.unexpected.call(void 0,\"Unterminated string constant\");return}const ch=_base.input.charCodeAt(_base.state.pos);if(ch===_charcodes.charCodes.backslash){_base.state.pos++}else if(ch===quote){break}_base.state.pos++}_base.state.pos++;finishToken(_types.TokenType.string)}__name(readString,\"readString\");function readTmplToken(){for(;;){if(_base.state.pos>=_base.input.length){_util.unexpected.call(void 0,\"Unterminated template\");return}const ch=_base.input.charCodeAt(_base.state.pos);if(ch===_charcodes.charCodes.graveAccent||ch===_charcodes.charCodes.dollarSign&&_base.input.charCodeAt(_base.state.pos+1)===_charcodes.charCodes.leftCurlyBrace){if(_base.state.pos===_base.state.start&&match(_types.TokenType.template)){if(ch===_charcodes.charCodes.dollarSign){_base.state.pos+=2;finishToken(_types.TokenType.dollarBraceL);return}else{++_base.state.pos;finishToken(_types.TokenType.backQuote);return}}finishToken(_types.TokenType.template);return}if(ch===_charcodes.charCodes.backslash){_base.state.pos++}_base.state.pos++}}__name(readTmplToken,\"readTmplToken\");function skipWord(){while(_base.state.pos<_base.input.length){const ch=_base.input.charCodeAt(_base.state.pos);if(_identifier.IS_IDENTIFIER_CHAR[ch]){_base.state.pos++}else if(ch===_charcodes.charCodes.backslash){_base.state.pos+=2;if(_base.input.charCodeAt(_base.state.pos)===_charcodes.charCodes.leftCurlyBrace){while(_base.state.pos<_base.input.length&&_base.input.charCodeAt(_base.state.pos)!==_charcodes.charCodes.rightCurlyBrace){_base.state.pos++}_base.state.pos++}}else{break}}}__name(skipWord,\"skipWord\");exports.skipWord=skipWord;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAG,SAAS,uBAAuB,IAAK,CAAE,OAAO,KAAO,IAAI,WAAa,IAAM,CAAE,QAAS,GAAI,CAAG,CAArF,wDAEnF,IAAI,MAAQ,QAAQ,mBAAmB,EACvC,IAAI,MAAQ,QAAQ,mBAAmB,EACvC,IAAI,WAAa,QAAQ,mBAAmB,EAC5C,IAAI,YAAc,QAAQ,oBAAoB,EAC9C,IAAI,YAAc,QAAQ,oBAAoB,EAC9C,IAAI,UAAY,QAAQ,YAAY,EACpC,IAAI,UAAY,QAAQ,YAAY,EAAG,IAAI,WAAa,uBAAuB,SAAS,EACxF,IAAI,OAAS,QAAQ,SAAS,EAE9B,IAAI,gBAAiB,SAAUA,gBAAgB,CAC7C,MAAM,OAAS,EAAGA,gBAAeA,gBAAe,QAAQ,EAAI,MAAM,EAAI,SACtE,MAAM,aAAe,OAAS,EAAGA,gBAAeA,gBAAe,cAAc,EAAI,YAAY,EAAI,eACjG,MAAM,oBAAsB,aAAe,EAAGA,gBAAeA,gBAAe,qBAAqB,EAAI,mBAAmB,EAAI,sBAC5H,MAAM,0BAA4B,oBAAsB,EAAGA,gBAAeA,gBAAe,2BAA2B,EAAI,yBAAyB,EAAI,4BACrJ,MAAM,uBAAyB,0BAA4B,EAAGA,gBAAeA,gBAAe,wBAAwB,EAAI,sBAAsB,EAAI,yBAClJ,MAAM,mCAAqC,uBAAyB,EAAGA,gBAAeA,gBAAe,oCAAoC,EAAI,kCAAkC,EAAI,qCACnL,MAAM,yCAA2C,mCAAqC,EAAGA,gBAAeA,gBAAe,0CAA0C,EAAI,wCAAwC,EAAI,2CACjN,MAAM,sCAAwC,yCAA2C,EAAGA,gBAAeA,gBAAe,uCAAuC,EAAI,qCAAqC,EAAI,wCAC9M,MAAM,gBAAkB,sCAAwC,EAAGA,gBAAeA,gBAAe,iBAAiB,EAAI,eAAe,EAAI,kBAGzI,MAAM,kBAAoB,gBAAkB,EAAGA,gBAAeA,gBAAe,mBAAmB,EAAI,iBAAiB,EAAI,oBACzH,MAAM,UAAY,kBAAoB,EAAGA,gBAAeA,gBAAe,WAAW,EAAI,SAAS,EAAI,YAEnG,MAAM,aAAe,UAAY,EAAGA,gBAAeA,gBAAe,cAAc,EAAI,YAAY,EAAI,cACtG,GAAG,iBAAmB,QAAQ,eAAiB,eAAiB,CAAC,EAAE,EAMnE,IAAI,SAAU,SAAUC,SAAS,CAG/B,MAAM,WAAa,EAAGA,SAAQA,SAAQ,YAAY,EAAI,UAAU,EAAI,aAGpE,MAAM,SAAW,WAAa,EAAGA,SAAQA,SAAQ,UAAU,EAAI,QAAQ,EAAI,WAI3E,MAAM,eAAiB,SAAW,EAAGA,SAAQA,SAAQ,gBAAgB,EAAI,cAAc,EAAI,iBAG3F,MAAM,mBAAqB,eAAiB,EAAGA,SAAQA,SAAQ,oBAAoB,EAAI,kBAAkB,EAAI,oBAC/G,GAAG,UAAY,QAAQ,QAAU,QAAU,CAAC,EAAE,EAE7C,SAAS,cAAc,MAAO,CAC7B,MAAM,KAAO,MAAM,eACnB,OACE,OAAS,eAAe,qBACxB,OAAS,eAAe,2BACxB,OAAS,eAAe,wBACxB,OAAS,eAAe,oCACxB,OAAS,eAAe,0CACxB,OAAS,eAAe,qCAE5B,CAVU,sCAUR,QAAQ,cAAgB,cAEzB,SAAS,yBAAyB,MAAO,CACxC,MAAM,KAAO,MAAM,eACnB,OACE,OAAS,eAAe,2BACxB,OAAS,eAAe,wBACxB,OAAS,eAAe,0CACxB,OAAS,eAAe,qCAE5B,CARU,4DAQR,QAAQ,yBAA2B,yBAEpC,SAAS,sBAAsB,MAAO,CACrC,MAAM,KAAO,MAAM,eACnB,OACE,OAAS,eAAe,qBACxB,OAAS,eAAe,oCACxB,OAAS,eAAe,iBAE5B,CAPU,sDAOR,QAAQ,sBAAwB,sBAEjC,SAAS,yBAAyB,MAAO,CACxC,MAAM,KAAO,MAAM,eAEnB,OACE,OAAS,eAAe,qBACxB,OAAS,eAAe,wBACxB,OAAS,eAAe,oCACxB,OAAS,eAAe,qCAE5B,CATU,4DASR,QAAQ,yBAA2B,yBAEpC,SAAS,4BAA4B,MAAO,CAC3C,MAAM,KAAO,MAAM,eACnB,OACE,OAAS,eAAe,2BACxB,OAAS,eAAe,wCAE5B,CANU,kEAMR,QAAQ,4BAA8B,4BAEvC,SAAS,6BAA6B,MAAO,CAC5C,OACE,MAAM,iBAAmB,eAAe,oCACxC,MAAM,iBAAmB,eAAe,uCACxC,MAAM,iBAAmB,eAAe,wCAE5C,CANU,oEAMR,QAAQ,6BAA+B,6BAKxC,MAAM,KAAM,CACX,aAAc,CACZ,KAAK,KAAO,MAAM,MAAM,KACxB,KAAK,kBAAoB,MAAM,MAAM,kBACrC,KAAK,MAAQ,MAAM,MAAM,MACzB,KAAK,IAAM,MAAM,MAAM,IACvB,KAAK,WAAa,MAAM,MAAM,WAC9B,KAAK,OAAS,MAAM,MAAM,OAC1B,KAAK,eAAiB,KACtB,KAAK,QAAU,KACf,KAAK,cAAgB,MACrB,KAAK,iBAAmB,MACxB,KAAK,UAAY,KACjB,KAAK,YAAc,KACnB,KAAK,aAAe,MACpB,KAAK,yBAA2B,EAChC,KAAK,uBAAyB,EAC9B,KAAK,qBAAuB,MAC5B,KAAK,mBAAqB,MAC1B,KAAK,oBAAsB,KAC3B,KAAK,kBAAoB,IAC3B,CAkCF,CAvDO,sBAuDL,QAAQ,MAAQ,MAKjB,SAAS,MAAO,CACf,MAAM,MAAM,OAAO,KAAK,IAAI,KAAO,EACnC,UAAU,CACZ,CAHU,oBAGR,QAAQ,KAAO,KAGhB,SAAS,mBAAoB,CAC5B,MAAM,MAAM,OAAO,KAAK,IAAI,KAAO,EACnC,MAAM,MAAM,MAAQ,MAAM,MAAM,IAChC,cAAc,CAChB,CAJU,8CAIR,QAAQ,kBAAoB,kBAI7B,SAAS,wBAAyB,CACjC,GAAI,MAAM,MAAM,OAAS,OAAO,UAAU,OAAQ,CAChD,EAAE,MAAM,MAAM,GAChB,CACA,WAAW,CACb,CALU,wDAKR,QAAQ,uBAAyB,uBAElC,SAAS,gBAAgB,qBAAsB,CAC9C,QAAS,EAAI,MAAM,MAAM,OAAO,OAAS,qBAAsB,EAAI,MAAM,MAAM,OAAO,OAAQ,IAAK,CACjG,MAAM,MAAM,OAAO,CAAC,EAAE,OAAS,IACjC,CACA,MAAM,UAAY,MAAM,MAAM,OAC9B,MAAM,MAAM,OAAS,KACrB,OAAO,SACT,CAPU,0CAOR,QAAQ,gBAAkB,gBAE3B,SAAS,eAAe,UAAW,CAClC,MAAM,MAAM,OAAS,SACvB,CAFU,wCAER,QAAQ,eAAiB,eAE1B,SAAS,IAAI,KAAM,CAClB,GAAI,MAAM,IAAI,EAAG,CACf,KAAK,EACL,MAAO,KACT,KAAO,CACL,MAAO,MACT,CACF,CAPU,kBAOR,QAAQ,IAAM,IAEf,SAAS,aAAa,UAAW,CAChC,MAAM,UAAY,MAAM,MAAM,OAC9B,MAAM,MAAM,OAAS,KACrB,IAAI,SAAS,EACb,MAAM,MAAM,OAAS,SACvB,CALU,oCAKR,QAAQ,aAAe,aAExB,SAAS,MAAM,KAAM,CACpB,OAAO,MAAM,MAAM,OAAS,IAC9B,CAFU,sBAER,QAAQ,MAAQ,MAEjB,SAAS,eAAgB,CACxB,MAAM,SAAW,MAAM,MAAM,SAAS,EACtC,KAAK,EACL,MAAM,KAAO,MAAM,MAAM,KACzB,MAAM,MAAM,oBAAoB,QAAQ,EACxC,OAAO,IACT,CANU,sCAMR,QAAQ,cAAgB,cAEzB,MAAM,cAAe,CAGpB,YAAY,KAAM,kBAAmB,CACnC,KAAK,KAAO,KACZ,KAAK,kBAAoB,iBAC3B,CACF,CAPO,wCAOL,QAAQ,eAAiB,eAE1B,SAAS,yBAA0B,CAClC,MAAM,SAAW,MAAM,MAAM,SAAS,EACtC,KAAK,EACL,MAAM,KAAO,MAAM,MAAM,KACzB,MAAM,kBAAoB,MAAM,MAAM,kBACtC,MAAM,MAAM,oBAAoB,QAAQ,EACxC,OAAO,IAAI,eAAe,KAAM,iBAAiB,CACnD,CAPU,0DAOR,QAAQ,wBAA0B,wBAEnC,SAAS,gBAAiB,CACzB,OAAO,oBAAoB,MAAM,MAAM,GAAG,CAC5C,CAFU,wCAER,QAAQ,eAAiB,eAE1B,SAAS,oBAAoB,IAAK,CACjC,YAAY,eAAe,UAAY,IACvC,MAAM,KAAO,YAAY,eAAe,KAAK,MAAM,KAAK,EACxD,OAAO,IAAM,KAAK,CAAC,EAAE,MACvB,CAJU,kDAIR,QAAQ,oBAAsB,oBAE/B,SAAS,mBAAoB,CAC5B,OAAO,MAAM,MAAM,WAAW,eAAe,CAAC,CAChD,CAFU,8CAER,QAAQ,kBAAoB,kBAI7B,SAAS,WAAY,CACpB,UAAU,EACV,MAAM,MAAM,MAAQ,MAAM,MAAM,IAChC,GAAI,MAAM,MAAM,KAAO,MAAM,MAAM,OAAQ,CACzC,MAAM,OAAS,MAAM,MAAM,OAI3B,GACE,OAAO,QAAU,GACjB,OAAO,OAAO,OAAS,CAAC,EAAE,OAAS,MAAM,MAAM,QAC/C,OAAO,OAAO,OAAS,CAAC,EAAE,OAAS,MAAM,MAAM,OAC/C,CACA,MAAM,WAAW,KAAK,OAAQ,wCAAwC,CACxE,CACA,YAAY,OAAO,UAAU,GAAG,EAChC,MACF,CACA,UAAU,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,CAAC,CACnD,CAnBU,8BAmBR,QAAQ,UAAY,UAEtB,SAAS,UAAU,KAAM,CAGvB,GACE,YAAY,oBAAoB,IAAI,GACpC,OAAS,WAAW,UAAU,WAC7B,OAAS,WAAW,UAAU,QAAU,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,IAAM,WAAW,UAAU,OAC9G,CACA,WAAW,QAAQ,KAAK,MAAQ,CAClC,KAAO,CACL,iBAAiB,IAAI,CACvB,CACF,CAZS,8BAcT,SAAS,kBAAmB,CAC1B,MACE,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,IAAM,WAAW,UAAU,UACjE,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,IAAM,WAAW,UAAU,MACrE,CACA,MAAM,MAAM,MACZ,GAAI,MAAM,MAAM,IAAM,MAAM,MAAM,OAAQ,CACxC,MAAM,WAAW,KAAK,OAAQ,uBAAwB,MAAM,MAAM,IAAM,CAAC,EACzE,MACF,CACF,CACA,MAAM,MAAM,KAAO,CACrB,CAZS,4CAcR,SAAS,gBAAgB,UAAW,CACnC,IAAI,GAAK,MAAM,MAAM,WAAY,MAAM,MAAM,KAAO,SAAU,EAC9D,GAAI,MAAM,MAAM,IAAM,MAAM,MAAM,OAAQ,CACxC,MACE,KAAO,WAAW,UAAU,UAC5B,KAAO,WAAW,UAAU,gBAC5B,KAAO,WAAW,UAAU,eAC5B,KAAO,WAAW,UAAU,oBAC5B,EAAE,MAAM,MAAM,IAAM,MAAM,MAAM,OAChC,CACA,GAAK,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,CAC7C,CACF,CACF,CAbU,0CAaR,QAAQ,gBAAkB,gBAI3B,SAAS,WAAY,CACpB,MAAO,MAAM,MAAM,IAAM,MAAM,MAAM,OAAQ,CAC3C,MAAM,GAAK,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,EACjD,OAAQ,GAAI,CACV,KAAK,WAAW,UAAU,eACxB,GAAI,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,IAAM,WAAW,UAAU,SAAU,CACjF,EAAE,MAAM,MAAM,GAChB,CAEF,KAAK,WAAW,UAAU,SAC1B,KAAK,WAAW,UAAU,cAC1B,KAAK,WAAW,UAAU,mBACxB,EAAE,MAAM,MAAM,IACd,MAEF,KAAK,WAAW,UAAU,MACxB,OAAQ,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,EAAG,CACnD,KAAK,WAAW,UAAU,SACxB,MAAM,MAAM,KAAO,EACnB,iBAAiB,EACjB,MAEF,KAAK,WAAW,UAAU,MACxB,gBAAgB,CAAC,EACjB,MAEF,QACE,MACJ,CACA,MAEF,QACE,GAAI,YAAY,cAAc,EAAE,EAAG,CACjC,EAAE,MAAM,MAAM,GAChB,KAAO,CACL,MACF,CACJ,CACF,CACF,CAvCU,8BAuCR,QAAQ,UAAY,UAIrB,SAAS,YACR,KACA,kBAAoB,UAAU,kBAAkB,KAChD,CACA,MAAM,MAAM,IAAM,MAAM,MAAM,IAC9B,MAAM,MAAM,KAAO,KACnB,MAAM,MAAM,kBAAoB,iBAClC,CAPU,kCAOR,QAAQ,YAAc,YAUxB,SAAS,eAAgB,CACvB,MAAM,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,EAC3D,GAAI,UAAY,WAAW,UAAU,QAAU,UAAY,WAAW,UAAU,OAAQ,CACtF,WAAW,IAAI,EACf,MACF,CAEA,GAAI,WAAa,WAAW,UAAU,KAAO,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,IAAM,WAAW,UAAU,IAAK,CACrH,MAAM,MAAM,KAAO,EACnB,YAAY,OAAO,UAAU,QAAQ,CACvC,KAAO,CACL,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,GAAG,CAClC,CACF,CAdS,sCAgBT,SAAS,iBAAkB,CACzB,MAAM,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,EAC3D,GAAI,WAAa,WAAW,UAAU,SAAU,CAC9C,SAAS,OAAO,UAAU,OAAQ,CAAC,CACrC,KAAO,CACL,SAAS,OAAO,UAAU,MAAO,CAAC,CACpC,CACF,CAPS,0CAST,SAAS,sBAAsB,KAAM,CAEnC,IAAI,UAAY,OAAS,WAAW,UAAU,SAAW,OAAO,UAAU,KAAO,OAAO,UAAU,OAClG,IAAI,MAAQ,EACZ,IAAI,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,EAGzD,GAAI,OAAS,WAAW,UAAU,UAAY,WAAa,WAAW,UAAU,SAAU,CACxF,QACA,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,EACrD,UAAY,OAAO,UAAU,QAC/B,CAGA,GACE,WAAa,WAAW,UAAU,UAClC,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,IAAM,WAAW,UAAU,YACrE,CACA,QACA,UAAY,OAAO,UAAU,MAC/B,CAEA,SAAS,UAAW,KAAK,CAC3B,CAvBS,sDAyBT,SAAS,mBAAmB,KAAM,CAEhC,MAAM,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,EAE3D,GAAI,WAAa,KAAM,CACrB,GAAI,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,IAAM,WAAW,UAAU,SAAU,CAEjF,SAAS,OAAO,UAAU,OAAQ,CAAC,CACrC,KAAO,CAEL,SAAS,OAAS,WAAW,UAAU,YAAc,OAAO,UAAU,UAAY,OAAO,UAAU,WAAY,CAAC,CAClH,CACA,MACF,CAEA,GAAI,OAAS,WAAW,UAAU,YAAa,CAE7C,GAAI,WAAa,WAAW,UAAU,YAAa,CACjD,SAAS,OAAO,UAAU,SAAU,CAAC,EACrC,MACF,SAAW,WAAa,WAAW,UAAU,iBAAmB,MAAM,cAAe,CAEnF,SAAS,OAAO,UAAU,UAAW,CAAC,EACtC,MACF,CACF,CAEA,GAAI,WAAa,WAAW,UAAU,SAAU,CAC9C,SAAS,OAAO,UAAU,OAAQ,CAAC,EACnC,MACF,CAEA,SAAS,OAAS,WAAW,UAAU,YAAc,OAAO,UAAU,UAAY,OAAO,UAAU,WAAY,CAAC,CAClH,CAjCS,gDAmCT,SAAS,iBAAkB,CAEzB,MAAM,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,EAC3D,GAAI,WAAa,WAAW,UAAU,SAAU,CAC9C,SAAS,OAAO,UAAU,OAAQ,CAAC,CACrC,KAAO,CACL,SAAS,OAAO,UAAU,WAAY,CAAC,CACzC,CACF,CARS,0CAUT,SAAS,mBAAmB,KAAM,CAEhC,MAAM,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,EAE3D,GAAI,WAAa,KAAM,CAErB,SAAS,OAAO,UAAU,UAAW,CAAC,EACtC,MACF,CAEA,GAAI,WAAa,WAAW,UAAU,SAAU,CAC9C,SAAS,OAAO,UAAU,OAAQ,CAAC,CACrC,SAAW,OAAS,WAAW,UAAU,SAAU,CACjD,SAAS,OAAO,UAAU,KAAM,CAAC,CACnC,KAAO,CACL,SAAS,OAAO,UAAU,MAAO,CAAC,CACpC,CACF,CAjBS,gDAmBT,SAAS,cAAe,CACtB,MAAM,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,EAE3D,GAAI,WAAa,WAAW,UAAU,SAAU,CAC9C,GAAI,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,IAAM,WAAW,UAAU,SAAU,CACjF,SAAS,OAAO,UAAU,OAAQ,CAAC,EACnC,MACF,CAGA,GAAI,MAAM,MAAM,OAAQ,CAOtB,SAAS,OAAO,UAAU,SAAU,CAAC,CACvC,KAAO,CAOL,SAAS,OAAO,UAAU,UAAW,CAAC,CACxC,CACA,MACF,CAEA,GAAI,WAAa,WAAW,UAAU,SAAU,CAE9C,SAAS,OAAO,UAAU,kBAAmB,CAAC,CAChD,KAAO,CACL,SAAS,OAAO,UAAU,SAAU,CAAC,CACvC,CACF,CApCS,oCAsCT,SAAS,cAAe,CACtB,GAAI,MAAM,MAAM,OAAQ,CAGtB,SAAS,OAAO,UAAU,YAAa,CAAC,EACxC,MACF,CAEA,MAAM,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,EAE3D,GAAI,WAAa,WAAW,UAAU,YAAa,CACjD,MAAM,KAAO,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,IAAM,WAAW,UAAU,YAAc,EAAI,EACpG,GAAI,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,IAAI,IAAM,WAAW,UAAU,SAAU,CACpF,SAAS,OAAO,UAAU,OAAQ,KAAO,CAAC,EAC1C,MACF,CACA,SAAS,OAAO,UAAU,UAAW,IAAI,EACzC,MACF,CAEA,GAAI,WAAa,WAAW,UAAU,SAAU,CAE9C,SAAS,OAAO,UAAU,kBAAmB,CAAC,CAChD,KAAO,CACL,SAAS,OAAO,UAAU,YAAa,CAAC,CAC1C,CACF,CA1BS,oCAuCR,SAAS,WAAY,CACpB,GAAI,MAAM,MAAM,OAAS,OAAO,UAAU,YAAa,CACrD,MAAM,MAAM,KAAO,EACnB,aAAa,CACf,CACF,CALU,8BAKR,QAAQ,UAAY,UAEtB,SAAS,kBAAkB,KAAM,CAE/B,MAAM,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,EAC3D,GAAI,WAAa,WAAW,UAAU,SAAU,CAC9C,SAAS,OAAO,UAAU,SAAU,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,IAAM,WAAW,UAAU,SAAW,EAAI,CAAC,EACzH,MACF,CACA,GAAI,OAAS,WAAW,UAAU,UAAY,WAAa,WAAW,UAAU,YAAa,CAE3F,MAAM,MAAM,KAAO,EACnB,YAAY,OAAO,UAAU,KAAK,EAClC,MACF,CACA,SAAS,OAAS,WAAW,UAAU,SAAW,OAAO,UAAU,GAAK,OAAO,UAAU,KAAM,CAAC,CAClG,CAdS,8CAgBT,SAAS,oBAAqB,CAE5B,MAAM,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,EAC3D,MAAM,UAAY,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,EAC5D,GACE,WAAa,WAAW,UAAU,cAGlC,EAAE,MAAM,eAAiB,MAAM,MAAM,QACrC,CACA,GAAI,YAAc,WAAW,UAAU,SAAU,CAE/C,SAAS,OAAO,UAAU,OAAQ,CAAC,CACrC,KAAO,CAEL,SAAS,OAAO,UAAU,kBAAmB,CAAC,CAChD,CACF,SACE,WAAa,WAAW,UAAU,KAClC,EAAE,WAAa,WAAW,UAAU,QAAU,WAAa,WAAW,UAAU,QAChF,CAEA,MAAM,MAAM,KAAO,EACnB,YAAY,OAAO,UAAU,WAAW,CAC1C,KAAO,CACL,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,QAAQ,CACvC,CACF,CA5BS,gDA8BR,SAAS,iBAAiB,KAAM,CAC/B,OAAQ,KAAM,CACZ,KAAK,WAAW,UAAU,WACxB,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,IAAI,EACjC,OAKF,KAAK,WAAW,UAAU,IACxB,cAAc,EACd,OAGF,KAAK,WAAW,UAAU,gBACxB,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,MAAM,EACnC,OACF,KAAK,WAAW,UAAU,iBACxB,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,MAAM,EACnC,OACF,KAAK,WAAW,UAAU,UACxB,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,IAAI,EACjC,OACF,KAAK,WAAW,UAAU,MACxB,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,KAAK,EAClC,OACF,KAAK,WAAW,UAAU,kBACxB,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,QAAQ,EACrC,OACF,KAAK,WAAW,UAAU,mBACxB,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,QAAQ,EACrC,OAEF,KAAK,WAAW,UAAU,eACxB,GAAI,MAAM,eAAiB,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,IAAM,WAAW,UAAU,YAAa,CAC3G,SAAS,OAAO,UAAU,UAAW,CAAC,CACxC,KAAO,CACL,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,MAAM,CACrC,CACA,OAEF,KAAK,WAAW,UAAU,gBACxB,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,MAAM,EACnC,OAEF,KAAK,WAAW,UAAU,MACxB,GAAI,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,IAAM,WAAW,UAAU,MAAO,CAC9E,SAAS,OAAO,UAAU,YAAa,CAAC,CAC1C,KAAO,CACL,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,KAAK,CACpC,CACA,OAEF,KAAK,WAAW,UAAU,aACxB,mBAAmB,EACnB,OACF,KAAK,WAAW,UAAU,OACxB,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,EAAE,EAC/B,OAEF,KAAK,WAAW,UAAU,YACxB,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,SAAS,EACtC,OAEF,KAAK,WAAW,UAAU,OAAQ,CAChC,MAAM,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,EAE3D,GACE,WAAa,WAAW,UAAU,YAClC,WAAa,WAAW,UAAU,YAClC,WAAa,WAAW,UAAU,YAClC,WAAa,WAAW,UAAU,YAClC,WAAa,WAAW,UAAU,YAClC,WAAa,WAAW,UAAU,WAClC,CACA,gBAAgB,EAChB,MACF,CACF,CAGA,KAAK,WAAW,UAAU,OAC1B,KAAK,WAAW,UAAU,OAC1B,KAAK,WAAW,UAAU,OAC1B,KAAK,WAAW,UAAU,OAC1B,KAAK,WAAW,UAAU,OAC1B,KAAK,WAAW,UAAU,OAC1B,KAAK,WAAW,UAAU,OAC1B,KAAK,WAAW,UAAU,OAC1B,KAAK,WAAW,UAAU,OACxB,WAAW,KAAK,EAChB,OAGF,KAAK,WAAW,UAAU,cAC1B,KAAK,WAAW,UAAU,WACxB,WAAW,IAAI,EACf,OAOF,KAAK,WAAW,UAAU,MACxB,gBAAgB,EAChB,OAEF,KAAK,WAAW,UAAU,YAC1B,KAAK,WAAW,UAAU,SACxB,sBAAsB,IAAI,EAC1B,OAEF,KAAK,WAAW,UAAU,YAC1B,KAAK,WAAW,UAAU,UACxB,mBAAmB,IAAI,EACvB,OAEF,KAAK,WAAW,UAAU,MACxB,gBAAgB,EAChB,OAEF,KAAK,WAAW,UAAU,SAC1B,KAAK,WAAW,UAAU,KACxB,mBAAmB,IAAI,EACvB,OAEF,KAAK,WAAW,UAAU,SACxB,aAAa,EACb,OAEF,KAAK,WAAW,UAAU,YACxB,aAAa,EACb,OAEF,KAAK,WAAW,UAAU,SAC1B,KAAK,WAAW,UAAU,gBACxB,kBAAkB,IAAI,EACtB,OAEF,KAAK,WAAW,UAAU,MACxB,SAAS,OAAO,UAAU,MAAO,CAAC,EAClC,OAEF,QACE,KACJ,CAEA,MAAM,WAAW,KAAK,OAAQ,yBAAyB,OAAO,aAAa,IAAI,KAAM,MAAM,MAAM,GAAG,CACtG,CAjKU,4CAiKR,QAAQ,iBAAmB,iBAE7B,SAAS,SAAS,KAAM,KAAM,CAC5B,MAAM,MAAM,KAAO,KACnB,YAAY,IAAI,CAClB,CAHS,4BAKT,SAAS,YAAa,CACpB,MAAM,MAAQ,MAAM,MAAM,IAC1B,IAAI,QAAU,MACd,IAAI,QAAU,MACd,OAAS,CACP,GAAI,MAAM,MAAM,KAAO,MAAM,MAAM,OAAQ,CACzC,MAAM,WAAW,KAAK,OAAQ,kCAAmC,KAAK,EACtE,MACF,CACA,MAAM,KAAO,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,EACnD,GAAI,QAAS,CACX,QAAU,KACZ,KAAO,CACL,GAAI,OAAS,WAAW,UAAU,kBAAmB,CACnD,QAAU,IACZ,SAAW,OAAS,WAAW,UAAU,oBAAsB,QAAS,CACtE,QAAU,KACZ,SAAW,OAAS,WAAW,UAAU,OAAS,CAAC,QAAS,CAC1D,KACF,CACA,QAAU,OAAS,WAAW,UAAU,SAC1C,CACA,EAAE,MAAM,MAAM,GAChB,CACA,EAAE,MAAM,MAAM,IAEd,SAAS,EAET,YAAY,OAAO,UAAU,MAAM,CACrC,CA7BS,gCAoCT,SAAS,SAAU,CACjB,MAAO,KAAM,CACX,MAAM,KAAO,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,EACnD,GAAK,MAAQ,WAAW,UAAU,QAAU,MAAQ,WAAW,UAAU,QAAW,OAAS,WAAW,UAAU,WAAY,CAC5H,MAAM,MAAM,KACd,KAAO,CACL,KACF,CACF,CACF,CATS,0BAWT,SAAS,iBAAkB,CACzB,MAAM,MAAM,KAAO,EAGnB,MAAO,KAAM,CACX,MAAM,KAAO,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,EACnD,GACG,MAAQ,WAAW,UAAU,QAAU,MAAQ,WAAW,UAAU,QACpE,MAAQ,WAAW,UAAU,YAAc,MAAQ,WAAW,UAAU,YACxE,MAAQ,WAAW,UAAU,YAAc,MAAQ,WAAW,UAAU,YACzE,OAAS,WAAW,UAAU,WAC9B,CACA,MAAM,MAAM,KACd,KAAO,CACL,KACF,CACF,CAEA,MAAM,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,EACvD,GAAI,WAAa,WAAW,UAAU,WAAY,CAChD,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,MAAM,CACrC,KAAO,CACL,YAAY,OAAO,UAAU,GAAG,CAClC,CACF,CAzBS,0CA4BT,SAAS,WAAW,cAAe,CACjC,IAAI,SAAW,MACf,IAAI,UAAY,MAEhB,GAAI,CAAC,cAAe,CAClB,QAAQ,CACV,CAEA,IAAI,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,EACrD,GAAI,WAAa,WAAW,UAAU,IAAK,CACzC,EAAE,MAAM,MAAM,IACd,QAAQ,EACR,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,CACnD,CAEA,GAAI,WAAa,WAAW,UAAU,YAAc,WAAa,WAAW,UAAU,WAAY,CAChG,SAAW,MAAM,MAAM,WAAW,EAAE,MAAM,MAAM,GAAG,EACnD,GAAI,WAAa,WAAW,UAAU,UAAY,WAAa,WAAW,UAAU,KAAM,CACxF,EAAE,MAAM,MAAM,GAChB,CACA,QAAQ,EACR,SAAW,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,CACnD,CAEA,GAAI,WAAa,WAAW,UAAU,WAAY,CAChD,EAAE,MAAM,MAAM,IACd,SAAW,IACb,SAAW,WAAa,WAAW,UAAU,WAAY,CACvD,EAAE,MAAM,MAAM,IACd,UAAY,IACd,CAEA,GAAI,SAAU,CACZ,YAAY,OAAO,UAAU,MAAM,EACnC,MACF,CAEA,GAAI,UAAW,CACb,YAAY,OAAO,UAAU,OAAO,EACpC,MACF,CAEA,YAAY,OAAO,UAAU,GAAG,CAClC,CA3CS,gCA6CT,SAAS,WAAW,MAAO,CACzB,MAAM,MAAM,MACZ,OAAS,CACP,GAAI,MAAM,MAAM,KAAO,MAAM,MAAM,OAAQ,CACzC,MAAM,WAAW,KAAK,OAAQ,8BAA8B,EAC5D,MACF,CACA,MAAM,GAAK,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,EACjD,GAAI,KAAO,WAAW,UAAU,UAAW,CACzC,MAAM,MAAM,KACd,SAAW,KAAO,MAAO,CACvB,KACF,CACA,MAAM,MAAM,KACd,CACA,MAAM,MAAM,MACZ,YAAY,OAAO,UAAU,MAAM,CACrC,CAjBS,gCAoBT,SAAS,eAAgB,CACvB,OAAS,CACP,GAAI,MAAM,MAAM,KAAO,MAAM,MAAM,OAAQ,CACzC,MAAM,WAAW,KAAK,OAAQ,uBAAuB,EACrD,MACF,CACA,MAAM,GAAK,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,EACjD,GACE,KAAO,WAAW,UAAU,aAC3B,KAAO,WAAW,UAAU,YAAc,MAAM,MAAM,WAAW,MAAM,MAAM,IAAM,CAAC,IAAM,WAAW,UAAU,eAChH,CACA,GAAI,MAAM,MAAM,MAAQ,MAAM,MAAM,OAAS,MAAM,OAAO,UAAU,QAAQ,EAAG,CAC7E,GAAI,KAAO,WAAW,UAAU,WAAY,CAC1C,MAAM,MAAM,KAAO,EACnB,YAAY,OAAO,UAAU,YAAY,EACzC,MACF,KAAO,CACL,EAAE,MAAM,MAAM,IACd,YAAY,OAAO,UAAU,SAAS,EACtC,MACF,CACF,CACA,YAAY,OAAO,UAAU,QAAQ,EACrC,MACF,CACA,GAAI,KAAO,WAAW,UAAU,UAAW,CACzC,MAAM,MAAM,KACd,CACA,MAAM,MAAM,KACd,CACF,CA9BS,sCAmCR,SAAS,UAAW,CACnB,MAAO,MAAM,MAAM,IAAM,MAAM,MAAM,OAAQ,CAC3C,MAAM,GAAK,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,EACjD,GAAI,YAAY,mBAAmB,EAAE,EAAG,CACtC,MAAM,MAAM,KACd,SAAW,KAAO,WAAW,UAAU,UAAW,CAEhD,MAAM,MAAM,KAAO,EACnB,GAAI,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,IAAM,WAAW,UAAU,eAAgB,CACnF,MACE,MAAM,MAAM,IAAM,MAAM,MAAM,QAC9B,MAAM,MAAM,WAAW,MAAM,MAAM,GAAG,IAAM,WAAW,UAAU,gBACjE,CACA,MAAM,MAAM,KACd,CACA,MAAM,MAAM,KACd,CACF,KAAO,CACL,KACF,CACF,CACF,CArBU,4BAqBR,QAAQ,SAAW","names":["IdentifierRole","JSXRole"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/parser/tokenizer/index.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }/* eslint max-len: 0 */\n\nvar _base = require('../traverser/base');\nvar _util = require('../traverser/util');\nvar _charcodes = require('../util/charcodes');\nvar _identifier = require('../util/identifier');\nvar _whitespace = require('../util/whitespace');\nvar _keywords = require('./keywords');\nvar _readWord = require('./readWord'); var _readWord2 = _interopRequireDefault(_readWord);\nvar _types = require('./types');\n\nvar IdentifierRole; (function (IdentifierRole) {\n  const Access = 0; IdentifierRole[IdentifierRole[\"Access\"] = Access] = \"Access\";\n  const ExportAccess = Access + 1; IdentifierRole[IdentifierRole[\"ExportAccess\"] = ExportAccess] = \"ExportAccess\";\n  const TopLevelDeclaration = ExportAccess + 1; IdentifierRole[IdentifierRole[\"TopLevelDeclaration\"] = TopLevelDeclaration] = \"TopLevelDeclaration\";\n  const FunctionScopedDeclaration = TopLevelDeclaration + 1; IdentifierRole[IdentifierRole[\"FunctionScopedDeclaration\"] = FunctionScopedDeclaration] = \"FunctionScopedDeclaration\";\n  const BlockScopedDeclaration = FunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"BlockScopedDeclaration\"] = BlockScopedDeclaration] = \"BlockScopedDeclaration\";\n  const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthandTopLevelDeclaration\"] = ObjectShorthandTopLevelDeclaration] = \"ObjectShorthandTopLevelDeclaration\";\n  const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthandFunctionScopedDeclaration\"] = ObjectShorthandFunctionScopedDeclaration] = \"ObjectShorthandFunctionScopedDeclaration\";\n  const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthandBlockScopedDeclaration\"] = ObjectShorthandBlockScopedDeclaration] = \"ObjectShorthandBlockScopedDeclaration\";\n  const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthand\"] = ObjectShorthand] = \"ObjectShorthand\";\n  // Any identifier bound in an import statement, e.g. both A and b from\n  // `import A, * as b from 'A';`\n  const ImportDeclaration = ObjectShorthand + 1; IdentifierRole[IdentifierRole[\"ImportDeclaration\"] = ImportDeclaration] = \"ImportDeclaration\";\n  const ObjectKey = ImportDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectKey\"] = ObjectKey] = \"ObjectKey\";\n  // The `foo` in `import {foo as bar} from \"./abc\";`.\n  const ImportAccess = ObjectKey + 1; IdentifierRole[IdentifierRole[\"ImportAccess\"] = ImportAccess] = \"ImportAccess\";\n})(IdentifierRole || (exports.IdentifierRole = IdentifierRole = {}));\n\n/**\n * Extra information on jsxTagStart tokens, used to determine which of the three\n * jsx functions are called in the automatic transform.\n */\nvar JSXRole; (function (JSXRole) {\n  // The element is self-closing or has a body that resolves to empty. We\n  // shouldn't emit children at all in this case.\n  const NoChildren = 0; JSXRole[JSXRole[\"NoChildren\"] = NoChildren] = \"NoChildren\";\n  // The element has a single explicit child, which might still be an arbitrary\n  // expression like an array. We should emit that expression as the children.\n  const OneChild = NoChildren + 1; JSXRole[JSXRole[\"OneChild\"] = OneChild] = \"OneChild\";\n  // The element has at least two explicitly-specified children or has spread\n  // children, so child positions are assumed to be \"static\". We should wrap\n  // these children in an array.\n  const StaticChildren = OneChild + 1; JSXRole[JSXRole[\"StaticChildren\"] = StaticChildren] = \"StaticChildren\";\n  // The element has a prop named \"key\" after a prop spread, so we should fall\n  // back to the createElement function.\n  const KeyAfterPropSpread = StaticChildren + 1; JSXRole[JSXRole[\"KeyAfterPropSpread\"] = KeyAfterPropSpread] = \"KeyAfterPropSpread\";\n})(JSXRole || (exports.JSXRole = JSXRole = {}));\n\n function isDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.TopLevelDeclaration ||\n    role === IdentifierRole.FunctionScopedDeclaration ||\n    role === IdentifierRole.BlockScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration\n  );\n} exports.isDeclaration = isDeclaration;\n\n function isNonTopLevelDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.FunctionScopedDeclaration ||\n    role === IdentifierRole.BlockScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration\n  );\n} exports.isNonTopLevelDeclaration = isNonTopLevelDeclaration;\n\n function isTopLevelDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.TopLevelDeclaration ||\n    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    role === IdentifierRole.ImportDeclaration\n  );\n} exports.isTopLevelDeclaration = isTopLevelDeclaration;\n\n function isBlockScopedDeclaration(token) {\n  const role = token.identifierRole;\n  // Treat top-level declarations as block scope since the distinction doesn't matter here.\n  return (\n    role === IdentifierRole.TopLevelDeclaration ||\n    role === IdentifierRole.BlockScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration\n  );\n} exports.isBlockScopedDeclaration = isBlockScopedDeclaration;\n\n function isFunctionScopedDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.FunctionScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration\n  );\n} exports.isFunctionScopedDeclaration = isFunctionScopedDeclaration;\n\n function isObjectShorthandDeclaration(token) {\n  return (\n    token.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    token.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration ||\n    token.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration\n  );\n} exports.isObjectShorthandDeclaration = isObjectShorthandDeclaration;\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n class Token {\n  constructor() {\n    this.type = _base.state.type;\n    this.contextualKeyword = _base.state.contextualKeyword;\n    this.start = _base.state.start;\n    this.end = _base.state.end;\n    this.scopeDepth = _base.state.scopeDepth;\n    this.isType = _base.state.isType;\n    this.identifierRole = null;\n    this.jsxRole = null;\n    this.shadowsGlobal = false;\n    this.isAsyncOperation = false;\n    this.contextId = null;\n    this.rhsEndIndex = null;\n    this.isExpression = false;\n    this.numNullishCoalesceStarts = 0;\n    this.numNullishCoalesceEnds = 0;\n    this.isOptionalChainStart = false;\n    this.isOptionalChainEnd = false;\n    this.subscriptStartIndex = null;\n    this.nullishStartIndex = null;\n  }\n\n  \n  \n  \n  \n  \n  \n  \n  \n  // Initially false for all tokens, then may be computed in a follow-up step that does scope\n  // analysis.\n  \n  // Initially false for all tokens, but may be set during transform to mark it as containing an\n  // await operation.\n  \n  \n  // For assignments, the index of the RHS. For export tokens, the end of the export.\n  \n  // For class tokens, records if the class is a class expression or a class statement.\n  \n  // Number of times to insert a `nullishCoalesce(` snippet before this token.\n  \n  // Number of times to insert a `)` snippet after this token.\n  \n  // If true, insert an `optionalChain([` snippet before this token.\n  \n  // If true, insert a `])` snippet after this token.\n  \n  // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the \"root\" token for this\n  // subscript chain. This can be used to determine if this chain is an optional chain.\n  \n  // Tag for `??` operators to denote the root token for this nullish coalescing call.\n  \n} exports.Token = Token;\n\n// ## Tokenizer\n\n// Move to the next token\n function next() {\n  _base.state.tokens.push(new Token());\n  nextToken();\n} exports.next = next;\n\n// Call instead of next when inside a template, since that needs to be handled differently.\n function nextTemplateToken() {\n  _base.state.tokens.push(new Token());\n  _base.state.start = _base.state.pos;\n  readTmplToken();\n} exports.nextTemplateToken = nextTemplateToken;\n\n// The tokenizer never parses regexes by default. Instead, the parser is responsible for\n// instructing it to parse a regex when we see a slash at the start of an expression.\n function retokenizeSlashAsRegex() {\n  if (_base.state.type === _types.TokenType.assign) {\n    --_base.state.pos;\n  }\n  readRegexp();\n} exports.retokenizeSlashAsRegex = retokenizeSlashAsRegex;\n\n function pushTypeContext(existingTokensInType) {\n  for (let i = _base.state.tokens.length - existingTokensInType; i < _base.state.tokens.length; i++) {\n    _base.state.tokens[i].isType = true;\n  }\n  const oldIsType = _base.state.isType;\n  _base.state.isType = true;\n  return oldIsType;\n} exports.pushTypeContext = pushTypeContext;\n\n function popTypeContext(oldIsType) {\n  _base.state.isType = oldIsType;\n} exports.popTypeContext = popTypeContext;\n\n function eat(type) {\n  if (match(type)) {\n    next();\n    return true;\n  } else {\n    return false;\n  }\n} exports.eat = eat;\n\n function eatTypeToken(tokenType) {\n  const oldIsType = _base.state.isType;\n  _base.state.isType = true;\n  eat(tokenType);\n  _base.state.isType = oldIsType;\n} exports.eatTypeToken = eatTypeToken;\n\n function match(type) {\n  return _base.state.type === type;\n} exports.match = match;\n\n function lookaheadType() {\n  const snapshot = _base.state.snapshot();\n  next();\n  const type = _base.state.type;\n  _base.state.restoreFromSnapshot(snapshot);\n  return type;\n} exports.lookaheadType = lookaheadType;\n\n class TypeAndKeyword {\n  \n  \n  constructor(type, contextualKeyword) {\n    this.type = type;\n    this.contextualKeyword = contextualKeyword;\n  }\n} exports.TypeAndKeyword = TypeAndKeyword;\n\n function lookaheadTypeAndKeyword() {\n  const snapshot = _base.state.snapshot();\n  next();\n  const type = _base.state.type;\n  const contextualKeyword = _base.state.contextualKeyword;\n  _base.state.restoreFromSnapshot(snapshot);\n  return new TypeAndKeyword(type, contextualKeyword);\n} exports.lookaheadTypeAndKeyword = lookaheadTypeAndKeyword;\n\n function nextTokenStart() {\n  return nextTokenStartSince(_base.state.pos);\n} exports.nextTokenStart = nextTokenStart;\n\n function nextTokenStartSince(pos) {\n  _whitespace.skipWhiteSpace.lastIndex = pos;\n  const skip = _whitespace.skipWhiteSpace.exec(_base.input);\n  return pos + skip[0].length;\n} exports.nextTokenStartSince = nextTokenStartSince;\n\n function lookaheadCharCode() {\n  return _base.input.charCodeAt(nextTokenStart());\n} exports.lookaheadCharCode = lookaheadCharCode;\n\n// Read a single token, updating the parser object's token-related\n// properties.\n function nextToken() {\n  skipSpace();\n  _base.state.start = _base.state.pos;\n  if (_base.state.pos >= _base.input.length) {\n    const tokens = _base.state.tokens;\n    // We normally run past the end a bit, but if we're way past the end, avoid an infinite loop.\n    // Also check the token positions rather than the types since sometimes we rewrite the token\n    // type to something else.\n    if (\n      tokens.length >= 2 &&\n      tokens[tokens.length - 1].start >= _base.input.length &&\n      tokens[tokens.length - 2].start >= _base.input.length\n    ) {\n      _util.unexpected.call(void 0, \"Unexpectedly reached the end of input.\");\n    }\n    finishToken(_types.TokenType.eof);\n    return;\n  }\n  readToken(_base.input.charCodeAt(_base.state.pos));\n} exports.nextToken = nextToken;\n\nfunction readToken(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (\n    _identifier.IS_IDENTIFIER_START[code] ||\n    code === _charcodes.charCodes.backslash ||\n    (code === _charcodes.charCodes.atSign && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.atSign)\n  ) {\n    _readWord2.default.call(void 0, );\n  } else {\n    getTokenFromCode(code);\n  }\n}\n\nfunction skipBlockComment() {\n  while (\n    _base.input.charCodeAt(_base.state.pos) !== _charcodes.charCodes.asterisk ||\n    _base.input.charCodeAt(_base.state.pos + 1) !== _charcodes.charCodes.slash\n  ) {\n    _base.state.pos++;\n    if (_base.state.pos > _base.input.length) {\n      _util.unexpected.call(void 0, \"Unterminated comment\", _base.state.pos - 2);\n      return;\n    }\n  }\n  _base.state.pos += 2;\n}\n\n function skipLineComment(startSkip) {\n  let ch = _base.input.charCodeAt((_base.state.pos += startSkip));\n  if (_base.state.pos < _base.input.length) {\n    while (\n      ch !== _charcodes.charCodes.lineFeed &&\n      ch !== _charcodes.charCodes.carriageReturn &&\n      ch !== _charcodes.charCodes.lineSeparator &&\n      ch !== _charcodes.charCodes.paragraphSeparator &&\n      ++_base.state.pos < _base.input.length\n    ) {\n      ch = _base.input.charCodeAt(_base.state.pos);\n    }\n  }\n} exports.skipLineComment = skipLineComment;\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments.\n function skipSpace() {\n  while (_base.state.pos < _base.input.length) {\n    const ch = _base.input.charCodeAt(_base.state.pos);\n    switch (ch) {\n      case _charcodes.charCodes.carriageReturn:\n        if (_base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.lineFeed) {\n          ++_base.state.pos;\n        }\n\n      case _charcodes.charCodes.lineFeed:\n      case _charcodes.charCodes.lineSeparator:\n      case _charcodes.charCodes.paragraphSeparator:\n        ++_base.state.pos;\n        break;\n\n      case _charcodes.charCodes.slash:\n        switch (_base.input.charCodeAt(_base.state.pos + 1)) {\n          case _charcodes.charCodes.asterisk:\n            _base.state.pos += 2;\n            skipBlockComment();\n            break;\n\n          case _charcodes.charCodes.slash:\n            skipLineComment(2);\n            break;\n\n          default:\n            return;\n        }\n        break;\n\n      default:\n        if (_whitespace.IS_WHITESPACE[ch]) {\n          ++_base.state.pos;\n        } else {\n          return;\n        }\n    }\n  }\n} exports.skipSpace = skipSpace;\n\n// Called at the end of every token. Sets various fields, and skips the space after the token, so\n// that the next one's `start` will point at the right position.\n function finishToken(\n  type,\n  contextualKeyword = _keywords.ContextualKeyword.NONE,\n) {\n  _base.state.end = _base.state.pos;\n  _base.state.type = type;\n  _base.state.contextualKeyword = contextualKeyword;\n} exports.finishToken = finishToken;\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\nfunction readToken_dot() {\n  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);\n  if (nextChar >= _charcodes.charCodes.digit0 && nextChar <= _charcodes.charCodes.digit9) {\n    readNumber(true);\n    return;\n  }\n\n  if (nextChar === _charcodes.charCodes.dot && _base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.dot) {\n    _base.state.pos += 3;\n    finishToken(_types.TokenType.ellipsis);\n  } else {\n    ++_base.state.pos;\n    finishToken(_types.TokenType.dot);\n  }\n}\n\nfunction readToken_slash() {\n  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);\n  if (nextChar === _charcodes.charCodes.equalsTo) {\n    finishOp(_types.TokenType.assign, 2);\n  } else {\n    finishOp(_types.TokenType.slash, 1);\n  }\n}\n\nfunction readToken_mult_modulo(code) {\n  // '%*'\n  let tokenType = code === _charcodes.charCodes.asterisk ? _types.TokenType.star : _types.TokenType.modulo;\n  let width = 1;\n  let nextChar = _base.input.charCodeAt(_base.state.pos + 1);\n\n  // Exponentiation operator **\n  if (code === _charcodes.charCodes.asterisk && nextChar === _charcodes.charCodes.asterisk) {\n    width++;\n    nextChar = _base.input.charCodeAt(_base.state.pos + 2);\n    tokenType = _types.TokenType.exponent;\n  }\n\n  // Match *= or %=, disallowing *=> which can be valid in flow.\n  if (\n    nextChar === _charcodes.charCodes.equalsTo &&\n    _base.input.charCodeAt(_base.state.pos + 2) !== _charcodes.charCodes.greaterThan\n  ) {\n    width++;\n    tokenType = _types.TokenType.assign;\n  }\n\n  finishOp(tokenType, width);\n}\n\nfunction readToken_pipe_amp(code) {\n  // '|&'\n  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);\n\n  if (nextChar === code) {\n    if (_base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.equalsTo) {\n      // ||= or &&=\n      finishOp(_types.TokenType.assign, 3);\n    } else {\n      // || or &&\n      finishOp(code === _charcodes.charCodes.verticalBar ? _types.TokenType.logicalOR : _types.TokenType.logicalAND, 2);\n    }\n    return;\n  }\n\n  if (code === _charcodes.charCodes.verticalBar) {\n    // '|>'\n    if (nextChar === _charcodes.charCodes.greaterThan) {\n      finishOp(_types.TokenType.pipeline, 2);\n      return;\n    } else if (nextChar === _charcodes.charCodes.rightCurlyBrace && _base.isFlowEnabled) {\n      // '|}'\n      finishOp(_types.TokenType.braceBarR, 2);\n      return;\n    }\n  }\n\n  if (nextChar === _charcodes.charCodes.equalsTo) {\n    finishOp(_types.TokenType.assign, 2);\n    return;\n  }\n\n  finishOp(code === _charcodes.charCodes.verticalBar ? _types.TokenType.bitwiseOR : _types.TokenType.bitwiseAND, 1);\n}\n\nfunction readToken_caret() {\n  // '^'\n  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);\n  if (nextChar === _charcodes.charCodes.equalsTo) {\n    finishOp(_types.TokenType.assign, 2);\n  } else {\n    finishOp(_types.TokenType.bitwiseXOR, 1);\n  }\n}\n\nfunction readToken_plus_min(code) {\n  // '+-'\n  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);\n\n  if (nextChar === code) {\n    // Tentatively call this a prefix operator, but it might be changed to postfix later.\n    finishOp(_types.TokenType.preIncDec, 2);\n    return;\n  }\n\n  if (nextChar === _charcodes.charCodes.equalsTo) {\n    finishOp(_types.TokenType.assign, 2);\n  } else if (code === _charcodes.charCodes.plusSign) {\n    finishOp(_types.TokenType.plus, 1);\n  } else {\n    finishOp(_types.TokenType.minus, 1);\n  }\n}\n\nfunction readToken_lt() {\n  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);\n\n  if (nextChar === _charcodes.charCodes.lessThan) {\n    if (_base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.equalsTo) {\n      finishOp(_types.TokenType.assign, 3);\n      return;\n    }\n    // We see <<, but need to be really careful about whether to treat it as a\n    // true left-shift or as two < tokens.\n    if (_base.state.isType) {\n      // Within a type, << might come up in a snippet like `Array<<T>() => void>`,\n      // so treat it as two < tokens. Importantly, this should only override <<\n      // rather than other tokens like <= . If we treated <= as < in a type\n      // context, then the snippet `a as T <= 1` would incorrectly start parsing\n      // a type argument on T. We don't need to worry about `a as T << 1`\n      // because TypeScript disallows that syntax.\n      finishOp(_types.TokenType.lessThan, 1);\n    } else {\n      // Outside a type, this might be a true left-shift operator, or it might\n      // still be two open-type-arg tokens, such as in `f<<T>() => void>()`. We\n      // look at the token while considering the `f`, so we don't yet know that\n      // we're in a type context. In this case, we initially tokenize as a\n      // left-shift and correct after-the-fact as necessary in\n      // tsParseTypeArgumentsWithPossibleBitshift .\n      finishOp(_types.TokenType.bitShiftL, 2);\n    }\n    return;\n  }\n\n  if (nextChar === _charcodes.charCodes.equalsTo) {\n    // <=\n    finishOp(_types.TokenType.relationalOrEqual, 2);\n  } else {\n    finishOp(_types.TokenType.lessThan, 1);\n  }\n}\n\nfunction readToken_gt() {\n  if (_base.state.isType) {\n    // Avoid right-shift for things like `Array<Array<string>>` and\n    // greater-than-or-equal for things like `const a: Array<number>=[];`.\n    finishOp(_types.TokenType.greaterThan, 1);\n    return;\n  }\n\n  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);\n\n  if (nextChar === _charcodes.charCodes.greaterThan) {\n    const size = _base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.greaterThan ? 3 : 2;\n    if (_base.input.charCodeAt(_base.state.pos + size) === _charcodes.charCodes.equalsTo) {\n      finishOp(_types.TokenType.assign, size + 1);\n      return;\n    }\n    finishOp(_types.TokenType.bitShiftR, size);\n    return;\n  }\n\n  if (nextChar === _charcodes.charCodes.equalsTo) {\n    // >=\n    finishOp(_types.TokenType.relationalOrEqual, 2);\n  } else {\n    finishOp(_types.TokenType.greaterThan, 1);\n  }\n}\n\n/**\n * Called after `as` expressions in TS; we're switching from a type to a\n * non-type context, so a > token may actually be >= . This is needed because >=\n * must be tokenized as a > in a type context because of code like\n * `const x: Array<T>=[];`, but `a as T >= 1` is a code example where it must be\n * treated as >=.\n *\n * Notably, this only applies to >, not <. In a code snippet like `a as T <= 1`,\n * we must NOT tokenize as <, or else the type parser will start parsing a type\n * argument and fail.\n */\n function rescan_gt() {\n  if (_base.state.type === _types.TokenType.greaterThan) {\n    _base.state.pos -= 1;\n    readToken_gt();\n  }\n} exports.rescan_gt = rescan_gt;\n\nfunction readToken_eq_excl(code) {\n  // '=!'\n  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);\n  if (nextChar === _charcodes.charCodes.equalsTo) {\n    finishOp(_types.TokenType.equality, _base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.equalsTo ? 3 : 2);\n    return;\n  }\n  if (code === _charcodes.charCodes.equalsTo && nextChar === _charcodes.charCodes.greaterThan) {\n    // '=>'\n    _base.state.pos += 2;\n    finishToken(_types.TokenType.arrow);\n    return;\n  }\n  finishOp(code === _charcodes.charCodes.equalsTo ? _types.TokenType.eq : _types.TokenType.bang, 1);\n}\n\nfunction readToken_question() {\n  // '?'\n  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);\n  const nextChar2 = _base.input.charCodeAt(_base.state.pos + 2);\n  if (\n    nextChar === _charcodes.charCodes.questionMark &&\n    // In Flow (but not TypeScript), ??string is a valid type that should be\n    // tokenized as two individual ? tokens.\n    !(_base.isFlowEnabled && _base.state.isType)\n  ) {\n    if (nextChar2 === _charcodes.charCodes.equalsTo) {\n      // '??='\n      finishOp(_types.TokenType.assign, 3);\n    } else {\n      // '??'\n      finishOp(_types.TokenType.nullishCoalescing, 2);\n    }\n  } else if (\n    nextChar === _charcodes.charCodes.dot &&\n    !(nextChar2 >= _charcodes.charCodes.digit0 && nextChar2 <= _charcodes.charCodes.digit9)\n  ) {\n    // '.' not followed by a number\n    _base.state.pos += 2;\n    finishToken(_types.TokenType.questionDot);\n  } else {\n    ++_base.state.pos;\n    finishToken(_types.TokenType.question);\n  }\n}\n\n function getTokenFromCode(code) {\n  switch (code) {\n    case _charcodes.charCodes.numberSign:\n      ++_base.state.pos;\n      finishToken(_types.TokenType.hash);\n      return;\n\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n\n    case _charcodes.charCodes.dot:\n      readToken_dot();\n      return;\n\n    // Punctuation tokens.\n    case _charcodes.charCodes.leftParenthesis:\n      ++_base.state.pos;\n      finishToken(_types.TokenType.parenL);\n      return;\n    case _charcodes.charCodes.rightParenthesis:\n      ++_base.state.pos;\n      finishToken(_types.TokenType.parenR);\n      return;\n    case _charcodes.charCodes.semicolon:\n      ++_base.state.pos;\n      finishToken(_types.TokenType.semi);\n      return;\n    case _charcodes.charCodes.comma:\n      ++_base.state.pos;\n      finishToken(_types.TokenType.comma);\n      return;\n    case _charcodes.charCodes.leftSquareBracket:\n      ++_base.state.pos;\n      finishToken(_types.TokenType.bracketL);\n      return;\n    case _charcodes.charCodes.rightSquareBracket:\n      ++_base.state.pos;\n      finishToken(_types.TokenType.bracketR);\n      return;\n\n    case _charcodes.charCodes.leftCurlyBrace:\n      if (_base.isFlowEnabled && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.verticalBar) {\n        finishOp(_types.TokenType.braceBarL, 2);\n      } else {\n        ++_base.state.pos;\n        finishToken(_types.TokenType.braceL);\n      }\n      return;\n\n    case _charcodes.charCodes.rightCurlyBrace:\n      ++_base.state.pos;\n      finishToken(_types.TokenType.braceR);\n      return;\n\n    case _charcodes.charCodes.colon:\n      if (_base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.colon) {\n        finishOp(_types.TokenType.doubleColon, 2);\n      } else {\n        ++_base.state.pos;\n        finishToken(_types.TokenType.colon);\n      }\n      return;\n\n    case _charcodes.charCodes.questionMark:\n      readToken_question();\n      return;\n    case _charcodes.charCodes.atSign:\n      ++_base.state.pos;\n      finishToken(_types.TokenType.at);\n      return;\n\n    case _charcodes.charCodes.graveAccent:\n      ++_base.state.pos;\n      finishToken(_types.TokenType.backQuote);\n      return;\n\n    case _charcodes.charCodes.digit0: {\n      const nextChar = _base.input.charCodeAt(_base.state.pos + 1);\n      // '0x', '0X', '0o', '0O', '0b', '0B'\n      if (\n        nextChar === _charcodes.charCodes.lowercaseX ||\n        nextChar === _charcodes.charCodes.uppercaseX ||\n        nextChar === _charcodes.charCodes.lowercaseO ||\n        nextChar === _charcodes.charCodes.uppercaseO ||\n        nextChar === _charcodes.charCodes.lowercaseB ||\n        nextChar === _charcodes.charCodes.uppercaseB\n      ) {\n        readRadixNumber();\n        return;\n      }\n    }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case _charcodes.charCodes.digit1:\n    case _charcodes.charCodes.digit2:\n    case _charcodes.charCodes.digit3:\n    case _charcodes.charCodes.digit4:\n    case _charcodes.charCodes.digit5:\n    case _charcodes.charCodes.digit6:\n    case _charcodes.charCodes.digit7:\n    case _charcodes.charCodes.digit8:\n    case _charcodes.charCodes.digit9:\n      readNumber(false);\n      return;\n\n    // Quotes produce strings.\n    case _charcodes.charCodes.quotationMark:\n    case _charcodes.charCodes.apostrophe:\n      readString(code);\n      return;\n\n    // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case _charcodes.charCodes.slash:\n      readToken_slash();\n      return;\n\n    case _charcodes.charCodes.percentSign:\n    case _charcodes.charCodes.asterisk:\n      readToken_mult_modulo(code);\n      return;\n\n    case _charcodes.charCodes.verticalBar:\n    case _charcodes.charCodes.ampersand:\n      readToken_pipe_amp(code);\n      return;\n\n    case _charcodes.charCodes.caret:\n      readToken_caret();\n      return;\n\n    case _charcodes.charCodes.plusSign:\n    case _charcodes.charCodes.dash:\n      readToken_plus_min(code);\n      return;\n\n    case _charcodes.charCodes.lessThan:\n      readToken_lt();\n      return;\n\n    case _charcodes.charCodes.greaterThan:\n      readToken_gt();\n      return;\n\n    case _charcodes.charCodes.equalsTo:\n    case _charcodes.charCodes.exclamationMark:\n      readToken_eq_excl(code);\n      return;\n\n    case _charcodes.charCodes.tilde:\n      finishOp(_types.TokenType.tilde, 1);\n      return;\n\n    default:\n      break;\n  }\n\n  _util.unexpected.call(void 0, `Unexpected character '${String.fromCharCode(code)}'`, _base.state.pos);\n} exports.getTokenFromCode = getTokenFromCode;\n\nfunction finishOp(type, size) {\n  _base.state.pos += size;\n  finishToken(type);\n}\n\nfunction readRegexp() {\n  const start = _base.state.pos;\n  let escaped = false;\n  let inClass = false;\n  for (;;) {\n    if (_base.state.pos >= _base.input.length) {\n      _util.unexpected.call(void 0, \"Unterminated regular expression\", start);\n      return;\n    }\n    const code = _base.input.charCodeAt(_base.state.pos);\n    if (escaped) {\n      escaped = false;\n    } else {\n      if (code === _charcodes.charCodes.leftSquareBracket) {\n        inClass = true;\n      } else if (code === _charcodes.charCodes.rightSquareBracket && inClass) {\n        inClass = false;\n      } else if (code === _charcodes.charCodes.slash && !inClass) {\n        break;\n      }\n      escaped = code === _charcodes.charCodes.backslash;\n    }\n    ++_base.state.pos;\n  }\n  ++_base.state.pos;\n  // Need to use `skipWord` because '\\uXXXX' sequences are allowed here (don't ask).\n  skipWord();\n\n  finishToken(_types.TokenType.regexp);\n}\n\n/**\n * Read a decimal integer. Note that this can't be unified with the similar code\n * in readRadixNumber (which also handles hex digits) because \"e\" needs to be\n * the end of the integer so that we can properly handle scientific notation.\n */\nfunction readInt() {\n  while (true) {\n    const code = _base.input.charCodeAt(_base.state.pos);\n    if ((code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9) || code === _charcodes.charCodes.underscore) {\n      _base.state.pos++;\n    } else {\n      break;\n    }\n  }\n}\n\nfunction readRadixNumber() {\n  _base.state.pos += 2; // 0x\n\n  // Walk to the end of the number, allowing hex digits.\n  while (true) {\n    const code = _base.input.charCodeAt(_base.state.pos);\n    if (\n      (code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9) ||\n      (code >= _charcodes.charCodes.lowercaseA && code <= _charcodes.charCodes.lowercaseF) ||\n      (code >= _charcodes.charCodes.uppercaseA && code <= _charcodes.charCodes.uppercaseF) ||\n      code === _charcodes.charCodes.underscore\n    ) {\n      _base.state.pos++;\n    } else {\n      break;\n    }\n  }\n\n  const nextChar = _base.input.charCodeAt(_base.state.pos);\n  if (nextChar === _charcodes.charCodes.lowercaseN) {\n    ++_base.state.pos;\n    finishToken(_types.TokenType.bigint);\n  } else {\n    finishToken(_types.TokenType.num);\n  }\n}\n\n// Read an integer, octal integer, or floating-point number.\nfunction readNumber(startsWithDot) {\n  let isBigInt = false;\n  let isDecimal = false;\n\n  if (!startsWithDot) {\n    readInt();\n  }\n\n  let nextChar = _base.input.charCodeAt(_base.state.pos);\n  if (nextChar === _charcodes.charCodes.dot) {\n    ++_base.state.pos;\n    readInt();\n    nextChar = _base.input.charCodeAt(_base.state.pos);\n  }\n\n  if (nextChar === _charcodes.charCodes.uppercaseE || nextChar === _charcodes.charCodes.lowercaseE) {\n    nextChar = _base.input.charCodeAt(++_base.state.pos);\n    if (nextChar === _charcodes.charCodes.plusSign || nextChar === _charcodes.charCodes.dash) {\n      ++_base.state.pos;\n    }\n    readInt();\n    nextChar = _base.input.charCodeAt(_base.state.pos);\n  }\n\n  if (nextChar === _charcodes.charCodes.lowercaseN) {\n    ++_base.state.pos;\n    isBigInt = true;\n  } else if (nextChar === _charcodes.charCodes.lowercaseM) {\n    ++_base.state.pos;\n    isDecimal = true;\n  }\n\n  if (isBigInt) {\n    finishToken(_types.TokenType.bigint);\n    return;\n  }\n\n  if (isDecimal) {\n    finishToken(_types.TokenType.decimal);\n    return;\n  }\n\n  finishToken(_types.TokenType.num);\n}\n\nfunction readString(quote) {\n  _base.state.pos++;\n  for (;;) {\n    if (_base.state.pos >= _base.input.length) {\n      _util.unexpected.call(void 0, \"Unterminated string constant\");\n      return;\n    }\n    const ch = _base.input.charCodeAt(_base.state.pos);\n    if (ch === _charcodes.charCodes.backslash) {\n      _base.state.pos++;\n    } else if (ch === quote) {\n      break;\n    }\n    _base.state.pos++;\n  }\n  _base.state.pos++;\n  finishToken(_types.TokenType.string);\n}\n\n// Reads template string tokens.\nfunction readTmplToken() {\n  for (;;) {\n    if (_base.state.pos >= _base.input.length) {\n      _util.unexpected.call(void 0, \"Unterminated template\");\n      return;\n    }\n    const ch = _base.input.charCodeAt(_base.state.pos);\n    if (\n      ch === _charcodes.charCodes.graveAccent ||\n      (ch === _charcodes.charCodes.dollarSign && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.leftCurlyBrace)\n    ) {\n      if (_base.state.pos === _base.state.start && match(_types.TokenType.template)) {\n        if (ch === _charcodes.charCodes.dollarSign) {\n          _base.state.pos += 2;\n          finishToken(_types.TokenType.dollarBraceL);\n          return;\n        } else {\n          ++_base.state.pos;\n          finishToken(_types.TokenType.backQuote);\n          return;\n        }\n      }\n      finishToken(_types.TokenType.template);\n      return;\n    }\n    if (ch === _charcodes.charCodes.backslash) {\n      _base.state.pos++;\n    }\n    _base.state.pos++;\n  }\n}\n\n// Skip to the end of the current word. Note that this is the same as the snippet at the end of\n// readWord, but calling skipWord from readWord seems to slightly hurt performance from some rough\n// measurements.\n function skipWord() {\n  while (_base.state.pos < _base.input.length) {\n    const ch = _base.input.charCodeAt(_base.state.pos);\n    if (_identifier.IS_IDENTIFIER_CHAR[ch]) {\n      _base.state.pos++;\n    } else if (ch === _charcodes.charCodes.backslash) {\n      // \\u\n      _base.state.pos += 2;\n      if (_base.input.charCodeAt(_base.state.pos) === _charcodes.charCodes.leftCurlyBrace) {\n        while (\n          _base.state.pos < _base.input.length &&\n          _base.input.charCodeAt(_base.state.pos) !== _charcodes.charCodes.rightCurlyBrace\n        ) {\n          _base.state.pos++;\n        }\n        _base.state.pos++;\n      }\n    } else {\n      break;\n    }\n  }\n} exports.skipWord = skipWord;\n"]}}