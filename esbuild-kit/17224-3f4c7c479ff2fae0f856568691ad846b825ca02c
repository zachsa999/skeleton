{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});const matcher_1=require(\"./matcher\");class PartialMatcher extends matcher_1.default{match(filepath){const parts=filepath.split(\"/\");const levels=parts.length;const patterns=this._storage.filter(info=>!info.complete||info.segments.length>levels);for(const pattern of patterns){const section=pattern.sections[0];if(!pattern.complete&&levels>section.length){return true}const match=parts.every((part,index)=>{const segment=pattern.segments[index];if(segment.dynamic&&segment.patternRe.test(part)){return true}if(!segment.dynamic&&segment.pattern===part){return true}return false});if(match){return true}}return false}}__name(PartialMatcher,\"PartialMatcher\");exports.default=PartialMatcher;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CAAE,MAAO,IAAK,CAAC,EAC5D,MAAM,UAAY,QAAQ,WAAW,EACrC,MAAM,uBAAuB,UAAU,OAAQ,CAC3C,MAAM,SAAU,CACZ,MAAM,MAAQ,SAAS,MAAM,GAAG,EAChC,MAAM,OAAS,MAAM,OACrB,MAAM,SAAW,KAAK,SAAS,OAAQ,MAAS,CAAC,KAAK,UAAY,KAAK,SAAS,OAAS,MAAM,EAC/F,UAAW,WAAW,SAAU,CAC5B,MAAM,QAAU,QAAQ,SAAS,CAAC,EAQlC,GAAI,CAAC,QAAQ,UAAY,OAAS,QAAQ,OAAQ,CAC9C,MAAO,KACX,CACA,MAAM,MAAQ,MAAM,MAAM,CAAC,KAAM,QAAU,CACvC,MAAM,QAAU,QAAQ,SAAS,KAAK,EACtC,GAAI,QAAQ,SAAW,QAAQ,UAAU,KAAK,IAAI,EAAG,CACjD,MAAO,KACX,CACA,GAAI,CAAC,QAAQ,SAAW,QAAQ,UAAY,KAAM,CAC9C,MAAO,KACX,CACA,MAAO,MACX,CAAC,EACD,GAAI,MAAO,CACP,MAAO,KACX,CACJ,CACA,MAAO,MACX,CACJ,CAjCM,wCAkCN,QAAQ,QAAU","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/matchers/partial.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst matcher_1 = require(\"./matcher\");\r\nclass PartialMatcher extends matcher_1.default {\r\n    match(filepath) {\r\n        const parts = filepath.split('/');\r\n        const levels = parts.length;\r\n        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);\r\n        for (const pattern of patterns) {\r\n            const section = pattern.sections[0];\r\n            /**\r\n             * In this case, the pattern has a globstar and we must read all directories unconditionally,\r\n             * but only if the level has reached the end of the first group.\r\n             *\r\n             * fixtures/{a,b}/**\r\n             *  ^ true/false  ^ always true\r\n            */\r\n            if (!pattern.complete && levels > section.length) {\r\n                return true;\r\n            }\r\n            const match = parts.every((part, index) => {\r\n                const segment = pattern.segments[index];\r\n                if (segment.dynamic && segment.patternRe.test(part)) {\r\n                    return true;\r\n                }\r\n                if (!segment.dynamic && segment.pattern === part) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n            if (match) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexports.default = PartialMatcher;\r\n"]}}