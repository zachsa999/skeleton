{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interopRequireDefault,\"_interopRequireDefault\");var _xhtml=require(\"../parser/plugins/jsx/xhtml\");var _xhtml2=_interopRequireDefault(_xhtml);var _tokenizer=require(\"../parser/tokenizer\");var _types=require(\"../parser/tokenizer/types\");var _charcodes=require(\"../parser/util/charcodes\");var _getJSXPragmaInfo=require(\"../util/getJSXPragmaInfo\");var _getJSXPragmaInfo2=_interopRequireDefault(_getJSXPragmaInfo);var _Transformer=require(\"./Transformer\");var _Transformer2=_interopRequireDefault(_Transformer);class JSXTransformer extends _Transformer2.default{__init(){this.lastLineNumber=1}__init2(){this.lastIndex=0}__init3(){this.filenameVarName=null}__init4(){this.esmAutomaticImportNameResolutions={}}__init5(){this.cjsAutomaticModuleNameResolutions={}}constructor(rootTransformer,tokens,importProcessor,nameManager,options){super();this.rootTransformer=rootTransformer;this.tokens=tokens;this.importProcessor=importProcessor;this.nameManager=nameManager;this.options=options;JSXTransformer.prototype.__init.call(this);JSXTransformer.prototype.__init2.call(this);JSXTransformer.prototype.__init3.call(this);JSXTransformer.prototype.__init4.call(this);JSXTransformer.prototype.__init5.call(this);;this.jsxPragmaInfo=_getJSXPragmaInfo2.default.call(void 0,options);this.isAutomaticRuntime=options.jsxRuntime===\"automatic\";this.jsxImportSource=options.jsxImportSource||\"react\"}process(){if(this.tokens.matches1(_types.TokenType.jsxTagStart)){this.processJSXTag();return true}return false}getPrefixCode(){let prefix=\"\";if(this.filenameVarName){prefix+=`const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath||\"\")};`}if(this.isAutomaticRuntime){if(this.importProcessor){for(const[path,resolvedName]of Object.entries(this.cjsAutomaticModuleNameResolutions)){prefix+=`var ${resolvedName} = require(\"${path}\");`}}else{const{createElement:createElementResolution,...otherResolutions}=this.esmAutomaticImportNameResolutions;if(createElementResolution){prefix+=`import {createElement as ${createElementResolution}} from \"${this.jsxImportSource}\";`}const importSpecifiers=Object.entries(otherResolutions).map(([name,resolvedName])=>`${name} as ${resolvedName}`).join(\", \");if(importSpecifiers){const importPath=this.jsxImportSource+(this.options.production?\"/jsx-runtime\":\"/jsx-dev-runtime\");prefix+=`import {${importSpecifiers}} from \"${importPath}\";`}}}return prefix}processJSXTag(){const{jsxRole,start}=this.tokens.currentToken();const elementLocationCode=this.options.production?null:this.getElementLocationCode(start);if(this.isAutomaticRuntime&&jsxRole!==_tokenizer.JSXRole.KeyAfterPropSpread){this.transformTagToJSXFunc(elementLocationCode,jsxRole)}else{this.transformTagToCreateElement(elementLocationCode)}}getElementLocationCode(firstTokenStart){const lineNumber=this.getLineNumberForIndex(firstTokenStart);return`lineNumber: ${lineNumber}`}getLineNumberForIndex(index){const code=this.tokens.code;while(this.lastIndex<index&&this.lastIndex<code.length){if(code[this.lastIndex]===\"\\n\"){this.lastLineNumber++}this.lastIndex++}return this.lastLineNumber}transformTagToJSXFunc(elementLocationCode,jsxRole){const isStatic=jsxRole===_tokenizer.JSXRole.StaticChildren;this.tokens.replaceToken(this.getJSXFuncInvocationCode(isStatic));let keyCode=null;if(this.tokens.matches1(_types.TokenType.jsxTagEnd)){this.tokens.replaceToken(`${this.getFragmentCode()}, {`);this.processAutomaticChildrenAndEndProps(jsxRole)}else{this.processTagIntro();this.tokens.appendCode(\", {\");keyCode=this.processProps(true);if(this.tokens.matches2(_types.TokenType.slash,_types.TokenType.jsxTagEnd)){this.tokens.appendCode(\"}\")}else if(this.tokens.matches1(_types.TokenType.jsxTagEnd)){this.tokens.removeToken();this.processAutomaticChildrenAndEndProps(jsxRole)}else{throw new Error(\"Expected either /> or > at the end of the tag.\")}if(keyCode){this.tokens.appendCode(`, ${keyCode}`)}}if(!this.options.production){if(keyCode===null){this.tokens.appendCode(\", void 0\")}this.tokens.appendCode(`, ${isStatic}, ${this.getDevSource(elementLocationCode)}, this`)}this.tokens.removeInitialToken();while(!this.tokens.matches1(_types.TokenType.jsxTagEnd)){this.tokens.removeToken()}this.tokens.replaceToken(\")\")}transformTagToCreateElement(elementLocationCode){this.tokens.replaceToken(this.getCreateElementInvocationCode());if(this.tokens.matches1(_types.TokenType.jsxTagEnd)){this.tokens.replaceToken(`${this.getFragmentCode()}, null`);this.processChildren(true)}else{this.processTagIntro();this.processPropsObjectWithDevInfo(elementLocationCode);if(this.tokens.matches2(_types.TokenType.slash,_types.TokenType.jsxTagEnd)){}else if(this.tokens.matches1(_types.TokenType.jsxTagEnd)){this.tokens.removeToken();this.processChildren(true)}else{throw new Error(\"Expected either /> or > at the end of the tag.\")}}this.tokens.removeInitialToken();while(!this.tokens.matches1(_types.TokenType.jsxTagEnd)){this.tokens.removeToken()}this.tokens.replaceToken(\")\")}getJSXFuncInvocationCode(isStatic){if(this.options.production){if(isStatic){return this.claimAutoImportedFuncInvocation(\"jsxs\",\"/jsx-runtime\")}else{return this.claimAutoImportedFuncInvocation(\"jsx\",\"/jsx-runtime\")}}else{return this.claimAutoImportedFuncInvocation(\"jsxDEV\",\"/jsx-dev-runtime\")}}getCreateElementInvocationCode(){if(this.isAutomaticRuntime){return this.claimAutoImportedFuncInvocation(\"createElement\",\"\")}else{const{jsxPragmaInfo}=this;const resolvedPragmaBaseName=this.importProcessor?this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.base)||jsxPragmaInfo.base:jsxPragmaInfo.base;return`${resolvedPragmaBaseName}${jsxPragmaInfo.suffix}(`}}getFragmentCode(){if(this.isAutomaticRuntime){return this.claimAutoImportedName(\"Fragment\",this.options.production?\"/jsx-runtime\":\"/jsx-dev-runtime\")}else{const{jsxPragmaInfo}=this;const resolvedFragmentPragmaBaseName=this.importProcessor?this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.fragmentBase)||jsxPragmaInfo.fragmentBase:jsxPragmaInfo.fragmentBase;return resolvedFragmentPragmaBaseName+jsxPragmaInfo.fragmentSuffix}}claimAutoImportedFuncInvocation(funcName,importPathSuffix){const funcCode=this.claimAutoImportedName(funcName,importPathSuffix);if(this.importProcessor){return`${funcCode}.call(void 0, `}else{return`${funcCode}(`}}claimAutoImportedName(funcName,importPathSuffix){if(this.importProcessor){const path=this.jsxImportSource+importPathSuffix;if(!this.cjsAutomaticModuleNameResolutions[path]){this.cjsAutomaticModuleNameResolutions[path]=this.importProcessor.getFreeIdentifierForPath(path)}return`${this.cjsAutomaticModuleNameResolutions[path]}.${funcName}`}else{if(!this.esmAutomaticImportNameResolutions[funcName]){this.esmAutomaticImportNameResolutions[funcName]=this.nameManager.claimFreeName(`_${funcName}`)}return this.esmAutomaticImportNameResolutions[funcName]}}processTagIntro(){let introEnd=this.tokens.currentIndex()+1;while(this.tokens.tokens[introEnd].isType||!this.tokens.matches2AtIndex(introEnd-1,_types.TokenType.jsxName,_types.TokenType.jsxName)&&!this.tokens.matches2AtIndex(introEnd-1,_types.TokenType.greaterThan,_types.TokenType.jsxName)&&!this.tokens.matches1AtIndex(introEnd,_types.TokenType.braceL)&&!this.tokens.matches1AtIndex(introEnd,_types.TokenType.jsxTagEnd)&&!this.tokens.matches2AtIndex(introEnd,_types.TokenType.slash,_types.TokenType.jsxTagEnd)){introEnd++}if(introEnd===this.tokens.currentIndex()+1){const tagName=this.tokens.identifierName();if(startsWithLowerCase(tagName)){this.tokens.replaceToken(`'${tagName}'`)}}while(this.tokens.currentIndex()<introEnd){this.rootTransformer.processToken()}}processPropsObjectWithDevInfo(elementLocationCode){const devProps=this.options.production?\"\":`__self: this, __source: ${this.getDevSource(elementLocationCode)}`;if(!this.tokens.matches1(_types.TokenType.jsxName)&&!this.tokens.matches1(_types.TokenType.braceL)){if(devProps){this.tokens.appendCode(`, {${devProps}}`)}else{this.tokens.appendCode(`, null`)}return}this.tokens.appendCode(`, {`);this.processProps(false);if(devProps){this.tokens.appendCode(` ${devProps}}`)}else{this.tokens.appendCode(\"}\")}}processProps(extractKeyCode){let keyCode=null;while(true){if(this.tokens.matches2(_types.TokenType.jsxName,_types.TokenType.eq)){const propName=this.tokens.identifierName();if(extractKeyCode&&propName===\"key\"){if(keyCode!==null){this.tokens.appendCode(keyCode.replace(/[^\\n]/g,\"\"))}this.tokens.removeToken();this.tokens.removeToken();const snapshot=this.tokens.snapshot();this.processPropValue();keyCode=this.tokens.dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot);continue}else{this.processPropName(propName);this.tokens.replaceToken(\": \");this.processPropValue()}}else if(this.tokens.matches1(_types.TokenType.jsxName)){const propName=this.tokens.identifierName();this.processPropName(propName);this.tokens.appendCode(\": true\")}else if(this.tokens.matches1(_types.TokenType.braceL)){this.tokens.replaceToken(\"\");this.rootTransformer.processBalancedCode();this.tokens.replaceToken(\"\")}else{break}this.tokens.appendCode(\",\")}return keyCode}processPropName(propName){if(propName.includes(\"-\")){this.tokens.replaceToken(`'${propName}'`)}else{this.tokens.copyToken()}}processPropValue(){if(this.tokens.matches1(_types.TokenType.braceL)){this.tokens.replaceToken(\"\");this.rootTransformer.processBalancedCode();this.tokens.replaceToken(\"\")}else if(this.tokens.matches1(_types.TokenType.jsxTagStart)){this.processJSXTag()}else{this.processStringPropValue()}}processStringPropValue(){const token=this.tokens.currentToken();const valueCode=this.tokens.code.slice(token.start+1,token.end-1);const replacementCode=formatJSXTextReplacement(valueCode);const literalCode=formatJSXStringValueLiteral(valueCode);this.tokens.replaceToken(literalCode+replacementCode)}processAutomaticChildrenAndEndProps(jsxRole){if(jsxRole===_tokenizer.JSXRole.StaticChildren){this.tokens.appendCode(\" children: [\");this.processChildren(false);this.tokens.appendCode(\"]}\")}else{if(jsxRole===_tokenizer.JSXRole.OneChild){this.tokens.appendCode(\" children: \")}this.processChildren(false);this.tokens.appendCode(\"}\")}}processChildren(needsInitialComma){let needsComma=needsInitialComma;while(true){if(this.tokens.matches2(_types.TokenType.jsxTagStart,_types.TokenType.slash)){return}let didEmitElement=false;if(this.tokens.matches1(_types.TokenType.braceL)){if(this.tokens.matches2(_types.TokenType.braceL,_types.TokenType.braceR)){this.tokens.replaceToken(\"\");this.tokens.replaceToken(\"\")}else{this.tokens.replaceToken(needsComma?\", \":\"\");this.rootTransformer.processBalancedCode();this.tokens.replaceToken(\"\");didEmitElement=true}}else if(this.tokens.matches1(_types.TokenType.jsxTagStart)){this.tokens.appendCode(needsComma?\", \":\"\");this.processJSXTag();didEmitElement=true}else if(this.tokens.matches1(_types.TokenType.jsxText)||this.tokens.matches1(_types.TokenType.jsxEmptyText)){didEmitElement=this.processChildTextElement(needsComma)}else{throw new Error(\"Unexpected token when processing JSX children.\")}if(didEmitElement){needsComma=true}}}processChildTextElement(needsComma){const token=this.tokens.currentToken();const valueCode=this.tokens.code.slice(token.start,token.end);const replacementCode=formatJSXTextReplacement(valueCode);const literalCode=formatJSXTextLiteral(valueCode);if(literalCode==='\"\"'){this.tokens.replaceToken(replacementCode);return false}else{this.tokens.replaceToken(`${needsComma?\", \":\"\"}${literalCode}${replacementCode}`);return true}}getDevSource(elementLocationCode){return`{fileName: ${this.getFilenameVarName()}, ${elementLocationCode}}`}getFilenameVarName(){if(!this.filenameVarName){this.filenameVarName=this.nameManager.claimFreeName(\"_jsxFileName\")}return this.filenameVarName}}__name(JSXTransformer,\"JSXTransformer\");exports.default=JSXTransformer;function startsWithLowerCase(s){const firstChar=s.charCodeAt(0);return firstChar>=_charcodes.charCodes.lowercaseA&&firstChar<=_charcodes.charCodes.lowercaseZ}__name(startsWithLowerCase,\"startsWithLowerCase\");exports.startsWithLowerCase=startsWithLowerCase;function formatJSXTextLiteral(text){let result=\"\";let whitespace=\"\";let isInInitialLineWhitespace=false;let seenNonWhitespace=false;for(let i=0;i<text.length;i++){const c=text[i];if(c===\" \"||c===\"\t\"||c===\"\\r\"){if(!isInInitialLineWhitespace){whitespace+=c}}else if(c===\"\\n\"){whitespace=\"\";isInInitialLineWhitespace=true}else{if(seenNonWhitespace&&isInInitialLineWhitespace){result+=\" \"}result+=whitespace;whitespace=\"\";if(c===\"&\"){const{entity,newI}=processEntity(text,i+1);i=newI-1;result+=entity}else{result+=c}seenNonWhitespace=true;isInInitialLineWhitespace=false}}if(!isInInitialLineWhitespace){result+=whitespace}return JSON.stringify(result)}__name(formatJSXTextLiteral,\"formatJSXTextLiteral\");function formatJSXTextReplacement(text){let numNewlines=0;let numSpaces=0;for(const c of text){if(c===\"\\n\"){numNewlines++;numSpaces=0}else if(c===\" \"){numSpaces++}}return\"\\n\".repeat(numNewlines)+\" \".repeat(numSpaces)}__name(formatJSXTextReplacement,\"formatJSXTextReplacement\");function formatJSXStringValueLiteral(text){let result=\"\";for(let i=0;i<text.length;i++){const c=text[i];if(c===\"\\n\"){if(/\\s/.test(text[i+1])){result+=\" \";while(i<text.length&&/\\s/.test(text[i+1])){i++}}else{result+=\"\\n\"}}else if(c===\"&\"){const{entity,newI}=processEntity(text,i+1);result+=entity;i=newI-1}else{result+=c}}return JSON.stringify(result)}__name(formatJSXStringValueLiteral,\"formatJSXStringValueLiteral\");function processEntity(text,indexAfterAmpersand){let str=\"\";let count=0;let entity;let i=indexAfterAmpersand;if(text[i]===\"#\"){let radix=10;i++;let numStart;if(text[i]===\"x\"){radix=16;i++;numStart=i;while(i<text.length&&isHexDigit(text.charCodeAt(i))){i++}}else{numStart=i;while(i<text.length&&isDecimalDigit(text.charCodeAt(i))){i++}}if(text[i]===\";\"){const numStr=text.slice(numStart,i);if(numStr){i++;entity=String.fromCodePoint(parseInt(numStr,radix))}}}else{while(i<text.length&&count++<10){const ch=text[i];i++;if(ch===\";\"){entity=_xhtml2.default.get(str);break}str+=ch}}if(!entity){return{entity:\"&\",newI:indexAfterAmpersand}}return{entity,newI:i}}__name(processEntity,\"processEntity\");function isDecimalDigit(code){return code>=_charcodes.charCodes.digit0&&code<=_charcodes.charCodes.digit9}__name(isDecimalDigit,\"isDecimalDigit\");function isHexDigit(code){return code>=_charcodes.charCodes.digit0&&code<=_charcodes.charCodes.digit9||code>=_charcodes.charCodes.lowercaseA&&code<=_charcodes.charCodes.lowercaseF||code>=_charcodes.charCodes.uppercaseA&&code<=_charcodes.charCodes.uppercaseF}__name(isHexDigit,\"isHexDigit\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/transformers/JSXTransformer.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\nvar _xhtml = require('../parser/plugins/jsx/xhtml'); var _xhtml2 = _interopRequireDefault(_xhtml);\nvar _tokenizer = require('../parser/tokenizer');\nvar _types = require('../parser/tokenizer/types');\nvar _charcodes = require('../parser/util/charcodes');\n\nvar _getJSXPragmaInfo = require('../util/getJSXPragmaInfo'); var _getJSXPragmaInfo2 = _interopRequireDefault(_getJSXPragmaInfo);\n\nvar _Transformer = require('./Transformer'); var _Transformer2 = _interopRequireDefault(_Transformer);\n\n class JSXTransformer extends _Transformer2.default {\n  \n  \n  \n\n  // State for calculating the line number of each JSX tag in development.\n  __init() {this.lastLineNumber = 1}\n  __init2() {this.lastIndex = 0}\n\n  // In development, variable name holding the name of the current file.\n  __init3() {this.filenameVarName = null}\n  // Mapping of claimed names for imports in the automatic transform, e,g.\n  // {jsx: \"_jsx\"}. This determines which imports to generate in the prefix.\n  __init4() {this.esmAutomaticImportNameResolutions = {}}\n  // When automatically adding imports in CJS mode, we store the variable name\n  // holding the imported CJS module so we can require it in the prefix.\n  __init5() {this.cjsAutomaticModuleNameResolutions = {}}\n\n  constructor(\n     rootTransformer,\n     tokens,\n     importProcessor,\n     nameManager,\n     options,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.options = options;JSXTransformer.prototype.__init.call(this);JSXTransformer.prototype.__init2.call(this);JSXTransformer.prototype.__init3.call(this);JSXTransformer.prototype.__init4.call(this);JSXTransformer.prototype.__init5.call(this);;\n    this.jsxPragmaInfo = _getJSXPragmaInfo2.default.call(void 0, options);\n    this.isAutomaticRuntime = options.jsxRuntime === \"automatic\";\n    this.jsxImportSource = options.jsxImportSource || \"react\";\n  }\n\n  process() {\n    if (this.tokens.matches1(_types.TokenType.jsxTagStart)) {\n      this.processJSXTag();\n      return true;\n    }\n    return false;\n  }\n\n  getPrefixCode() {\n    let prefix = \"\";\n    if (this.filenameVarName) {\n      prefix += `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || \"\")};`;\n    }\n    if (this.isAutomaticRuntime) {\n      if (this.importProcessor) {\n        // CJS mode: emit require statements for all modules that were referenced.\n        for (const [path, resolvedName] of Object.entries(this.cjsAutomaticModuleNameResolutions)) {\n          prefix += `var ${resolvedName} = require(\"${path}\");`;\n        }\n      } else {\n        // ESM mode: consolidate and emit import statements for referenced names.\n        const {createElement: createElementResolution, ...otherResolutions} =\n          this.esmAutomaticImportNameResolutions;\n        if (createElementResolution) {\n          prefix += `import {createElement as ${createElementResolution}} from \"${this.jsxImportSource}\";`;\n        }\n        const importSpecifiers = Object.entries(otherResolutions)\n          .map(([name, resolvedName]) => `${name} as ${resolvedName}`)\n          .join(\", \");\n        if (importSpecifiers) {\n          const importPath =\n            this.jsxImportSource + (this.options.production ? \"/jsx-runtime\" : \"/jsx-dev-runtime\");\n          prefix += `import {${importSpecifiers}} from \"${importPath}\";`;\n        }\n      }\n    }\n    return prefix;\n  }\n\n  processJSXTag() {\n    const {jsxRole, start} = this.tokens.currentToken();\n    // Calculate line number information at the very start (if in development\n    // mode) so that the information is guaranteed to be queried in token order.\n    const elementLocationCode = this.options.production ? null : this.getElementLocationCode(start);\n    if (this.isAutomaticRuntime && jsxRole !== _tokenizer.JSXRole.KeyAfterPropSpread) {\n      this.transformTagToJSXFunc(elementLocationCode, jsxRole);\n    } else {\n      this.transformTagToCreateElement(elementLocationCode);\n    }\n  }\n\n  getElementLocationCode(firstTokenStart) {\n    const lineNumber = this.getLineNumberForIndex(firstTokenStart);\n    return `lineNumber: ${lineNumber}`;\n  }\n\n  /**\n   * Get the line number for this source position. This is calculated lazily and\n   * must be called in increasing order by index.\n   */\n  getLineNumberForIndex(index) {\n    const code = this.tokens.code;\n    while (this.lastIndex < index && this.lastIndex < code.length) {\n      if (code[this.lastIndex] === \"\\n\") {\n        this.lastLineNumber++;\n      }\n      this.lastIndex++;\n    }\n    return this.lastLineNumber;\n  }\n\n  /**\n   * Convert the current JSX element to a call to jsx, jsxs, or jsxDEV. This is\n   * the primary transformation for the automatic transform.\n   *\n   * Example:\n   * <div a={1} key={2}>Hello{x}</div>\n   * becomes\n   * jsxs('div', {a: 1, children: [\"Hello\", x]}, 2)\n   */\n  transformTagToJSXFunc(elementLocationCode, jsxRole) {\n    const isStatic = jsxRole === _tokenizer.JSXRole.StaticChildren;\n    // First tag is always jsxTagStart.\n    this.tokens.replaceToken(this.getJSXFuncInvocationCode(isStatic));\n\n    let keyCode = null;\n    if (this.tokens.matches1(_types.TokenType.jsxTagEnd)) {\n      // Fragment syntax.\n      this.tokens.replaceToken(`${this.getFragmentCode()}, {`);\n      this.processAutomaticChildrenAndEndProps(jsxRole);\n    } else {\n      // Normal open tag or self-closing tag.\n      this.processTagIntro();\n      this.tokens.appendCode(\", {\");\n      keyCode = this.processProps(true);\n\n      if (this.tokens.matches2(_types.TokenType.slash, _types.TokenType.jsxTagEnd)) {\n        // Self-closing tag, no children to add, so close the props.\n        this.tokens.appendCode(\"}\");\n      } else if (this.tokens.matches1(_types.TokenType.jsxTagEnd)) {\n        // Tag with children.\n        this.tokens.removeToken();\n        this.processAutomaticChildrenAndEndProps(jsxRole);\n      } else {\n        throw new Error(\"Expected either /> or > at the end of the tag.\");\n      }\n      // If a key was present, move it to its own arg. Note that moving code\n      // like this will cause line numbers to get out of sync within the JSX\n      // element if the key expression has a newline in it. This is unfortunate,\n      // but hopefully should be rare.\n      if (keyCode) {\n        this.tokens.appendCode(`, ${keyCode}`);\n      }\n    }\n    if (!this.options.production) {\n      // If the key wasn't already added, add it now so we can correctly set\n      // positional args for jsxDEV.\n      if (keyCode === null) {\n        this.tokens.appendCode(\", void 0\");\n      }\n      this.tokens.appendCode(`, ${isStatic}, ${this.getDevSource(elementLocationCode)}, this`);\n    }\n    // We're at the close-tag or the end of a self-closing tag, so remove\n    // everything else and close the function call.\n    this.tokens.removeInitialToken();\n    while (!this.tokens.matches1(_types.TokenType.jsxTagEnd)) {\n      this.tokens.removeToken();\n    }\n    this.tokens.replaceToken(\")\");\n  }\n\n  /**\n   * Convert the current JSX element to a createElement call. In the classic\n   * runtime, this is the only case. In the automatic runtime, this is called\n   * as a fallback in some situations.\n   *\n   * Example:\n   * <div a={1} key={2}>Hello{x}</div>\n   * becomes\n   * React.createElement('div', {a: 1, key: 2}, \"Hello\", x)\n   */\n  transformTagToCreateElement(elementLocationCode) {\n    // First tag is always jsxTagStart.\n    this.tokens.replaceToken(this.getCreateElementInvocationCode());\n\n    if (this.tokens.matches1(_types.TokenType.jsxTagEnd)) {\n      // Fragment syntax.\n      this.tokens.replaceToken(`${this.getFragmentCode()}, null`);\n      this.processChildren(true);\n    } else {\n      // Normal open tag or self-closing tag.\n      this.processTagIntro();\n      this.processPropsObjectWithDevInfo(elementLocationCode);\n\n      if (this.tokens.matches2(_types.TokenType.slash, _types.TokenType.jsxTagEnd)) {\n        // Self-closing tag; no children to process.\n      } else if (this.tokens.matches1(_types.TokenType.jsxTagEnd)) {\n        // Tag with children and a close-tag; process the children as args.\n        this.tokens.removeToken();\n        this.processChildren(true);\n      } else {\n        throw new Error(\"Expected either /> or > at the end of the tag.\");\n      }\n    }\n    // We're at the close-tag or the end of a self-closing tag, so remove\n    // everything else and close the function call.\n    this.tokens.removeInitialToken();\n    while (!this.tokens.matches1(_types.TokenType.jsxTagEnd)) {\n      this.tokens.removeToken();\n    }\n    this.tokens.replaceToken(\")\");\n  }\n\n  /**\n   * Get the code for the relevant function for this context: jsx, jsxs,\n   * or jsxDEV. The following open-paren is included as well.\n   *\n   * These functions are only used for the automatic runtime, so they are always\n   * auto-imported, but the auto-import will be either CJS or ESM based on the\n   * target module format.\n   */\n  getJSXFuncInvocationCode(isStatic) {\n    if (this.options.production) {\n      if (isStatic) {\n        return this.claimAutoImportedFuncInvocation(\"jsxs\", \"/jsx-runtime\");\n      } else {\n        return this.claimAutoImportedFuncInvocation(\"jsx\", \"/jsx-runtime\");\n      }\n    } else {\n      return this.claimAutoImportedFuncInvocation(\"jsxDEV\", \"/jsx-dev-runtime\");\n    }\n  }\n\n  /**\n   * Return the code to use for the createElement function, e.g.\n   * `React.createElement`, including the following open-paren.\n   *\n   * This is the main function to use for the classic runtime. For the\n   * automatic runtime, this function is used as a fallback function to\n   * preserve behavior when there is a prop spread followed by an explicit\n   * key. In that automatic runtime case, the function should be automatically\n   * imported.\n   */\n  getCreateElementInvocationCode() {\n    if (this.isAutomaticRuntime) {\n      return this.claimAutoImportedFuncInvocation(\"createElement\", \"\");\n    } else {\n      const {jsxPragmaInfo} = this;\n      const resolvedPragmaBaseName = this.importProcessor\n        ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.base) || jsxPragmaInfo.base\n        : jsxPragmaInfo.base;\n      return `${resolvedPragmaBaseName}${jsxPragmaInfo.suffix}(`;\n    }\n  }\n\n  /**\n   * Return the code to use as the component when compiling a shorthand\n   * fragment, e.g. `React.Fragment`.\n   *\n   * This may be called from either the classic or automatic runtime, and\n   * the value should be auto-imported for the automatic runtime.\n   */\n  getFragmentCode() {\n    if (this.isAutomaticRuntime) {\n      return this.claimAutoImportedName(\n        \"Fragment\",\n        this.options.production ? \"/jsx-runtime\" : \"/jsx-dev-runtime\",\n      );\n    } else {\n      const {jsxPragmaInfo} = this;\n      const resolvedFragmentPragmaBaseName = this.importProcessor\n        ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.fragmentBase) ||\n          jsxPragmaInfo.fragmentBase\n        : jsxPragmaInfo.fragmentBase;\n      return resolvedFragmentPragmaBaseName + jsxPragmaInfo.fragmentSuffix;\n    }\n  }\n\n  /**\n   * Return code that invokes the given function.\n   *\n   * When the imports transform is enabled, use the CJSImportTransformer\n   * strategy of using `.call(void 0, ...` to avoid passing a `this` value in a\n   * situation that would otherwise look like a method call.\n   */\n  claimAutoImportedFuncInvocation(funcName, importPathSuffix) {\n    const funcCode = this.claimAutoImportedName(funcName, importPathSuffix);\n    if (this.importProcessor) {\n      return `${funcCode}.call(void 0, `;\n    } else {\n      return `${funcCode}(`;\n    }\n  }\n\n  claimAutoImportedName(funcName, importPathSuffix) {\n    if (this.importProcessor) {\n      // CJS mode: claim a name for the module and mark it for import.\n      const path = this.jsxImportSource + importPathSuffix;\n      if (!this.cjsAutomaticModuleNameResolutions[path]) {\n        this.cjsAutomaticModuleNameResolutions[path] =\n          this.importProcessor.getFreeIdentifierForPath(path);\n      }\n      return `${this.cjsAutomaticModuleNameResolutions[path]}.${funcName}`;\n    } else {\n      // ESM mode: claim a name for this function and add it to the names that\n      // should be auto-imported when the prefix is generated.\n      if (!this.esmAutomaticImportNameResolutions[funcName]) {\n        this.esmAutomaticImportNameResolutions[funcName] = this.nameManager.claimFreeName(\n          `_${funcName}`,\n        );\n      }\n      return this.esmAutomaticImportNameResolutions[funcName];\n    }\n  }\n\n  /**\n   * Process the first part of a tag, before any props.\n   */\n  processTagIntro() {\n    // Walk forward until we see one of these patterns:\n    // jsxName to start the first prop, preceded by another jsxName to end the tag name.\n    // jsxName to start the first prop, preceded by greaterThan to end the type argument.\n    // [open brace] to start the first prop.\n    // [jsxTagEnd] to end the open-tag.\n    // [slash, jsxTagEnd] to end the self-closing tag.\n    let introEnd = this.tokens.currentIndex() + 1;\n    while (\n      this.tokens.tokens[introEnd].isType ||\n      (!this.tokens.matches2AtIndex(introEnd - 1, _types.TokenType.jsxName, _types.TokenType.jsxName) &&\n        !this.tokens.matches2AtIndex(introEnd - 1, _types.TokenType.greaterThan, _types.TokenType.jsxName) &&\n        !this.tokens.matches1AtIndex(introEnd, _types.TokenType.braceL) &&\n        !this.tokens.matches1AtIndex(introEnd, _types.TokenType.jsxTagEnd) &&\n        !this.tokens.matches2AtIndex(introEnd, _types.TokenType.slash, _types.TokenType.jsxTagEnd))\n    ) {\n      introEnd++;\n    }\n    if (introEnd === this.tokens.currentIndex() + 1) {\n      const tagName = this.tokens.identifierName();\n      if (startsWithLowerCase(tagName)) {\n        this.tokens.replaceToken(`'${tagName}'`);\n      }\n    }\n    while (this.tokens.currentIndex() < introEnd) {\n      this.rootTransformer.processToken();\n    }\n  }\n\n  /**\n   * Starting at the beginning of the props, add the props argument to\n   * React.createElement, including the comma before it.\n   */\n  processPropsObjectWithDevInfo(elementLocationCode) {\n    const devProps = this.options.production\n      ? \"\"\n      : `__self: this, __source: ${this.getDevSource(elementLocationCode)}`;\n    if (!this.tokens.matches1(_types.TokenType.jsxName) && !this.tokens.matches1(_types.TokenType.braceL)) {\n      if (devProps) {\n        this.tokens.appendCode(`, {${devProps}}`);\n      } else {\n        this.tokens.appendCode(`, null`);\n      }\n      return;\n    }\n    this.tokens.appendCode(`, {`);\n    this.processProps(false);\n    if (devProps) {\n      this.tokens.appendCode(` ${devProps}}`);\n    } else {\n      this.tokens.appendCode(\"}\");\n    }\n  }\n\n  /**\n   * Transform the core part of the props, assuming that a { has already been\n   * inserted before us and that a } will be inserted after us.\n   *\n   * If extractKeyCode is true (i.e. when using any jsx... function), any prop\n   * named \"key\" has its code captured and returned rather than being emitted to\n   * the output code. This shifts line numbers, and emitting the code later will\n   * correct line numbers again. If no key is found or if extractKeyCode is\n   * false, this function returns null.\n   */\n  processProps(extractKeyCode) {\n    let keyCode = null;\n    while (true) {\n      if (this.tokens.matches2(_types.TokenType.jsxName, _types.TokenType.eq)) {\n        // This is a regular key={value} or key=\"value\" prop.\n        const propName = this.tokens.identifierName();\n        if (extractKeyCode && propName === \"key\") {\n          if (keyCode !== null) {\n            // The props list has multiple keys. Different implementations are\n            // inconsistent about what to do here: as of this writing, Babel and\n            // swc keep the *last* key and completely remove the rest, while\n            // TypeScript uses the *first* key and leaves the others as regular\n            // props. The React team collaborated with Babel on the\n            // implementation of this behavior, so presumably the Babel behavior\n            // is the one to use.\n            // Since we won't ever be emitting the previous key code, we need to\n            // at least emit its newlines here so that the line numbers match up\n            // in the long run.\n            this.tokens.appendCode(keyCode.replace(/[^\\n]/g, \"\"));\n          }\n          // key\n          this.tokens.removeToken();\n          // =\n          this.tokens.removeToken();\n          const snapshot = this.tokens.snapshot();\n          this.processPropValue();\n          keyCode = this.tokens.dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot);\n          // Don't add a comma\n          continue;\n        } else {\n          this.processPropName(propName);\n          this.tokens.replaceToken(\": \");\n          this.processPropValue();\n        }\n      } else if (this.tokens.matches1(_types.TokenType.jsxName)) {\n        // This is a shorthand prop like <input disabled />.\n        const propName = this.tokens.identifierName();\n        this.processPropName(propName);\n        this.tokens.appendCode(\": true\");\n      } else if (this.tokens.matches1(_types.TokenType.braceL)) {\n        // This is prop spread, like <div {...getProps()}>, which we can pass\n        // through fairly directly as an object spread.\n        this.tokens.replaceToken(\"\");\n        this.rootTransformer.processBalancedCode();\n        this.tokens.replaceToken(\"\");\n      } else {\n        break;\n      }\n      this.tokens.appendCode(\",\");\n    }\n    return keyCode;\n  }\n\n  processPropName(propName) {\n    if (propName.includes(\"-\")) {\n      this.tokens.replaceToken(`'${propName}'`);\n    } else {\n      this.tokens.copyToken();\n    }\n  }\n\n  processPropValue() {\n    if (this.tokens.matches1(_types.TokenType.braceL)) {\n      this.tokens.replaceToken(\"\");\n      this.rootTransformer.processBalancedCode();\n      this.tokens.replaceToken(\"\");\n    } else if (this.tokens.matches1(_types.TokenType.jsxTagStart)) {\n      this.processJSXTag();\n    } else {\n      this.processStringPropValue();\n    }\n  }\n\n  processStringPropValue() {\n    const token = this.tokens.currentToken();\n    const valueCode = this.tokens.code.slice(token.start + 1, token.end - 1);\n    const replacementCode = formatJSXTextReplacement(valueCode);\n    const literalCode = formatJSXStringValueLiteral(valueCode);\n    this.tokens.replaceToken(literalCode + replacementCode);\n  }\n\n  /**\n   * Starting in the middle of the props object literal, produce an additional\n   * prop for the children and close the object literal.\n   */\n  processAutomaticChildrenAndEndProps(jsxRole) {\n    if (jsxRole === _tokenizer.JSXRole.StaticChildren) {\n      this.tokens.appendCode(\" children: [\");\n      this.processChildren(false);\n      this.tokens.appendCode(\"]}\");\n    } else {\n      // The parser information tells us whether we will see a real child or if\n      // all remaining children (if any) will resolve to empty. If there are no\n      // non-empty children, don't emit a children prop at all, but still\n      // process children so that we properly transform the code into nothing.\n      if (jsxRole === _tokenizer.JSXRole.OneChild) {\n        this.tokens.appendCode(\" children: \");\n      }\n      this.processChildren(false);\n      this.tokens.appendCode(\"}\");\n    }\n  }\n\n  /**\n   * Transform children into a comma-separated list, which will be either\n   * arguments to createElement or array elements of a children prop.\n   */\n  processChildren(needsInitialComma) {\n    let needsComma = needsInitialComma;\n    while (true) {\n      if (this.tokens.matches2(_types.TokenType.jsxTagStart, _types.TokenType.slash)) {\n        // Closing tag, so no more children.\n        return;\n      }\n      let didEmitElement = false;\n      if (this.tokens.matches1(_types.TokenType.braceL)) {\n        if (this.tokens.matches2(_types.TokenType.braceL, _types.TokenType.braceR)) {\n          // Empty interpolations and comment-only interpolations are allowed\n          // and don't create an extra child arg.\n          this.tokens.replaceToken(\"\");\n          this.tokens.replaceToken(\"\");\n        } else {\n          // Interpolated expression.\n          this.tokens.replaceToken(needsComma ? \", \" : \"\");\n          this.rootTransformer.processBalancedCode();\n          this.tokens.replaceToken(\"\");\n          didEmitElement = true;\n        }\n      } else if (this.tokens.matches1(_types.TokenType.jsxTagStart)) {\n        // Child JSX element\n        this.tokens.appendCode(needsComma ? \", \" : \"\");\n        this.processJSXTag();\n        didEmitElement = true;\n      } else if (this.tokens.matches1(_types.TokenType.jsxText) || this.tokens.matches1(_types.TokenType.jsxEmptyText)) {\n        didEmitElement = this.processChildTextElement(needsComma);\n      } else {\n        throw new Error(\"Unexpected token when processing JSX children.\");\n      }\n      if (didEmitElement) {\n        needsComma = true;\n      }\n    }\n  }\n\n  /**\n   * Turn a JSX text element into a string literal, or nothing at all if the JSX\n   * text resolves to the empty string.\n   *\n   * Returns true if a string literal is emitted, false otherwise.\n   */\n  processChildTextElement(needsComma) {\n    const token = this.tokens.currentToken();\n    const valueCode = this.tokens.code.slice(token.start, token.end);\n    const replacementCode = formatJSXTextReplacement(valueCode);\n    const literalCode = formatJSXTextLiteral(valueCode);\n    if (literalCode === '\"\"') {\n      this.tokens.replaceToken(replacementCode);\n      return false;\n    } else {\n      this.tokens.replaceToken(`${needsComma ? \", \" : \"\"}${literalCode}${replacementCode}`);\n      return true;\n    }\n  }\n\n  getDevSource(elementLocationCode) {\n    return `{fileName: ${this.getFilenameVarName()}, ${elementLocationCode}}`;\n  }\n\n  getFilenameVarName() {\n    if (!this.filenameVarName) {\n      this.filenameVarName = this.nameManager.claimFreeName(\"_jsxFileName\");\n    }\n    return this.filenameVarName;\n  }\n} exports.default = JSXTransformer;\n\n/**\n * Spec for identifiers: https://tc39.github.io/ecma262/#prod-IdentifierStart.\n *\n * Really only treat anything starting with a-z as tag names.  `_`, `$`, `Ã©`\n * should be treated as component names\n */\n function startsWithLowerCase(s) {\n  const firstChar = s.charCodeAt(0);\n  return firstChar >= _charcodes.charCodes.lowercaseA && firstChar <= _charcodes.charCodes.lowercaseZ;\n} exports.startsWithLowerCase = startsWithLowerCase;\n\n/**\n * Turn the given jsxText string into a JS string literal. Leading and trailing\n * whitespace on lines is removed, except immediately after the open-tag and\n * before the close-tag. Empty lines are completely removed, and spaces are\n * added between lines after that.\n *\n * We use JSON.stringify to introduce escape characters as necessary, and trim\n * the start and end of each line and remove blank lines.\n */\nfunction formatJSXTextLiteral(text) {\n  let result = \"\";\n  let whitespace = \"\";\n\n  let isInInitialLineWhitespace = false;\n  let seenNonWhitespace = false;\n  for (let i = 0; i < text.length; i++) {\n    const c = text[i];\n    if (c === \" \" || c === \"\\t\" || c === \"\\r\") {\n      if (!isInInitialLineWhitespace) {\n        whitespace += c;\n      }\n    } else if (c === \"\\n\") {\n      whitespace = \"\";\n      isInInitialLineWhitespace = true;\n    } else {\n      if (seenNonWhitespace && isInInitialLineWhitespace) {\n        result += \" \";\n      }\n      result += whitespace;\n      whitespace = \"\";\n      if (c === \"&\") {\n        const {entity, newI} = processEntity(text, i + 1);\n        i = newI - 1;\n        result += entity;\n      } else {\n        result += c;\n      }\n      seenNonWhitespace = true;\n      isInInitialLineWhitespace = false;\n    }\n  }\n  if (!isInInitialLineWhitespace) {\n    result += whitespace;\n  }\n  return JSON.stringify(result);\n}\n\n/**\n * Produce the code that should be printed after the JSX text string literal,\n * with most content removed, but all newlines preserved and all spacing at the\n * end preserved.\n */\nfunction formatJSXTextReplacement(text) {\n  let numNewlines = 0;\n  let numSpaces = 0;\n  for (const c of text) {\n    if (c === \"\\n\") {\n      numNewlines++;\n      numSpaces = 0;\n    } else if (c === \" \") {\n      numSpaces++;\n    }\n  }\n  return \"\\n\".repeat(numNewlines) + \" \".repeat(numSpaces);\n}\n\n/**\n * Format a string in the value position of a JSX prop.\n *\n * Use the same implementation as convertAttribute from\n * babel-helper-builder-react-jsx.\n */\nfunction formatJSXStringValueLiteral(text) {\n  let result = \"\";\n  for (let i = 0; i < text.length; i++) {\n    const c = text[i];\n    if (c === \"\\n\") {\n      if (/\\s/.test(text[i + 1])) {\n        result += \" \";\n        while (i < text.length && /\\s/.test(text[i + 1])) {\n          i++;\n        }\n      } else {\n        result += \"\\n\";\n      }\n    } else if (c === \"&\") {\n      const {entity, newI} = processEntity(text, i + 1);\n      result += entity;\n      i = newI - 1;\n    } else {\n      result += c;\n    }\n  }\n  return JSON.stringify(result);\n}\n\n/**\n * Starting at a &, see if there's an HTML entity (specified by name, decimal\n * char code, or hex char code) and return it if so.\n *\n * Modified from jsxReadString in babel-parser.\n */\nfunction processEntity(text, indexAfterAmpersand) {\n  let str = \"\";\n  let count = 0;\n  let entity;\n  let i = indexAfterAmpersand;\n\n  if (text[i] === \"#\") {\n    let radix = 10;\n    i++;\n    let numStart;\n    if (text[i] === \"x\") {\n      radix = 16;\n      i++;\n      numStart = i;\n      while (i < text.length && isHexDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    } else {\n      numStart = i;\n      while (i < text.length && isDecimalDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text[i] === \";\") {\n      const numStr = text.slice(numStart, i);\n      if (numStr) {\n        i++;\n        entity = String.fromCodePoint(parseInt(numStr, radix));\n      }\n    }\n  } else {\n    while (i < text.length && count++ < 10) {\n      const ch = text[i];\n      i++;\n      if (ch === \";\") {\n        entity = _xhtml2.default.get(str);\n        break;\n      }\n      str += ch;\n    }\n  }\n\n  if (!entity) {\n    return {entity: \"&\", newI: indexAfterAmpersand};\n  }\n  return {entity, newI: i};\n}\n\nfunction isDecimalDigit(code) {\n  return code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9;\n}\n\nfunction isHexDigit(code) {\n  return (\n    (code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9) ||\n    (code >= _charcodes.charCodes.lowercaseA && code <= _charcodes.charCodes.lowercaseF) ||\n    (code >= _charcodes.charCodes.uppercaseA && code <= _charcodes.charCodes.uppercaseF)\n  );\n}\n"]}}