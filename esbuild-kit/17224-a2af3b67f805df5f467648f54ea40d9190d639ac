{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const util=require(\"util\");const braces=require(\"braces\");const picomatch=require(\"picomatch\");const utils=require(\"picomatch/lib/utils\");const isEmptyString=__name(val=>val===\"\"||val===\"./\",\"isEmptyString\");const micromatch=__name((list,patterns,options)=>{patterns=[].concat(patterns);list=[].concat(list);let omit=new Set;let keep=new Set;let items=new Set;let negatives=0;let onResult=__name(state=>{items.add(state.output);if(options&&options.onResult){options.onResult(state)}},\"onResult\");for(let i=0;i<patterns.length;i++){let isMatch=picomatch(String(patterns[i]),{...options,onResult},true);let negated=isMatch.state.negated||isMatch.state.negatedExtglob;if(negated)negatives++;for(let item of list){let matched=isMatch(item,true);let match=negated?!matched.isMatch:matched.isMatch;if(!match)continue;if(negated){omit.add(matched.output)}else{omit.delete(matched.output);keep.add(matched.output)}}}let result=negatives===patterns.length?[...items]:[...keep];let matches=result.filter(item=>!omit.has(item));if(options&&matches.length===0){if(options.failglob===true){throw new Error(`No matches found for \"${patterns.join(\", \")}\"`)}if(options.nonull===true||options.nullglob===true){return options.unescape?patterns.map(p=>p.replace(/\\\\/g,\"\")):patterns}}return matches},\"micromatch\");micromatch.match=micromatch;micromatch.matcher=(pattern,options)=>picomatch(pattern,options);micromatch.isMatch=(str,patterns,options)=>picomatch(patterns,options)(str);micromatch.any=micromatch.isMatch;micromatch.not=(list,patterns,options={})=>{patterns=[].concat(patterns).map(String);let result=new Set;let items=[];let onResult=__name(state=>{if(options.onResult)options.onResult(state);items.push(state.output)},\"onResult\");let matches=new Set(micromatch(list,patterns,{...options,onResult}));for(let item of items){if(!matches.has(item)){result.add(item)}}return[...result]};micromatch.contains=(str,pattern,options)=>{if(typeof str!==\"string\"){throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`)}if(Array.isArray(pattern)){return pattern.some(p=>micromatch.contains(str,p,options))}if(typeof pattern===\"string\"){if(isEmptyString(str)||isEmptyString(pattern)){return false}if(str.includes(pattern)||str.startsWith(\"./\")&&str.slice(2).includes(pattern)){return true}}return micromatch.isMatch(str,pattern,{...options,contains:true})};micromatch.matchKeys=(obj,patterns,options)=>{if(!utils.isObject(obj)){throw new TypeError(\"Expected the first argument to be an object\")}let keys=micromatch(Object.keys(obj),patterns,options);let res={};for(let key of keys)res[key]=obj[key];return res};micromatch.some=(list,patterns,options)=>{let items=[].concat(list);for(let pattern of[].concat(patterns)){let isMatch=picomatch(String(pattern),options);if(items.some(item=>isMatch(item))){return true}}return false};micromatch.every=(list,patterns,options)=>{let items=[].concat(list);for(let pattern of[].concat(patterns)){let isMatch=picomatch(String(pattern),options);if(!items.every(item=>isMatch(item))){return false}}return true};micromatch.all=(str,patterns,options)=>{if(typeof str!==\"string\"){throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`)}return[].concat(patterns).every(p=>picomatch(p,options)(str))};micromatch.capture=(glob,input,options)=>{let posix=utils.isWindows(options);let regex=picomatch.makeRe(String(glob),{...options,capture:true});let match=regex.exec(posix?utils.toPosixSlashes(input):input);if(match){return match.slice(1).map(v=>v===void 0?\"\":v)}};micromatch.makeRe=(...args)=>picomatch.makeRe(...args);micromatch.scan=(...args)=>picomatch.scan(...args);micromatch.parse=(patterns,options)=>{let res=[];for(let pattern of[].concat(patterns||[])){for(let str of braces(String(pattern),options)){res.push(picomatch.parse(str,options))}}return res};micromatch.braces=(pattern,options)=>{if(typeof pattern!==\"string\")throw new TypeError(\"Expected a string\");if(options&&options.nobrace===true||!/\\{.*\\}/.test(pattern)){return[pattern]}return braces(pattern,options)};micromatch.braceExpand=(pattern,options)=>{if(typeof pattern!==\"string\")throw new TypeError(\"Expected a string\");return micromatch.braces(pattern,{...options,expand:true})};module.exports=micromatch;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/micromatch@4.0.5/node_modules/micromatch/index.js"],"sourcesContent":["'use strict';\n\nconst util = require('util');\nconst braces = require('braces');\nconst picomatch = require('picomatch');\nconst utils = require('picomatch/lib/utils');\nconst isEmptyString = val => val === '' || val === './';\n\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} `list` List of strings to match.\n * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nconst micromatch = (list, patterns, options) => {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n\n  let omit = new Set();\n  let keep = new Set();\n  let items = new Set();\n  let negatives = 0;\n\n  let onResult = state => {\n    items.add(state.output);\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n\n  for (let i = 0; i < patterns.length; i++) {\n    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n\n    for (let item of list) {\n      let matched = isMatch(item, true);\n\n      let match = negated ? !matched.isMatch : matched.isMatch;\n      if (!match) continue;\n\n      if (negated) {\n        omit.add(matched.output);\n      } else {\n        omit.delete(matched.output);\n        keep.add(matched.output);\n      }\n    }\n  }\n\n  let result = negatives === patterns.length ? [...items] : [...keep];\n  let matches = result.filter(item => !omit.has(item));\n\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n    }\n  }\n\n  return matches;\n};\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.match = micromatch;\n\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = (pattern, options) => picomatch(pattern, options);\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `[options]` See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.any = micromatch.isMatch;\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = (list, patterns, options = {}) => {\n  patterns = [].concat(patterns).map(String);\n  let result = new Set();\n  let items = [];\n\n  let onResult = state => {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n\n  let matches = new Set(micromatch(list, patterns, { ...options, onResult }));\n\n  for (let item of items) {\n    if (!matches.has(item)) {\n      result.add(item);\n    }\n  }\n  return [...result];\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any of the patterns matches any part of `str`.\n * @api public\n */\n\nmicromatch.contains = (str, pattern, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  if (Array.isArray(pattern)) {\n    return pattern.some(p => micromatch.contains(str, p, options));\n  }\n\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n\n    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {\n      return true;\n    }\n  }\n\n  return micromatch.isMatch(str, pattern, { ...options, contains: true });\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nmicromatch.matchKeys = (obj, patterns, options) => {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n  let keys = micromatch(Object.keys(obj), patterns, options);\n  let res = {};\n  for (let key of keys) res[key] = obj[key];\n  return res;\n};\n\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`\n * @api public\n */\n\nmicromatch.some = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (items.some(item => isMatch(item))) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`\n * @api public\n */\n\nmicromatch.every = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (!items.every(item => isMatch(item))) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.all = (str, patterns, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  return [].concat(patterns).every(p => picomatch(p, options)(str));\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nmicromatch.capture = (glob, input, options) => {\n  let posix = utils.isWindows(options);\n  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });\n  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n\n  if (match) {\n    return match.slice(1).map(v => v === void 0 ? '' : v);\n  }\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nmicromatch.makeRe = (...args) => picomatch.makeRe(...args);\n\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\nmicromatch.scan = (...args) => picomatch.scan(...args);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.parse(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\n\nmicromatch.parse = (patterns, options) => {\n  let res = [];\n  for (let pattern of [].concat(patterns || [])) {\n    for (let str of braces(String(pattern), options)) {\n      res.push(picomatch.parse(str, options));\n    }\n  }\n  return res;\n};\n\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\nmicromatch.braces = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  if ((options && options.nobrace === true) || !/\\{.*\\}/.test(pattern)) {\n    return [pattern];\n  }\n  return braces(pattern, options);\n};\n\n/**\n * Expand braces\n */\n\nmicromatch.braceExpand = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, { ...options, expand: true });\n};\n\n/**\n * Expose micromatch\n */\n\nmodule.exports = micromatch;\n"]}}