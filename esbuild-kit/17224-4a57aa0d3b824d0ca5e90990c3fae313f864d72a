{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _types=require(\"../parser/tokenizer/types\");function shouldElideDefaultExport(isTypeScriptTransformEnabled,tokens,declarationInfo){if(!isTypeScriptTransformEnabled){return false}const exportToken=tokens.currentToken();if(exportToken.rhsEndIndex==null){throw new Error(\"Expected non-null rhsEndIndex on export token.\")}const numTokens=exportToken.rhsEndIndex-tokens.currentIndex();if(numTokens!==3&&!(numTokens===4&&tokens.matches1AtIndex(exportToken.rhsEndIndex-1,_types.TokenType.semi))){return false}const identifierToken=tokens.tokenAtRelativeIndex(2);if(identifierToken.type!==_types.TokenType.name){return false}const exportedName=tokens.identifierNameForToken(identifierToken);return declarationInfo.typeDeclarations.has(exportedName)&&!declarationInfo.valueDeclarations.has(exportedName)}__name(shouldElideDefaultExport,\"shouldElideDefaultExport\");exports.default=shouldElideDefaultExport;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAE,IAAI,OAAS,QAAQ,2BAA2B,EAOxH,SAAS,yBACR,6BACA,OACA,gBACA,CACA,GAAI,CAAC,6BAA8B,CACjC,MAAO,MACT,CACA,MAAM,YAAc,OAAO,aAAa,EACxC,GAAI,YAAY,aAAe,KAAM,CACnC,MAAM,IAAI,MAAM,gDAAgD,CAClE,CAEA,MAAM,UAAY,YAAY,YAAc,OAAO,aAAa,EAChE,GACE,YAAc,GACd,EAAE,YAAc,GAAK,OAAO,gBAAgB,YAAY,YAAc,EAAG,OAAO,UAAU,IAAI,GAC9F,CACA,MAAO,MACT,CACA,MAAM,gBAAkB,OAAO,qBAAqB,CAAC,EACrD,GAAI,gBAAgB,OAAS,OAAO,UAAU,KAAM,CAClD,MAAO,MACT,CACA,MAAM,aAAe,OAAO,uBAAuB,eAAe,EAClE,OACE,gBAAgB,iBAAiB,IAAI,YAAY,GACjD,CAAC,gBAAgB,kBAAkB,IAAI,YAAY,CAEvD,CA7BU,4DA6BR,QAAQ,QAAU","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/util/shouldElideDefaultExport.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});var _types = require('../parser/tokenizer/types');\n\n\n\n/**\n * Common method sharing code between CJS and ESM cases, since they're the same here.\n */\n function shouldElideDefaultExport(\n  isTypeScriptTransformEnabled,\n  tokens,\n  declarationInfo,\n) {\n  if (!isTypeScriptTransformEnabled) {\n    return false;\n  }\n  const exportToken = tokens.currentToken();\n  if (exportToken.rhsEndIndex == null) {\n    throw new Error(\"Expected non-null rhsEndIndex on export token.\");\n  }\n  // The export must be of the form `export default a` or `export default a;`.\n  const numTokens = exportToken.rhsEndIndex - tokens.currentIndex();\n  if (\n    numTokens !== 3 &&\n    !(numTokens === 4 && tokens.matches1AtIndex(exportToken.rhsEndIndex - 1, _types.TokenType.semi))\n  ) {\n    return false;\n  }\n  const identifierToken = tokens.tokenAtRelativeIndex(2);\n  if (identifierToken.type !== _types.TokenType.name) {\n    return false;\n  }\n  const exportedName = tokens.identifierNameForToken(identifierToken);\n  return (\n    declarationInfo.typeDeclarations.has(exportedName) &&\n    !declarationInfo.valueDeclarations.has(exportedName)\n  );\n} exports.default = shouldElideDefaultExport;\n"]}}