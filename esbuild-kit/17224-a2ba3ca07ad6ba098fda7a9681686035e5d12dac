{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:true,get:all[name]})}__name(_export,\"_export\");_export(exports,{elementSelectorParser:function(){return elementSelectorParser},default:function(){return resolveDefaultsAtRules}});const _postcss=_interop_require_default(require(\"postcss\"));const _postcssselectorparser=_interop_require_default(require(\"postcss-selector-parser\"));const _featureFlags=require(\"../featureFlags\");function _interop_require_default(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interop_require_default,\"_interop_require_default\");let getNode={id(node){return _postcssselectorparser.default.attribute({attribute:\"id\",operator:\"=\",value:node.value,quoteMark:'\"'})}};function minimumImpactSelector(nodes){let rest=nodes.filter(node2=>{if(node2.type!==\"pseudo\")return true;if(node2.nodes.length>0)return true;return node2.value.startsWith(\"::\")||[\":before\",\":after\",\":first-line\",\":first-letter\"].includes(node2.value)}).reverse();let searchFor=new Set([\"tag\",\"class\",\"id\",\"attribute\"]);let splitPointIdx=rest.findIndex(n=>searchFor.has(n.type));if(splitPointIdx===-1)return rest.reverse().join(\"\").trim();let node=rest[splitPointIdx];let bestNode=getNode[node.type]?getNode[node.type](node):node;rest=rest.slice(0,splitPointIdx);let combinatorIdx=rest.findIndex(n=>n.type===\"combinator\"&&n.value===\">\");if(combinatorIdx!==-1){rest.splice(0,combinatorIdx);rest.unshift(_postcssselectorparser.default.universal())}return[bestNode,...rest.reverse()].join(\"\").trim()}__name(minimumImpactSelector,\"minimumImpactSelector\");let elementSelectorParser=(0,_postcssselectorparser.default)(selectors=>{return selectors.map(s=>{let nodes=s.split(n=>n.type===\"combinator\"&&n.value===\" \").pop();return minimumImpactSelector(nodes)})});let cache=new Map;function extractElementSelector(selector){if(!cache.has(selector)){cache.set(selector,elementSelectorParser.transformSync(selector))}return cache.get(selector)}__name(extractElementSelector,\"extractElementSelector\");function resolveDefaultsAtRules({tailwindConfig}){return root=>{let variableNodeMap=new Map;let universals=new Set;root.walkAtRules(\"defaults\",rule=>{if(rule.nodes&&rule.nodes.length>0){universals.add(rule);return}let variable=rule.params;if(!variableNodeMap.has(variable)){variableNodeMap.set(variable,new Set)}variableNodeMap.get(variable).add(rule.parent);rule.remove()});if((0,_featureFlags.flagEnabled)(tailwindConfig,\"optimizeUniversalDefaults\")){for(let universal of universals){let selectorGroups=new Map;var _variableNodeMap_get;let rules=(_variableNodeMap_get=variableNodeMap.get(universal.params))!==null&&_variableNodeMap_get!==void 0?_variableNodeMap_get:[];for(let rule of rules){for(let selector of extractElementSelector(rule.selector)){let selectorGroupName=selector.includes(\":-\")||selector.includes(\"::-\")?selector:\"__DEFAULT__\";var _selectorGroups_get;let selectors=(_selectorGroups_get=selectorGroups.get(selectorGroupName))!==null&&_selectorGroups_get!==void 0?_selectorGroups_get:new Set;selectorGroups.set(selectorGroupName,selectors);selectors.add(selector)}}if((0,_featureFlags.flagEnabled)(tailwindConfig,\"optimizeUniversalDefaults\")){if(selectorGroups.size===0){universal.remove();continue}for(let[,selectors]of selectorGroups){let universalRule=_postcss.default.rule({source:universal.source});universalRule.selectors=[...selectors];universalRule.append(universal.nodes.map(node=>node.clone()));universal.before(universalRule)}}universal.remove()}}else if(universals.size){let universalRule=_postcss.default.rule({selectors:[\"*\",\"::before\",\"::after\"]});for(let universal of universals){universalRule.append(universal.nodes);if(!universalRule.parent){universal.before(universalRule)}if(!universalRule.source){universalRule.source=universal.source}universal.remove()}let backdropRule=universalRule.clone({selectors:[\"::backdrop\"]});universalRule.after(backdropRule)}}}__name(resolveDefaultsAtRules,\"resolveDefaultsAtRules\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["node"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/lib/resolveDefaultsAtRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    elementSelectorParser: function() {\n        return elementSelectorParser;\n    },\n    default: function() {\n        return resolveDefaultsAtRules;\n    }\n});\nconst _postcss = /*#__PURE__*/ _interop_require_default(require(\"postcss\"));\nconst _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require(\"postcss-selector-parser\"));\nconst _featureFlags = require(\"../featureFlags\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nlet getNode = {\n    id (node) {\n        return _postcssselectorparser.default.attribute({\n            attribute: \"id\",\n            operator: \"=\",\n            value: node.value,\n            quoteMark: '\"'\n        });\n    }\n};\nfunction minimumImpactSelector(nodes) {\n    let rest = nodes.filter((node)=>{\n        // Keep non-pseudo nodes\n        if (node.type !== \"pseudo\") return true;\n        // Keep pseudo nodes that have subnodes\n        // E.g.: `:not()` contains subnodes inside the parentheses\n        if (node.nodes.length > 0) return true;\n        // Keep pseudo `elements`\n        // This implicitly means that we ignore pseudo `classes`\n        return node.value.startsWith(\"::\") || [\n            \":before\",\n            \":after\",\n            \":first-line\",\n            \":first-letter\"\n        ].includes(node.value);\n    }).reverse();\n    let searchFor = new Set([\n        \"tag\",\n        \"class\",\n        \"id\",\n        \"attribute\"\n    ]);\n    let splitPointIdx = rest.findIndex((n)=>searchFor.has(n.type));\n    if (splitPointIdx === -1) return rest.reverse().join(\"\").trim();\n    let node = rest[splitPointIdx];\n    let bestNode = getNode[node.type] ? getNode[node.type](node) : node;\n    rest = rest.slice(0, splitPointIdx);\n    let combinatorIdx = rest.findIndex((n)=>n.type === \"combinator\" && n.value === \">\");\n    if (combinatorIdx !== -1) {\n        rest.splice(0, combinatorIdx);\n        rest.unshift(_postcssselectorparser.default.universal());\n    }\n    return [\n        bestNode,\n        ...rest.reverse()\n    ].join(\"\").trim();\n}\nlet elementSelectorParser = (0, _postcssselectorparser.default)((selectors)=>{\n    return selectors.map((s)=>{\n        let nodes = s.split((n)=>n.type === \"combinator\" && n.value === \" \").pop();\n        return minimumImpactSelector(nodes);\n    });\n});\nlet cache = new Map();\nfunction extractElementSelector(selector) {\n    if (!cache.has(selector)) {\n        cache.set(selector, elementSelectorParser.transformSync(selector));\n    }\n    return cache.get(selector);\n}\nfunction resolveDefaultsAtRules({ tailwindConfig  }) {\n    return (root)=>{\n        let variableNodeMap = new Map();\n        /** @type {Set<import('postcss').AtRule>} */ let universals = new Set();\n        root.walkAtRules(\"defaults\", (rule)=>{\n            if (rule.nodes && rule.nodes.length > 0) {\n                universals.add(rule);\n                return;\n            }\n            let variable = rule.params;\n            if (!variableNodeMap.has(variable)) {\n                variableNodeMap.set(variable, new Set());\n            }\n            variableNodeMap.get(variable).add(rule.parent);\n            rule.remove();\n        });\n        if ((0, _featureFlags.flagEnabled)(tailwindConfig, \"optimizeUniversalDefaults\")) {\n            for (let universal of universals){\n                /** @type {Map<string, Set<string>>} */ let selectorGroups = new Map();\n                var _variableNodeMap_get;\n                let rules = (_variableNodeMap_get = variableNodeMap.get(universal.params)) !== null && _variableNodeMap_get !== void 0 ? _variableNodeMap_get : [];\n                for (let rule of rules){\n                    for (let selector of extractElementSelector(rule.selector)){\n                        // If selector contains a vendor prefix after a pseudo element or class,\n                        // we consider them separately because merging the declarations into\n                        // a single rule will cause browsers that do not understand the\n                        // vendor prefix to throw out the whole rule\n                        let selectorGroupName = selector.includes(\":-\") || selector.includes(\"::-\") ? selector : \"__DEFAULT__\";\n                        var _selectorGroups_get;\n                        let selectors = (_selectorGroups_get = selectorGroups.get(selectorGroupName)) !== null && _selectorGroups_get !== void 0 ? _selectorGroups_get : new Set();\n                        selectorGroups.set(selectorGroupName, selectors);\n                        selectors.add(selector);\n                    }\n                }\n                if ((0, _featureFlags.flagEnabled)(tailwindConfig, \"optimizeUniversalDefaults\")) {\n                    if (selectorGroups.size === 0) {\n                        universal.remove();\n                        continue;\n                    }\n                    for (let [, selectors] of selectorGroups){\n                        let universalRule = _postcss.default.rule({\n                            source: universal.source\n                        });\n                        universalRule.selectors = [\n                            ...selectors\n                        ];\n                        universalRule.append(universal.nodes.map((node)=>node.clone()));\n                        universal.before(universalRule);\n                    }\n                }\n                universal.remove();\n            }\n        } else if (universals.size) {\n            let universalRule = _postcss.default.rule({\n                selectors: [\n                    \"*\",\n                    \"::before\",\n                    \"::after\"\n                ]\n            });\n            for (let universal of universals){\n                universalRule.append(universal.nodes);\n                if (!universalRule.parent) {\n                    universal.before(universalRule);\n                }\n                if (!universalRule.source) {\n                    universalRule.source = universal.source;\n                }\n                universal.remove();\n            }\n            let backdropRule = universalRule.clone({\n                selectors: [\n                    \"::backdrop\"\n                ]\n            });\n            universalRule.after(backdropRule);\n        }\n    };\n}\n"]}}