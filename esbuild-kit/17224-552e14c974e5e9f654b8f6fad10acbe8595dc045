{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const constants=require(\"./constants\");const utils=require(\"./utils\");const{MAX_LENGTH,POSIX_REGEX_SOURCE,REGEX_NON_SPECIAL_CHARS,REGEX_SPECIAL_CHARS_BACKREF,REPLACEMENTS}=constants;const expandRange=__name((args,options)=>{if(typeof options.expandRange===\"function\"){return options.expandRange(...args,options)}args.sort();const value=`[${args.join(\"-\")}]`;try{new RegExp(value)}catch(ex){return args.map(v=>utils.escapeRegex(v)).join(\"..\")}return value},\"expandRange\");const syntaxError=__name((type,char)=>{return`Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`},\"syntaxError\");const parse=__name((input,options)=>{if(typeof input!==\"string\"){throw new TypeError(\"Expected a string\")}input=REPLACEMENTS[input]||input;const opts={...options};const max=typeof opts.maxLength===\"number\"?Math.min(MAX_LENGTH,opts.maxLength):MAX_LENGTH;let len=input.length;if(len>max){throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`)}const bos={type:\"bos\",value:\"\",output:opts.prepend||\"\"};const tokens=[bos];const capture=opts.capture?\"\":\"?:\";const win32=utils.isWindows(options);const PLATFORM_CHARS=constants.globChars(win32);const EXTGLOB_CHARS=constants.extglobChars(PLATFORM_CHARS);const{DOT_LITERAL,PLUS_LITERAL,SLASH_LITERAL,ONE_CHAR,DOTS_SLASH,NO_DOT,NO_DOT_SLASH,NO_DOTS_SLASH,QMARK,QMARK_NO_DOT,STAR,START_ANCHOR}=PLATFORM_CHARS;const globstar=__name(opts2=>{return`(${capture}(?:(?!${START_ANCHOR}${opts2.dot?DOTS_SLASH:DOT_LITERAL}).)*?)`},\"globstar\");const nodot=opts.dot?\"\":NO_DOT;const qmarkNoDot=opts.dot?QMARK:QMARK_NO_DOT;let star=opts.bash===true?globstar(opts):STAR;if(opts.capture){star=`(${star})`}if(typeof opts.noext===\"boolean\"){opts.noextglob=opts.noext}const state={input,index:-1,start:0,dot:opts.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens};input=utils.removePrefix(input,state);len=input.length;const extglobs=[];const braces=[];const stack=[];let prev=bos;let value;const eos=__name(()=>state.index===len-1,\"eos\");const peek=state.peek=(n=1)=>input[state.index+n];const advance=state.advance=()=>input[++state.index]||\"\";const remaining=__name(()=>input.slice(state.index+1),\"remaining\");const consume=__name((value2=\"\",num=0)=>{state.consumed+=value2;state.index+=num},\"consume\");const append=__name(token=>{state.output+=token.output!=null?token.output:token.value;consume(token.value)},\"append\");const negate=__name(()=>{let count=1;while(peek()===\"!\"&&(peek(2)!==\"(\"||peek(3)===\"?\")){advance();state.start++;count++}if(count%2===0){return false}state.negated=true;state.start++;return true},\"negate\");const increment=__name(type=>{state[type]++;stack.push(type)},\"increment\");const decrement=__name(type=>{state[type]--;stack.pop()},\"decrement\");const push=__name(tok=>{if(prev.type===\"globstar\"){const isBrace=state.braces>0&&(tok.type===\"comma\"||tok.type===\"brace\");const isExtglob=tok.extglob===true||extglobs.length&&(tok.type===\"pipe\"||tok.type===\"paren\");if(tok.type!==\"slash\"&&tok.type!==\"paren\"&&!isBrace&&!isExtglob){state.output=state.output.slice(0,-prev.output.length);prev.type=\"star\";prev.value=\"*\";prev.output=star;state.output+=prev.output}}if(extglobs.length&&tok.type!==\"paren\"){extglobs[extglobs.length-1].inner+=tok.value}if(tok.value||tok.output)append(tok);if(prev&&prev.type===\"text\"&&tok.type===\"text\"){prev.value+=tok.value;prev.output=(prev.output||\"\")+tok.value;return}tok.prev=prev;tokens.push(tok);prev=tok},\"push\");const extglobOpen=__name((type,value2)=>{const token={...EXTGLOB_CHARS[value2],conditions:1,inner:\"\"};token.prev=prev;token.parens=state.parens;token.output=state.output;const output=(opts.capture?\"(\":\"\")+token.open;increment(\"parens\");push({type,value:value2,output:state.output?\"\":ONE_CHAR});push({type:\"paren\",extglob:true,value:advance(),output});extglobs.push(token)},\"extglobOpen\");const extglobClose=__name(token=>{let output=token.close+(opts.capture?\")\":\"\");let rest;if(token.type===\"negate\"){let extglobStar=star;if(token.inner&&token.inner.length>1&&token.inner.includes(\"/\")){extglobStar=globstar(opts)}if(extglobStar!==star||eos()||/^\\)+$/.test(remaining())){output=token.close=`)$))${extglobStar}`}if(token.inner.includes(\"*\")&&(rest=remaining())&&/^\\.[^\\\\/.]+$/.test(rest)){const expression=parse(rest,{...options,fastpaths:false}).output;output=token.close=`)${expression})${extglobStar})`}if(token.prev.type===\"bos\"){state.negatedExtglob=true}}push({type:\"paren\",extglob:true,value,output});decrement(\"parens\")},\"extglobClose\");if(opts.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(input)){let backslashes=false;let output=input.replace(REGEX_SPECIAL_CHARS_BACKREF,(m,esc,chars,first,rest,index)=>{if(first===\"\\\\\"){backslashes=true;return m}if(first===\"?\"){if(esc){return esc+first+(rest?QMARK.repeat(rest.length):\"\")}if(index===0){return qmarkNoDot+(rest?QMARK.repeat(rest.length):\"\")}return QMARK.repeat(chars.length)}if(first===\".\"){return DOT_LITERAL.repeat(chars.length)}if(first===\"*\"){if(esc){return esc+first+(rest?star:\"\")}return star}return esc?m:`\\\\${m}`});if(backslashes===true){if(opts.unescape===true){output=output.replace(/\\\\/g,\"\")}else{output=output.replace(/\\\\+/g,m=>{return m.length%2===0?\"\\\\\\\\\":m?\"\\\\\":\"\"})}}if(output===input&&opts.contains===true){state.output=input;return state}state.output=utils.wrapOutput(output,state,options);return state}while(!eos()){value=advance();if(value===\"\\0\"){continue}if(value===\"\\\\\"){const next=peek();if(next===\"/\"&&opts.bash!==true){continue}if(next===\".\"||next===\";\"){continue}if(!next){value+=\"\\\\\";push({type:\"text\",value});continue}const match=/^\\\\+/.exec(remaining());let slashes=0;if(match&&match[0].length>2){slashes=match[0].length;state.index+=slashes;if(slashes%2!==0){value+=\"\\\\\"}}if(opts.unescape===true){value=advance()}else{value+=advance()}if(state.brackets===0){push({type:\"text\",value});continue}}if(state.brackets>0&&(value!==\"]\"||prev.value===\"[\"||prev.value===\"[^\")){if(opts.posix!==false&&value===\":\"){const inner=prev.value.slice(1);if(inner.includes(\"[\")){prev.posix=true;if(inner.includes(\":\")){const idx=prev.value.lastIndexOf(\"[\");const pre=prev.value.slice(0,idx);const rest2=prev.value.slice(idx+2);const posix=POSIX_REGEX_SOURCE[rest2];if(posix){prev.value=pre+posix;state.backtrack=true;advance();if(!bos.output&&tokens.indexOf(prev)===1){bos.output=ONE_CHAR}continue}}}}if(value===\"[\"&&peek()!==\":\"||value===\"-\"&&peek()===\"]\"){value=`\\\\${value}`}if(value===\"]\"&&(prev.value===\"[\"||prev.value===\"[^\")){value=`\\\\${value}`}if(opts.posix===true&&value===\"!\"&&prev.value===\"[\"){value=\"^\"}prev.value+=value;append({value});continue}if(state.quotes===1&&value!=='\"'){value=utils.escapeRegex(value);prev.value+=value;append({value});continue}if(value==='\"'){state.quotes=state.quotes===1?0:1;if(opts.keepQuotes===true){push({type:\"text\",value})}continue}if(value===\"(\"){increment(\"parens\");push({type:\"paren\",value});continue}if(value===\")\"){if(state.parens===0&&opts.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const extglob=extglobs[extglobs.length-1];if(extglob&&state.parens===extglob.parens+1){extglobClose(extglobs.pop());continue}push({type:\"paren\",value,output:state.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(value===\"[\"){if(opts.nobracket===true||!remaining().includes(\"]\")){if(opts.nobracket!==true&&opts.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}value=`\\\\${value}`}else{increment(\"brackets\")}push({type:\"bracket\",value});continue}if(value===\"]\"){if(opts.nobracket===true||prev&&prev.type===\"bracket\"&&prev.value.length===1){push({type:\"text\",value,output:`\\\\${value}`});continue}if(state.brackets===0){if(opts.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value,output:`\\\\${value}`});continue}decrement(\"brackets\");const prevValue=prev.value.slice(1);if(prev.posix!==true&&prevValue[0]===\"^\"&&!prevValue.includes(\"/\")){value=`/${value}`}prev.value+=value;append({value});if(opts.literalBrackets===false||utils.hasRegexChars(prevValue)){continue}const escaped=utils.escapeRegex(prev.value);state.output=state.output.slice(0,-prev.value.length);if(opts.literalBrackets===true){state.output+=escaped;prev.value=escaped;continue}prev.value=`(${capture}${escaped}|${prev.value})`;state.output+=prev.value;continue}if(value===\"{\"&&opts.nobrace!==true){increment(\"braces\");const open={type:\"brace\",value,output:\"(\",outputIndex:state.output.length,tokensIndex:state.tokens.length};braces.push(open);push(open);continue}if(value===\"}\"){const brace=braces[braces.length-1];if(opts.nobrace===true||!brace){push({type:\"text\",value,output:value});continue}let output=\")\";if(brace.dots===true){const arr=tokens.slice();const range=[];for(let i=arr.length-1;i>=0;i--){tokens.pop();if(arr[i].type===\"brace\"){break}if(arr[i].type!==\"dots\"){range.unshift(arr[i].value)}}output=expandRange(range,opts);state.backtrack=true}if(brace.comma!==true&&brace.dots!==true){const out=state.output.slice(0,brace.outputIndex);const toks=state.tokens.slice(brace.tokensIndex);brace.value=brace.output=\"\\\\{\";value=output=\"\\\\}\";state.output=out;for(const t of toks){state.output+=t.output||t.value}}push({type:\"brace\",value,output});decrement(\"braces\");braces.pop();continue}if(value===\"|\"){if(extglobs.length>0){extglobs[extglobs.length-1].conditions++}push({type:\"text\",value});continue}if(value===\",\"){let output=value;const brace=braces[braces.length-1];if(brace&&stack[stack.length-1]===\"braces\"){brace.comma=true;output=\"|\"}push({type:\"comma\",value,output});continue}if(value===\"/\"){if(prev.type===\"dot\"&&state.index===state.start+1){state.start=state.index+1;state.consumed=\"\";state.output=\"\";tokens.pop();prev=bos;continue}push({type:\"slash\",value,output:SLASH_LITERAL});continue}if(value===\".\"){if(state.braces>0&&prev.type===\"dot\"){if(prev.value===\".\")prev.output=DOT_LITERAL;const brace=braces[braces.length-1];prev.type=\"dots\";prev.output+=value;prev.value+=value;brace.dots=true;continue}if(state.braces+state.parens===0&&prev.type!==\"bos\"&&prev.type!==\"slash\"){push({type:\"text\",value,output:DOT_LITERAL});continue}push({type:\"dot\",value,output:DOT_LITERAL});continue}if(value===\"?\"){const isGroup=prev&&prev.value===\"(\";if(!isGroup&&opts.noextglob!==true&&peek()===\"(\"&&peek(2)!==\"?\"){extglobOpen(\"qmark\",value);continue}if(prev&&prev.type===\"paren\"){const next=peek();let output=value;if(next===\"<\"&&!utils.supportsLookbehinds()){throw new Error(\"Node.js v10 or higher is required for regex lookbehinds\")}if(prev.value===\"(\"&&!/[!=<:]/.test(next)||next===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){output=`\\\\${value}`}push({type:\"text\",value,output});continue}if(opts.dot!==true&&(prev.type===\"slash\"||prev.type===\"bos\")){push({type:\"qmark\",value,output:QMARK_NO_DOT});continue}push({type:\"qmark\",value,output:QMARK});continue}if(value===\"!\"){if(opts.noextglob!==true&&peek()===\"(\"){if(peek(2)!==\"?\"||!/[!=<:]/.test(peek(3))){extglobOpen(\"negate\",value);continue}}if(opts.nonegate!==true&&state.index===0){negate();continue}}if(value===\"+\"){if(opts.noextglob!==true&&peek()===\"(\"&&peek(2)!==\"?\"){extglobOpen(\"plus\",value);continue}if(prev&&prev.value===\"(\"||opts.regex===false){push({type:\"plus\",value,output:PLUS_LITERAL});continue}if(prev&&(prev.type===\"bracket\"||prev.type===\"paren\"||prev.type===\"brace\")||state.parens>0){push({type:\"plus\",value});continue}push({type:\"plus\",value:PLUS_LITERAL});continue}if(value===\"@\"){if(opts.noextglob!==true&&peek()===\"(\"&&peek(2)!==\"?\"){push({type:\"at\",extglob:true,value,output:\"\"});continue}push({type:\"text\",value});continue}if(value!==\"*\"){if(value===\"$\"||value===\"^\"){value=`\\\\${value}`}const match=REGEX_NON_SPECIAL_CHARS.exec(remaining());if(match){value+=match[0];state.index+=match[0].length}push({type:\"text\",value});continue}if(prev&&(prev.type===\"globstar\"||prev.star===true)){prev.type=\"star\";prev.star=true;prev.value+=value;prev.output=star;state.backtrack=true;state.globstar=true;consume(value);continue}let rest=remaining();if(opts.noextglob!==true&&/^\\([^?]/.test(rest)){extglobOpen(\"star\",value);continue}if(prev.type===\"star\"){if(opts.noglobstar===true){consume(value);continue}const prior=prev.prev;const before=prior.prev;const isStart=prior.type===\"slash\"||prior.type===\"bos\";const afterStar=before&&(before.type===\"star\"||before.type===\"globstar\");if(opts.bash===true&&(!isStart||rest[0]&&rest[0]!==\"/\")){push({type:\"star\",value,output:\"\"});continue}const isBrace=state.braces>0&&(prior.type===\"comma\"||prior.type===\"brace\");const isExtglob=extglobs.length&&(prior.type===\"pipe\"||prior.type===\"paren\");if(!isStart&&prior.type!==\"paren\"&&!isBrace&&!isExtglob){push({type:\"star\",value,output:\"\"});continue}while(rest.slice(0,3)===\"/**\"){const after=input[state.index+4];if(after&&after!==\"/\"){break}rest=rest.slice(3);consume(\"/**\",3)}if(prior.type===\"bos\"&&eos()){prev.type=\"globstar\";prev.value+=value;prev.output=globstar(opts);state.output=prev.output;state.globstar=true;consume(value);continue}if(prior.type===\"slash\"&&prior.prev.type!==\"bos\"&&!afterStar&&eos()){state.output=state.output.slice(0,-(prior.output+prev.output).length);prior.output=`(?:${prior.output}`;prev.type=\"globstar\";prev.output=globstar(opts)+(opts.strictSlashes?\")\":\"|$)\");prev.value+=value;state.globstar=true;state.output+=prior.output+prev.output;consume(value);continue}if(prior.type===\"slash\"&&prior.prev.type!==\"bos\"&&rest[0]===\"/\"){const end=rest[1]!==void 0?\"|$\":\"\";state.output=state.output.slice(0,-(prior.output+prev.output).length);prior.output=`(?:${prior.output}`;prev.type=\"globstar\";prev.output=`${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;prev.value+=value;state.output+=prior.output+prev.output;state.globstar=true;consume(value+advance());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(prior.type===\"bos\"&&rest[0]===\"/\"){prev.type=\"globstar\";prev.value+=value;prev.output=`(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;state.output=prev.output;state.globstar=true;consume(value+advance());push({type:\"slash\",value:\"/\",output:\"\"});continue}state.output=state.output.slice(0,-prev.output.length);prev.type=\"globstar\";prev.output=globstar(opts);prev.value+=value;state.output+=prev.output;state.globstar=true;consume(value);continue}const token={type:\"star\",value,output:star};if(opts.bash===true){token.output=\".*?\";if(prev.type===\"bos\"||prev.type===\"slash\"){token.output=nodot+token.output}push(token);continue}if(prev&&(prev.type===\"bracket\"||prev.type===\"paren\")&&opts.regex===true){token.output=value;push(token);continue}if(state.index===state.start||prev.type===\"slash\"||prev.type===\"dot\"){if(prev.type===\"dot\"){state.output+=NO_DOT_SLASH;prev.output+=NO_DOT_SLASH}else if(opts.dot===true){state.output+=NO_DOTS_SLASH;prev.output+=NO_DOTS_SLASH}else{state.output+=nodot;prev.output+=nodot}if(peek()!==\"*\"){state.output+=ONE_CHAR;prev.output+=ONE_CHAR}}push(token)}while(state.brackets>0){if(opts.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));state.output=utils.escapeLast(state.output,\"[\");decrement(\"brackets\")}while(state.parens>0){if(opts.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));state.output=utils.escapeLast(state.output,\"(\");decrement(\"parens\")}while(state.braces>0){if(opts.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));state.output=utils.escapeLast(state.output,\"{\");decrement(\"braces\")}if(opts.strictSlashes!==true&&(prev.type===\"star\"||prev.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${SLASH_LITERAL}?`})}if(state.backtrack===true){state.output=\"\";for(const token of state.tokens){state.output+=token.output!=null?token.output:token.value;if(token.suffix){state.output+=token.suffix}}}return state},\"parse\");parse.fastpaths=(input,options)=>{const opts={...options};const max=typeof opts.maxLength===\"number\"?Math.min(MAX_LENGTH,opts.maxLength):MAX_LENGTH;const len=input.length;if(len>max){throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`)}input=REPLACEMENTS[input]||input;const win32=utils.isWindows(options);const{DOT_LITERAL,SLASH_LITERAL,ONE_CHAR,DOTS_SLASH,NO_DOT,NO_DOTS,NO_DOTS_SLASH,STAR,START_ANCHOR}=constants.globChars(win32);const nodot=opts.dot?NO_DOTS:NO_DOT;const slashDot=opts.dot?NO_DOTS_SLASH:NO_DOT;const capture=opts.capture?\"\":\"?:\";const state={negated:false,prefix:\"\"};let star=opts.bash===true?\".*?\":STAR;if(opts.capture){star=`(${star})`}const globstar=__name(opts2=>{if(opts2.noglobstar===true)return star;return`(${capture}(?:(?!${START_ANCHOR}${opts2.dot?DOTS_SLASH:DOT_LITERAL}).)*?)`},\"globstar\");const create=__name(str=>{switch(str){case\"*\":return`${nodot}${ONE_CHAR}${star}`;case\".*\":return`${DOT_LITERAL}${ONE_CHAR}${star}`;case\"*.*\":return`${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;case\"*/*\":return`${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;case\"**\":return nodot+globstar(opts);case\"**/*\":return`(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;case\"**/*.*\":return`(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;case\"**/.*\":return`(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;default:{const match=/^(.*?)\\.(\\w+)$/.exec(str);if(!match)return;const source2=create(match[1]);if(!source2)return;return source2+DOT_LITERAL+match[2]}}},\"create\");const output=utils.removePrefix(input,state);let source=create(output);if(source&&opts.strictSlashes!==true){source+=`${SLASH_LITERAL}?`}return source};module.exports=parse;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["opts","value","rest","source"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js"],"sourcesContent":["'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n"]}}