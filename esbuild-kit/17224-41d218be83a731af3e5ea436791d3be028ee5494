{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const valueParser=require(\"postcss-value-parser\");const{stringify}=valueParser;function split(params,start){const list=[];const last=params.reduce((item,node,index)=>{if(index<start)return\"\";if(node.type===\"div\"&&node.value===\",\"){list.push(item);return\"\"}return item+stringify(node)},\"\");list.push(last);return list}__name(split,\"split\");module.exports=function(result,styles){const statements=[];let nodes=[];styles.each(node=>{let stmt;if(node.type===\"atrule\"){if(node.name===\"import\")stmt=parseImport(result,node);else if(node.name===\"media\")stmt=parseMedia(result,node);else if(node.name===\"charset\")stmt=parseCharset(result,node)}if(stmt){if(nodes.length){statements.push({type:\"nodes\",nodes,media:[],layer:[]});nodes=[]}statements.push(stmt)}else nodes.push(node)});if(nodes.length){statements.push({type:\"nodes\",nodes,media:[],layer:[]})}return statements};function parseMedia(result,atRule){const params=valueParser(atRule.params).nodes;return{type:\"media\",node:atRule,media:split(params,0),layer:[]}}__name(parseMedia,\"parseMedia\");function parseCharset(result,atRule){if(atRule.prev()){return result.warn(\"@charset must precede all other statements\",{node:atRule})}return{type:\"charset\",node:atRule,media:[],layer:[]}}__name(parseCharset,\"parseCharset\");function parseImport(result,atRule){let prev=atRule.prev();if(prev){do{if(prev.type!==\"comment\"&&(prev.type!==\"atrule\"||prev.name!==\"import\"&&prev.name!==\"charset\"&&!(prev.name===\"layer\"&&!prev.nodes))){return result.warn(\"@import must precede all other statements (besides @charset or empty @layer)\",{node:atRule})}prev=prev.prev()}while(prev)}if(atRule.nodes){return result.warn(\"It looks like you didn't end your @import statement correctly. Child nodes are attached to it.\",{node:atRule})}const params=valueParser(atRule.params).nodes;const stmt={type:\"import\",node:atRule,media:[],layer:[]};if(!params.length||(params[0].type!==\"string\"||!params[0].value)&&(params[0].type!==\"function\"||params[0].value!==\"url\"||!params[0].nodes.length||!params[0].nodes[0].value)){return result.warn(`Unable to find uri in '${atRule.toString()}'`,{node:atRule})}if(params[0].type===\"string\")stmt.uri=params[0].value;else stmt.uri=params[0].nodes[0].value;stmt.fullUri=stringify(params[0]);let remainder=params;if(remainder.length>2){if((remainder[2].type===\"word\"||remainder[2].type===\"function\")&&remainder[2].value===\"layer\"){if(remainder[1].type!==\"space\"){return result.warn(\"Invalid import layer statement\",{node:atRule})}if(remainder[2].nodes){stmt.layer=[stringify(remainder[2].nodes)]}else{stmt.layer=[\"\"]}remainder=remainder.slice(2)}}if(remainder.length>2){if(remainder[1].type!==\"space\"){return result.warn(\"Invalid import media statement\",{node:atRule})}stmt.media=split(remainder,2)}return stmt}__name(parseImport,\"parseImport\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/postcss-import@15.1.0_postcss@8.4.24/node_modules/postcss-import/lib/parse-statements.js"],"sourcesContent":["\"use strict\"\n\n// external tooling\nconst valueParser = require(\"postcss-value-parser\")\n\n// extended tooling\nconst { stringify } = valueParser\n\nfunction split(params, start) {\n  const list = []\n  const last = params.reduce((item, node, index) => {\n    if (index < start) return \"\"\n    if (node.type === \"div\" && node.value === \",\") {\n      list.push(item)\n      return \"\"\n    }\n    return item + stringify(node)\n  }, \"\")\n  list.push(last)\n  return list\n}\n\nmodule.exports = function (result, styles) {\n  const statements = []\n  let nodes = []\n\n  styles.each(node => {\n    let stmt\n    if (node.type === \"atrule\") {\n      if (node.name === \"import\") stmt = parseImport(result, node)\n      else if (node.name === \"media\") stmt = parseMedia(result, node)\n      else if (node.name === \"charset\") stmt = parseCharset(result, node)\n    }\n\n    if (stmt) {\n      if (nodes.length) {\n        statements.push({\n          type: \"nodes\",\n          nodes,\n          media: [],\n          layer: [],\n        })\n        nodes = []\n      }\n      statements.push(stmt)\n    } else nodes.push(node)\n  })\n\n  if (nodes.length) {\n    statements.push({\n      type: \"nodes\",\n      nodes,\n      media: [],\n      layer: [],\n    })\n  }\n\n  return statements\n}\n\nfunction parseMedia(result, atRule) {\n  const params = valueParser(atRule.params).nodes\n  return {\n    type: \"media\",\n    node: atRule,\n    media: split(params, 0),\n    layer: [],\n  }\n}\n\nfunction parseCharset(result, atRule) {\n  if (atRule.prev()) {\n    return result.warn(\"@charset must precede all other statements\", {\n      node: atRule,\n    })\n  }\n  return {\n    type: \"charset\",\n    node: atRule,\n    media: [],\n    layer: [],\n  }\n}\n\nfunction parseImport(result, atRule) {\n  let prev = atRule.prev()\n  if (prev) {\n    do {\n      if (\n        prev.type !== \"comment\" &&\n        (prev.type !== \"atrule\" ||\n          (prev.name !== \"import\" &&\n            prev.name !== \"charset\" &&\n            !(prev.name === \"layer\" && !prev.nodes)))\n      ) {\n        return result.warn(\n          \"@import must precede all other statements (besides @charset or empty @layer)\",\n          { node: atRule }\n        )\n      }\n      prev = prev.prev()\n    } while (prev)\n  }\n\n  if (atRule.nodes) {\n    return result.warn(\n      \"It looks like you didn't end your @import statement correctly. \" +\n        \"Child nodes are attached to it.\",\n      { node: atRule }\n    )\n  }\n\n  const params = valueParser(atRule.params).nodes\n  const stmt = {\n    type: \"import\",\n    node: atRule,\n    media: [],\n    layer: [],\n  }\n\n  // prettier-ignore\n  if (\n    !params.length ||\n    (\n      params[0].type !== \"string\" ||\n      !params[0].value\n    ) &&\n    (\n      params[0].type !== \"function\" ||\n      params[0].value !== \"url\" ||\n      !params[0].nodes.length ||\n      !params[0].nodes[0].value\n    )\n  ) {\n    return result.warn(`Unable to find uri in '${  atRule.toString()  }'`, {\n      node: atRule,\n    })\n  }\n\n  if (params[0].type === \"string\") stmt.uri = params[0].value\n  else stmt.uri = params[0].nodes[0].value\n  stmt.fullUri = stringify(params[0])\n\n  let remainder = params\n  if (remainder.length > 2) {\n    if (\n      (remainder[2].type === \"word\" || remainder[2].type === \"function\") &&\n      remainder[2].value === \"layer\"\n    ) {\n      if (remainder[1].type !== \"space\") {\n        return result.warn(\"Invalid import layer statement\", { node: atRule })\n      }\n\n      if (remainder[2].nodes) {\n        stmt.layer = [stringify(remainder[2].nodes)]\n      } else {\n        stmt.layer = [\"\"]\n      }\n      remainder = remainder.slice(2)\n    }\n  }\n\n  if (remainder.length > 2) {\n    if (remainder[1].type !== \"space\") {\n      return result.warn(\"Invalid import media statement\", { node: atRule })\n    }\n\n    stmt.media = split(remainder, 2)\n  }\n\n  return stmt\n}\n"]}}