{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});Object.defineProperty(exports,\"default\",{enumerable:true,get:function(){return expandApplyAtRules}});const _postcss=_interop_require_default(require(\"postcss\"));const _postcssselectorparser=_interop_require_default(require(\"postcss-selector-parser\"));const _generateRules=require(\"./generateRules\");const _escapeClassName=_interop_require_default(require(\"../util/escapeClassName\"));const _applyImportantSelector=require(\"../util/applyImportantSelector\");const _pseudoElements=require(\"../util/pseudoElements\");function _interop_require_default(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interop_require_default,\"_interop_require_default\");function extractClasses(node){let groups=new Map;let container=_postcss.default.root({nodes:[node.clone()]});container.walkRules(rule=>{(0,_postcssselectorparser.default)(selectors=>{selectors.walkClasses(classSelector=>{let parentSelector=classSelector.parent.toString();let classes2=groups.get(parentSelector);if(!classes2){groups.set(parentSelector,classes2=new Set)}classes2.add(classSelector.value)})}).processSync(rule.selector)});let normalizedGroups=Array.from(groups.values(),classes2=>Array.from(classes2));let classes=normalizedGroups.flat();return Object.assign(classes,{groups:normalizedGroups})}__name(extractClasses,\"extractClasses\");let selectorExtractor=(0,_postcssselectorparser.default)();function extractSelectors(ruleSelectors){return selectorExtractor.astSync(ruleSelectors)}__name(extractSelectors,\"extractSelectors\");function extractBaseCandidates(candidates,separator){let baseClasses=new Set;for(let candidate of candidates){baseClasses.add(candidate.split(separator).pop())}return Array.from(baseClasses)}__name(extractBaseCandidates,\"extractBaseCandidates\");function prefix(context,selector){let prefix2=context.tailwindConfig.prefix;return typeof prefix2===\"function\"?prefix2(selector):prefix2+selector}__name(prefix,\"prefix\");function*pathToRoot(node){yield node;while(node.parent){yield node.parent;node=node.parent}}__name(pathToRoot,\"pathToRoot\");function shallowClone(node,overrides={}){let children=node.nodes;node.nodes=[];let tmp=node.clone(overrides);node.nodes=children;return tmp}__name(shallowClone,\"shallowClone\");function nestedClone(node){for(let parent of pathToRoot(node)){if(node===parent){continue}if(parent.type===\"root\"){break}node=shallowClone(parent,{nodes:[node]})}return node}__name(nestedClone,\"nestedClone\");function buildLocalApplyCache(root,context){let cache=new Map;root.walkRules(rule=>{for(let node of pathToRoot(rule)){var _node_raws_tailwind;if(((_node_raws_tailwind=node.raws.tailwind)===null||_node_raws_tailwind===void 0?void 0:_node_raws_tailwind.layer)!==void 0){return}}let container=nestedClone(rule);let sort=context.offsets.create(\"user\");for(let className of extractClasses(rule)){let list=cache.get(className)||[];cache.set(className,list);list.push([{layer:\"user\",sort,important:false},container])}});return cache}__name(buildLocalApplyCache,\"buildLocalApplyCache\");function buildApplyCache(applyCandidates,context){for(let candidate of applyCandidates){if(context.notClassCache.has(candidate)||context.applyClassCache.has(candidate)){continue}if(context.classCache.has(candidate)){context.applyClassCache.set(candidate,context.classCache.get(candidate).map(([meta,rule])=>[meta,rule.clone()]));continue}let matches=Array.from((0,_generateRules.resolveMatches)(candidate,context));if(matches.length===0){context.notClassCache.add(candidate);continue}context.applyClassCache.set(candidate,matches)}return context.applyClassCache}__name(buildApplyCache,\"buildApplyCache\");function lazyCache(buildCacheFn){let cache=null;return{get:name=>{cache=cache||buildCacheFn();return cache.get(name)},has:name=>{cache=cache||buildCacheFn();return cache.has(name)}}}__name(lazyCache,\"lazyCache\");function combineCaches(caches){return{get:name=>caches.flatMap(cache=>cache.get(name)||[]),has:name=>caches.some(cache=>cache.has(name))}}__name(combineCaches,\"combineCaches\");function extractApplyCandidates(params){let candidates=params.split(/[\\s\\t\\n]+/g);if(candidates[candidates.length-1]===\"!important\"){return[candidates.slice(0,-1),true]}return[candidates,false]}__name(extractApplyCandidates,\"extractApplyCandidates\");function processApply(root,context,localCache){let applyCandidates=new Set;let applies=[];root.walkAtRules(\"apply\",rule=>{let[candidates]=extractApplyCandidates(rule.params);for(let util of candidates){applyCandidates.add(util)}applies.push(rule)});if(applies.length===0){return}let applyClassCache=combineCaches([localCache,buildApplyCache(applyCandidates,context)]);function replaceSelector(selector,utilitySelectors,candidate){let selectorList=extractSelectors(selector);let utilitySelectorsList=extractSelectors(utilitySelectors);let candidateList=extractSelectors(`.${(0,_escapeClassName.default)(candidate)}`);let candidateClass=candidateList.nodes[0].nodes[0];selectorList.each(sel=>{let replaced=new Set;utilitySelectorsList.each(utilitySelector=>{let hasReplaced=false;utilitySelector=utilitySelector.clone();utilitySelector.walkClasses(node=>{if(node.value!==candidateClass.value){return}if(hasReplaced){return}node.replaceWith(...sel.nodes.map(node2=>node2.clone()));replaced.add(utilitySelector);hasReplaced=true})});for(let sel2 of replaced){let groups=[[]];for(let node of sel2.nodes){if(node.type===\"combinator\"){groups.push(node);groups.push([])}else{let last=groups[groups.length-1];last.push(node)}}sel2.nodes=[];for(let group of groups){if(Array.isArray(group)){group.sort((a,b)=>{if(a.type===\"tag\"&&b.type===\"class\"){return-1}else if(a.type===\"class\"&&b.type===\"tag\"){return 1}else if(a.type===\"class\"&&b.type===\"pseudo\"&&b.value.startsWith(\"::\")){return-1}else if(a.type===\"pseudo\"&&a.value.startsWith(\"::\")&&b.type===\"class\"){return 1}return 0})}sel2.nodes=sel2.nodes.concat(group)}}sel.replaceWith(...replaced)});return selectorList.toString()}__name(replaceSelector,\"replaceSelector\");let perParentApplies=new Map;for(let apply of applies){let[candidates]=perParentApplies.get(apply.parent)||[[],apply.source];perParentApplies.set(apply.parent,[candidates,apply.source]);let[applyCandidates2,important]=extractApplyCandidates(apply.params);if(apply.parent.type===\"atrule\"){if(apply.parent.name===\"screen\"){let screenType=apply.parent.params;throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates2.map(c=>`${screenType}:${c}`).join(\" \")} instead.`)}throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`)}for(let applyCandidate of applyCandidates2){if([prefix(context,\"group\"),prefix(context,\"peer\")].includes(applyCandidate)){throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`)}if(!applyClassCache.has(applyCandidate)){throw apply.error(`The \\`${applyCandidate}\\` class does not exist. If \\`${applyCandidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`)}let rules=applyClassCache.get(applyCandidate);candidates.push([applyCandidate,important,rules])}}for(let[parent,[candidates,atApplySource]]of perParentApplies){let siblings=[];for(let[applyCandidate,important,rules]of candidates){let potentialApplyCandidates=[applyCandidate,...extractBaseCandidates([applyCandidate],context.tailwindConfig.separator)];for(let[meta,node]of rules){let parentClasses=extractClasses(parent);let nodeClasses=extractClasses(node);nodeClasses=nodeClasses.groups.filter(classList=>classList.some(className=>potentialApplyCandidates.includes(className))).flat();nodeClasses=nodeClasses.concat(extractBaseCandidates(nodeClasses,context.tailwindConfig.separator));let intersects=parentClasses.some(selector=>nodeClasses.includes(selector));if(intersects){throw node.error(`You cannot \\`@apply\\` the \\`${applyCandidate}\\` utility here because it creates a circular dependency.`)}let root2=_postcss.default.root({nodes:[node.clone()]});root2.walk(node2=>{node2.source=atApplySource});let canRewriteSelector=node.type!==\"atrule\"||node.type===\"atrule\"&&node.name!==\"keyframes\";if(canRewriteSelector){root2.walkRules(rule=>{if(!extractClasses(rule).some(candidate=>candidate===applyCandidate)){rule.remove();return}let importantSelector=typeof context.tailwindConfig.important===\"string\"?context.tailwindConfig.important:null;let isGenerated=parent.raws.tailwind!==void 0;let parentSelector=isGenerated&&importantSelector&&parent.selector.indexOf(importantSelector)===0?parent.selector.slice(importantSelector.length):parent.selector;rule.selector=replaceSelector(parentSelector,rule.selector,applyCandidate);if(importantSelector&&parentSelector!==parent.selector){rule.selector=(0,_applyImportantSelector.applyImportantSelector)(rule.selector,importantSelector)}rule.walkDecls(d=>{d.important=meta.important||important});let selector=(0,_postcssselectorparser.default)().astSync(rule.selector);selector.each(sel=>(0,_pseudoElements.movePseudos)(sel));rule.selector=selector.toString()})}if(!root2.nodes[0]){continue}siblings.push([meta.sort,root2.nodes[0]])}}let nodes=context.offsets.sort(siblings).map(s=>s[1]);parent.after(nodes)}for(let apply of applies){if(apply.parent.nodes.length>1){apply.remove()}else{apply.parent.remove()}}processApply(root,context,localCache)}__name(processApply,\"processApply\");function expandApplyAtRules(context){return root=>{let localCache=lazyCache(()=>buildLocalApplyCache(root,context));processApply(root,context,localCache)}}__name(expandApplyAtRules,\"expandApplyAtRules\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["classes","prefix","node","sel","applyCandidates","root"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/lib/expandApplyAtRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return expandApplyAtRules;\n    }\n});\nconst _postcss = /*#__PURE__*/ _interop_require_default(require(\"postcss\"));\nconst _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require(\"postcss-selector-parser\"));\nconst _generateRules = require(\"./generateRules\");\nconst _escapeClassName = /*#__PURE__*/ _interop_require_default(require(\"../util/escapeClassName\"));\nconst _applyImportantSelector = require(\"../util/applyImportantSelector\");\nconst _pseudoElements = require(\"../util/pseudoElements\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n/** @typedef {Map<string, [any, import('postcss').Rule[]]>} ApplyCache */ function extractClasses(node) {\n    /** @type {Map<string, Set<string>>} */ let groups = new Map();\n    let container = _postcss.default.root({\n        nodes: [\n            node.clone()\n        ]\n    });\n    container.walkRules((rule)=>{\n        (0, _postcssselectorparser.default)((selectors)=>{\n            selectors.walkClasses((classSelector)=>{\n                let parentSelector = classSelector.parent.toString();\n                let classes = groups.get(parentSelector);\n                if (!classes) {\n                    groups.set(parentSelector, classes = new Set());\n                }\n                classes.add(classSelector.value);\n            });\n        }).processSync(rule.selector);\n    });\n    let normalizedGroups = Array.from(groups.values(), (classes)=>Array.from(classes));\n    let classes = normalizedGroups.flat();\n    return Object.assign(classes, {\n        groups: normalizedGroups\n    });\n}\nlet selectorExtractor = (0, _postcssselectorparser.default)();\n/**\n * @param {string} ruleSelectors\n */ function extractSelectors(ruleSelectors) {\n    return selectorExtractor.astSync(ruleSelectors);\n}\nfunction extractBaseCandidates(candidates, separator) {\n    let baseClasses = new Set();\n    for (let candidate of candidates){\n        baseClasses.add(candidate.split(separator).pop());\n    }\n    return Array.from(baseClasses);\n}\nfunction prefix(context, selector) {\n    let prefix = context.tailwindConfig.prefix;\n    return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction* pathToRoot(node) {\n    yield node;\n    while(node.parent){\n        yield node.parent;\n        node = node.parent;\n    }\n}\n/**\n * Only clone the node itself and not its children\n *\n * @param {*} node\n * @param {*} overrides\n * @returns\n */ function shallowClone(node, overrides = {}) {\n    let children = node.nodes;\n    node.nodes = [];\n    let tmp = node.clone(overrides);\n    node.nodes = children;\n    return tmp;\n}\n/**\n * Clone just the nodes all the way to the top that are required to represent\n * this singular rule in the tree.\n *\n * For example, if we have CSS like this:\n * ```css\n * @media (min-width: 768px) {\n *   @supports (display: grid) {\n *     .foo {\n *       display: grid;\n *       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n *     }\n *   }\n *\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n *\n *   .baz {\n *     color: orange;\n *   }\n * }\n * ```\n *\n * And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:\n *\n * ```css\n * @media (min-width: 768px) {\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n * }\n * ```\n *\n * @param {import('postcss').Node} node\n */ function nestedClone(node) {\n    for (let parent of pathToRoot(node)){\n        if (node === parent) {\n            continue;\n        }\n        if (parent.type === \"root\") {\n            break;\n        }\n        node = shallowClone(parent, {\n            nodes: [\n                node\n            ]\n        });\n    }\n    return node;\n}\n/**\n * @param {import('postcss').Root} root\n */ function buildLocalApplyCache(root, context) {\n    /** @type {ApplyCache} */ let cache = new Map();\n    root.walkRules((rule)=>{\n        // Ignore rules generated by Tailwind\n        for (let node of pathToRoot(rule)){\n            var _node_raws_tailwind;\n            if (((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.layer) !== undefined) {\n                return;\n            }\n        }\n        // Clone what's required to represent this singular rule in the tree\n        let container = nestedClone(rule);\n        let sort = context.offsets.create(\"user\");\n        for (let className of extractClasses(rule)){\n            let list = cache.get(className) || [];\n            cache.set(className, list);\n            list.push([\n                {\n                    layer: \"user\",\n                    sort,\n                    important: false\n                },\n                container\n            ]);\n        }\n    });\n    return cache;\n}\n/**\n * @returns {ApplyCache}\n */ function buildApplyCache(applyCandidates, context) {\n    for (let candidate of applyCandidates){\n        if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {\n            continue;\n        }\n        if (context.classCache.has(candidate)) {\n            context.applyClassCache.set(candidate, context.classCache.get(candidate).map(([meta, rule])=>[\n                    meta,\n                    rule.clone()\n                ]));\n            continue;\n        }\n        let matches = Array.from((0, _generateRules.resolveMatches)(candidate, context));\n        if (matches.length === 0) {\n            context.notClassCache.add(candidate);\n            continue;\n        }\n        context.applyClassCache.set(candidate, matches);\n    }\n    return context.applyClassCache;\n}\n/**\n * Build a cache only when it's first used\n *\n * @param {() => ApplyCache} buildCacheFn\n * @returns {ApplyCache}\n */ function lazyCache(buildCacheFn) {\n    let cache = null;\n    return {\n        get: (name)=>{\n            cache = cache || buildCacheFn();\n            return cache.get(name);\n        },\n        has: (name)=>{\n            cache = cache || buildCacheFn();\n            return cache.has(name);\n        }\n    };\n}\n/**\n * Take a series of multiple caches and merge\n * them so they act like one large cache\n *\n * @param {ApplyCache[]} caches\n * @returns {ApplyCache}\n */ function combineCaches(caches) {\n    return {\n        get: (name)=>caches.flatMap((cache)=>cache.get(name) || []),\n        has: (name)=>caches.some((cache)=>cache.has(name))\n    };\n}\nfunction extractApplyCandidates(params) {\n    let candidates = params.split(/[\\s\\t\\n]+/g);\n    if (candidates[candidates.length - 1] === \"!important\") {\n        return [\n            candidates.slice(0, -1),\n            true\n        ];\n    }\n    return [\n        candidates,\n        false\n    ];\n}\nfunction processApply(root, context, localCache) {\n    let applyCandidates = new Set();\n    // Collect all @apply rules and candidates\n    let applies = [];\n    root.walkAtRules(\"apply\", (rule)=>{\n        let [candidates] = extractApplyCandidates(rule.params);\n        for (let util of candidates){\n            applyCandidates.add(util);\n        }\n        applies.push(rule);\n    });\n    // Start the @apply process if we have rules with @apply in them\n    if (applies.length === 0) {\n        return;\n    }\n    // Fill up some caches!\n    let applyClassCache = combineCaches([\n        localCache,\n        buildApplyCache(applyCandidates, context)\n    ]);\n    /**\n   * When we have an apply like this:\n   *\n   * .abc {\n   *    @apply hover:font-bold;\n   * }\n   *\n   * What we essentially will do is resolve to this:\n   *\n   * .abc {\n   *    @apply .hover\\:font-bold:hover {\n   *      font-weight: 500;\n   *    }\n   * }\n   *\n   * Notice that the to-be-applied class is `.hover\\:font-bold:hover` and that the utility candidate was `hover:font-bold`.\n   * What happens in this function is that we prepend a `.` and escape the candidate.\n   * This will result in `.hover\\:font-bold`\n   * Which means that we can replace `.hover\\:font-bold` with `.abc` in `.hover\\:font-bold:hover` resulting in `.abc:hover`\n   *\n   * @param {string} selector\n   * @param {string} utilitySelectors\n   * @param {string} candidate\n   */ function replaceSelector(selector, utilitySelectors, candidate) {\n        let selectorList = extractSelectors(selector);\n        let utilitySelectorsList = extractSelectors(utilitySelectors);\n        let candidateList = extractSelectors(`.${(0, _escapeClassName.default)(candidate)}`);\n        let candidateClass = candidateList.nodes[0].nodes[0];\n        selectorList.each((sel)=>{\n            /** @type {Set<import('postcss-selector-parser').Selector>} */ let replaced = new Set();\n            utilitySelectorsList.each((utilitySelector)=>{\n                let hasReplaced = false;\n                utilitySelector = utilitySelector.clone();\n                utilitySelector.walkClasses((node)=>{\n                    if (node.value !== candidateClass.value) {\n                        return;\n                    }\n                    // Don't replace multiple instances of the same class\n                    // This is theoretically correct but only partially\n                    // We'd need to generate every possible permutation of the replacement\n                    // For example with `.foo + .foo { … }` and `section { @apply foo; }`\n                    // We'd need to generate all of these:\n                    // - `.foo + .foo`\n                    // - `.foo + section`\n                    // - `section + .foo`\n                    // - `section + section`\n                    if (hasReplaced) {\n                        return;\n                    }\n                    // Since you can only `@apply` class names this is sufficient\n                    // We want to replace the matched class name with the selector the user is using\n                    // Ex: Replace `.text-blue-500` with `.foo.bar:is(.something-cool)`\n                    node.replaceWith(...sel.nodes.map((node)=>node.clone()));\n                    // Record that we did something and we want to use this new selector\n                    replaced.add(utilitySelector);\n                    hasReplaced = true;\n                });\n            });\n            // Sort tag names before class names (but only sort each group (separated by a combinator)\n            // separately and not in total)\n            // This happens when replacing `.bar` in `.foo.bar` with a tag like `section`\n            for (let sel of replaced){\n                let groups = [\n                    []\n                ];\n                for (let node of sel.nodes){\n                    if (node.type === \"combinator\") {\n                        groups.push(node);\n                        groups.push([]);\n                    } else {\n                        let last = groups[groups.length - 1];\n                        last.push(node);\n                    }\n                }\n                sel.nodes = [];\n                for (let group of groups){\n                    if (Array.isArray(group)) {\n                        group.sort((a, b)=>{\n                            if (a.type === \"tag\" && b.type === \"class\") {\n                                return -1;\n                            } else if (a.type === \"class\" && b.type === \"tag\") {\n                                return 1;\n                            } else if (a.type === \"class\" && b.type === \"pseudo\" && b.value.startsWith(\"::\")) {\n                                return -1;\n                            } else if (a.type === \"pseudo\" && a.value.startsWith(\"::\") && b.type === \"class\") {\n                                return 1;\n                            }\n                            return 0;\n                        });\n                    }\n                    sel.nodes = sel.nodes.concat(group);\n                }\n            }\n            sel.replaceWith(...replaced);\n        });\n        return selectorList.toString();\n    }\n    let perParentApplies = new Map();\n    // Collect all apply candidates and their rules\n    for (let apply of applies){\n        let [candidates] = perParentApplies.get(apply.parent) || [\n            [],\n            apply.source\n        ];\n        perParentApplies.set(apply.parent, [\n            candidates,\n            apply.source\n        ]);\n        let [applyCandidates, important] = extractApplyCandidates(apply.params);\n        if (apply.parent.type === \"atrule\") {\n            if (apply.parent.name === \"screen\") {\n                let screenType = apply.parent.params;\n                throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates.map((c)=>`${screenType}:${c}`).join(\" \")} instead.`);\n            }\n            throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);\n        }\n        for (let applyCandidate of applyCandidates){\n            if ([\n                prefix(context, \"group\"),\n                prefix(context, \"peer\")\n            ].includes(applyCandidate)) {\n                // TODO: Link to specific documentation page with error code.\n                throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);\n            }\n            if (!applyClassCache.has(applyCandidate)) {\n                throw apply.error(`The \\`${applyCandidate}\\` class does not exist. If \\`${applyCandidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`);\n            }\n            let rules = applyClassCache.get(applyCandidate);\n            candidates.push([\n                applyCandidate,\n                important,\n                rules\n            ]);\n        }\n    }\n    for (let [parent, [candidates, atApplySource]] of perParentApplies){\n        let siblings = [];\n        for (let [applyCandidate, important, rules] of candidates){\n            let potentialApplyCandidates = [\n                applyCandidate,\n                ...extractBaseCandidates([\n                    applyCandidate\n                ], context.tailwindConfig.separator)\n            ];\n            for (let [meta, node] of rules){\n                let parentClasses = extractClasses(parent);\n                let nodeClasses = extractClasses(node);\n                // When we encounter a rule like `.dark .a, .b { … }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`\n                // So we've split them into groups\n                nodeClasses = nodeClasses.groups.filter((classList)=>classList.some((className)=>potentialApplyCandidates.includes(className))).flat();\n                // Add base utility classes from the @apply node to the list of\n                // classes to check whether it intersects and therefore results in a\n                // circular dependency or not.\n                //\n                // E.g.:\n                // .foo {\n                //   @apply hover:a; // This applies \"a\" but with a modifier\n                // }\n                //\n                // We only have to do that with base classes of the `node`, not of the `parent`\n                // E.g.:\n                // .hover\\:foo {\n                //   @apply bar;\n                // }\n                // .bar {\n                //   @apply foo;\n                // }\n                //\n                // This should not result in a circular dependency because we are\n                // just applying `.foo` and the rule above is `.hover\\:foo` which is\n                // unrelated. However, if we were to apply `hover:foo` then we _did_\n                // have to include this one.\n                nodeClasses = nodeClasses.concat(extractBaseCandidates(nodeClasses, context.tailwindConfig.separator));\n                let intersects = parentClasses.some((selector)=>nodeClasses.includes(selector));\n                if (intersects) {\n                    throw node.error(`You cannot \\`@apply\\` the \\`${applyCandidate}\\` utility here because it creates a circular dependency.`);\n                }\n                let root = _postcss.default.root({\n                    nodes: [\n                        node.clone()\n                    ]\n                });\n                // Make sure every node in the entire tree points back at the @apply rule that generated it\n                root.walk((node)=>{\n                    node.source = atApplySource;\n                });\n                let canRewriteSelector = node.type !== \"atrule\" || node.type === \"atrule\" && node.name !== \"keyframes\";\n                if (canRewriteSelector) {\n                    root.walkRules((rule)=>{\n                        // Let's imagine you have the following structure:\n                        //\n                        // .foo {\n                        //   @apply bar;\n                        // }\n                        //\n                        // @supports (a: b) {\n                        //   .bar {\n                        //     color: blue\n                        //   }\n                        //\n                        //   .something-unrelated {}\n                        // }\n                        //\n                        // In this case we want to apply `.bar` but it happens to be in\n                        // an atrule node. We clone that node instead of the nested one\n                        // because we still want that @supports rule to be there once we\n                        // applied everything.\n                        //\n                        // However it happens to be that the `.something-unrelated` is\n                        // also in that same shared @supports atrule. This is not good,\n                        // and this should not be there. The good part is that this is\n                        // a clone already and it can be safely removed. The question is\n                        // how do we know we can remove it. Basically what we can do is\n                        // match it against the applyCandidate that you want to apply. If\n                        // it doesn't match the we can safely delete it.\n                        //\n                        // If we didn't do this, then the `replaceSelector` function\n                        // would have replaced this with something that didn't exist and\n                        // therefore it removed the selector altogether. In this specific\n                        // case it would result in `{}` instead of `.something-unrelated {}`\n                        if (!extractClasses(rule).some((candidate)=>candidate === applyCandidate)) {\n                            rule.remove();\n                            return;\n                        }\n                        // Strip the important selector from the parent selector if at the beginning\n                        let importantSelector = typeof context.tailwindConfig.important === \"string\" ? context.tailwindConfig.important : null;\n                        // We only want to move the \"important\" selector if this is a Tailwind-generated utility\n                        // We do *not* want to do this for user CSS that happens to be structured the same\n                        let isGenerated = parent.raws.tailwind !== undefined;\n                        let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;\n                        rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate);\n                        // And then re-add it if it was removed\n                        if (importantSelector && parentSelector !== parent.selector) {\n                            rule.selector = (0, _applyImportantSelector.applyImportantSelector)(rule.selector, importantSelector);\n                        }\n                        rule.walkDecls((d)=>{\n                            d.important = meta.important || important;\n                        });\n                        // Move pseudo elements to the end of the selector (if necessary)\n                        let selector = (0, _postcssselectorparser.default)().astSync(rule.selector);\n                        selector.each((sel)=>(0, _pseudoElements.movePseudos)(sel));\n                        rule.selector = selector.toString();\n                    });\n                }\n                // It could be that the node we were inserted was removed because the class didn't match\n                // If that was the *only* rule in the parent, then we have nothing add so we skip it\n                if (!root.nodes[0]) {\n                    continue;\n                }\n                // Insert it\n                siblings.push([\n                    meta.sort,\n                    root.nodes[0]\n                ]);\n            }\n        }\n        // Inject the rules, sorted, correctly\n        let nodes = context.offsets.sort(siblings).map((s)=>s[1]);\n        // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }\n        parent.after(nodes);\n    }\n    for (let apply of applies){\n        // If there are left-over declarations, just remove the @apply\n        if (apply.parent.nodes.length > 1) {\n            apply.remove();\n        } else {\n            // The node is empty, drop the full node\n            apply.parent.remove();\n        }\n    }\n    // Do it again, in case we have other `@apply` rules\n    processApply(root, context, localCache);\n}\nfunction expandApplyAtRules(context) {\n    return (root)=>{\n        // Build a cache of the user's CSS so we can use it to resolve classes used by @apply\n        let localCache = lazyCache(()=>buildLocalApplyCache(root, context));\n        processApply(root, context, localCache);\n    };\n}\n"]}}