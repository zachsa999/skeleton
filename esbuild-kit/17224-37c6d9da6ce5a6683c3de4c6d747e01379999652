{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _keywords=require(\"../parser/tokenizer/keywords\");var _types=require(\"../parser/tokenizer/types\");function getClassInfo(rootTransformer,tokens,nameManager,disableESTransforms){const snapshot=tokens.snapshot();const headerInfo=processClassHeader(tokens);let constructorInitializerStatements=[];const instanceInitializerNames=[];const staticInitializerNames=[];let constructorInsertPos=null;const fields=[];const rangesToRemove=[];const classContextId=tokens.currentToken().contextId;if(classContextId==null){throw new Error(\"Expected non-null class context ID on class open-brace.\")}tokens.nextToken();while(!tokens.matchesContextIdAndLabel(_types.TokenType.braceR,classContextId)){if(tokens.matchesContextual(_keywords.ContextualKeyword._constructor)&&!tokens.currentToken().isType){({constructorInitializerStatements,constructorInsertPos}=processConstructor(tokens))}else if(tokens.matches1(_types.TokenType.semi)){if(!disableESTransforms){rangesToRemove.push({start:tokens.currentIndex(),end:tokens.currentIndex()+1})}tokens.nextToken()}else if(tokens.currentToken().isType){tokens.nextToken()}else{const statementStartIndex=tokens.currentIndex();let isStatic=false;let isESPrivate=false;let isDeclareOrAbstract=false;while(isAccessModifier(tokens.currentToken())){if(tokens.matches1(_types.TokenType._static)){isStatic=true}if(tokens.matches1(_types.TokenType.hash)){isESPrivate=true}if(tokens.matches1(_types.TokenType._declare)||tokens.matches1(_types.TokenType._abstract)){isDeclareOrAbstract=true}tokens.nextToken()}if(isStatic&&tokens.matches1(_types.TokenType.braceL)){skipToNextClassElement(tokens,classContextId);continue}if(isESPrivate){skipToNextClassElement(tokens,classContextId);continue}if(tokens.matchesContextual(_keywords.ContextualKeyword._constructor)&&!tokens.currentToken().isType){({constructorInitializerStatements,constructorInsertPos}=processConstructor(tokens));continue}const nameStartIndex=tokens.currentIndex();skipFieldName(tokens);if(tokens.matches1(_types.TokenType.lessThan)||tokens.matches1(_types.TokenType.parenL)){skipToNextClassElement(tokens,classContextId);continue}while(tokens.currentToken().isType){tokens.nextToken()}if(tokens.matches1(_types.TokenType.eq)){const equalsIndex=tokens.currentIndex();const valueEnd=tokens.currentToken().rhsEndIndex;if(valueEnd==null){throw new Error(\"Expected rhsEndIndex on class field assignment.\")}tokens.nextToken();while(tokens.currentIndex()<valueEnd){rootTransformer.processToken()}let initializerName;if(isStatic){initializerName=nameManager.claimFreeName(\"__initStatic\");staticInitializerNames.push(initializerName)}else{initializerName=nameManager.claimFreeName(\"__init\");instanceInitializerNames.push(initializerName)}fields.push({initializerName,equalsIndex,start:nameStartIndex,end:tokens.currentIndex()})}else if(!disableESTransforms||isDeclareOrAbstract){rangesToRemove.push({start:statementStartIndex,end:tokens.currentIndex()})}}}tokens.restoreToSnapshot(snapshot);if(disableESTransforms){return{headerInfo,constructorInitializerStatements,instanceInitializerNames:[],staticInitializerNames:[],constructorInsertPos,fields:[],rangesToRemove}}else{return{headerInfo,constructorInitializerStatements,instanceInitializerNames,staticInitializerNames,constructorInsertPos,fields,rangesToRemove}}}__name(getClassInfo,\"getClassInfo\");exports.default=getClassInfo;function skipToNextClassElement(tokens,classContextId){tokens.nextToken();while(tokens.currentToken().contextId!==classContextId){tokens.nextToken()}while(isAccessModifier(tokens.tokenAtRelativeIndex(-1))){tokens.previousToken()}}__name(skipToNextClassElement,\"skipToNextClassElement\");function processClassHeader(tokens){const classToken=tokens.currentToken();const contextId=classToken.contextId;if(contextId==null){throw new Error(\"Expected context ID on class token.\")}const isExpression=classToken.isExpression;if(isExpression==null){throw new Error(\"Expected isExpression on class token.\")}let className=null;let hasSuperclass=false;tokens.nextToken();if(tokens.matches1(_types.TokenType.name)){className=tokens.identifierName()}while(!tokens.matchesContextIdAndLabel(_types.TokenType.braceL,contextId)){if(tokens.matches1(_types.TokenType._extends)&&!tokens.currentToken().isType){hasSuperclass=true}tokens.nextToken()}return{isExpression,className,hasSuperclass}}__name(processClassHeader,\"processClassHeader\");function processConstructor(tokens){const constructorInitializerStatements=[];tokens.nextToken();const constructorContextId=tokens.currentToken().contextId;if(constructorContextId==null){throw new Error(\"Expected context ID on open-paren starting constructor params.\")}while(!tokens.matchesContextIdAndLabel(_types.TokenType.parenR,constructorContextId)){if(tokens.currentToken().contextId===constructorContextId){tokens.nextToken();if(isAccessModifier(tokens.currentToken())){tokens.nextToken();while(isAccessModifier(tokens.currentToken())){tokens.nextToken()}const token=tokens.currentToken();if(token.type!==_types.TokenType.name){throw new Error(\"Expected identifier after access modifiers in constructor arg.\")}const name=tokens.identifierNameForToken(token);constructorInitializerStatements.push(`this.${name} = ${name}`)}}else{tokens.nextToken()}}tokens.nextToken();let constructorInsertPos=tokens.currentIndex();let foundSuperCall=false;while(!tokens.matchesContextIdAndLabel(_types.TokenType.braceR,constructorContextId)){if(!foundSuperCall&&tokens.matches2(_types.TokenType._super,_types.TokenType.parenL)){tokens.nextToken();const superCallContextId=tokens.currentToken().contextId;if(superCallContextId==null){throw new Error(\"Expected a context ID on the super call\")}while(!tokens.matchesContextIdAndLabel(_types.TokenType.parenR,superCallContextId)){tokens.nextToken()}constructorInsertPos=tokens.currentIndex();foundSuperCall=true}tokens.nextToken()}tokens.nextToken();return{constructorInitializerStatements,constructorInsertPos}}__name(processConstructor,\"processConstructor\");function isAccessModifier(token){return[_types.TokenType._async,_types.TokenType._get,_types.TokenType._set,_types.TokenType.plus,_types.TokenType.minus,_types.TokenType._readonly,_types.TokenType._static,_types.TokenType._public,_types.TokenType._private,_types.TokenType._protected,_types.TokenType._override,_types.TokenType._abstract,_types.TokenType.star,_types.TokenType._declare,_types.TokenType.hash].includes(token.type)}__name(isAccessModifier,\"isAccessModifier\");function skipFieldName(tokens){if(tokens.matches1(_types.TokenType.bracketL)){const startToken=tokens.currentToken();const classContextId=startToken.contextId;if(classContextId==null){throw new Error(\"Expected class context ID on computed name open bracket.\")}while(!tokens.matchesContextIdAndLabel(_types.TokenType.bracketR,classContextId)){tokens.nextToken()}tokens.nextToken()}else{tokens.nextToken()}}__name(skipFieldName,\"skipFieldName\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/util/getClassInfo.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});\n\nvar _keywords = require('../parser/tokenizer/keywords');\nvar _types = require('../parser/tokenizer/types');\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Get information about the class fields for this class, given a token processor pointing to the\n * open-brace at the start of the class.\n */\n function getClassInfo(\n  rootTransformer,\n  tokens,\n  nameManager,\n  disableESTransforms,\n) {\n  const snapshot = tokens.snapshot();\n\n  const headerInfo = processClassHeader(tokens);\n\n  let constructorInitializerStatements = [];\n  const instanceInitializerNames = [];\n  const staticInitializerNames = [];\n  let constructorInsertPos = null;\n  const fields = [];\n  const rangesToRemove = [];\n\n  const classContextId = tokens.currentToken().contextId;\n  if (classContextId == null) {\n    throw new Error(\"Expected non-null class context ID on class open-brace.\");\n  }\n\n  tokens.nextToken();\n  while (!tokens.matchesContextIdAndLabel(_types.TokenType.braceR, classContextId)) {\n    if (tokens.matchesContextual(_keywords.ContextualKeyword._constructor) && !tokens.currentToken().isType) {\n      ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));\n    } else if (tokens.matches1(_types.TokenType.semi)) {\n      if (!disableESTransforms) {\n        rangesToRemove.push({start: tokens.currentIndex(), end: tokens.currentIndex() + 1});\n      }\n      tokens.nextToken();\n    } else if (tokens.currentToken().isType) {\n      tokens.nextToken();\n    } else {\n      // Either a method or a field. Skip to the identifier part.\n      const statementStartIndex = tokens.currentIndex();\n      let isStatic = false;\n      let isESPrivate = false;\n      let isDeclareOrAbstract = false;\n      while (isAccessModifier(tokens.currentToken())) {\n        if (tokens.matches1(_types.TokenType._static)) {\n          isStatic = true;\n        }\n        if (tokens.matches1(_types.TokenType.hash)) {\n          isESPrivate = true;\n        }\n        if (tokens.matches1(_types.TokenType._declare) || tokens.matches1(_types.TokenType._abstract)) {\n          isDeclareOrAbstract = true;\n        }\n        tokens.nextToken();\n      }\n      if (isStatic && tokens.matches1(_types.TokenType.braceL)) {\n        // This is a static block, so don't process it in any special way.\n        skipToNextClassElement(tokens, classContextId);\n        continue;\n      }\n      if (isESPrivate) {\n        // Sucrase doesn't attempt to transpile private fields; just leave them as-is.\n        skipToNextClassElement(tokens, classContextId);\n        continue;\n      }\n      if (\n        tokens.matchesContextual(_keywords.ContextualKeyword._constructor) &&\n        !tokens.currentToken().isType\n      ) {\n        ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));\n        continue;\n      }\n\n      const nameStartIndex = tokens.currentIndex();\n      skipFieldName(tokens);\n      if (tokens.matches1(_types.TokenType.lessThan) || tokens.matches1(_types.TokenType.parenL)) {\n        // This is a method, so nothing to process.\n        skipToNextClassElement(tokens, classContextId);\n        continue;\n      }\n      // There might be a type annotation that we need to skip.\n      while (tokens.currentToken().isType) {\n        tokens.nextToken();\n      }\n      if (tokens.matches1(_types.TokenType.eq)) {\n        const equalsIndex = tokens.currentIndex();\n        // This is an initializer, so we need to wrap in an initializer method.\n        const valueEnd = tokens.currentToken().rhsEndIndex;\n        if (valueEnd == null) {\n          throw new Error(\"Expected rhsEndIndex on class field assignment.\");\n        }\n        tokens.nextToken();\n        while (tokens.currentIndex() < valueEnd) {\n          rootTransformer.processToken();\n        }\n        let initializerName;\n        if (isStatic) {\n          initializerName = nameManager.claimFreeName(\"__initStatic\");\n          staticInitializerNames.push(initializerName);\n        } else {\n          initializerName = nameManager.claimFreeName(\"__init\");\n          instanceInitializerNames.push(initializerName);\n        }\n        // Fields start at the name, so `static x = 1;` has a field range of `x = 1;`.\n        fields.push({\n          initializerName,\n          equalsIndex,\n          start: nameStartIndex,\n          end: tokens.currentIndex(),\n        });\n      } else if (!disableESTransforms || isDeclareOrAbstract) {\n        // This is a regular field declaration, like `x;`. With the class transform enabled, we just\n        // remove the line so that no output is produced. With the class transform disabled, we\n        // usually want to preserve the declaration (but still strip types), but if the `declare`\n        // or `abstract` keyword is specified, we should remove the line to avoid initializing the\n        // value to undefined.\n        rangesToRemove.push({start: statementStartIndex, end: tokens.currentIndex()});\n      }\n    }\n  }\n\n  tokens.restoreToSnapshot(snapshot);\n  if (disableESTransforms) {\n    // With ES transforms disabled, we don't want to transform regular class\n    // field declarations, and we don't need to do any additional tricks to\n    // reference the constructor for static init, but we still need to transform\n    // TypeScript field initializers defined as constructor parameters and we\n    // still need to remove `declare` fields. For now, we run the same code\n    // path but omit any field information, as if the class had no field\n    // declarations. In the future, when we fully drop the class fields\n    // transform, we can simplify this code significantly.\n    return {\n      headerInfo,\n      constructorInitializerStatements,\n      instanceInitializerNames: [],\n      staticInitializerNames: [],\n      constructorInsertPos,\n      fields: [],\n      rangesToRemove,\n    };\n  } else {\n    return {\n      headerInfo,\n      constructorInitializerStatements,\n      instanceInitializerNames,\n      staticInitializerNames,\n      constructorInsertPos,\n      fields,\n      rangesToRemove,\n    };\n  }\n} exports.default = getClassInfo;\n\n/**\n * Move the token processor to the next method/field in the class.\n *\n * To do that, we seek forward to the next start of a class name (either an open\n * bracket or an identifier, or the closing curly brace), then seek backward to\n * include any access modifiers.\n */\nfunction skipToNextClassElement(tokens, classContextId) {\n  tokens.nextToken();\n  while (tokens.currentToken().contextId !== classContextId) {\n    tokens.nextToken();\n  }\n  while (isAccessModifier(tokens.tokenAtRelativeIndex(-1))) {\n    tokens.previousToken();\n  }\n}\n\nfunction processClassHeader(tokens) {\n  const classToken = tokens.currentToken();\n  const contextId = classToken.contextId;\n  if (contextId == null) {\n    throw new Error(\"Expected context ID on class token.\");\n  }\n  const isExpression = classToken.isExpression;\n  if (isExpression == null) {\n    throw new Error(\"Expected isExpression on class token.\");\n  }\n  let className = null;\n  let hasSuperclass = false;\n  tokens.nextToken();\n  if (tokens.matches1(_types.TokenType.name)) {\n    className = tokens.identifierName();\n  }\n  while (!tokens.matchesContextIdAndLabel(_types.TokenType.braceL, contextId)) {\n    // If this has a superclass, there will always be an `extends` token. If it doesn't have a\n    // superclass, only type parameters and `implements` clauses can show up here, all of which\n    // consist only of type tokens. A declaration like `class A<B extends C> {` should *not* count\n    // as having a superclass.\n    if (tokens.matches1(_types.TokenType._extends) && !tokens.currentToken().isType) {\n      hasSuperclass = true;\n    }\n    tokens.nextToken();\n  }\n  return {isExpression, className, hasSuperclass};\n}\n\n/**\n * Extract useful information out of a constructor, starting at the \"constructor\" name.\n */\nfunction processConstructor(tokens)\n\n\n {\n  const constructorInitializerStatements = [];\n\n  tokens.nextToken();\n  const constructorContextId = tokens.currentToken().contextId;\n  if (constructorContextId == null) {\n    throw new Error(\"Expected context ID on open-paren starting constructor params.\");\n  }\n  // Advance through parameters looking for access modifiers.\n  while (!tokens.matchesContextIdAndLabel(_types.TokenType.parenR, constructorContextId)) {\n    if (tokens.currentToken().contextId === constructorContextId) {\n      // Current token is an open paren or comma just before a param, so check\n      // that param for access modifiers.\n      tokens.nextToken();\n      if (isAccessModifier(tokens.currentToken())) {\n        tokens.nextToken();\n        while (isAccessModifier(tokens.currentToken())) {\n          tokens.nextToken();\n        }\n        const token = tokens.currentToken();\n        if (token.type !== _types.TokenType.name) {\n          throw new Error(\"Expected identifier after access modifiers in constructor arg.\");\n        }\n        const name = tokens.identifierNameForToken(token);\n        constructorInitializerStatements.push(`this.${name} = ${name}`);\n      }\n    } else {\n      tokens.nextToken();\n    }\n  }\n  // )\n  tokens.nextToken();\n  let constructorInsertPos = tokens.currentIndex();\n\n  // Advance through body looking for a super call.\n  let foundSuperCall = false;\n  while (!tokens.matchesContextIdAndLabel(_types.TokenType.braceR, constructorContextId)) {\n    if (!foundSuperCall && tokens.matches2(_types.TokenType._super, _types.TokenType.parenL)) {\n      tokens.nextToken();\n      const superCallContextId = tokens.currentToken().contextId;\n      if (superCallContextId == null) {\n        throw new Error(\"Expected a context ID on the super call\");\n      }\n      while (!tokens.matchesContextIdAndLabel(_types.TokenType.parenR, superCallContextId)) {\n        tokens.nextToken();\n      }\n      constructorInsertPos = tokens.currentIndex();\n      foundSuperCall = true;\n    }\n    tokens.nextToken();\n  }\n  // }\n  tokens.nextToken();\n\n  return {constructorInitializerStatements, constructorInsertPos};\n}\n\n/**\n * Determine if this is any token that can go before the name in a method/field.\n */\nfunction isAccessModifier(token) {\n  return [\n    _types.TokenType._async,\n    _types.TokenType._get,\n    _types.TokenType._set,\n    _types.TokenType.plus,\n    _types.TokenType.minus,\n    _types.TokenType._readonly,\n    _types.TokenType._static,\n    _types.TokenType._public,\n    _types.TokenType._private,\n    _types.TokenType._protected,\n    _types.TokenType._override,\n    _types.TokenType._abstract,\n    _types.TokenType.star,\n    _types.TokenType._declare,\n    _types.TokenType.hash,\n  ].includes(token.type);\n}\n\n/**\n * The next token or set of tokens is either an identifier or an expression in square brackets, for\n * a method or field name.\n */\nfunction skipFieldName(tokens) {\n  if (tokens.matches1(_types.TokenType.bracketL)) {\n    const startToken = tokens.currentToken();\n    const classContextId = startToken.contextId;\n    if (classContextId == null) {\n      throw new Error(\"Expected class context ID on computed name open bracket.\");\n    }\n    while (!tokens.matchesContextIdAndLabel(_types.TokenType.bracketR, classContextId)) {\n      tokens.nextToken();\n    }\n    tokens.nextToken();\n  } else {\n    tokens.nextToken();\n  }\n}\n"]}}