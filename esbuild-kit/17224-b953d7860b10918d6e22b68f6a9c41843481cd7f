{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});Object.defineProperty(exports,\"default\",{enumerable:true,get:function(){return collapseDuplicateDeclarations}});function collapseDuplicateDeclarations(){return root=>{root.walkRules(node=>{let seen=new Map;let droppable=new Set([]);let byProperty=new Map;node.walkDecls(decl=>{if(decl.parent!==node){return}if(seen.has(decl.prop)){if(seen.get(decl.prop).value===decl.value){droppable.add(seen.get(decl.prop));seen.set(decl.prop,decl);return}if(!byProperty.has(decl.prop)){byProperty.set(decl.prop,new Set)}byProperty.get(decl.prop).add(seen.get(decl.prop));byProperty.get(decl.prop).add(decl)}seen.set(decl.prop,decl)});for(let decl of droppable){decl.remove()}for(let declarations of byProperty.values()){let byUnit=new Map;for(let decl of declarations){let unit=resolveUnit(decl.value);if(unit===null){continue}if(!byUnit.has(unit)){byUnit.set(unit,new Set)}byUnit.get(unit).add(decl)}for(let declarations2 of byUnit.values()){let removableDeclarations=Array.from(declarations2).slice(0,-1);for(let decl of removableDeclarations){decl.remove()}}}})}}__name(collapseDuplicateDeclarations,\"collapseDuplicateDeclarations\");let UNITLESS_NUMBER=Symbol(\"unitless-number\");function resolveUnit(input){let result=/^-?\\d*.?\\d+([\\w%]+)?$/g.exec(input);if(result){var _result_;return(_result_=result[1])!==null&&_result_!==void 0?_result_:UNITLESS_NUMBER}return null}__name(resolveUnit,\"resolveUnit\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CACzC,MAAO,IACX,CAAC,EACD,OAAO,eAAe,QAAS,UAAW,CACtC,WAAY,KACZ,IAAK,UAAW,CACZ,OAAO,6BACX,CACJ,CAAC,EACD,SAAS,+BAAgC,CACrC,OAAQ,MAAO,CACX,KAAK,UAAW,MAAO,CACnB,IAAI,KAAO,IAAI,IACf,IAAI,UAAY,IAAI,IAAI,CAAC,CAAC,EAC1B,IAAI,WAAa,IAAI,IACrB,KAAK,UAAW,MAAO,CAKnB,GAAI,KAAK,SAAW,KAAM,CACtB,MACJ,CACA,GAAI,KAAK,IAAI,KAAK,IAAI,EAAG,CAErB,GAAI,KAAK,IAAI,KAAK,IAAI,EAAE,QAAU,KAAK,MAAO,CAE1C,UAAU,IAAI,KAAK,IAAI,KAAK,IAAI,CAAC,EAKjC,KAAK,IAAI,KAAK,KAAM,IAAI,EACxB,MACJ,CAGA,GAAI,CAAC,WAAW,IAAI,KAAK,IAAI,EAAG,CAC5B,WAAW,IAAI,KAAK,KAAM,IAAI,GAAK,CACvC,CACA,WAAW,IAAI,KAAK,IAAI,EAAE,IAAI,KAAK,IAAI,KAAK,IAAI,CAAC,EACjD,WAAW,IAAI,KAAK,IAAI,EAAE,IAAI,IAAI,CACtC,CACA,KAAK,IAAI,KAAK,KAAM,IAAI,CAC5B,CAAC,EAGD,QAAS,QAAQ,UAAU,CACvB,KAAK,OAAO,CAChB,CAGA,QAAS,gBAAgB,WAAW,OAAO,EAAE,CACzC,IAAI,OAAS,IAAI,IACjB,QAAS,QAAQ,aAAa,CAC1B,IAAI,KAAO,YAAY,KAAK,KAAK,EACjC,GAAI,OAAS,KAAM,CACf,QACJ,CACA,GAAI,CAAC,OAAO,IAAI,IAAI,EAAG,CACnB,OAAO,IAAI,KAAM,IAAI,GAAK,CAC9B,CACA,OAAO,IAAI,IAAI,EAAE,IAAI,IAAI,CAC7B,CACA,QAASA,iBAAgB,OAAO,OAAO,EAAE,CAErC,IAAI,sBAAwB,MAAM,KAAKA,aAAY,EAAE,MAAM,EAAG,EAAE,EAChE,QAAS,QAAQ,sBAAsB,CACnC,KAAK,OAAO,CAChB,CACJ,CACJ,CACJ,CAAC,CACL,CACJ,CAjES,sEAkET,IAAI,gBAAkB,OAAO,iBAAiB,EAC9C,SAAS,YAAY,MAAO,CACxB,IAAI,OAAS,yBAAyB,KAAK,KAAK,EAChD,GAAI,OAAQ,CACR,IAAI,SACJ,OAAQ,SAAW,OAAO,CAAC,KAAO,MAAQ,WAAa,OAAS,SAAW,eAC/E,CACA,OAAO,IACX,CAPS","names":["declarations"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/lib/collapseDuplicateDeclarations.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return collapseDuplicateDeclarations;\n    }\n});\nfunction collapseDuplicateDeclarations() {\n    return (root)=>{\n        root.walkRules((node)=>{\n            let seen = new Map();\n            let droppable = new Set([]);\n            let byProperty = new Map();\n            node.walkDecls((decl)=>{\n                // This could happen if we have nested selectors. In that case the\n                // parent will loop over all its declarations but also the declarations\n                // of nested rules. With this we ensure that we are shallowly checking\n                // declarations.\n                if (decl.parent !== node) {\n                    return;\n                }\n                if (seen.has(decl.prop)) {\n                    // Exact same value as what we have seen so far\n                    if (seen.get(decl.prop).value === decl.value) {\n                        // Keep the last one, drop the one we've seen so far\n                        droppable.add(seen.get(decl.prop));\n                        // Override the existing one with the new value. This is necessary\n                        // so that if we happen to have more than one declaration with the\n                        // same value, that we keep removing the previous one. Otherwise we\n                        // will only remove the *first* one.\n                        seen.set(decl.prop, decl);\n                        return;\n                    }\n                    // Not the same value, so we need to check if we can merge it so\n                    // let's collect it first.\n                    if (!byProperty.has(decl.prop)) {\n                        byProperty.set(decl.prop, new Set());\n                    }\n                    byProperty.get(decl.prop).add(seen.get(decl.prop));\n                    byProperty.get(decl.prop).add(decl);\n                }\n                seen.set(decl.prop, decl);\n            });\n            // Drop all the duplicate declarations with the exact same value we've\n            // already seen so far.\n            for (let decl of droppable){\n                decl.remove();\n            }\n            // Analyze the declarations based on its unit, drop all the declarations\n            // with the same unit but the last one in the list.\n            for (let declarations of byProperty.values()){\n                let byUnit = new Map();\n                for (let decl of declarations){\n                    let unit = resolveUnit(decl.value);\n                    if (unit === null) {\n                        continue;\n                    }\n                    if (!byUnit.has(unit)) {\n                        byUnit.set(unit, new Set());\n                    }\n                    byUnit.get(unit).add(decl);\n                }\n                for (let declarations of byUnit.values()){\n                    // Get all but the last one\n                    let removableDeclarations = Array.from(declarations).slice(0, -1);\n                    for (let decl of removableDeclarations){\n                        decl.remove();\n                    }\n                }\n            }\n        });\n    };\n}\nlet UNITLESS_NUMBER = Symbol(\"unitless-number\");\nfunction resolveUnit(input) {\n    let result = /^-?\\d*.?\\d+([\\w%]+)?$/g.exec(input);\n    if (result) {\n        var _result_;\n        return (_result_ = result[1]) !== null && _result_ !== void 0 ? _result_ : UNITLESS_NUMBER;\n    }\n    return null;\n}\n"]}}