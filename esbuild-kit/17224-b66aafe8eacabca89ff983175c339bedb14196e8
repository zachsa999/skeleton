{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});exports.__esModule=true;exports.FIELDS=void 0;exports[\"default\"]=tokenize;var t=_interopRequireWildcard(require(\"./tokenTypes\"));var _unescapable,_wordDelimiters;function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!==\"function\")return null;var cacheBabelInterop=new WeakMap;var cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=__name(function _getRequireWildcardCache2(nodeInterop2){return nodeInterop2?cacheNodeInterop:cacheBabelInterop},\"_getRequireWildcardCache\"))(nodeInterop)}__name(_getRequireWildcardCache,\"_getRequireWildcardCache\");function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj}if(obj===null||typeof obj!==\"object\"&&typeof obj!==\"function\"){return{\"default\":obj}}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj)}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!==\"default\"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}newObj[\"default\"]=obj;if(cache){cache.set(obj,newObj)}return newObj}__name(_interopRequireWildcard,\"_interopRequireWildcard\");var unescapable=(_unescapable={},_unescapable[t.tab]=true,_unescapable[t.newline]=true,_unescapable[t.cr]=true,_unescapable[t.feed]=true,_unescapable);var wordDelimiters=(_wordDelimiters={},_wordDelimiters[t.space]=true,_wordDelimiters[t.tab]=true,_wordDelimiters[t.newline]=true,_wordDelimiters[t.cr]=true,_wordDelimiters[t.feed]=true,_wordDelimiters[t.ampersand]=true,_wordDelimiters[t.asterisk]=true,_wordDelimiters[t.bang]=true,_wordDelimiters[t.comma]=true,_wordDelimiters[t.colon]=true,_wordDelimiters[t.semicolon]=true,_wordDelimiters[t.openParenthesis]=true,_wordDelimiters[t.closeParenthesis]=true,_wordDelimiters[t.openSquare]=true,_wordDelimiters[t.closeSquare]=true,_wordDelimiters[t.singleQuote]=true,_wordDelimiters[t.doubleQuote]=true,_wordDelimiters[t.plus]=true,_wordDelimiters[t.pipe]=true,_wordDelimiters[t.tilde]=true,_wordDelimiters[t.greaterThan]=true,_wordDelimiters[t.equals]=true,_wordDelimiters[t.dollar]=true,_wordDelimiters[t.caret]=true,_wordDelimiters[t.slash]=true,_wordDelimiters);var hex={};var hexChars=\"0123456789abcdefABCDEF\";for(var i=0;i<hexChars.length;i++){hex[hexChars.charCodeAt(i)]=true}function consumeWord(css,start){var next=start;var code;do{code=css.charCodeAt(next);if(wordDelimiters[code]){return next-1}else if(code===t.backslash){next=consumeEscape(css,next)+1}else{next++}}while(next<css.length);return next-1}__name(consumeWord,\"consumeWord\");function consumeEscape(css,start){var next=start;var code=css.charCodeAt(next+1);if(unescapable[code]){}else if(hex[code]){var hexDigits=0;do{next++;hexDigits++;code=css.charCodeAt(next+1)}while(hex[code]&&hexDigits<6);if(hexDigits<6&&code===t.space){next++}}else{next++}return next}__name(consumeEscape,\"consumeEscape\");var FIELDS={TYPE:0,START_LINE:1,START_COL:2,END_LINE:3,END_COL:4,START_POS:5,END_POS:6};exports.FIELDS=FIELDS;function tokenize(input){var tokens=[];var css=input.css.valueOf();var _css=css,length=_css.length;var offset=-1;var line=1;var start=0;var end=0;var code,content,endColumn,endLine,escaped,escapePos,last,lines,next,nextLine,nextOffset,quote,tokenType;function unclosed(what,fix){if(input.safe){css+=fix;next=css.length-1}else{throw input.error(\"Unclosed \"+what,line,start-offset,start)}}__name(unclosed,\"unclosed\");while(start<length){code=css.charCodeAt(start);if(code===t.newline){offset=start;line+=1}switch(code){case t.space:case t.tab:case t.newline:case t.cr:case t.feed:next=start;do{next+=1;code=css.charCodeAt(next);if(code===t.newline){offset=next;line+=1}}while(code===t.space||code===t.newline||code===t.tab||code===t.cr||code===t.feed);tokenType=t.space;endLine=line;endColumn=next-offset-1;end=next;break;case t.plus:case t.greaterThan:case t.tilde:case t.pipe:next=start;do{next+=1;code=css.charCodeAt(next)}while(code===t.plus||code===t.greaterThan||code===t.tilde||code===t.pipe);tokenType=t.combinator;endLine=line;endColumn=start-offset;end=next;break;case t.asterisk:case t.ampersand:case t.bang:case t.comma:case t.equals:case t.dollar:case t.caret:case t.openSquare:case t.closeSquare:case t.colon:case t.semicolon:case t.openParenthesis:case t.closeParenthesis:next=start;tokenType=code;endLine=line;endColumn=start-offset;end=next+1;break;case t.singleQuote:case t.doubleQuote:quote=code===t.singleQuote?\"'\":'\"';next=start;do{escaped=false;next=css.indexOf(quote,next+1);if(next===-1){unclosed(\"quote\",quote)}escapePos=next;while(css.charCodeAt(escapePos-1)===t.backslash){escapePos-=1;escaped=!escaped}}while(escaped);tokenType=t.str;endLine=line;endColumn=start-offset;end=next+1;break;default:if(code===t.slash&&css.charCodeAt(start+1)===t.asterisk){next=css.indexOf(\"*/\",start+2)+1;if(next===0){unclosed(\"comment\",\"*/\")}content=css.slice(start,next+1);lines=content.split(\"\\n\");last=lines.length-1;if(last>0){nextLine=line+last;nextOffset=next-lines[last].length}else{nextLine=line;nextOffset=offset}tokenType=t.comment;line=nextLine;endLine=nextLine;endColumn=next-nextOffset}else if(code===t.slash){next=start;tokenType=code;endLine=line;endColumn=start-offset;end=next+1}else{next=consumeWord(css,start);tokenType=t.word;endLine=line;endColumn=next-offset}end=next+1;break}tokens.push([tokenType,line,start-offset,endLine,endColumn,start,end]);if(nextOffset){offset=nextOffset;nextOffset=null}start=end}return tokens}__name(tokenize,\"tokenize\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAEA,QAAQ,WAAa,KACrB,QAAQ,OAAS,OACjB,QAAQ,SAAS,EAAI,SACrB,IAAI,EAAI,wBAAwB,QAAQ,cAAc,CAAC,EACvD,IAAI,aAAc,gBAClB,SAAS,yBAAyB,YAAa,CAAE,GAAI,OAAO,UAAY,WAAY,OAAO,KAAM,IAAI,kBAAoB,IAAI,QAAW,IAAI,iBAAmB,IAAI,QAAW,OAAQ,yBAA2B,gBAASA,0BAAyBC,aAAa,CAAE,OAAOA,aAAc,iBAAmB,iBAAmB,EAA5G,6BAA+G,WAAW,CAAG,CAArU,4DACT,SAAS,wBAAwB,IAAK,YAAa,CAAE,GAAI,CAAC,aAAe,KAAO,IAAI,WAAY,CAAE,OAAO,GAAK,CAAE,GAAI,MAAQ,MAAQ,OAAO,MAAQ,UAAY,OAAO,MAAQ,WAAY,CAAE,MAAO,CAAE,UAAW,GAAI,CAAG,CAAE,IAAI,MAAQ,yBAAyB,WAAW,EAAG,GAAI,OAAS,MAAM,IAAI,GAAG,EAAG,CAAE,OAAO,MAAM,IAAI,GAAG,CAAG,CAAE,IAAI,OAAS,CAAC,EAAG,IAAI,sBAAwB,OAAO,gBAAkB,OAAO,yBAA0B,QAAS,OAAO,IAAK,CAAE,GAAI,MAAQ,WAAa,OAAO,UAAU,eAAe,KAAK,IAAK,GAAG,EAAG,CAAE,IAAI,KAAO,sBAAwB,OAAO,yBAAyB,IAAK,GAAG,EAAI,KAAM,GAAI,OAAS,KAAK,KAAO,KAAK,KAAM,CAAE,OAAO,eAAe,OAAQ,IAAK,IAAI,CAAG,KAAO,CAAE,OAAO,GAAG,EAAI,IAAI,GAAG,CAAG,CAAE,CAAE,CAAE,OAAO,SAAS,EAAI,IAAK,GAAI,MAAO,CAAE,MAAM,IAAI,IAAK,MAAM,CAAG,CAAE,OAAO,MAAQ,CAA/xB,0DACT,IAAI,aAAe,aAAe,CAAC,EAAG,aAAa,EAAE,GAAG,EAAI,KAAM,aAAa,EAAE,OAAO,EAAI,KAAM,aAAa,EAAE,EAAE,EAAI,KAAM,aAAa,EAAE,IAAI,EAAI,KAAM,cAC1J,IAAI,gBAAkB,gBAAkB,CAAC,EAAG,gBAAgB,EAAE,KAAK,EAAI,KAAM,gBAAgB,EAAE,GAAG,EAAI,KAAM,gBAAgB,EAAE,OAAO,EAAI,KAAM,gBAAgB,EAAE,EAAE,EAAI,KAAM,gBAAgB,EAAE,IAAI,EAAI,KAAM,gBAAgB,EAAE,SAAS,EAAI,KAAM,gBAAgB,EAAE,QAAQ,EAAI,KAAM,gBAAgB,EAAE,IAAI,EAAI,KAAM,gBAAgB,EAAE,KAAK,EAAI,KAAM,gBAAgB,EAAE,KAAK,EAAI,KAAM,gBAAgB,EAAE,SAAS,EAAI,KAAM,gBAAgB,EAAE,eAAe,EAAI,KAAM,gBAAgB,EAAE,gBAAgB,EAAI,KAAM,gBAAgB,EAAE,UAAU,EAAI,KAAM,gBAAgB,EAAE,WAAW,EAAI,KAAM,gBAAgB,EAAE,WAAW,EAAI,KAAM,gBAAgB,EAAE,WAAW,EAAI,KAAM,gBAAgB,EAAE,IAAI,EAAI,KAAM,gBAAgB,EAAE,IAAI,EAAI,KAAM,gBAAgB,EAAE,KAAK,EAAI,KAAM,gBAAgB,EAAE,WAAW,EAAI,KAAM,gBAAgB,EAAE,MAAM,EAAI,KAAM,gBAAgB,EAAE,MAAM,EAAI,KAAM,gBAAgB,EAAE,KAAK,EAAI,KAAM,gBAAgB,EAAE,KAAK,EAAI,KAAM,iBAC75B,IAAI,IAAM,CAAC,EACX,IAAI,SAAW,yBACf,QAAS,EAAI,EAAG,EAAI,SAAS,OAAQ,IAAK,CACxC,IAAI,SAAS,WAAW,CAAC,CAAC,EAAI,IAChC,CAOA,SAAS,YAAY,IAAK,MAAO,CAC/B,IAAI,KAAO,MACX,IAAI,KACJ,EAAG,CACD,KAAO,IAAI,WAAW,IAAI,EAC1B,GAAI,eAAe,IAAI,EAAG,CACxB,OAAO,KAAO,CAChB,SAAW,OAAS,EAAE,UAAW,CAC/B,KAAO,cAAc,IAAK,IAAI,EAAI,CACpC,KAAO,CAEL,MACF,CACF,OAAS,KAAO,IAAI,QACpB,OAAO,KAAO,CAChB,CAfS,kCAsBT,SAAS,cAAc,IAAK,MAAO,CACjC,IAAI,KAAO,MACX,IAAI,KAAO,IAAI,WAAW,KAAO,CAAC,EAClC,GAAI,YAAY,IAAI,EAAG,CAEvB,SAAW,IAAI,IAAI,EAAG,CACpB,IAAI,UAAY,EAEhB,EAAG,CACD,OACA,YACA,KAAO,IAAI,WAAW,KAAO,CAAC,CAChC,OAAS,IAAI,IAAI,GAAK,UAAY,GAElC,GAAI,UAAY,GAAK,OAAS,EAAE,MAAO,CACrC,MACF,CACF,KAAO,CAEL,MACF,CACA,OAAO,IACT,CAtBS,sCAuBT,IAAI,OAAS,CACX,KAAM,EACN,WAAY,EACZ,UAAW,EACX,SAAU,EACV,QAAS,EACT,UAAW,EACX,QAAS,CACX,EACA,QAAQ,OAAS,OACjB,SAAS,SAAS,MAAO,CACvB,IAAI,OAAS,CAAC,EACd,IAAI,IAAM,MAAM,IAAI,QAAQ,EAC5B,IAAI,KAAO,IACT,OAAS,KAAK,OAChB,IAAI,OAAS,GACb,IAAI,KAAO,EACX,IAAI,MAAQ,EACZ,IAAI,IAAM,EACV,IAAI,KAAM,QAAS,UAAW,QAAS,QAAS,UAAW,KAAM,MAAO,KAAM,SAAU,WAAY,MAAO,UAC3G,SAAS,SAAS,KAAM,IAAK,CAC3B,GAAI,MAAM,KAAM,CAEd,KAAO,IACP,KAAO,IAAI,OAAS,CACtB,KAAO,CACL,MAAM,MAAM,MAAM,YAAc,KAAM,KAAM,MAAQ,OAAQ,KAAK,CACnE,CACF,CARS,4BAST,MAAO,MAAQ,OAAQ,CACrB,KAAO,IAAI,WAAW,KAAK,EAC3B,GAAI,OAAS,EAAE,QAAS,CACtB,OAAS,MACT,MAAQ,CACV,CACA,OAAQ,KAAM,CACZ,KAAK,EAAE,MACP,KAAK,EAAE,IACP,KAAK,EAAE,QACP,KAAK,EAAE,GACP,KAAK,EAAE,KACL,KAAO,MACP,EAAG,CACD,MAAQ,EACR,KAAO,IAAI,WAAW,IAAI,EAC1B,GAAI,OAAS,EAAE,QAAS,CACtB,OAAS,KACT,MAAQ,CACV,CACF,OAAS,OAAS,EAAE,OAAS,OAAS,EAAE,SAAW,OAAS,EAAE,KAAO,OAAS,EAAE,IAAM,OAAS,EAAE,MACjG,UAAY,EAAE,MACd,QAAU,KACV,UAAY,KAAO,OAAS,EAC5B,IAAM,KACN,MACF,KAAK,EAAE,KACP,KAAK,EAAE,YACP,KAAK,EAAE,MACP,KAAK,EAAE,KACL,KAAO,MACP,EAAG,CACD,MAAQ,EACR,KAAO,IAAI,WAAW,IAAI,CAC5B,OAAS,OAAS,EAAE,MAAQ,OAAS,EAAE,aAAe,OAAS,EAAE,OAAS,OAAS,EAAE,MACrF,UAAY,EAAE,WACd,QAAU,KACV,UAAY,MAAQ,OACpB,IAAM,KACN,MAGF,KAAK,EAAE,SACP,KAAK,EAAE,UACP,KAAK,EAAE,KACP,KAAK,EAAE,MACP,KAAK,EAAE,OACP,KAAK,EAAE,OACP,KAAK,EAAE,MACP,KAAK,EAAE,WACP,KAAK,EAAE,YACP,KAAK,EAAE,MACP,KAAK,EAAE,UACP,KAAK,EAAE,gBACP,KAAK,EAAE,iBACL,KAAO,MACP,UAAY,KACZ,QAAU,KACV,UAAY,MAAQ,OACpB,IAAM,KAAO,EACb,MACF,KAAK,EAAE,YACP,KAAK,EAAE,YACL,MAAQ,OAAS,EAAE,YAAc,IAAM,IACvC,KAAO,MACP,EAAG,CACD,QAAU,MACV,KAAO,IAAI,QAAQ,MAAO,KAAO,CAAC,EAClC,GAAI,OAAS,GAAI,CACf,SAAS,QAAS,KAAK,CACzB,CACA,UAAY,KACZ,MAAO,IAAI,WAAW,UAAY,CAAC,IAAM,EAAE,UAAW,CACpD,WAAa,EACb,QAAU,CAAC,OACb,CACF,OAAS,SACT,UAAY,EAAE,IACd,QAAU,KACV,UAAY,MAAQ,OACpB,IAAM,KAAO,EACb,MACF,QACE,GAAI,OAAS,EAAE,OAAS,IAAI,WAAW,MAAQ,CAAC,IAAM,EAAE,SAAU,CAChE,KAAO,IAAI,QAAQ,KAAM,MAAQ,CAAC,EAAI,EACtC,GAAI,OAAS,EAAG,CACd,SAAS,UAAW,IAAI,CAC1B,CACA,QAAU,IAAI,MAAM,MAAO,KAAO,CAAC,EACnC,MAAQ,QAAQ,MAAM,IAAI,EAC1B,KAAO,MAAM,OAAS,EACtB,GAAI,KAAO,EAAG,CACZ,SAAW,KAAO,KAClB,WAAa,KAAO,MAAM,IAAI,EAAE,MAClC,KAAO,CACL,SAAW,KACX,WAAa,MACf,CACA,UAAY,EAAE,QACd,KAAO,SACP,QAAU,SACV,UAAY,KAAO,UACrB,SAAW,OAAS,EAAE,MAAO,CAC3B,KAAO,MACP,UAAY,KACZ,QAAU,KACV,UAAY,MAAQ,OACpB,IAAM,KAAO,CACf,KAAO,CACL,KAAO,YAAY,IAAK,KAAK,EAC7B,UAAY,EAAE,KACd,QAAU,KACV,UAAY,KAAO,MACrB,CACA,IAAM,KAAO,EACb,KACJ,CAGA,OAAO,KAAK,CAAC,UAEb,KAEA,MAAQ,OAER,QAEA,UAEA,MAEA,GACA,CAAC,EAGD,GAAI,WAAY,CACd,OAAS,WACT,WAAa,IACf,CACA,MAAQ,GACV,CACA,OAAO,MACT,CAjKS","names":["_getRequireWildcardCache","nodeInterop"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/postcss-selector-parser@6.0.13/node_modules/postcss-selector-parser/dist/tokenize.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.FIELDS = void 0;\nexports[\"default\"] = tokenize;\nvar t = _interopRequireWildcard(require(\"./tokenTypes\"));\nvar _unescapable, _wordDelimiters;\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);\nvar wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);\nvar hex = {};\nvar hexChars = \"0123456789abcdefABCDEF\";\nfor (var i = 0; i < hexChars.length; i++) {\n  hex[hexChars.charCodeAt(i)] = true;\n}\n\n/**\n *  Returns the last index of the bar css word\n * @param {string} css The string in which the word begins\n * @param {number} start The index into the string where word's first letter occurs\n */\nfunction consumeWord(css, start) {\n  var next = start;\n  var code;\n  do {\n    code = css.charCodeAt(next);\n    if (wordDelimiters[code]) {\n      return next - 1;\n    } else if (code === t.backslash) {\n      next = consumeEscape(css, next) + 1;\n    } else {\n      // All other characters are part of the word\n      next++;\n    }\n  } while (next < css.length);\n  return next - 1;\n}\n\n/**\n *  Returns the last index of the escape sequence\n * @param {string} css The string in which the sequence begins\n * @param {number} start The index into the string where escape character (`\\`) occurs.\n */\nfunction consumeEscape(css, start) {\n  var next = start;\n  var code = css.charCodeAt(next + 1);\n  if (unescapable[code]) {\n    // just consume the escape char\n  } else if (hex[code]) {\n    var hexDigits = 0;\n    // consume up to 6 hex chars\n    do {\n      next++;\n      hexDigits++;\n      code = css.charCodeAt(next + 1);\n    } while (hex[code] && hexDigits < 6);\n    // if fewer than 6 hex chars, a trailing space ends the escape\n    if (hexDigits < 6 && code === t.space) {\n      next++;\n    }\n  } else {\n    // the next char is part of the current word\n    next++;\n  }\n  return next;\n}\nvar FIELDS = {\n  TYPE: 0,\n  START_LINE: 1,\n  START_COL: 2,\n  END_LINE: 3,\n  END_COL: 4,\n  START_POS: 5,\n  END_POS: 6\n};\nexports.FIELDS = FIELDS;\nfunction tokenize(input) {\n  var tokens = [];\n  var css = input.css.valueOf();\n  var _css = css,\n    length = _css.length;\n  var offset = -1;\n  var line = 1;\n  var start = 0;\n  var end = 0;\n  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;\n  function unclosed(what, fix) {\n    if (input.safe) {\n      // fyi: this is never set to true.\n      css += fix;\n      next = css.length - 1;\n    } else {\n      throw input.error('Unclosed ' + what, line, start - offset, start);\n    }\n  }\n  while (start < length) {\n    code = css.charCodeAt(start);\n    if (code === t.newline) {\n      offset = start;\n      line += 1;\n    }\n    switch (code) {\n      case t.space:\n      case t.tab:\n      case t.newline:\n      case t.cr:\n      case t.feed:\n        next = start;\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n          if (code === t.newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n        tokenType = t.space;\n        endLine = line;\n        endColumn = next - offset - 1;\n        end = next;\n        break;\n      case t.plus:\n      case t.greaterThan:\n      case t.tilde:\n      case t.pipe:\n        next = start;\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n        tokenType = t.combinator;\n        endLine = line;\n        endColumn = start - offset;\n        end = next;\n        break;\n\n      // Consume these characters as single tokens.\n      case t.asterisk:\n      case t.ampersand:\n      case t.bang:\n      case t.comma:\n      case t.equals:\n      case t.dollar:\n      case t.caret:\n      case t.openSquare:\n      case t.closeSquare:\n      case t.colon:\n      case t.semicolon:\n      case t.openParenthesis:\n      case t.closeParenthesis:\n        next = start;\n        tokenType = code;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n      case t.singleQuote:\n      case t.doubleQuote:\n        quote = code === t.singleQuote ? \"'\" : '\"';\n        next = start;\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n          escapePos = next;\n          while (css.charCodeAt(escapePos - 1) === t.backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n        tokenType = t.str;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n      default:\n        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n          next = css.indexOf('*/', start + 2) + 1;\n          if (next === 0) {\n            unclosed('comment', '*/');\n          }\n          content = css.slice(start, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n          tokenType = t.comment;\n          line = nextLine;\n          endLine = nextLine;\n          endColumn = next - nextOffset;\n        } else if (code === t.slash) {\n          next = start;\n          tokenType = code;\n          endLine = line;\n          endColumn = start - offset;\n          end = next + 1;\n        } else {\n          next = consumeWord(css, start);\n          tokenType = t.word;\n          endLine = line;\n          endColumn = next - offset;\n        }\n        end = next + 1;\n        break;\n    }\n\n    // Ensure that the token structure remains consistent\n    tokens.push([tokenType,\n    // [0] Token type\n    line,\n    // [1] Starting line\n    start - offset,\n    // [2] Starting column\n    endLine,\n    // [3] Ending line\n    endColumn,\n    // [4] Ending column\n    start,\n    // [5] Start position / Source index\n    end // [6] End position\n    ]);\n\n    // Reset offset for the next token\n    if (nextOffset) {\n      offset = nextOffset;\n      nextOffset = null;\n    }\n    start = end;\n  }\n  return tokens;\n}"]}}