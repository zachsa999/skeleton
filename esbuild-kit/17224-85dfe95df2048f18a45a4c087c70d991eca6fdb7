{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});Object.defineProperty(exports,\"default\",{enumerable:true,get:function(){return negateValue}});function negateValue(value){value=`${value}`;if(value===\"0\"){return\"0\"}if(/^[+-]?(\\d+|\\d*\\.\\d+)(e[+-]?\\d+)?(%|\\w+)?$/.test(value)){return value.replace(/^[+-]?/,sign=>sign===\"-\"?\"\":\"-\")}let numericFunctions=[\"var\",\"calc\",\"min\",\"max\",\"clamp\"];for(const fn of numericFunctions){if(value.includes(`${fn}(`)){return`calc(${value} * -1)`}}}__name(negateValue,\"negateValue\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CACzC,MAAO,IACX,CAAC,EACD,OAAO,eAAe,QAAS,UAAW,CACtC,WAAY,KACZ,IAAK,UAAW,CACZ,OAAO,WACX,CACJ,CAAC,EACD,SAAS,YAAY,MAAO,CACxB,MAAQ,GAAG,QACX,GAAI,QAAU,IAAK,CACf,MAAO,GACX,CAEA,GAAI,4CAA4C,KAAK,KAAK,EAAG,CACzD,OAAO,MAAM,QAAQ,SAAW,MAAO,OAAS,IAAM,GAAK,GAAG,CAClE,CAKA,IAAI,iBAAmB,CACnB,MACA,OACA,MACA,MACA,OACJ,EACA,UAAW,MAAM,iBAAiB,CAC9B,GAAI,MAAM,SAAS,GAAG,KAAK,EAAG,CAC1B,MAAO,QAAQ,aACnB,CACJ,CACJ,CAzBS","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/util/negateValue.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return negateValue;\n    }\n});\nfunction negateValue(value) {\n    value = `${value}`;\n    if (value === \"0\") {\n        return \"0\";\n    }\n    // Flip sign of numbers\n    if (/^[+-]?(\\d+|\\d*\\.\\d+)(e[+-]?\\d+)?(%|\\w+)?$/.test(value)) {\n        return value.replace(/^[+-]?/, (sign)=>sign === \"-\" ? \"\" : \"-\");\n    }\n    // What functions we support negating numeric values for\n    // var() isn't inherently a numeric function but we support it anyway\n    // The trigonometric functions are omitted because you'll need to use calc(â€¦) with them _anyway_\n    // to produce generally useful results and that will be covered already\n    let numericFunctions = [\n        \"var\",\n        \"calc\",\n        \"min\",\n        \"max\",\n        \"clamp\"\n    ];\n    for (const fn of numericFunctions){\n        if (value.includes(`${fn}(`)) {\n            return `calc(${value} * -1)`;\n        }\n    }\n}\n"]}}