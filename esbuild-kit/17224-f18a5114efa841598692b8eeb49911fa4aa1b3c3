{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:true,get:all[name]})}__name(_export,\"_export\");_export(exports,{isValidVariantFormatString:function(){return isValidVariantFormatString},parseVariant:function(){return parseVariant},getFileModifiedMap:function(){return getFileModifiedMap},createContext:function(){return createContext},getContext:function(){return getContext}});const _fs=_interop_require_default(require(\"fs\"));const _url=_interop_require_default(require(\"url\"));const _postcss=_interop_require_default(require(\"postcss\"));const _dlv=_interop_require_default(require(\"dlv\"));const _postcssselectorparser=_interop_require_default(require(\"postcss-selector-parser\"));const _transformThemeValue=_interop_require_default(require(\"../util/transformThemeValue\"));const _parseObjectStyles=_interop_require_default(require(\"../util/parseObjectStyles\"));const _prefixSelector=_interop_require_default(require(\"../util/prefixSelector\"));const _isPlainObject=_interop_require_default(require(\"../util/isPlainObject\"));const _escapeClassName=_interop_require_default(require(\"../util/escapeClassName\"));const _nameClass=_interop_require_wildcard(require(\"../util/nameClass\"));const _pluginUtils=require(\"../util/pluginUtils\");const _corePlugins=require(\"../corePlugins\");const _sharedState=_interop_require_wildcard(require(\"./sharedState\"));const _toPath=require(\"../util/toPath\");const _log=_interop_require_default(require(\"../util/log\"));const _negateValue=_interop_require_default(require(\"../util/negateValue\"));const _isSyntacticallyValidPropertyValue=_interop_require_default(require(\"../util/isSyntacticallyValidPropertyValue\"));const _generateRules=require(\"./generateRules\");const _cacheInvalidation=require(\"./cacheInvalidation.js\");const _offsets=require(\"./offsets.js\");const _featureFlags=require(\"../featureFlags.js\");const _formatVariantSelector=require(\"../util/formatVariantSelector\");function _interop_require_default(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interop_require_default,\"_interop_require_default\");function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!==\"function\")return null;var cacheBabelInterop=new WeakMap;var cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=__name(function(nodeInterop2){return nodeInterop2?cacheNodeInterop:cacheBabelInterop},\"_getRequireWildcardCache\"))(nodeInterop)}__name(_getRequireWildcardCache,\"_getRequireWildcardCache\");function _interop_require_wildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj}if(obj===null||typeof obj!==\"object\"&&typeof obj!==\"function\"){return{default:obj}}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj)}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!==\"default\"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}newObj.default=obj;if(cache){cache.set(obj,newObj)}return newObj}__name(_interop_require_wildcard,\"_interop_require_wildcard\");const VARIANT_TYPES={AddVariant:Symbol.for(\"ADD_VARIANT\"),MatchVariant:Symbol.for(\"MATCH_VARIANT\")};const VARIANT_INFO={Base:1<<0,Dynamic:1<<1};function prefix(context,selector){let prefix2=context.tailwindConfig.prefix;return typeof prefix2===\"function\"?prefix2(selector):prefix2+selector}__name(prefix,\"prefix\");function normalizeOptionTypes({type=\"any\",...options}){let types=[].concat(type);return{...options,types:types.map(type2=>{if(Array.isArray(type2)){return{type:type2[0],...type2[1]}}return{type:type2,preferOnConflict:false}})}}__name(normalizeOptionTypes,\"normalizeOptionTypes\");function parseVariantFormatString(input){let parts=[];let current=\"\";let depth=0;for(let idx=0;idx<input.length;idx++){let char=input[idx];if(char===\"\\\\\"){current+=\"\\\\\"+input[++idx]}else if(char===\"{\"){++depth;parts.push(current.trim());current=\"\"}else if(char===\"}\"){if(--depth<0){throw new Error(`Your { and } are unbalanced.`)}parts.push(current.trim());current=\"\"}else{current+=char}}if(current.length>0){parts.push(current.trim())}parts=parts.filter(part=>part!==\"\");return parts}__name(parseVariantFormatString,\"parseVariantFormatString\");function insertInto(list,value,{before=[]}={}){before=[].concat(before);if(before.length<=0){list.push(value);return}let idx=list.length-1;for(let other of before){let iidx=list.indexOf(other);if(iidx===-1)continue;idx=Math.min(idx,iidx)}list.splice(idx,0,value)}__name(insertInto,\"insertInto\");function parseStyles(styles){if(!Array.isArray(styles)){return parseStyles([styles])}return styles.flatMap(style=>{let isNode=!Array.isArray(style)&&!(0,_isPlainObject.default)(style);return isNode?style:(0,_parseObjectStyles.default)(style)})}__name(parseStyles,\"parseStyles\");function getClasses(selector,mutate){let parser=(0,_postcssselectorparser.default)(selectors=>{let allClasses=[];if(mutate){mutate(selectors)}selectors.walkClasses(classNode=>{allClasses.push(classNode.value)});return allClasses});return parser.transformSync(selector)}__name(getClasses,\"getClasses\");function extractCandidates(node,state={containsNonOnDemandable:false},depth=0){let classes=[];if(node.type===\"rule\"){let ignoreNot=function(selectors){selectors.walkPseudos(pseudo=>{if(pseudo.value===\":not\"){pseudo.remove()}})};__name(ignoreNot,\"ignoreNot\");for(let selector of node.selectors){let classCandidates=getClasses(selector,ignoreNot);if(classCandidates.length===0){state.containsNonOnDemandable=true}for(let classCandidate of classCandidates){classes.push(classCandidate)}}}else if(node.type===\"atrule\"){node.walkRules(rule=>{for(let classCandidate of rule.selectors.flatMap(selector=>getClasses(selector))){classes.push(classCandidate)}})}if(depth===0){return[state.containsNonOnDemandable||classes.length===0,classes]}return classes}__name(extractCandidates,\"extractCandidates\");function withIdentifiers(styles){return parseStyles(styles).flatMap(node=>{let nodeMap=new Map;let[containsNonOnDemandableSelectors,candidates]=extractCandidates(node);if(containsNonOnDemandableSelectors){candidates.unshift(_sharedState.NOT_ON_DEMAND)}return candidates.map(c=>{if(!nodeMap.has(node)){nodeMap.set(node,node)}return[c,nodeMap.get(node)]})})}__name(withIdentifiers,\"withIdentifiers\");function isValidVariantFormatString(format){return format.startsWith(\"@\")||format.includes(\"&\")}__name(isValidVariantFormatString,\"isValidVariantFormatString\");function parseVariant(variant){variant=variant.replace(/\\n+/g,\"\").replace(/\\s{1,}/g,\" \").trim();let fns=parseVariantFormatString(variant).map(str=>{if(!str.startsWith(\"@\")){return({format})=>format(str)}let[,name,params]=/@(.*?)( .+|[({].*)/g.exec(str);return({wrap})=>wrap(_postcss.default.atRule({name,params:params.trim()}))}).reverse();return api=>{for(let fn of fns){fn(api)}}}__name(parseVariant,\"parseVariant\");function buildPluginApi(tailwindConfig,context,{variantList,variantMap,offsets,classList}){function getConfigValue(path,defaultValue){return path?(0,_dlv.default)(tailwindConfig,path,defaultValue):tailwindConfig}__name(getConfigValue,\"getConfigValue\");function applyConfiguredPrefix(selector){return(0,_prefixSelector.default)(tailwindConfig.prefix,selector)}__name(applyConfiguredPrefix,\"applyConfiguredPrefix\");function prefixIdentifier(identifier,options){if(identifier===_sharedState.NOT_ON_DEMAND){return _sharedState.NOT_ON_DEMAND}if(!options.respectPrefix){return identifier}return context.tailwindConfig.prefix+identifier}__name(prefixIdentifier,\"prefixIdentifier\");function resolveThemeValue(path,defaultValue,opts={}){let parts=(0,_toPath.toPath)(path);let value=getConfigValue([\"theme\",...parts],defaultValue);return(0,_transformThemeValue.default)(parts[0])(value,opts)}__name(resolveThemeValue,\"resolveThemeValue\");let variantIdentifier=0;let api={postcss:_postcss.default,prefix:applyConfiguredPrefix,e:_escapeClassName.default,config:getConfigValue,theme:resolveThemeValue,corePlugins:path=>{if(Array.isArray(tailwindConfig.corePlugins)){return tailwindConfig.corePlugins.includes(path)}return getConfigValue([\"corePlugins\",path],true)},variants:()=>{return[]},addBase(base){for(let[identifier,rule]of withIdentifiers(base)){let prefixedIdentifier=prefixIdentifier(identifier,{});let offset=offsets.create(\"base\");if(!context.candidateRuleMap.has(prefixedIdentifier)){context.candidateRuleMap.set(prefixedIdentifier,[])}context.candidateRuleMap.get(prefixedIdentifier).push([{sort:offset,layer:\"base\"},rule])}},addDefaults(group,declarations){const groups={[`@defaults ${group}`]:declarations};for(let[identifier,rule]of withIdentifiers(groups)){let prefixedIdentifier=prefixIdentifier(identifier,{});if(!context.candidateRuleMap.has(prefixedIdentifier)){context.candidateRuleMap.set(prefixedIdentifier,[])}context.candidateRuleMap.get(prefixedIdentifier).push([{sort:offsets.create(\"defaults\"),layer:\"defaults\"},rule])}},addComponents(components,options){let defaultOptions={preserveSource:false,respectPrefix:true,respectImportant:false};options=Object.assign({},defaultOptions,Array.isArray(options)?{}:options);for(let[identifier,rule]of withIdentifiers(components)){let prefixedIdentifier=prefixIdentifier(identifier,options);classList.add(prefixedIdentifier);if(!context.candidateRuleMap.has(prefixedIdentifier)){context.candidateRuleMap.set(prefixedIdentifier,[])}context.candidateRuleMap.get(prefixedIdentifier).push([{sort:offsets.create(\"components\"),layer:\"components\",options},rule])}},addUtilities(utilities,options){let defaultOptions={preserveSource:false,respectPrefix:true,respectImportant:true};options=Object.assign({},defaultOptions,Array.isArray(options)?{}:options);for(let[identifier,rule]of withIdentifiers(utilities)){let prefixedIdentifier=prefixIdentifier(identifier,options);classList.add(prefixedIdentifier);if(!context.candidateRuleMap.has(prefixedIdentifier)){context.candidateRuleMap.set(prefixedIdentifier,[])}context.candidateRuleMap.get(prefixedIdentifier).push([{sort:offsets.create(\"utilities\"),layer:\"utilities\",options},rule])}},matchUtilities:function(utilities,options){let defaultOptions={respectPrefix:true,respectImportant:true,modifiers:false};options=normalizeOptionTypes({...defaultOptions,...options});let offset=offsets.create(\"utilities\");for(let identifier in utilities){let wrapped=function(modifier,{isOnlyPlugin}){let[value,coercedType,utilityModifier]=(0,_pluginUtils.coerceValue)(options.types,modifier,options,tailwindConfig);if(value===void 0){return[]}if(!options.types.some(({type})=>type===coercedType)){if(isOnlyPlugin){_log.default.warn([`Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`,`You can safely update it to \\`${identifier}-${modifier.replace(coercedType+\":\",\"\")}\\`.`])}else{return[]}}if(!(0,_isSyntacticallyValidPropertyValue.default)(value)){return[]}let extras={get modifier(){if(!options.modifiers){_log.default.warn(`modifier-used-without-options-for-${identifier}`,[\"Your plugin must set `modifiers: true` in its options to support modifiers.\"])}return utilityModifier}};let modifiersEnabled=(0,_featureFlags.flagEnabled)(tailwindConfig,\"generalizedModifiers\");let ruleSets=[].concat(modifiersEnabled?rule(value,extras):rule(value)).filter(Boolean).map(declaration=>({[(0,_nameClass.default)(identifier,modifier)]:declaration}));return ruleSets};__name(wrapped,\"wrapped\");let prefixedIdentifier=prefixIdentifier(identifier,options);let rule=utilities[identifier];classList.add([prefixedIdentifier,options]);let withOffsets=[{sort:offset,layer:\"utilities\",options},wrapped];if(!context.candidateRuleMap.has(prefixedIdentifier)){context.candidateRuleMap.set(prefixedIdentifier,[])}context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets)}},matchComponents:function(components,options){let defaultOptions={respectPrefix:true,respectImportant:false,modifiers:false};options=normalizeOptionTypes({...defaultOptions,...options});let offset=offsets.create(\"components\");for(let identifier in components){let wrapped=function(modifier,{isOnlyPlugin}){let[value,coercedType,utilityModifier]=(0,_pluginUtils.coerceValue)(options.types,modifier,options,tailwindConfig);if(value===void 0){return[]}if(!options.types.some(({type})=>type===coercedType)){if(isOnlyPlugin){_log.default.warn([`Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`,`You can safely update it to \\`${identifier}-${modifier.replace(coercedType+\":\",\"\")}\\`.`])}else{return[]}}if(!(0,_isSyntacticallyValidPropertyValue.default)(value)){return[]}let extras={get modifier(){if(!options.modifiers){_log.default.warn(`modifier-used-without-options-for-${identifier}`,[\"Your plugin must set `modifiers: true` in its options to support modifiers.\"])}return utilityModifier}};let modifiersEnabled=(0,_featureFlags.flagEnabled)(tailwindConfig,\"generalizedModifiers\");let ruleSets=[].concat(modifiersEnabled?rule(value,extras):rule(value)).filter(Boolean).map(declaration=>({[(0,_nameClass.default)(identifier,modifier)]:declaration}));return ruleSets};__name(wrapped,\"wrapped\");let prefixedIdentifier=prefixIdentifier(identifier,options);let rule=components[identifier];classList.add([prefixedIdentifier,options]);let withOffsets=[{sort:offset,layer:\"components\",options},wrapped];if(!context.candidateRuleMap.has(prefixedIdentifier)){context.candidateRuleMap.set(prefixedIdentifier,[])}context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets)}},addVariant(variantName,variantFunctions,options={}){variantFunctions=[].concat(variantFunctions).map(variantFunction=>{if(typeof variantFunction!==\"string\"){return(api2={})=>{let{args,modifySelectors,container,separator,wrap,format}=api2;let result=variantFunction(Object.assign({modifySelectors,container,separator},options.type===VARIANT_TYPES.MatchVariant&&{args,wrap,format}));if(typeof result===\"string\"&&!isValidVariantFormatString(result)){throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`)}if(Array.isArray(result)){return result.filter(variant=>typeof variant===\"string\").map(variant=>parseVariant(variant))}return result&&typeof result===\"string\"&&parseVariant(result)(api2)}}if(!isValidVariantFormatString(variantFunction)){throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`)}return parseVariant(variantFunction)});insertInto(variantList,variantName,options);variantMap.set(variantName,variantFunctions);context.variantOptions.set(variantName,options)},matchVariant(variant,variantFn,options){var _options_id;let id=(_options_id=options===null||options===void 0?void 0:options.id)!==null&&_options_id!==void 0?_options_id:++variantIdentifier;let isSpecial=variant===\"@\";let modifiersEnabled=(0,_featureFlags.flagEnabled)(tailwindConfig,\"generalizedModifiers\");var _options_values;for(let[key,value]of Object.entries((_options_values=options===null||options===void 0?void 0:options.values)!==null&&_options_values!==void 0?_options_values:{})){if(key===\"DEFAULT\")continue;api.addVariant(isSpecial?`${variant}${key}`:`${variant}-${key}`,({args,container})=>{return variantFn(value,modifiersEnabled?{modifier:args===null||args===void 0?void 0:args.modifier,container}:{container})},{...options,value,id,type:VARIANT_TYPES.MatchVariant,variantInfo:VARIANT_INFO.Base})}var _options_values1;let hasDefault=\"DEFAULT\"in((_options_values1=options===null||options===void 0?void 0:options.values)!==null&&_options_values1!==void 0?_options_values1:{});api.addVariant(variant,({args,container})=>{if((args===null||args===void 0?void 0:args.value)===_sharedState.NONE&&!hasDefault){return null}var _args_value;return variantFn((args===null||args===void 0?void 0:args.value)===_sharedState.NONE?options.values.DEFAULT:(_args_value=args===null||args===void 0?void 0:args.value)!==null&&_args_value!==void 0?_args_value:typeof args===\"string\"?args:\"\",modifiersEnabled?{modifier:args===null||args===void 0?void 0:args.modifier,container}:{container})},{...options,id,type:VARIANT_TYPES.MatchVariant,variantInfo:VARIANT_INFO.Dynamic})}};return api}__name(buildPluginApi,\"buildPluginApi\");let fileModifiedMapCache=new WeakMap;function getFileModifiedMap(context){if(!fileModifiedMapCache.has(context)){fileModifiedMapCache.set(context,new Map)}return fileModifiedMapCache.get(context)}__name(getFileModifiedMap,\"getFileModifiedMap\");function trackModified(files,fileModifiedMap){let changed=false;let mtimesToCommit=new Map;for(let file of files){var _fs_statSync;if(!file)continue;let parsed=_url.default.parse(file);let pathname=parsed.hash?parsed.href.replace(parsed.hash,\"\"):parsed.href;pathname=parsed.search?pathname.replace(parsed.search,\"\"):pathname;let newModified=(_fs_statSync=_fs.default.statSync(decodeURIComponent(pathname),{throwIfNoEntry:false}))===null||_fs_statSync===void 0?void 0:_fs_statSync.mtimeMs;if(!newModified){continue}if(!fileModifiedMap.has(file)||newModified>fileModifiedMap.get(file)){changed=true}mtimesToCommit.set(file,newModified)}return[changed,mtimesToCommit]}__name(trackModified,\"trackModified\");function extractVariantAtRules(node){node.walkAtRules(atRule=>{if([\"responsive\",\"variants\"].includes(atRule.name)){extractVariantAtRules(atRule);atRule.before(atRule.nodes);atRule.remove()}})}__name(extractVariantAtRules,\"extractVariantAtRules\");function collectLayerPlugins(root){let layerPlugins=[];root.each(node=>{if(node.type===\"atrule\"&&[\"responsive\",\"variants\"].includes(node.name)){node.name=\"layer\";node.params=\"utilities\"}});root.walkAtRules(\"layer\",layerRule=>{extractVariantAtRules(layerRule);if(layerRule.params===\"base\"){for(let node of layerRule.nodes){layerPlugins.push(function({addBase}){addBase(node,{respectPrefix:false})})}layerRule.remove()}else if(layerRule.params===\"components\"){for(let node of layerRule.nodes){layerPlugins.push(function({addComponents}){addComponents(node,{respectPrefix:false,preserveSource:true})})}layerRule.remove()}else if(layerRule.params===\"utilities\"){for(let node of layerRule.nodes){layerPlugins.push(function({addUtilities}){addUtilities(node,{respectPrefix:false,preserveSource:true})})}layerRule.remove()}});return layerPlugins}__name(collectLayerPlugins,\"collectLayerPlugins\");function resolvePlugins(context,root){let corePluginList=Object.entries({..._corePlugins.variantPlugins,..._corePlugins.corePlugins}).map(([name,plugin])=>{if(!context.tailwindConfig.corePlugins.includes(name)){return null}return plugin}).filter(Boolean);let userPlugins=context.tailwindConfig.plugins.map(plugin=>{if(plugin.__isOptionsFunction){plugin=plugin()}return typeof plugin===\"function\"?plugin:plugin.handler});let layerPlugins=collectLayerPlugins(root);let beforeVariants=[_corePlugins.variantPlugins[\"pseudoElementVariants\"],_corePlugins.variantPlugins[\"pseudoClassVariants\"],_corePlugins.variantPlugins[\"ariaVariants\"],_corePlugins.variantPlugins[\"dataVariants\"]];let afterVariants=[_corePlugins.variantPlugins[\"supportsVariants\"],_corePlugins.variantPlugins[\"directionVariants\"],_corePlugins.variantPlugins[\"reducedMotionVariants\"],_corePlugins.variantPlugins[\"prefersContrastVariants\"],_corePlugins.variantPlugins[\"darkVariants\"],_corePlugins.variantPlugins[\"printVariant\"],_corePlugins.variantPlugins[\"screenVariants\"],_corePlugins.variantPlugins[\"orientationVariants\"]];return[...corePluginList,...beforeVariants,...userPlugins,...afterVariants,...layerPlugins]}__name(resolvePlugins,\"resolvePlugins\");function registerPlugins(plugins,context){let variantList=[];let variantMap=new Map;context.variantMap=variantMap;let offsets=new _offsets.Offsets;context.offsets=offsets;let classList=new Set;let pluginApi=buildPluginApi(context.tailwindConfig,context,{variantList,variantMap,offsets,classList});for(let plugin of plugins){if(Array.isArray(plugin)){for(let pluginItem of plugin){pluginItem(pluginApi)}}else{plugin===null||plugin===void 0?void 0:plugin(pluginApi)}}offsets.recordVariants(variantList,variant=>variantMap.get(variant).length);for(let[variantName,variantFunctions]of variantMap.entries()){context.variantMap.set(variantName,variantFunctions.map((variantFunction,idx)=>[offsets.forVariant(variantName,idx),variantFunction]))}var _context_tailwindConfig_safelist;let safelist=((_context_tailwindConfig_safelist=context.tailwindConfig.safelist)!==null&&_context_tailwindConfig_safelist!==void 0?_context_tailwindConfig_safelist:[]).filter(Boolean);if(safelist.length>0){let checks=[];for(let value of safelist){if(typeof value===\"string\"){context.changedContent.push({content:value,extension:\"html\"});continue}if(value instanceof RegExp){_log.default.warn(\"root-regex\",[\"Regular expressions in `safelist` work differently in Tailwind CSS v3.0.\",\"Update your `safelist` configuration to eliminate this warning.\",\"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"]);continue}checks.push(value)}if(checks.length>0){let patternMatchingCount=new Map;let prefixLength=context.tailwindConfig.prefix.length;let checkImportantUtils=checks.some(check=>check.pattern.source.includes(\"!\"));for(let util of classList){let utils=Array.isArray(util)?(()=>{let[utilName,options]=util;var _options_values;let values=Object.keys((_options_values=options===null||options===void 0?void 0:options.values)!==null&&_options_values!==void 0?_options_values:{});let classes=values.map(value=>(0,_nameClass.formatClass)(utilName,value));if(options===null||options===void 0?void 0:options.supportsNegativeValues){classes=[...classes,...classes.map(cls=>\"-\"+cls)];classes=[...classes,...classes.map(cls=>cls.slice(0,prefixLength)+\"-\"+cls.slice(prefixLength))]}if(options.types.some(({type})=>type===\"color\")){classes=[...classes,...classes.flatMap(cls=>Object.keys(context.tailwindConfig.theme.opacity).map(opacity=>`${cls}/${opacity}`))]}if(checkImportantUtils&&(options===null||options===void 0?void 0:options.respectImportant)){classes=[...classes,...classes.map(cls=>\"!\"+cls)]}return classes})():[util];for(let util2 of utils){for(let{pattern,variants=[]}of checks){pattern.lastIndex=0;if(!patternMatchingCount.has(pattern)){patternMatchingCount.set(pattern,0)}if(!pattern.test(util2))continue;patternMatchingCount.set(pattern,patternMatchingCount.get(pattern)+1);context.changedContent.push({content:util2,extension:\"html\"});for(let variant of variants){context.changedContent.push({content:variant+context.tailwindConfig.separator+util2,extension:\"html\"})}}}}for(let[regex,count]of patternMatchingCount.entries()){if(count!==0)continue;_log.default.warn([`The safelist pattern \\`${regex}\\` doesn't match any Tailwind CSS classes.`,\"Fix this pattern or remove it from your `safelist` configuration.\",\"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"])}}}var _context_tailwindConfig_darkMode,_concat_;let darkClassName=(_concat_=[].concat((_context_tailwindConfig_darkMode=context.tailwindConfig.darkMode)!==null&&_context_tailwindConfig_darkMode!==void 0?_context_tailwindConfig_darkMode:\"media\")[1])!==null&&_concat_!==void 0?_concat_:\"dark\";let parasiteUtilities=[prefix(context,darkClassName),prefix(context,\"group\"),prefix(context,\"peer\")];context.getClassOrder=__name(function getClassOrder(classes){let sorted=[...classes].sort((a,z)=>{if(a===z)return 0;if(a<z)return-1;return 1});let sortedClassNames=new Map(sorted.map(className=>[className,null]));let rules=(0,_generateRules.generateRules)(new Set(sorted),context);rules=context.offsets.sort(rules);let idx=BigInt(parasiteUtilities.length);for(const[,rule]of rules){sortedClassNames.set(rule.raws.tailwind.candidate,idx++)}return classes.map(className=>{var _sortedClassNames_get;let order=(_sortedClassNames_get=sortedClassNames.get(className))!==null&&_sortedClassNames_get!==void 0?_sortedClassNames_get:null;let parasiteIndex=parasiteUtilities.indexOf(className);if(order===null&&parasiteIndex!==-1){order=BigInt(parasiteIndex)}return[className,order]})},\"getClassOrder\");context.getClassList=__name(function getClassList(options={}){let output=[];for(let util of classList){if(Array.isArray(util)){var _utilOptions_types;let[utilName,utilOptions]=util;let negativeClasses=[];var _utilOptions_modifiers;let modifiers=Object.keys((_utilOptions_modifiers=utilOptions===null||utilOptions===void 0?void 0:utilOptions.modifiers)!==null&&_utilOptions_modifiers!==void 0?_utilOptions_modifiers:{});if(utilOptions===null||utilOptions===void 0?void 0:(_utilOptions_types=utilOptions.types)===null||_utilOptions_types===void 0?void 0:_utilOptions_types.some(({type})=>type===\"color\")){var _context_tailwindConfig_theme_opacity;modifiers.push(...Object.keys((_context_tailwindConfig_theme_opacity=context.tailwindConfig.theme.opacity)!==null&&_context_tailwindConfig_theme_opacity!==void 0?_context_tailwindConfig_theme_opacity:{}))}let metadata={modifiers};let includeMetadata=options.includeMetadata&&modifiers.length>0;var _utilOptions_values;for(let[key,value]of Object.entries((_utilOptions_values=utilOptions===null||utilOptions===void 0?void 0:utilOptions.values)!==null&&_utilOptions_values!==void 0?_utilOptions_values:{})){if(value==null){continue}let cls=(0,_nameClass.formatClass)(utilName,key);output.push(includeMetadata?[cls,metadata]:cls);if((utilOptions===null||utilOptions===void 0?void 0:utilOptions.supportsNegativeValues)&&(0,_negateValue.default)(value)){let cls2=(0,_nameClass.formatClass)(utilName,`-${key}`);negativeClasses.push(includeMetadata?[cls2,metadata]:cls2)}}output.push(...negativeClasses)}else{output.push(util)}}return output},\"getClassList\");context.getVariants=__name(function getVariants(){let result=[];for(let[name,options]of context.variantOptions.entries()){if(options.variantInfo===VARIANT_INFO.Base)continue;var _options_values;result.push({name,isArbitrary:options.type===Symbol.for(\"MATCH_VARIANT\"),values:Object.keys((_options_values=options.values)!==null&&_options_values!==void 0?_options_values:{}),hasDash:name!==\"@\",selectors({modifier,value}={}){let candidate=\"__TAILWIND_PLACEHOLDER__\";let rule=_postcss.default.rule({selector:`.${candidate}`});let container=_postcss.default.root({nodes:[rule.clone()]});let before=container.toString();var _context_variantMap_get;let fns=((_context_variantMap_get=context.variantMap.get(name))!==null&&_context_variantMap_get!==void 0?_context_variantMap_get:[]).flatMap(([_,fn])=>fn);let formatStrings=[];for(let fn of fns){var _options_values2;let localFormatStrings=[];var _options_values_value;let api={args:{modifier,value:(_options_values_value=(_options_values2=options.values)===null||_options_values2===void 0?void 0:_options_values2[value])!==null&&_options_values_value!==void 0?_options_values_value:value},separator:context.tailwindConfig.separator,modifySelectors(modifierFunction){container.each(rule2=>{if(rule2.type!==\"rule\"){return}rule2.selectors=rule2.selectors.map(selector=>{return modifierFunction({get className(){return(0,_generateRules.getClassNameFromSelector)(selector)},selector})})});return container},format(str){localFormatStrings.push(str)},wrap(wrapper){localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`)},container};let ruleWithVariant=fn(api);if(localFormatStrings.length>0){formatStrings.push(localFormatStrings)}if(Array.isArray(ruleWithVariant)){for(let variantFunction of ruleWithVariant){localFormatStrings=[];variantFunction(api);formatStrings.push(localFormatStrings)}}}let manualFormatStrings=[];let after=container.toString();if(before!==after){container.walkRules(rule2=>{let modified=rule2.selector;let rebuiltBase=(0,_postcssselectorparser.default)(selectors=>{selectors.walkClasses(classNode=>{classNode.value=`${name}${context.tailwindConfig.separator}${classNode.value}`})}).processSync(modified);manualFormatStrings.push(modified.replace(rebuiltBase,\"&\").replace(candidate,\"&\"))});container.walkAtRules(atrule=>{manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`)})}var _options_values1;let isArbitraryVariant=!(value in((_options_values1=options.values)!==null&&_options_values1!==void 0?_options_values1:{}));formatStrings=formatStrings.map(format=>format.map(str=>({format:str,isArbitraryVariant})));manualFormatStrings=manualFormatStrings.map(format=>({format,isArbitraryVariant}));let opts={candidate,context};let result2=formatStrings.map(formats=>(0,_formatVariantSelector.finalizeSelector)(`.${candidate}`,(0,_formatVariantSelector.formatVariantSelector)(formats,opts),opts).replace(`.${candidate}`,\"&\").replace(\"{ & }\",\"\").trim());if(manualFormatStrings.length>0){result2.push((0,_formatVariantSelector.formatVariantSelector)(manualFormatStrings,opts).toString().replace(`.${candidate}`,\"&\"))}return result2}})}return result},\"getVariants\")}__name(registerPlugins,\"registerPlugins\");function markInvalidUtilityCandidate(context,candidate){if(!context.classCache.has(candidate)){return}context.notClassCache.add(candidate);context.classCache.delete(candidate);context.applyClassCache.delete(candidate);context.candidateRuleMap.delete(candidate);context.candidateRuleCache.delete(candidate);context.stylesheetCache=null}__name(markInvalidUtilityCandidate,\"markInvalidUtilityCandidate\");function markInvalidUtilityNode(context,node){let candidate=node.raws.tailwind.candidate;if(!candidate){return}for(const entry of context.ruleCache){if(entry[1].raws.tailwind.candidate===candidate){context.ruleCache.delete(entry)}}markInvalidUtilityCandidate(context,candidate)}__name(markInvalidUtilityNode,\"markInvalidUtilityNode\");function createContext(tailwindConfig,changedContent=[],root=_postcss.default.root()){var _tailwindConfig_blocklist;let context={disposables:[],ruleCache:new Set,candidateRuleCache:new Map,classCache:new Map,applyClassCache:new Map,notClassCache:new Set((_tailwindConfig_blocklist=tailwindConfig.blocklist)!==null&&_tailwindConfig_blocklist!==void 0?_tailwindConfig_blocklist:[]),postCssNodeCache:new Map,candidateRuleMap:new Map,tailwindConfig,changedContent,variantMap:new Map,stylesheetCache:null,variantOptions:new Map,markInvalidUtilityCandidate:candidate=>markInvalidUtilityCandidate(context,candidate),markInvalidUtilityNode:node=>markInvalidUtilityNode(context,node)};let resolvedPlugins=resolvePlugins(context,root);registerPlugins(resolvedPlugins,context);return context}__name(createContext,\"createContext\");let contextMap=_sharedState.contextMap;let configContextMap=_sharedState.configContextMap;let contextSourcesMap=_sharedState.contextSourcesMap;function getContext(root,result,tailwindConfig,userConfigPath,tailwindConfigHash,contextDependencies){let sourcePath=result.opts.from;let isConfigFile=userConfigPath!==null;_sharedState.env.DEBUG&&console.log(\"Source path:\",sourcePath);let existingContext;if(isConfigFile&&contextMap.has(sourcePath)){existingContext=contextMap.get(sourcePath)}else if(configContextMap.has(tailwindConfigHash)){let context2=configContextMap.get(tailwindConfigHash);contextSourcesMap.get(context2).add(sourcePath);contextMap.set(sourcePath,context2);existingContext=context2}let cssDidChange=(0,_cacheInvalidation.hasContentChanged)(sourcePath,root);if(existingContext){let[contextDependenciesChanged,mtimesToCommit2]=trackModified([...contextDependencies],getFileModifiedMap(existingContext));if(!contextDependenciesChanged&&!cssDidChange){return[existingContext,false,mtimesToCommit2]}}if(contextMap.has(sourcePath)){let oldContext=contextMap.get(sourcePath);if(contextSourcesMap.has(oldContext)){contextSourcesMap.get(oldContext).delete(sourcePath);if(contextSourcesMap.get(oldContext).size===0){contextSourcesMap.delete(oldContext);for(let[tailwindConfigHash2,context2]of configContextMap){if(context2===oldContext){configContextMap.delete(tailwindConfigHash2)}}for(let disposable of oldContext.disposables.splice(0)){disposable(oldContext)}}}}_sharedState.env.DEBUG&&console.log(\"Setting up new context...\");let context=createContext(tailwindConfig,[],root);Object.assign(context,{userConfigPath});let[,mtimesToCommit]=trackModified([...contextDependencies],getFileModifiedMap(context));configContextMap.set(tailwindConfigHash,context);contextMap.set(sourcePath,context);if(!contextSourcesMap.has(context)){contextSourcesMap.set(context,new Set)}contextSourcesMap.get(context).add(sourcePath);return[context,true,mtimesToCommit]}__name(getContext,\"getContext\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["nodeInterop","prefix","type","api","util","cls","_options_values","rule","result","context","mtimesToCommit","tailwindConfigHash"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/lib/setupContextUtils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isValidVariantFormatString: function() {\n        return isValidVariantFormatString;\n    },\n    parseVariant: function() {\n        return parseVariant;\n    },\n    getFileModifiedMap: function() {\n        return getFileModifiedMap;\n    },\n    createContext: function() {\n        return createContext;\n    },\n    getContext: function() {\n        return getContext;\n    }\n});\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _url = /*#__PURE__*/ _interop_require_default(require(\"url\"));\nconst _postcss = /*#__PURE__*/ _interop_require_default(require(\"postcss\"));\nconst _dlv = /*#__PURE__*/ _interop_require_default(require(\"dlv\"));\nconst _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require(\"postcss-selector-parser\"));\nconst _transformThemeValue = /*#__PURE__*/ _interop_require_default(require(\"../util/transformThemeValue\"));\nconst _parseObjectStyles = /*#__PURE__*/ _interop_require_default(require(\"../util/parseObjectStyles\"));\nconst _prefixSelector = /*#__PURE__*/ _interop_require_default(require(\"../util/prefixSelector\"));\nconst _isPlainObject = /*#__PURE__*/ _interop_require_default(require(\"../util/isPlainObject\"));\nconst _escapeClassName = /*#__PURE__*/ _interop_require_default(require(\"../util/escapeClassName\"));\nconst _nameClass = /*#__PURE__*/ _interop_require_wildcard(require(\"../util/nameClass\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _corePlugins = require(\"../corePlugins\");\nconst _sharedState = /*#__PURE__*/ _interop_require_wildcard(require(\"./sharedState\"));\nconst _toPath = require(\"../util/toPath\");\nconst _log = /*#__PURE__*/ _interop_require_default(require(\"../util/log\"));\nconst _negateValue = /*#__PURE__*/ _interop_require_default(require(\"../util/negateValue\"));\nconst _isSyntacticallyValidPropertyValue = /*#__PURE__*/ _interop_require_default(require(\"../util/isSyntacticallyValidPropertyValue\"));\nconst _generateRules = require(\"./generateRules\");\nconst _cacheInvalidation = require(\"./cacheInvalidation.js\");\nconst _offsets = require(\"./offsets.js\");\nconst _featureFlags = require(\"../featureFlags.js\");\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst VARIANT_TYPES = {\n    AddVariant: Symbol.for(\"ADD_VARIANT\"),\n    MatchVariant: Symbol.for(\"MATCH_VARIANT\")\n};\nconst VARIANT_INFO = {\n    Base: 1 << 0,\n    Dynamic: 1 << 1\n};\nfunction prefix(context, selector) {\n    let prefix = context.tailwindConfig.prefix;\n    return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction normalizeOptionTypes({ type =\"any\" , ...options }) {\n    let types = [].concat(type);\n    return {\n        ...options,\n        types: types.map((type)=>{\n            if (Array.isArray(type)) {\n                return {\n                    type: type[0],\n                    ...type[1]\n                };\n            }\n            return {\n                type,\n                preferOnConflict: false\n            };\n        })\n    };\n}\nfunction parseVariantFormatString(input) {\n    /** @type {string[]} */ let parts = [];\n    // When parsing whitespace around special characters are insignificant\n    // However, _inside_ of a variant they could be\n    // Because the selector could look like this\n    // @media { &[data-name=\"foo bar\"] }\n    // This is why we do not skip whitespace\n    let current = \"\";\n    let depth = 0;\n    for(let idx = 0; idx < input.length; idx++){\n        let char = input[idx];\n        if (char === \"\\\\\") {\n            // Escaped characters are not special\n            current += \"\\\\\" + input[++idx];\n        } else if (char === \"{\") {\n            // Nested rule: start\n            ++depth;\n            parts.push(current.trim());\n            current = \"\";\n        } else if (char === \"}\") {\n            // Nested rule: end\n            if (--depth < 0) {\n                throw new Error(`Your { and } are unbalanced.`);\n            }\n            parts.push(current.trim());\n            current = \"\";\n        } else {\n            // Normal character\n            current += char;\n        }\n    }\n    if (current.length > 0) {\n        parts.push(current.trim());\n    }\n    parts = parts.filter((part)=>part !== \"\");\n    return parts;\n}\nfunction insertInto(list, value, { before =[]  } = {}) {\n    before = [].concat(before);\n    if (before.length <= 0) {\n        list.push(value);\n        return;\n    }\n    let idx = list.length - 1;\n    for (let other of before){\n        let iidx = list.indexOf(other);\n        if (iidx === -1) continue;\n        idx = Math.min(idx, iidx);\n    }\n    list.splice(idx, 0, value);\n}\nfunction parseStyles(styles) {\n    if (!Array.isArray(styles)) {\n        return parseStyles([\n            styles\n        ]);\n    }\n    return styles.flatMap((style)=>{\n        let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);\n        return isNode ? style : (0, _parseObjectStyles.default)(style);\n    });\n}\nfunction getClasses(selector, mutate) {\n    let parser = (0, _postcssselectorparser.default)((selectors)=>{\n        let allClasses = [];\n        if (mutate) {\n            mutate(selectors);\n        }\n        selectors.walkClasses((classNode)=>{\n            allClasses.push(classNode.value);\n        });\n        return allClasses;\n    });\n    return parser.transformSync(selector);\n}\nfunction extractCandidates(node, state = {\n    containsNonOnDemandable: false\n}, depth = 0) {\n    let classes = [];\n    // Handle normal rules\n    if (node.type === \"rule\") {\n        // Ignore everything inside a :not(...). This allows you to write code like\n        // `div:not(.foo)`. If `.foo` is never found in your code, then we used to\n        // not generated it. But now we will ignore everything inside a `:not`, so\n        // that it still gets generated.\n        function ignoreNot(selectors) {\n            selectors.walkPseudos((pseudo)=>{\n                if (pseudo.value === \":not\") {\n                    pseudo.remove();\n                }\n            });\n        }\n        for (let selector of node.selectors){\n            let classCandidates = getClasses(selector, ignoreNot);\n            // At least one of the selectors contains non-\"on-demandable\" candidates.\n            if (classCandidates.length === 0) {\n                state.containsNonOnDemandable = true;\n            }\n            for (let classCandidate of classCandidates){\n                classes.push(classCandidate);\n            }\n        }\n    } else if (node.type === \"atrule\") {\n        node.walkRules((rule)=>{\n            for (let classCandidate of rule.selectors.flatMap((selector)=>getClasses(selector))){\n                classes.push(classCandidate);\n            }\n        });\n    }\n    if (depth === 0) {\n        return [\n            state.containsNonOnDemandable || classes.length === 0,\n            classes\n        ];\n    }\n    return classes;\n}\nfunction withIdentifiers(styles) {\n    return parseStyles(styles).flatMap((node)=>{\n        let nodeMap = new Map();\n        let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);\n        // If this isn't \"on-demandable\", assign it a universal candidate to always include it.\n        if (containsNonOnDemandableSelectors) {\n            candidates.unshift(_sharedState.NOT_ON_DEMAND);\n        }\n        // However, it could be that it also contains \"on-demandable\" candidates.\n        // E.g.: `span, .foo {}`, in that case it should still be possible to use\n        // `@apply foo` for example.\n        return candidates.map((c)=>{\n            if (!nodeMap.has(node)) {\n                nodeMap.set(node, node);\n            }\n            return [\n                c,\n                nodeMap.get(node)\n            ];\n        });\n    });\n}\nfunction isValidVariantFormatString(format) {\n    return format.startsWith(\"@\") || format.includes(\"&\");\n}\nfunction parseVariant(variant) {\n    variant = variant.replace(/\\n+/g, \"\").replace(/\\s{1,}/g, \" \").trim();\n    let fns = parseVariantFormatString(variant).map((str)=>{\n        if (!str.startsWith(\"@\")) {\n            return ({ format  })=>format(str);\n        }\n        let [, name, params] = /@(.*?)( .+|[({].*)/g.exec(str);\n        return ({ wrap  })=>wrap(_postcss.default.atRule({\n                name,\n                params: params.trim()\n            }));\n    }).reverse();\n    return (api)=>{\n        for (let fn of fns){\n            fn(api);\n        }\n    };\n}\n/**\n *\n * @param {any} tailwindConfig\n * @param {any} context\n * @param {object} param2\n * @param {Offsets} param2.offsets\n */ function buildPluginApi(tailwindConfig, context, { variantList , variantMap , offsets , classList  }) {\n    function getConfigValue(path, defaultValue) {\n        return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;\n    }\n    function applyConfiguredPrefix(selector) {\n        return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);\n    }\n    function prefixIdentifier(identifier, options) {\n        if (identifier === _sharedState.NOT_ON_DEMAND) {\n            return _sharedState.NOT_ON_DEMAND;\n        }\n        if (!options.respectPrefix) {\n            return identifier;\n        }\n        return context.tailwindConfig.prefix + identifier;\n    }\n    function resolveThemeValue(path, defaultValue, opts = {}) {\n        let parts = (0, _toPath.toPath)(path);\n        let value = getConfigValue([\n            \"theme\",\n            ...parts\n        ], defaultValue);\n        return (0, _transformThemeValue.default)(parts[0])(value, opts);\n    }\n    let variantIdentifier = 0;\n    let api = {\n        postcss: _postcss.default,\n        prefix: applyConfiguredPrefix,\n        e: _escapeClassName.default,\n        config: getConfigValue,\n        theme: resolveThemeValue,\n        corePlugins: (path)=>{\n            if (Array.isArray(tailwindConfig.corePlugins)) {\n                return tailwindConfig.corePlugins.includes(path);\n            }\n            return getConfigValue([\n                \"corePlugins\",\n                path\n            ], true);\n        },\n        variants: ()=>{\n            // Preserved for backwards compatibility but not used in v3.0+\n            return [];\n        },\n        addBase (base) {\n            for (let [identifier, rule] of withIdentifiers(base)){\n                let prefixedIdentifier = prefixIdentifier(identifier, {});\n                let offset = offsets.create(\"base\");\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offset,\n                        layer: \"base\"\n                    },\n                    rule\n                ]);\n            }\n        },\n        /**\n     * @param {string} group\n     * @param {Record<string, string | string[]>} declarations\n     */ addDefaults (group, declarations) {\n            const groups = {\n                [`@defaults ${group}`]: declarations\n            };\n            for (let [identifier, rule] of withIdentifiers(groups)){\n                let prefixedIdentifier = prefixIdentifier(identifier, {});\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.create(\"defaults\"),\n                        layer: \"defaults\"\n                    },\n                    rule\n                ]);\n            }\n        },\n        addComponents (components, options) {\n            let defaultOptions = {\n                preserveSource: false,\n                respectPrefix: true,\n                respectImportant: false\n            };\n            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n            for (let [identifier, rule] of withIdentifiers(components)){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                classList.add(prefixedIdentifier);\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.create(\"components\"),\n                        layer: \"components\",\n                        options\n                    },\n                    rule\n                ]);\n            }\n        },\n        addUtilities (utilities, options) {\n            let defaultOptions = {\n                preserveSource: false,\n                respectPrefix: true,\n                respectImportant: true\n            };\n            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n            for (let [identifier, rule] of withIdentifiers(utilities)){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                classList.add(prefixedIdentifier);\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.create(\"utilities\"),\n                        layer: \"utilities\",\n                        options\n                    },\n                    rule\n                ]);\n            }\n        },\n        matchUtilities: function(utilities, options) {\n            let defaultOptions = {\n                respectPrefix: true,\n                respectImportant: true,\n                modifiers: false\n            };\n            options = normalizeOptionTypes({\n                ...defaultOptions,\n                ...options\n            });\n            let offset = offsets.create(\"utilities\");\n            for(let identifier in utilities){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                let rule = utilities[identifier];\n                classList.add([\n                    prefixedIdentifier,\n                    options\n                ]);\n                function wrapped(modifier, { isOnlyPlugin  }) {\n                    let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n                    if (value === undefined) {\n                        return [];\n                    }\n                    if (!options.types.some(({ type  })=>type === coercedType)) {\n                        if (isOnlyPlugin) {\n                            _log.default.warn([\n                                `Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`,\n                                `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`\n                            ]);\n                        } else {\n                            return [];\n                        }\n                    }\n                    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n                        return [];\n                    }\n                    let extras = {\n                        get modifier () {\n                            if (!options.modifiers) {\n                                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\n                                    \"Your plugin must set `modifiers: true` in its options to support modifiers.\"\n                                ]);\n                            }\n                            return utilityModifier;\n                        }\n                    };\n                    let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n                    let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration)=>({\n                            [(0, _nameClass.default)(identifier, modifier)]: declaration\n                        }));\n                    return ruleSets;\n                }\n                let withOffsets = [\n                    {\n                        sort: offset,\n                        layer: \"utilities\",\n                        options\n                    },\n                    wrapped\n                ];\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n            }\n        },\n        matchComponents: function(components, options) {\n            let defaultOptions = {\n                respectPrefix: true,\n                respectImportant: false,\n                modifiers: false\n            };\n            options = normalizeOptionTypes({\n                ...defaultOptions,\n                ...options\n            });\n            let offset = offsets.create(\"components\");\n            for(let identifier in components){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                let rule = components[identifier];\n                classList.add([\n                    prefixedIdentifier,\n                    options\n                ]);\n                function wrapped(modifier, { isOnlyPlugin  }) {\n                    let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n                    if (value === undefined) {\n                        return [];\n                    }\n                    if (!options.types.some(({ type  })=>type === coercedType)) {\n                        if (isOnlyPlugin) {\n                            _log.default.warn([\n                                `Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`,\n                                `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`\n                            ]);\n                        } else {\n                            return [];\n                        }\n                    }\n                    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n                        return [];\n                    }\n                    let extras = {\n                        get modifier () {\n                            if (!options.modifiers) {\n                                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\n                                    \"Your plugin must set `modifiers: true` in its options to support modifiers.\"\n                                ]);\n                            }\n                            return utilityModifier;\n                        }\n                    };\n                    let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n                    let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration)=>({\n                            [(0, _nameClass.default)(identifier, modifier)]: declaration\n                        }));\n                    return ruleSets;\n                }\n                let withOffsets = [\n                    {\n                        sort: offset,\n                        layer: \"components\",\n                        options\n                    },\n                    wrapped\n                ];\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n            }\n        },\n        addVariant (variantName, variantFunctions, options = {}) {\n            variantFunctions = [].concat(variantFunctions).map((variantFunction)=>{\n                if (typeof variantFunction !== \"string\") {\n                    // Safelist public API functions\n                    return (api = {})=>{\n                        let { args , modifySelectors , container , separator , wrap , format  } = api;\n                        let result = variantFunction(Object.assign({\n                            modifySelectors,\n                            container,\n                            separator\n                        }, options.type === VARIANT_TYPES.MatchVariant && {\n                            args,\n                            wrap,\n                            format\n                        }));\n                        if (typeof result === \"string\" && !isValidVariantFormatString(result)) {\n                            throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n                        }\n                        if (Array.isArray(result)) {\n                            return result.filter((variant)=>typeof variant === \"string\").map((variant)=>parseVariant(variant));\n                        }\n                        // result may be undefined with legacy variants that use APIs like `modifySelectors`\n                        // result may also be a postcss node if someone was returning the result from `modifySelectors`\n                        return result && typeof result === \"string\" && parseVariant(result)(api);\n                    };\n                }\n                if (!isValidVariantFormatString(variantFunction)) {\n                    throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n                }\n                return parseVariant(variantFunction);\n            });\n            insertInto(variantList, variantName, options);\n            variantMap.set(variantName, variantFunctions);\n            context.variantOptions.set(variantName, options);\n        },\n        matchVariant (variant, variantFn, options) {\n            var _options_id;\n            // A unique identifier that \"groups\" these variants together.\n            // This is for internal use only which is why it is not present in the types\n            let id = (_options_id = options === null || options === void 0 ? void 0 : options.id) !== null && _options_id !== void 0 ? _options_id : ++variantIdentifier;\n            let isSpecial = variant === \"@\";\n            let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n            var _options_values;\n            for (let [key, value] of Object.entries((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {})){\n                if (key === \"DEFAULT\") continue;\n                api.addVariant(isSpecial ? `${variant}${key}` : `${variant}-${key}`, ({ args , container  })=>{\n                    return variantFn(value, modifiersEnabled ? {\n                        modifier: args === null || args === void 0 ? void 0 : args.modifier,\n                        container\n                    } : {\n                        container\n                    });\n                }, {\n                    ...options,\n                    value,\n                    id,\n                    type: VARIANT_TYPES.MatchVariant,\n                    variantInfo: VARIANT_INFO.Base\n                });\n            }\n            var _options_values1;\n            let hasDefault = \"DEFAULT\" in ((_options_values1 = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {});\n            api.addVariant(variant, ({ args , container  })=>{\n                if ((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE && !hasDefault) {\n                    return null;\n                }\n                var // (JetBrains) plugins.\n                _args_value;\n                return variantFn((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE ? options.values.DEFAULT : (_args_value = args === null || args === void 0 ? void 0 : args.value) !== null && _args_value !== void 0 ? _args_value : typeof args === \"string\" ? args : \"\", modifiersEnabled ? {\n                    modifier: args === null || args === void 0 ? void 0 : args.modifier,\n                    container\n                } : {\n                    container\n                });\n            }, {\n                ...options,\n                id,\n                type: VARIANT_TYPES.MatchVariant,\n                variantInfo: VARIANT_INFO.Dynamic\n            });\n        }\n    };\n    return api;\n}\nlet fileModifiedMapCache = new WeakMap();\nfunction getFileModifiedMap(context) {\n    if (!fileModifiedMapCache.has(context)) {\n        fileModifiedMapCache.set(context, new Map());\n    }\n    return fileModifiedMapCache.get(context);\n}\nfunction trackModified(files, fileModifiedMap) {\n    let changed = false;\n    let mtimesToCommit = new Map();\n    for (let file of files){\n        var _fs_statSync;\n        if (!file) continue;\n        let parsed = _url.default.parse(file);\n        let pathname = parsed.hash ? parsed.href.replace(parsed.hash, \"\") : parsed.href;\n        pathname = parsed.search ? pathname.replace(parsed.search, \"\") : pathname;\n        let newModified = (_fs_statSync = _fs.default.statSync(decodeURIComponent(pathname), {\n            throwIfNoEntry: false\n        })) === null || _fs_statSync === void 0 ? void 0 : _fs_statSync.mtimeMs;\n        if (!newModified) {\n            continue;\n        }\n        if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n            changed = true;\n        }\n        mtimesToCommit.set(file, newModified);\n    }\n    return [\n        changed,\n        mtimesToCommit\n    ];\n}\nfunction extractVariantAtRules(node) {\n    node.walkAtRules((atRule)=>{\n        if ([\n            \"responsive\",\n            \"variants\"\n        ].includes(atRule.name)) {\n            extractVariantAtRules(atRule);\n            atRule.before(atRule.nodes);\n            atRule.remove();\n        }\n    });\n}\nfunction collectLayerPlugins(root) {\n    let layerPlugins = [];\n    root.each((node)=>{\n        if (node.type === \"atrule\" && [\n            \"responsive\",\n            \"variants\"\n        ].includes(node.name)) {\n            node.name = \"layer\";\n            node.params = \"utilities\";\n        }\n    });\n    // Walk @layer rules and treat them like plugins\n    root.walkAtRules(\"layer\", (layerRule)=>{\n        extractVariantAtRules(layerRule);\n        if (layerRule.params === \"base\") {\n            for (let node of layerRule.nodes){\n                layerPlugins.push(function({ addBase  }) {\n                    addBase(node, {\n                        respectPrefix: false\n                    });\n                });\n            }\n            layerRule.remove();\n        } else if (layerRule.params === \"components\") {\n            for (let node of layerRule.nodes){\n                layerPlugins.push(function({ addComponents  }) {\n                    addComponents(node, {\n                        respectPrefix: false,\n                        preserveSource: true\n                    });\n                });\n            }\n            layerRule.remove();\n        } else if (layerRule.params === \"utilities\") {\n            for (let node of layerRule.nodes){\n                layerPlugins.push(function({ addUtilities  }) {\n                    addUtilities(node, {\n                        respectPrefix: false,\n                        preserveSource: true\n                    });\n                });\n            }\n            layerRule.remove();\n        }\n    });\n    return layerPlugins;\n}\nfunction resolvePlugins(context, root) {\n    let corePluginList = Object.entries({\n        ..._corePlugins.variantPlugins,\n        ..._corePlugins.corePlugins\n    }).map(([name, plugin])=>{\n        if (!context.tailwindConfig.corePlugins.includes(name)) {\n            return null;\n        }\n        return plugin;\n    }).filter(Boolean);\n    let userPlugins = context.tailwindConfig.plugins.map((plugin)=>{\n        if (plugin.__isOptionsFunction) {\n            plugin = plugin();\n        }\n        return typeof plugin === \"function\" ? plugin : plugin.handler;\n    });\n    let layerPlugins = collectLayerPlugins(root);\n    // TODO: This is a workaround for backwards compatibility, since custom variants\n    // were historically sorted before screen/stackable variants.\n    let beforeVariants = [\n        _corePlugins.variantPlugins[\"pseudoElementVariants\"],\n        _corePlugins.variantPlugins[\"pseudoClassVariants\"],\n        _corePlugins.variantPlugins[\"ariaVariants\"],\n        _corePlugins.variantPlugins[\"dataVariants\"]\n    ];\n    let afterVariants = [\n        _corePlugins.variantPlugins[\"supportsVariants\"],\n        _corePlugins.variantPlugins[\"directionVariants\"],\n        _corePlugins.variantPlugins[\"reducedMotionVariants\"],\n        _corePlugins.variantPlugins[\"prefersContrastVariants\"],\n        _corePlugins.variantPlugins[\"darkVariants\"],\n        _corePlugins.variantPlugins[\"printVariant\"],\n        _corePlugins.variantPlugins[\"screenVariants\"],\n        _corePlugins.variantPlugins[\"orientationVariants\"]\n    ];\n    return [\n        ...corePluginList,\n        ...beforeVariants,\n        ...userPlugins,\n        ...afterVariants,\n        ...layerPlugins\n    ];\n}\nfunction registerPlugins(plugins, context) {\n    let variantList = [];\n    let variantMap = new Map();\n    context.variantMap = variantMap;\n    let offsets = new _offsets.Offsets();\n    context.offsets = offsets;\n    let classList = new Set();\n    let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n        variantList,\n        variantMap,\n        offsets,\n        classList\n    });\n    for (let plugin of plugins){\n        if (Array.isArray(plugin)) {\n            for (let pluginItem of plugin){\n                pluginItem(pluginApi);\n            }\n        } else {\n            plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);\n        }\n    }\n    // Make sure to record bit masks for every variant\n    offsets.recordVariants(variantList, (variant)=>variantMap.get(variant).length);\n    // Build variantMap\n    for (let [variantName, variantFunctions] of variantMap.entries()){\n        context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx)=>[\n                offsets.forVariant(variantName, idx),\n                variantFunction\n            ]));\n    }\n    var _context_tailwindConfig_safelist;\n    let safelist = ((_context_tailwindConfig_safelist = context.tailwindConfig.safelist) !== null && _context_tailwindConfig_safelist !== void 0 ? _context_tailwindConfig_safelist : []).filter(Boolean);\n    if (safelist.length > 0) {\n        let checks = [];\n        for (let value of safelist){\n            if (typeof value === \"string\") {\n                context.changedContent.push({\n                    content: value,\n                    extension: \"html\"\n                });\n                continue;\n            }\n            if (value instanceof RegExp) {\n                _log.default.warn(\"root-regex\", [\n                    \"Regular expressions in `safelist` work differently in Tailwind CSS v3.0.\",\n                    \"Update your `safelist` configuration to eliminate this warning.\",\n                    \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"\n                ]);\n                continue;\n            }\n            checks.push(value);\n        }\n        if (checks.length > 0) {\n            let patternMatchingCount = new Map();\n            let prefixLength = context.tailwindConfig.prefix.length;\n            let checkImportantUtils = checks.some((check)=>check.pattern.source.includes(\"!\"));\n            for (let util of classList){\n                let utils = Array.isArray(util) ? (()=>{\n                    let [utilName, options] = util;\n                    var _options_values;\n                    let values = Object.keys((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {});\n                    let classes = values.map((value)=>(0, _nameClass.formatClass)(utilName, value));\n                    if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {\n                        // This is the normal negated version\n                        // e.g. `-inset-1` or `-tw-inset-1`\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>\"-\" + cls)\n                        ];\n                        // This is the negated version *after* the prefix\n                        // e.g. `tw--inset-1`\n                        // The prefix is already attached to util name\n                        // So we add the negative after the prefix\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>cls.slice(0, prefixLength) + \"-\" + cls.slice(prefixLength))\n                        ];\n                    }\n                    if (options.types.some(({ type  })=>type === \"color\")) {\n                        classes = [\n                            ...classes,\n                            ...classes.flatMap((cls)=>Object.keys(context.tailwindConfig.theme.opacity).map((opacity)=>`${cls}/${opacity}`))\n                        ];\n                    }\n                    if (checkImportantUtils && (options === null || options === void 0 ? void 0 : options.respectImportant)) {\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>\"!\" + cls)\n                        ];\n                    }\n                    return classes;\n                })() : [\n                    util\n                ];\n                for (let util of utils){\n                    for (let { pattern , variants =[]  } of checks){\n                        // RegExp with the /g flag are stateful, so let's reset the last\n                        // index pointer to reset the state.\n                        pattern.lastIndex = 0;\n                        if (!patternMatchingCount.has(pattern)) {\n                            patternMatchingCount.set(pattern, 0);\n                        }\n                        if (!pattern.test(util)) continue;\n                        patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);\n                        context.changedContent.push({\n                            content: util,\n                            extension: \"html\"\n                        });\n                        for (let variant of variants){\n                            context.changedContent.push({\n                                content: variant + context.tailwindConfig.separator + util,\n                                extension: \"html\"\n                            });\n                        }\n                    }\n                }\n            }\n            for (let [regex, count] of patternMatchingCount.entries()){\n                if (count !== 0) continue;\n                _log.default.warn([\n                    `The safelist pattern \\`${regex}\\` doesn't match any Tailwind CSS classes.`,\n                    \"Fix this pattern or remove it from your `safelist` configuration.\",\n                    \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"\n                ]);\n            }\n        }\n    }\n    var _context_tailwindConfig_darkMode, _concat_;\n    let darkClassName = (_concat_ = [].concat((_context_tailwindConfig_darkMode = context.tailwindConfig.darkMode) !== null && _context_tailwindConfig_darkMode !== void 0 ? _context_tailwindConfig_darkMode : \"media\")[1]) !== null && _concat_ !== void 0 ? _concat_ : \"dark\";\n    // A list of utilities that are used by certain Tailwind CSS utilities but\n    // that don't exist on their own. This will result in them \"not existing\" and\n    // sorting could be weird since you still require them in order to make the\n    // host utilities work properly. (Thanks Biology)\n    let parasiteUtilities = [\n        prefix(context, darkClassName),\n        prefix(context, \"group\"),\n        prefix(context, \"peer\")\n    ];\n    context.getClassOrder = function getClassOrder(classes) {\n        // Sort classes so they're ordered in a deterministic manner\n        let sorted = [\n            ...classes\n        ].sort((a, z)=>{\n            if (a === z) return 0;\n            if (a < z) return -1;\n            return 1;\n        });\n        // Non-util classes won't be generated, so we default them to null\n        let sortedClassNames = new Map(sorted.map((className)=>[\n                className,\n                null\n            ]));\n        // Sort all classes in order\n        // Non-tailwind classes won't be generated and will be left as `null`\n        let rules = (0, _generateRules.generateRules)(new Set(sorted), context);\n        rules = context.offsets.sort(rules);\n        let idx = BigInt(parasiteUtilities.length);\n        for (const [, rule] of rules){\n            sortedClassNames.set(rule.raws.tailwind.candidate, idx++);\n        }\n        return classes.map((className)=>{\n            var _sortedClassNames_get;\n            let order = (_sortedClassNames_get = sortedClassNames.get(className)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : null;\n            let parasiteIndex = parasiteUtilities.indexOf(className);\n            if (order === null && parasiteIndex !== -1) {\n                // This will make sure that it is at the very beginning of the\n                // `components` layer which technically means 'before any\n                // components'.\n                order = BigInt(parasiteIndex);\n            }\n            return [\n                className,\n                order\n            ];\n        });\n    };\n    // Generate a list of strings for autocompletion purposes, e.g.\n    // ['uppercase', 'lowercase', ...]\n    context.getClassList = function getClassList(options = {}) {\n        let output = [];\n        for (let util of classList){\n            if (Array.isArray(util)) {\n                var _utilOptions_types;\n                let [utilName, utilOptions] = util;\n                let negativeClasses = [];\n                var _utilOptions_modifiers;\n                let modifiers = Object.keys((_utilOptions_modifiers = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.modifiers) !== null && _utilOptions_modifiers !== void 0 ? _utilOptions_modifiers : {});\n                if (utilOptions === null || utilOptions === void 0 ? void 0 : (_utilOptions_types = utilOptions.types) === null || _utilOptions_types === void 0 ? void 0 : _utilOptions_types.some(({ type  })=>type === \"color\")) {\n                    var _context_tailwindConfig_theme_opacity;\n                    modifiers.push(...Object.keys((_context_tailwindConfig_theme_opacity = context.tailwindConfig.theme.opacity) !== null && _context_tailwindConfig_theme_opacity !== void 0 ? _context_tailwindConfig_theme_opacity : {}));\n                }\n                let metadata = {\n                    modifiers\n                };\n                let includeMetadata = options.includeMetadata && modifiers.length > 0;\n                var _utilOptions_values;\n                for (let [key, value] of Object.entries((_utilOptions_values = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.values) !== null && _utilOptions_values !== void 0 ? _utilOptions_values : {})){\n                    // Ignore undefined and null values\n                    if (value == null) {\n                        continue;\n                    }\n                    let cls = (0, _nameClass.formatClass)(utilName, key);\n                    output.push(includeMetadata ? [\n                        cls,\n                        metadata\n                    ] : cls);\n                    if ((utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.supportsNegativeValues) && (0, _negateValue.default)(value)) {\n                        let cls = (0, _nameClass.formatClass)(utilName, `-${key}`);\n                        negativeClasses.push(includeMetadata ? [\n                            cls,\n                            metadata\n                        ] : cls);\n                    }\n                }\n                output.push(...negativeClasses);\n            } else {\n                output.push(util);\n            }\n        }\n        return output;\n    };\n    // Generate a list of available variants with meta information of the type of variant.\n    context.getVariants = function getVariants() {\n        let result = [];\n        for (let [name, options] of context.variantOptions.entries()){\n            if (options.variantInfo === VARIANT_INFO.Base) continue;\n            var _options_values;\n            result.push({\n                name,\n                isArbitrary: options.type === Symbol.for(\"MATCH_VARIANT\"),\n                values: Object.keys((_options_values = options.values) !== null && _options_values !== void 0 ? _options_values : {}),\n                hasDash: name !== \"@\",\n                selectors ({ modifier , value  } = {}) {\n                    let candidate = \"__TAILWIND_PLACEHOLDER__\";\n                    let rule = _postcss.default.rule({\n                        selector: `.${candidate}`\n                    });\n                    let container = _postcss.default.root({\n                        nodes: [\n                            rule.clone()\n                        ]\n                    });\n                    let before = container.toString();\n                    var _context_variantMap_get;\n                    let fns = ((_context_variantMap_get = context.variantMap.get(name)) !== null && _context_variantMap_get !== void 0 ? _context_variantMap_get : []).flatMap(([_, fn])=>fn);\n                    let formatStrings = [];\n                    for (let fn of fns){\n                        var _options_values;\n                        let localFormatStrings = [];\n                        var _options_values_value;\n                        let api = {\n                            args: {\n                                modifier,\n                                value: (_options_values_value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[value]) !== null && _options_values_value !== void 0 ? _options_values_value : value\n                            },\n                            separator: context.tailwindConfig.separator,\n                            modifySelectors (modifierFunction) {\n                                // Run the modifierFunction over each rule\n                                container.each((rule)=>{\n                                    if (rule.type !== \"rule\") {\n                                        return;\n                                    }\n                                    rule.selectors = rule.selectors.map((selector)=>{\n                                        return modifierFunction({\n                                            get className () {\n                                                return (0, _generateRules.getClassNameFromSelector)(selector);\n                                            },\n                                            selector\n                                        });\n                                    });\n                                });\n                                return container;\n                            },\n                            format (str) {\n                                localFormatStrings.push(str);\n                            },\n                            wrap (wrapper) {\n                                localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);\n                            },\n                            container\n                        };\n                        let ruleWithVariant = fn(api);\n                        if (localFormatStrings.length > 0) {\n                            formatStrings.push(localFormatStrings);\n                        }\n                        if (Array.isArray(ruleWithVariant)) {\n                            for (let variantFunction of ruleWithVariant){\n                                localFormatStrings = [];\n                                variantFunction(api);\n                                formatStrings.push(localFormatStrings);\n                            }\n                        }\n                    }\n                    // Reverse engineer the result of the `container`\n                    let manualFormatStrings = [];\n                    let after = container.toString();\n                    if (before !== after) {\n                        // Figure out all selectors\n                        container.walkRules((rule)=>{\n                            let modified = rule.selector;\n                            // Rebuild the base selector, this is what plugin authors would do\n                            // as well. E.g.: `${variant}${separator}${className}`.\n                            // However, plugin authors probably also prepend or append certain\n                            // classes, pseudos, ids, ...\n                            let rebuiltBase = (0, _postcssselectorparser.default)((selectors)=>{\n                                selectors.walkClasses((classNode)=>{\n                                    classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;\n                                });\n                            }).processSync(modified);\n                            // Now that we know the original selector, the new selector, and\n                            // the rebuild part in between, we can replace the part that plugin\n                            // authors need to rebuild with `&`, and eventually store it in the\n                            // collectedFormats. Similar to what `format('...')` would do.\n                            //\n                            // E.g.:\n                            //                   variant: foo\n                            //                  selector: .markdown > p\n                            //      modified (by plugin): .foo .foo\\\\:markdown > p\n                            //    rebuiltBase (internal): .foo\\\\:markdown > p\n                            //                    format: .foo &\n                            manualFormatStrings.push(modified.replace(rebuiltBase, \"&\").replace(candidate, \"&\"));\n                        });\n                        // Figure out all atrules\n                        container.walkAtRules((atrule)=>{\n                            manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);\n                        });\n                    }\n                    var _options_values1;\n                    let isArbitraryVariant = !(value in ((_options_values1 = options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {}));\n                    formatStrings = formatStrings.map((format)=>format.map((str)=>({\n                                format: str,\n                                isArbitraryVariant\n                            })));\n                    manualFormatStrings = manualFormatStrings.map((format)=>({\n                            format,\n                            isArbitraryVariant\n                        }));\n                    let opts = {\n                        candidate,\n                        context\n                    };\n                    let result = formatStrings.map((formats)=>(0, _formatVariantSelector.finalizeSelector)(`.${candidate}`, (0, _formatVariantSelector.formatVariantSelector)(formats, opts), opts).replace(`.${candidate}`, \"&\").replace(\"{ & }\", \"\").trim());\n                    if (manualFormatStrings.length > 0) {\n                        result.push((0, _formatVariantSelector.formatVariantSelector)(manualFormatStrings, opts).toString().replace(`.${candidate}`, \"&\"));\n                    }\n                    return result;\n                }\n            });\n        }\n        return result;\n    };\n}\n/**\n * Mark as class as retroactively invalid\n *\n *\n * @param {string} candidate\n */ function markInvalidUtilityCandidate(context, candidate) {\n    if (!context.classCache.has(candidate)) {\n        return;\n    }\n    // Mark this as not being a real utility\n    context.notClassCache.add(candidate);\n    // Remove it from any candidate-specific caches\n    context.classCache.delete(candidate);\n    context.applyClassCache.delete(candidate);\n    context.candidateRuleMap.delete(candidate);\n    context.candidateRuleCache.delete(candidate);\n    // Ensure the stylesheet gets rebuilt\n    context.stylesheetCache = null;\n}\n/**\n * Mark as class as retroactively invalid\n *\n * @param {import('postcss').Node} node\n */ function markInvalidUtilityNode(context, node) {\n    let candidate = node.raws.tailwind.candidate;\n    if (!candidate) {\n        return;\n    }\n    for (const entry of context.ruleCache){\n        if (entry[1].raws.tailwind.candidate === candidate) {\n            context.ruleCache.delete(entry);\n        // context.postCssNodeCache.delete(node)\n        }\n    }\n    markInvalidUtilityCandidate(context, candidate);\n}\nfunction createContext(tailwindConfig, changedContent = [], root = _postcss.default.root()) {\n    var _tailwindConfig_blocklist;\n    let context = {\n        disposables: [],\n        ruleCache: new Set(),\n        candidateRuleCache: new Map(),\n        classCache: new Map(),\n        applyClassCache: new Map(),\n        // Seed the not class cache with the blocklist (which is only strings)\n        notClassCache: new Set((_tailwindConfig_blocklist = tailwindConfig.blocklist) !== null && _tailwindConfig_blocklist !== void 0 ? _tailwindConfig_blocklist : []),\n        postCssNodeCache: new Map(),\n        candidateRuleMap: new Map(),\n        tailwindConfig,\n        changedContent: changedContent,\n        variantMap: new Map(),\n        stylesheetCache: null,\n        variantOptions: new Map(),\n        markInvalidUtilityCandidate: (candidate)=>markInvalidUtilityCandidate(context, candidate),\n        markInvalidUtilityNode: (node)=>markInvalidUtilityNode(context, node)\n    };\n    let resolvedPlugins = resolvePlugins(context, root);\n    registerPlugins(resolvedPlugins, context);\n    return context;\n}\nlet contextMap = _sharedState.contextMap;\nlet configContextMap = _sharedState.configContextMap;\nlet contextSourcesMap = _sharedState.contextSourcesMap;\nfunction getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n    let sourcePath = result.opts.from;\n    let isConfigFile = userConfigPath !== null;\n    _sharedState.env.DEBUG && console.log(\"Source path:\", sourcePath);\n    let existingContext;\n    if (isConfigFile && contextMap.has(sourcePath)) {\n        existingContext = contextMap.get(sourcePath);\n    } else if (configContextMap.has(tailwindConfigHash)) {\n        let context = configContextMap.get(tailwindConfigHash);\n        contextSourcesMap.get(context).add(sourcePath);\n        contextMap.set(sourcePath, context);\n        existingContext = context;\n    }\n    let cssDidChange = (0, _cacheInvalidation.hasContentChanged)(sourcePath, root);\n    // If there's already a context in the cache and we don't need to\n    // reset the context, return the cached context.\n    if (existingContext) {\n        let [contextDependenciesChanged, mtimesToCommit] = trackModified([\n            ...contextDependencies\n        ], getFileModifiedMap(existingContext));\n        if (!contextDependenciesChanged && !cssDidChange) {\n            return [\n                existingContext,\n                false,\n                mtimesToCommit\n            ];\n        }\n    }\n    // If this source is in the context map, get the old context.\n    // Remove this source from the context sources for the old context,\n    // and clean up that context if no one else is using it. This can be\n    // called by many processes in rapid succession, so we check for presence\n    // first because the first process to run this code will wipe it out first.\n    if (contextMap.has(sourcePath)) {\n        let oldContext = contextMap.get(sourcePath);\n        if (contextSourcesMap.has(oldContext)) {\n            contextSourcesMap.get(oldContext).delete(sourcePath);\n            if (contextSourcesMap.get(oldContext).size === 0) {\n                contextSourcesMap.delete(oldContext);\n                for (let [tailwindConfigHash, context] of configContextMap){\n                    if (context === oldContext) {\n                        configContextMap.delete(tailwindConfigHash);\n                    }\n                }\n                for (let disposable of oldContext.disposables.splice(0)){\n                    disposable(oldContext);\n                }\n            }\n        }\n    }\n    _sharedState.env.DEBUG && console.log(\"Setting up new context...\");\n    let context = createContext(tailwindConfig, [], root);\n    Object.assign(context, {\n        userConfigPath\n    });\n    let [, mtimesToCommit] = trackModified([\n        ...contextDependencies\n    ], getFileModifiedMap(context));\n    // ---\n    // Update all context tracking state\n    configContextMap.set(tailwindConfigHash, context);\n    contextMap.set(sourcePath, context);\n    if (!contextSourcesMap.has(context)) {\n        contextSourcesMap.set(context, new Set());\n    }\n    contextSourcesMap.get(context).add(sourcePath);\n    return [\n        context,\n        true,\n        mtimesToCommit\n    ];\n}\n"]}}