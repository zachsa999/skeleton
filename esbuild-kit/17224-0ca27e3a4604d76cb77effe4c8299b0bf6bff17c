{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _flow=require(\"../plugins/flow\");var _typescript=require(\"../plugins/typescript\");var _index=require(\"../tokenizer/index\");var _keywords=require(\"../tokenizer/keywords\");var _types=require(\"../tokenizer/types\");var _base=require(\"./base\");var _expression=require(\"./expression\");var _util=require(\"./util\");function parseSpread(){_index.next.call(void 0);_expression.parseMaybeAssign.call(void 0,false)}__name(parseSpread,\"parseSpread\");exports.parseSpread=parseSpread;function parseRest(isBlockScope){_index.next.call(void 0);parseBindingAtom(isBlockScope)}__name(parseRest,\"parseRest\");exports.parseRest=parseRest;function parseBindingIdentifier(isBlockScope){_expression.parseIdentifier.call(void 0);markPriorBindingIdentifier(isBlockScope)}__name(parseBindingIdentifier,\"parseBindingIdentifier\");exports.parseBindingIdentifier=parseBindingIdentifier;function parseImportedIdentifier(){_expression.parseIdentifier.call(void 0);_base.state.tokens[_base.state.tokens.length-1].identifierRole=_index.IdentifierRole.ImportDeclaration}__name(parseImportedIdentifier,\"parseImportedIdentifier\");exports.parseImportedIdentifier=parseImportedIdentifier;function markPriorBindingIdentifier(isBlockScope){let identifierRole;if(_base.state.scopeDepth===0){identifierRole=_index.IdentifierRole.TopLevelDeclaration}else if(isBlockScope){identifierRole=_index.IdentifierRole.BlockScopedDeclaration}else{identifierRole=_index.IdentifierRole.FunctionScopedDeclaration}_base.state.tokens[_base.state.tokens.length-1].identifierRole=identifierRole}__name(markPriorBindingIdentifier,\"markPriorBindingIdentifier\");exports.markPriorBindingIdentifier=markPriorBindingIdentifier;function parseBindingAtom(isBlockScope){switch(_base.state.type){case _types.TokenType._this:{const oldIsType=_index.pushTypeContext.call(void 0,0);_index.next.call(void 0);_index.popTypeContext.call(void 0,oldIsType);return}case _types.TokenType._yield:case _types.TokenType.name:{_base.state.type=_types.TokenType.name;parseBindingIdentifier(isBlockScope);return}case _types.TokenType.bracketL:{_index.next.call(void 0);parseBindingList(_types.TokenType.bracketR,isBlockScope,true);return}case _types.TokenType.braceL:_expression.parseObj.call(void 0,true,isBlockScope);return;default:_util.unexpected.call(void 0)}}__name(parseBindingAtom,\"parseBindingAtom\");exports.parseBindingAtom=parseBindingAtom;function parseBindingList(close,isBlockScope,allowEmpty=false,allowModifiers=false,contextId=0){let first=true;let hasRemovedComma=false;const firstItemTokenIndex=_base.state.tokens.length;while(!_index.eat.call(void 0,close)&&!_base.state.error){if(first){first=false}else{_util.expect.call(void 0,_types.TokenType.comma);_base.state.tokens[_base.state.tokens.length-1].contextId=contextId;if(!hasRemovedComma&&_base.state.tokens[firstItemTokenIndex].isType){_base.state.tokens[_base.state.tokens.length-1].isType=true;hasRemovedComma=true}}if(allowEmpty&&_index.match.call(void 0,_types.TokenType.comma)){}else if(_index.eat.call(void 0,close)){break}else if(_index.match.call(void 0,_types.TokenType.ellipsis)){parseRest(isBlockScope);parseAssignableListItemTypes();_index.eat.call(void 0,_types.TokenType.comma);_util.expect.call(void 0,close);break}else{parseAssignableListItem(allowModifiers,isBlockScope)}}}__name(parseBindingList,\"parseBindingList\");exports.parseBindingList=parseBindingList;function parseAssignableListItem(allowModifiers,isBlockScope){if(allowModifiers){_typescript.tsParseModifiers.call(void 0,[_keywords.ContextualKeyword._public,_keywords.ContextualKeyword._protected,_keywords.ContextualKeyword._private,_keywords.ContextualKeyword._readonly,_keywords.ContextualKeyword._override])}parseMaybeDefault(isBlockScope);parseAssignableListItemTypes();parseMaybeDefault(isBlockScope,true)}__name(parseAssignableListItem,\"parseAssignableListItem\");function parseAssignableListItemTypes(){if(_base.isFlowEnabled){_flow.flowParseAssignableListItemTypes.call(void 0)}else if(_base.isTypeScriptEnabled){_typescript.tsParseAssignableListItemTypes.call(void 0)}}__name(parseAssignableListItemTypes,\"parseAssignableListItemTypes\");function parseMaybeDefault(isBlockScope,leftAlreadyParsed=false){if(!leftAlreadyParsed){parseBindingAtom(isBlockScope)}if(!_index.eat.call(void 0,_types.TokenType.eq)){return}const eqIndex=_base.state.tokens.length-1;_expression.parseMaybeAssign.call(void 0);_base.state.tokens[eqIndex].rhsEndIndex=_base.state.tokens.length}__name(parseMaybeDefault,\"parseMaybeDefault\");exports.parseMaybeDefault=parseMaybeDefault;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/parser/traverser/lval.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});var _flow = require('../plugins/flow');\nvar _typescript = require('../plugins/typescript');\n\n\n\n\n\n\n\nvar _index = require('../tokenizer/index');\nvar _keywords = require('../tokenizer/keywords');\nvar _types = require('../tokenizer/types');\nvar _base = require('./base');\nvar _expression = require('./expression');\nvar _util = require('./util');\n\n function parseSpread() {\n  _index.next.call(void 0, );\n  _expression.parseMaybeAssign.call(void 0, false);\n} exports.parseSpread = parseSpread;\n\n function parseRest(isBlockScope) {\n  _index.next.call(void 0, );\n  parseBindingAtom(isBlockScope);\n} exports.parseRest = parseRest;\n\n function parseBindingIdentifier(isBlockScope) {\n  _expression.parseIdentifier.call(void 0, );\n  markPriorBindingIdentifier(isBlockScope);\n} exports.parseBindingIdentifier = parseBindingIdentifier;\n\n function parseImportedIdentifier() {\n  _expression.parseIdentifier.call(void 0, );\n  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;\n} exports.parseImportedIdentifier = parseImportedIdentifier;\n\n function markPriorBindingIdentifier(isBlockScope) {\n  let identifierRole;\n  if (_base.state.scopeDepth === 0) {\n    identifierRole = _index.IdentifierRole.TopLevelDeclaration;\n  } else if (isBlockScope) {\n    identifierRole = _index.IdentifierRole.BlockScopedDeclaration;\n  } else {\n    identifierRole = _index.IdentifierRole.FunctionScopedDeclaration;\n  }\n  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;\n} exports.markPriorBindingIdentifier = markPriorBindingIdentifier;\n\n// Parses lvalue (assignable) atom.\n function parseBindingAtom(isBlockScope) {\n  switch (_base.state.type) {\n    case _types.TokenType._this: {\n      // In TypeScript, \"this\" may be the name of a parameter, so allow it.\n      const oldIsType = _index.pushTypeContext.call(void 0, 0);\n      _index.next.call(void 0, );\n      _index.popTypeContext.call(void 0, oldIsType);\n      return;\n    }\n\n    case _types.TokenType._yield:\n    case _types.TokenType.name: {\n      _base.state.type = _types.TokenType.name;\n      parseBindingIdentifier(isBlockScope);\n      return;\n    }\n\n    case _types.TokenType.bracketL: {\n      _index.next.call(void 0, );\n      parseBindingList(_types.TokenType.bracketR, isBlockScope, true /* allowEmpty */);\n      return;\n    }\n\n    case _types.TokenType.braceL:\n      _expression.parseObj.call(void 0, true, isBlockScope);\n      return;\n\n    default:\n      _util.unexpected.call(void 0, );\n  }\n} exports.parseBindingAtom = parseBindingAtom;\n\n function parseBindingList(\n  close,\n  isBlockScope,\n  allowEmpty = false,\n  allowModifiers = false,\n  contextId = 0,\n) {\n  let first = true;\n\n  let hasRemovedComma = false;\n  const firstItemTokenIndex = _base.state.tokens.length;\n\n  while (!_index.eat.call(void 0, close) && !_base.state.error) {\n    if (first) {\n      first = false;\n    } else {\n      _util.expect.call(void 0, _types.TokenType.comma);\n      _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;\n      // After a \"this\" type in TypeScript, we need to set the following comma (if any) to also be\n      // a type token so that it will be removed.\n      if (!hasRemovedComma && _base.state.tokens[firstItemTokenIndex].isType) {\n        _base.state.tokens[_base.state.tokens.length - 1].isType = true;\n        hasRemovedComma = true;\n      }\n    }\n    if (allowEmpty && _index.match.call(void 0, _types.TokenType.comma)) {\n      // Empty item; nothing further to parse for this item.\n    } else if (_index.eat.call(void 0, close)) {\n      break;\n    } else if (_index.match.call(void 0, _types.TokenType.ellipsis)) {\n      parseRest(isBlockScope);\n      parseAssignableListItemTypes();\n      // Support rest element trailing commas allowed by TypeScript <2.9.\n      _index.eat.call(void 0, _types.TokenType.comma);\n      _util.expect.call(void 0, close);\n      break;\n    } else {\n      parseAssignableListItem(allowModifiers, isBlockScope);\n    }\n  }\n} exports.parseBindingList = parseBindingList;\n\nfunction parseAssignableListItem(allowModifiers, isBlockScope) {\n  if (allowModifiers) {\n    _typescript.tsParseModifiers.call(void 0, [\n      _keywords.ContextualKeyword._public,\n      _keywords.ContextualKeyword._protected,\n      _keywords.ContextualKeyword._private,\n      _keywords.ContextualKeyword._readonly,\n      _keywords.ContextualKeyword._override,\n    ]);\n  }\n\n  parseMaybeDefault(isBlockScope);\n  parseAssignableListItemTypes();\n  parseMaybeDefault(isBlockScope, true /* leftAlreadyParsed */);\n}\n\nfunction parseAssignableListItemTypes() {\n  if (_base.isFlowEnabled) {\n    _flow.flowParseAssignableListItemTypes.call(void 0, );\n  } else if (_base.isTypeScriptEnabled) {\n    _typescript.tsParseAssignableListItemTypes.call(void 0, );\n  }\n}\n\n// Parses assignment pattern around given atom if possible.\n function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {\n  if (!leftAlreadyParsed) {\n    parseBindingAtom(isBlockScope);\n  }\n  if (!_index.eat.call(void 0, _types.TokenType.eq)) {\n    return;\n  }\n  const eqIndex = _base.state.tokens.length - 1;\n  _expression.parseMaybeAssign.call(void 0, );\n  _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;\n} exports.parseMaybeDefault = parseMaybeDefault;\n"]}}