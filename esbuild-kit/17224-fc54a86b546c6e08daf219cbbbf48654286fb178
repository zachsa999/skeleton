{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const path=require(\"path\");const joinMedia=require(\"./lib/join-media\");const joinLayer=require(\"./lib/join-layer\");const resolveId=require(\"./lib/resolve-id\");const loadContent=require(\"./lib/load-content\");const processContent=require(\"./lib/process-content\");const parseStatements=require(\"./lib/parse-statements\");const assignLayerNames=require(\"./lib/assign-layer-names\");const dataURL=require(\"./lib/data-url\");function AtImport(options){options={root:process.cwd(),path:[],skipDuplicates:true,resolve:resolveId,load:loadContent,plugins:[],addModulesDirectories:[],nameLayer:null,...options};options.root=path.resolve(options.root);if(typeof options.path===\"string\")options.path=[options.path];if(!Array.isArray(options.path))options.path=[];options.path=options.path.map(p=>path.resolve(options.root,p));return{postcssPlugin:\"postcss-import\",Once(styles,{result,atRule,postcss}){const state={importedFiles:{},hashFiles:{},rootFilename:null,anonymousLayerCounter:0};if(styles.source?.input?.file){state.rootFilename=styles.source.input.file;state.importedFiles[styles.source.input.file]={}}if(options.plugins&&!Array.isArray(options.plugins)){throw new Error(\"plugins option must be an array\")}if(options.nameLayer&&typeof options.nameLayer!==\"function\"){throw new Error(\"nameLayer option must be a function\")}return parseStyles(result,styles,options,state,[],[]).then(bundle=>{applyRaws(bundle);applyMedia(bundle);applyStyles(bundle,styles)});function applyRaws(bundle){bundle.forEach((stmt,index)=>{if(index===0)return;if(stmt.parent){const{before}=stmt.parent.node.raws;if(stmt.type===\"nodes\")stmt.nodes[0].raws.before=before;else stmt.node.raws.before=before}else if(stmt.type===\"nodes\"){stmt.nodes[0].raws.before=stmt.nodes[0].raws.before||\"\\n\"}})}__name(applyRaws,\"applyRaws\");function applyMedia(bundle){bundle.forEach(stmt=>{if(!stmt.media.length&&!stmt.layer.length||stmt.type===\"charset\"){return}if(stmt.layer.length>1){assignLayerNames(stmt.layer,stmt.node,state,options)}if(stmt.type===\"import\"){const parts=[stmt.fullUri];const media=stmt.media.join(\", \");if(stmt.layer.length){const layerName=stmt.layer.join(\".\");let layerParams=\"layer\";if(layerName){layerParams=`layer(${layerName})`}parts.push(layerParams)}if(media){parts.push(media)}stmt.node.params=parts.join(\" \")}else if(stmt.type===\"media\"){if(stmt.layer.length){const layerNode=atRule({name:\"layer\",params:stmt.layer.join(\".\"),source:stmt.node.source});if(stmt.parentMedia?.length){const mediaNode=atRule({name:\"media\",params:stmt.parentMedia.join(\", \"),source:stmt.node.source});mediaNode.append(layerNode);layerNode.append(stmt.node);stmt.node=mediaNode}else{layerNode.append(stmt.node);stmt.node=layerNode}}else{stmt.node.params=stmt.media.join(\", \")}}else{const{nodes}=stmt;const{parent}=nodes[0];let outerAtRule;let innerAtRule;if(stmt.media.length&&stmt.layer.length){const mediaNode=atRule({name:\"media\",params:stmt.media.join(\", \"),source:parent.source});const layerNode=atRule({name:\"layer\",params:stmt.layer.join(\".\"),source:parent.source});mediaNode.append(layerNode);innerAtRule=layerNode;outerAtRule=mediaNode}else if(stmt.media.length){const mediaNode=atRule({name:\"media\",params:stmt.media.join(\", \"),source:parent.source});innerAtRule=mediaNode;outerAtRule=mediaNode}else if(stmt.layer.length){const layerNode=atRule({name:\"layer\",params:stmt.layer.join(\".\"),source:parent.source});innerAtRule=layerNode;outerAtRule=layerNode}parent.insertBefore(nodes[0],outerAtRule);nodes.forEach(node=>{node.parent=void 0});nodes[0].raws.before=nodes[0].raws.before||\"\\n\";innerAtRule.append(nodes);stmt.type=\"media\";stmt.node=outerAtRule;delete stmt.nodes}})}__name(applyMedia,\"applyMedia\");function applyStyles(bundle,styles2){styles2.nodes=[];bundle.forEach(stmt=>{if([\"charset\",\"import\",\"media\"].includes(stmt.type)){stmt.node.parent=void 0;styles2.append(stmt.node)}else if(stmt.type===\"nodes\"){stmt.nodes.forEach(node=>{node.parent=void 0;styles2.append(node)})}})}__name(applyStyles,\"applyStyles\");function parseStyles(result2,styles2,options2,state2,media,layer){const statements=parseStatements(result2,styles2);return Promise.resolve(statements).then(stmts=>{return stmts.reduce((promise,stmt)=>{return promise.then(()=>{stmt.media=joinMedia(media,stmt.media||[]);stmt.parentMedia=media;stmt.layer=joinLayer(layer,stmt.layer||[]);if(stmt.type!==\"import\"||/^(?:[a-z]+:)?\\/\\//i.test(stmt.uri)){return}if(options2.filter&&!options2.filter(stmt.uri)){return}return resolveImportId(result2,stmt,options2,state2)})},Promise.resolve())}).then(()=>{let charset;const imports=[];const bundle=[];function handleCharset(stmt){if(!charset)charset=stmt;else if(stmt.node.params.toLowerCase()!==charset.node.params.toLowerCase()){throw new Error(`Incompatable @charset statements:\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\n  ${charset.node.params} specified in ${charset.node.source.input.file}`)}}__name(handleCharset,\"handleCharset\");statements.forEach(stmt=>{if(stmt.type===\"charset\")handleCharset(stmt);else if(stmt.type===\"import\"){if(stmt.children){stmt.children.forEach((child,index)=>{if(child.type===\"import\")imports.push(child);else if(child.type===\"charset\")handleCharset(child);else bundle.push(child);if(index===0)child.parent=stmt})}else imports.push(stmt)}else if(stmt.type===\"media\"||stmt.type===\"nodes\"){bundle.push(stmt)}});return charset?[charset,...imports.concat(bundle)]:imports.concat(bundle)})}__name(parseStyles,\"parseStyles\");function resolveImportId(result2,stmt,options2,state2){if(dataURL.isValid(stmt.uri)){return loadImportContent(result2,stmt,stmt.uri,options2,state2).then(result3=>{stmt.children=result3})}const atRule2=stmt.node;let sourceFile;if(atRule2.source?.input?.file){sourceFile=atRule2.source.input.file}const base=sourceFile?path.dirname(atRule2.source.input.file):options2.root;return Promise.resolve(options2.resolve(stmt.uri,base,options2)).then(paths=>{if(!Array.isArray(paths))paths=[paths];return Promise.all(paths.map(file=>{return!path.isAbsolute(file)?resolveId(file,base,options2):file}))}).then(resolved=>{resolved.forEach(file=>{result2.messages.push({type:\"dependency\",plugin:\"postcss-import\",file,parent:sourceFile})});return Promise.all(resolved.map(file=>{return loadImportContent(result2,stmt,file,options2,state2)}))}).then(result3=>{stmt.children=result3.reduce((result4,statements)=>{return statements?result4.concat(statements):result4},[])})}__name(resolveImportId,\"resolveImportId\");function loadImportContent(result2,stmt,filename,options2,state2){const atRule2=stmt.node;const{media,layer}=stmt;assignLayerNames(layer,atRule2,state2,options2);if(options2.skipDuplicates){if(state2.importedFiles[filename]?.[media]?.[layer]){return}if(!state2.importedFiles[filename]){state2.importedFiles[filename]={}}if(!state2.importedFiles[filename][media]){state2.importedFiles[filename][media]={}}state2.importedFiles[filename][media][layer]=true}return Promise.resolve(options2.load(filename,options2)).then(content=>{if(content.trim()===\"\"){result2.warn(`${filename} is empty`,{node:atRule2});return}if(state2.hashFiles[content]?.[media]?.[layer]){return}return processContent(result2,content,filename,options2,postcss).then(importedResult=>{const styles2=importedResult.root;result2.messages=result2.messages.concat(importedResult.messages);if(options2.skipDuplicates){const hasImport=styles2.some(child=>{return child.type===\"atrule\"&&child.name===\"import\"});if(!hasImport){if(!state2.hashFiles[content]){state2.hashFiles[content]={}}if(!state2.hashFiles[content][media]){state2.hashFiles[content][media]={}}state2.hashFiles[content][media][layer]=true}}return parseStyles(result2,styles2,options2,state2,media,layer)})})}__name(loadImportContent,\"loadImportContent\")}}}__name(AtImport,\"AtImport\");AtImport.postcss=true;module.exports=AtImport;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["styles","result","options","state","atRule"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/postcss-import@15.1.0_postcss@8.4.24/node_modules/postcss-import/index.js"],"sourcesContent":["\"use strict\"\n// builtin tooling\nconst path = require(\"path\")\n\n// internal tooling\nconst joinMedia = require(\"./lib/join-media\")\nconst joinLayer = require(\"./lib/join-layer\")\nconst resolveId = require(\"./lib/resolve-id\")\nconst loadContent = require(\"./lib/load-content\")\nconst processContent = require(\"./lib/process-content\")\nconst parseStatements = require(\"./lib/parse-statements\")\nconst assignLayerNames = require(\"./lib/assign-layer-names\")\nconst dataURL = require(\"./lib/data-url\")\n\nfunction AtImport(options) {\n  options = {\n    root: process.cwd(),\n    path: [],\n    skipDuplicates: true,\n    resolve: resolveId,\n    load: loadContent,\n    plugins: [],\n    addModulesDirectories: [],\n    nameLayer: null,\n    ...options,\n  }\n\n  options.root = path.resolve(options.root)\n\n  // convert string to an array of a single element\n  if (typeof options.path === \"string\") options.path = [options.path]\n\n  if (!Array.isArray(options.path)) options.path = []\n\n  options.path = options.path.map(p => path.resolve(options.root, p))\n\n  return {\n    postcssPlugin: \"postcss-import\",\n    Once(styles, { result, atRule, postcss }) {\n      const state = {\n        importedFiles: {},\n        hashFiles: {},\n        rootFilename: null,\n        anonymousLayerCounter: 0,\n      }\n\n      if (styles.source?.input?.file) {\n        state.rootFilename = styles.source.input.file\n        state.importedFiles[styles.source.input.file] = {}\n      }\n\n      if (options.plugins && !Array.isArray(options.plugins)) {\n        throw new Error(\"plugins option must be an array\")\n      }\n\n      if (options.nameLayer && typeof options.nameLayer !== \"function\") {\n        throw new Error(\"nameLayer option must be a function\")\n      }\n\n      return parseStyles(result, styles, options, state, [], []).then(\n        bundle => {\n          applyRaws(bundle)\n          applyMedia(bundle)\n          applyStyles(bundle, styles)\n        }\n      )\n\n      function applyRaws(bundle) {\n        bundle.forEach((stmt, index) => {\n          if (index === 0) return\n\n          if (stmt.parent) {\n            const { before } = stmt.parent.node.raws\n            if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before\n            else stmt.node.raws.before = before\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\"\n          }\n        })\n      }\n\n      function applyMedia(bundle) {\n        bundle.forEach(stmt => {\n          if (\n            (!stmt.media.length && !stmt.layer.length) ||\n            stmt.type === \"charset\"\n          ) {\n            return\n          }\n\n          if (stmt.layer.length > 1) {\n            assignLayerNames(stmt.layer, stmt.node, state, options)\n          }\n\n          if (stmt.type === \"import\") {\n            const parts = [stmt.fullUri]\n\n            const media = stmt.media.join(\", \")\n\n            if (stmt.layer.length) {\n              const layerName = stmt.layer.join(\".\")\n\n              let layerParams = \"layer\"\n              if (layerName) {\n                layerParams = `layer(${layerName})`\n              }\n\n              parts.push(layerParams)\n            }\n\n            if (media) {\n              parts.push(media)\n            }\n\n            stmt.node.params = parts.join(\" \")\n          } else if (stmt.type === \"media\") {\n            if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: stmt.node.source,\n              })\n\n              if (stmt.parentMedia?.length) {\n                const mediaNode = atRule({\n                  name: \"media\",\n                  params: stmt.parentMedia.join(\", \"),\n                  source: stmt.node.source,\n                })\n\n                mediaNode.append(layerNode)\n                layerNode.append(stmt.node)\n                stmt.node = mediaNode\n              } else {\n                layerNode.append(stmt.node)\n                stmt.node = layerNode\n              }\n            } else {\n              stmt.node.params = stmt.media.join(\", \")\n            }\n          } else {\n            const { nodes } = stmt\n            const { parent } = nodes[0]\n\n            let outerAtRule\n            let innerAtRule\n            if (stmt.media.length && stmt.layer.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source,\n              })\n\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: parent.source,\n              })\n\n              mediaNode.append(layerNode)\n              innerAtRule = layerNode\n              outerAtRule = mediaNode\n            } else if (stmt.media.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source,\n              })\n\n              innerAtRule = mediaNode\n              outerAtRule = mediaNode\n            } else if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: parent.source,\n              })\n\n              innerAtRule = layerNode\n              outerAtRule = layerNode\n            }\n\n            parent.insertBefore(nodes[0], outerAtRule)\n\n            // remove nodes\n            nodes.forEach(node => {\n              node.parent = undefined\n            })\n\n            // better output\n            nodes[0].raws.before = nodes[0].raws.before || \"\\n\"\n\n            // wrap new rules with media query and/or layer at rule\n            innerAtRule.append(nodes)\n\n            stmt.type = \"media\"\n            stmt.node = outerAtRule\n            delete stmt.nodes\n          }\n        })\n      }\n\n      function applyStyles(bundle, styles) {\n        styles.nodes = []\n\n        // Strip additional statements.\n        bundle.forEach(stmt => {\n          if ([\"charset\", \"import\", \"media\"].includes(stmt.type)) {\n            stmt.node.parent = undefined\n            styles.append(stmt.node)\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes.forEach(node => {\n              node.parent = undefined\n              styles.append(node)\n            })\n          }\n        })\n      }\n\n      function parseStyles(result, styles, options, state, media, layer) {\n        const statements = parseStatements(result, styles)\n\n        return Promise.resolve(statements)\n          .then(stmts => {\n            // process each statement in series\n            return stmts.reduce((promise, stmt) => {\n              return promise.then(() => {\n                stmt.media = joinMedia(media, stmt.media || [])\n                stmt.parentMedia = media\n                stmt.layer = joinLayer(layer, stmt.layer || [])\n\n                // skip protocol base uri (protocol://url) or protocol-relative\n                if (\n                  stmt.type !== \"import\" ||\n                  /^(?:[a-z]+:)?\\/\\//i.test(stmt.uri)\n                ) {\n                  return\n                }\n\n                if (options.filter && !options.filter(stmt.uri)) {\n                  // rejected by filter\n                  return\n                }\n\n                return resolveImportId(result, stmt, options, state)\n              })\n            }, Promise.resolve())\n          })\n          .then(() => {\n            let charset\n            const imports = []\n            const bundle = []\n\n            function handleCharset(stmt) {\n              if (!charset) charset = stmt\n              // charsets aren't case-sensitive, so convert to lower case to compare\n              else if (\n                stmt.node.params.toLowerCase() !==\n                charset.node.params.toLowerCase()\n              ) {\n                throw new Error(\n                  `Incompatable @charset statements:\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\n  ${charset.node.params} specified in ${charset.node.source.input.file}`\n                )\n              }\n            }\n\n            // squash statements and their children\n            statements.forEach(stmt => {\n              if (stmt.type === \"charset\") handleCharset(stmt)\n              else if (stmt.type === \"import\") {\n                if (stmt.children) {\n                  stmt.children.forEach((child, index) => {\n                    if (child.type === \"import\") imports.push(child)\n                    else if (child.type === \"charset\") handleCharset(child)\n                    else bundle.push(child)\n                    // For better output\n                    if (index === 0) child.parent = stmt\n                  })\n                } else imports.push(stmt)\n              } else if (stmt.type === \"media\" || stmt.type === \"nodes\") {\n                bundle.push(stmt)\n              }\n            })\n\n            return charset\n              ? [charset, ...imports.concat(bundle)]\n              : imports.concat(bundle)\n          })\n      }\n\n      function resolveImportId(result, stmt, options, state) {\n        if (dataURL.isValid(stmt.uri)) {\n          return loadImportContent(result, stmt, stmt.uri, options, state).then(\n            result => {\n              stmt.children = result\n            }\n          )\n        }\n\n        const atRule = stmt.node\n        let sourceFile\n        if (atRule.source?.input?.file) {\n          sourceFile = atRule.source.input.file\n        }\n        const base = sourceFile\n          ? path.dirname(atRule.source.input.file)\n          : options.root\n\n        return Promise.resolve(options.resolve(stmt.uri, base, options))\n          .then(paths => {\n            if (!Array.isArray(paths)) paths = [paths]\n            // Ensure that each path is absolute:\n            return Promise.all(\n              paths.map(file => {\n                return !path.isAbsolute(file)\n                  ? resolveId(file, base, options)\n                  : file\n              })\n            )\n          })\n          .then(resolved => {\n            // Add dependency messages:\n            resolved.forEach(file => {\n              result.messages.push({\n                type: \"dependency\",\n                plugin: \"postcss-import\",\n                file,\n                parent: sourceFile,\n              })\n            })\n\n            return Promise.all(\n              resolved.map(file => {\n                return loadImportContent(result, stmt, file, options, state)\n              })\n            )\n          })\n          .then(result => {\n            // Merge loaded statements\n            stmt.children = result.reduce((result, statements) => {\n              return statements ? result.concat(statements) : result\n            }, [])\n          })\n      }\n\n      function loadImportContent(result, stmt, filename, options, state) {\n        const atRule = stmt.node\n        const { media, layer } = stmt\n\n        assignLayerNames(layer, atRule, state, options)\n\n        if (options.skipDuplicates) {\n          // skip files already imported at the same scope\n          if (state.importedFiles[filename]?.[media]?.[layer]) {\n            return\n          }\n\n          // save imported files to skip them next time\n          if (!state.importedFiles[filename]) {\n            state.importedFiles[filename] = {}\n          }\n          if (!state.importedFiles[filename][media]) {\n            state.importedFiles[filename][media] = {}\n          }\n          state.importedFiles[filename][media][layer] = true\n        }\n\n        return Promise.resolve(options.load(filename, options)).then(\n          content => {\n            if (content.trim() === \"\") {\n              result.warn(`${filename} is empty`, { node: atRule })\n              return\n            }\n\n            // skip previous imported files not containing @import rules\n            if (state.hashFiles[content]?.[media]?.[layer]) {\n              return\n            }\n\n            return processContent(\n              result,\n              content,\n              filename,\n              options,\n              postcss\n            ).then(importedResult => {\n              const styles = importedResult.root\n              result.messages = result.messages.concat(importedResult.messages)\n\n              if (options.skipDuplicates) {\n                const hasImport = styles.some(child => {\n                  return child.type === \"atrule\" && child.name === \"import\"\n                })\n                if (!hasImport) {\n                  // save hash files to skip them next time\n                  if (!state.hashFiles[content]) {\n                    state.hashFiles[content] = {}\n                  }\n                  if (!state.hashFiles[content][media]) {\n                    state.hashFiles[content][media] = {}\n                  }\n                  state.hashFiles[content][media][layer] = true\n                }\n              }\n\n              // recursion: import @import from imported file\n              return parseStyles(result, styles, options, state, media, layer)\n            })\n          }\n        )\n      }\n    },\n  }\n}\n\nAtImport.postcss = true\n\nmodule.exports = AtImport\n"]}}