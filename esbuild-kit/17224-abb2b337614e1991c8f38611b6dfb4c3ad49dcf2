{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interopRequireDefault,\"_interopRequireDefault\");var _keywords=require(\"../parser/tokenizer/keywords\");var _types=require(\"../parser/tokenizer/types\");var _elideImportEquals=require(\"../util/elideImportEquals\");var _elideImportEquals2=_interopRequireDefault(_elideImportEquals);var _getDeclarationInfo=require(\"../util/getDeclarationInfo\");var _getDeclarationInfo2=_interopRequireDefault(_getDeclarationInfo);var _getImportExportSpecifierInfo=require(\"../util/getImportExportSpecifierInfo\");var _getImportExportSpecifierInfo2=_interopRequireDefault(_getImportExportSpecifierInfo);var _getNonTypeIdentifiers=require(\"../util/getNonTypeIdentifiers\");var _removeMaybeImportAssertion=require(\"../util/removeMaybeImportAssertion\");var _shouldElideDefaultExport=require(\"../util/shouldElideDefaultExport\");var _shouldElideDefaultExport2=_interopRequireDefault(_shouldElideDefaultExport);var _Transformer=require(\"./Transformer\");var _Transformer2=_interopRequireDefault(_Transformer);class ESMImportTransformer extends _Transformer2.default{constructor(tokens,nameManager,helperManager,reactHotLoaderTransformer,isTypeScriptTransformEnabled,options){super();this.tokens=tokens;this.nameManager=nameManager;this.helperManager=helperManager;this.reactHotLoaderTransformer=reactHotLoaderTransformer;this.isTypeScriptTransformEnabled=isTypeScriptTransformEnabled;;this.nonTypeIdentifiers=isTypeScriptTransformEnabled?_getNonTypeIdentifiers.getNonTypeIdentifiers.call(void 0,tokens,options):new Set;this.declarationInfo=isTypeScriptTransformEnabled?_getDeclarationInfo2.default.call(void 0,tokens):_getDeclarationInfo.EMPTY_DECLARATION_INFO;this.injectCreateRequireForImportRequire=Boolean(options.injectCreateRequireForImportRequire)}process(){if(this.tokens.matches3(_types.TokenType._import,_types.TokenType.name,_types.TokenType.eq)){return this.processImportEquals()}if(this.tokens.matches4(_types.TokenType._import,_types.TokenType.name,_types.TokenType.name,_types.TokenType.eq)&&this.tokens.matchesContextualAtIndex(this.tokens.currentIndex()+1,_keywords.ContextualKeyword._type)){this.tokens.removeInitialToken();for(let i=0;i<7;i++){this.tokens.removeToken()}return true}if(this.tokens.matches2(_types.TokenType._export,_types.TokenType.eq)){this.tokens.replaceToken(\"module.exports\");return true}if(this.tokens.matches5(_types.TokenType._export,_types.TokenType._import,_types.TokenType.name,_types.TokenType.name,_types.TokenType.eq)&&this.tokens.matchesContextualAtIndex(this.tokens.currentIndex()+2,_keywords.ContextualKeyword._type)){this.tokens.removeInitialToken();for(let i=0;i<8;i++){this.tokens.removeToken()}return true}if(this.tokens.matches1(_types.TokenType._import)){return this.processImport()}if(this.tokens.matches2(_types.TokenType._export,_types.TokenType._default)){return this.processExportDefault()}if(this.tokens.matches2(_types.TokenType._export,_types.TokenType.braceL)){return this.processNamedExports()}if(this.tokens.matches2(_types.TokenType._export,_types.TokenType.name)&&this.tokens.matchesContextualAtIndex(this.tokens.currentIndex()+1,_keywords.ContextualKeyword._type)){this.tokens.removeInitialToken();this.tokens.removeToken();if(this.tokens.matches1(_types.TokenType.braceL)){while(!this.tokens.matches1(_types.TokenType.braceR)){this.tokens.removeToken()}this.tokens.removeToken()}else{this.tokens.removeToken();if(this.tokens.matches1(_types.TokenType._as)){this.tokens.removeToken();this.tokens.removeToken()}}if(this.tokens.matchesContextual(_keywords.ContextualKeyword._from)&&this.tokens.matches1AtIndex(this.tokens.currentIndex()+1,_types.TokenType.string)){this.tokens.removeToken();this.tokens.removeToken();_removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0,this.tokens)}return true}return false}processImportEquals(){const importName=this.tokens.identifierNameAtIndex(this.tokens.currentIndex()+1);if(this.isTypeName(importName)){_elideImportEquals2.default.call(void 0,this.tokens)}else if(this.injectCreateRequireForImportRequire){this.tokens.replaceToken(\"const\");this.tokens.copyToken();this.tokens.copyToken();this.tokens.replaceToken(this.helperManager.getHelperName(\"require\"))}else{this.tokens.replaceToken(\"const\")}return true}processImport(){if(this.tokens.matches2(_types.TokenType._import,_types.TokenType.parenL)){return false}const snapshot=this.tokens.snapshot();const allImportsRemoved=this.removeImportTypeBindings();if(allImportsRemoved){this.tokens.restoreToSnapshot(snapshot);while(!this.tokens.matches1(_types.TokenType.string)){this.tokens.removeToken()}this.tokens.removeToken();_removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0,this.tokens);if(this.tokens.matches1(_types.TokenType.semi)){this.tokens.removeToken()}}return true}removeImportTypeBindings(){this.tokens.copyExpectedToken(_types.TokenType._import);if(this.tokens.matchesContextual(_keywords.ContextualKeyword._type)&&!this.tokens.matches1AtIndex(this.tokens.currentIndex()+1,_types.TokenType.comma)&&!this.tokens.matchesContextualAtIndex(this.tokens.currentIndex()+1,_keywords.ContextualKeyword._from)){return true}if(this.tokens.matches1(_types.TokenType.string)){this.tokens.copyToken();return false}if(this.tokens.matchesContextual(_keywords.ContextualKeyword._module)&&this.tokens.matchesContextualAtIndex(this.tokens.currentIndex()+2,_keywords.ContextualKeyword._from)){this.tokens.copyToken()}let foundNonTypeImport=false;let needsComma=false;if(this.tokens.matches1(_types.TokenType.name)){if(this.isTypeName(this.tokens.identifierName())){this.tokens.removeToken();if(this.tokens.matches1(_types.TokenType.comma)){this.tokens.removeToken()}}else{foundNonTypeImport=true;this.tokens.copyToken();if(this.tokens.matches1(_types.TokenType.comma)){needsComma=true;this.tokens.removeToken()}}}if(this.tokens.matches1(_types.TokenType.star)){if(this.isTypeName(this.tokens.identifierNameAtRelativeIndex(2))){this.tokens.removeToken();this.tokens.removeToken();this.tokens.removeToken()}else{if(needsComma){this.tokens.appendCode(\",\")}foundNonTypeImport=true;this.tokens.copyExpectedToken(_types.TokenType.star);this.tokens.copyExpectedToken(_types.TokenType.name);this.tokens.copyExpectedToken(_types.TokenType.name)}}else if(this.tokens.matches1(_types.TokenType.braceL)){if(needsComma){this.tokens.appendCode(\",\")}this.tokens.copyToken();while(!this.tokens.matches1(_types.TokenType.braceR)){const specifierInfo=_getImportExportSpecifierInfo2.default.call(void 0,this.tokens);if(specifierInfo.isType||this.isTypeName(specifierInfo.rightName)){while(this.tokens.currentIndex()<specifierInfo.endIndex){this.tokens.removeToken()}if(this.tokens.matches1(_types.TokenType.comma)){this.tokens.removeToken()}}else{foundNonTypeImport=true;while(this.tokens.currentIndex()<specifierInfo.endIndex){this.tokens.copyToken()}if(this.tokens.matches1(_types.TokenType.comma)){this.tokens.copyToken()}}}this.tokens.copyExpectedToken(_types.TokenType.braceR)}return!foundNonTypeImport}isTypeName(name){return this.isTypeScriptTransformEnabled&&!this.nonTypeIdentifiers.has(name)}processExportDefault(){if(_shouldElideDefaultExport2.default.call(void 0,this.isTypeScriptTransformEnabled,this.tokens,this.declarationInfo)){this.tokens.removeInitialToken();this.tokens.removeToken();this.tokens.removeToken();return true}const alreadyHasName=this.tokens.matches4(_types.TokenType._export,_types.TokenType._default,_types.TokenType._function,_types.TokenType.name)||this.tokens.matches5(_types.TokenType._export,_types.TokenType._default,_types.TokenType.name,_types.TokenType._function,_types.TokenType.name)&&this.tokens.matchesContextualAtIndex(this.tokens.currentIndex()+2,_keywords.ContextualKeyword._async)||this.tokens.matches4(_types.TokenType._export,_types.TokenType._default,_types.TokenType._class,_types.TokenType.name)||this.tokens.matches5(_types.TokenType._export,_types.TokenType._default,_types.TokenType._abstract,_types.TokenType._class,_types.TokenType.name);if(!alreadyHasName&&this.reactHotLoaderTransformer){const defaultVarName=this.nameManager.claimFreeName(\"_default\");this.tokens.replaceToken(`let ${defaultVarName}; export`);this.tokens.copyToken();this.tokens.appendCode(` ${defaultVarName} =`);this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);return true}return false}processNamedExports(){if(!this.isTypeScriptTransformEnabled){return false}this.tokens.copyExpectedToken(_types.TokenType._export);this.tokens.copyExpectedToken(_types.TokenType.braceL);while(!this.tokens.matches1(_types.TokenType.braceR)){const specifierInfo=_getImportExportSpecifierInfo2.default.call(void 0,this.tokens);if(specifierInfo.isType||this.shouldElideExportedName(specifierInfo.leftName)){while(this.tokens.currentIndex()<specifierInfo.endIndex){this.tokens.removeToken()}if(this.tokens.matches1(_types.TokenType.comma)){this.tokens.removeToken()}}else{while(this.tokens.currentIndex()<specifierInfo.endIndex){this.tokens.copyToken()}if(this.tokens.matches1(_types.TokenType.comma)){this.tokens.copyToken()}}}this.tokens.copyExpectedToken(_types.TokenType.braceR);return true}shouldElideExportedName(name){return this.isTypeScriptTransformEnabled&&this.declarationInfo.typeDeclarations.has(name)&&!this.declarationInfo.valueDeclarations.has(name)}}__name(ESMImportTransformer,\"ESMImportTransformer\");exports.default=ESMImportTransformer;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/transformers/ESMImportTransformer.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\nvar _keywords = require('../parser/tokenizer/keywords');\nvar _types = require('../parser/tokenizer/types');\n\nvar _elideImportEquals = require('../util/elideImportEquals'); var _elideImportEquals2 = _interopRequireDefault(_elideImportEquals);\n\n\n\nvar _getDeclarationInfo = require('../util/getDeclarationInfo'); var _getDeclarationInfo2 = _interopRequireDefault(_getDeclarationInfo);\nvar _getImportExportSpecifierInfo = require('../util/getImportExportSpecifierInfo'); var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);\nvar _getNonTypeIdentifiers = require('../util/getNonTypeIdentifiers');\nvar _removeMaybeImportAssertion = require('../util/removeMaybeImportAssertion');\nvar _shouldElideDefaultExport = require('../util/shouldElideDefaultExport'); var _shouldElideDefaultExport2 = _interopRequireDefault(_shouldElideDefaultExport);\n\nvar _Transformer = require('./Transformer'); var _Transformer2 = _interopRequireDefault(_Transformer);\n\n/**\n * Class for editing import statements when we are keeping the code as ESM. We still need to remove\n * type-only imports in TypeScript and Flow.\n */\n class ESMImportTransformer extends _Transformer2.default {\n  \n  \n  \n\n  constructor(\n     tokens,\n     nameManager,\n     helperManager,\n     reactHotLoaderTransformer,\n     isTypeScriptTransformEnabled,\n    options,\n  ) {\n    super();this.tokens = tokens;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;;\n    this.nonTypeIdentifiers = isTypeScriptTransformEnabled\n      ? _getNonTypeIdentifiers.getNonTypeIdentifiers.call(void 0, tokens, options)\n      : new Set();\n    this.declarationInfo = isTypeScriptTransformEnabled\n      ? _getDeclarationInfo2.default.call(void 0, tokens)\n      : _getDeclarationInfo.EMPTY_DECLARATION_INFO;\n    this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);\n  }\n\n  process() {\n    // TypeScript `import foo = require('foo');` should always just be translated to plain require.\n    if (this.tokens.matches3(_types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)) {\n      return this.processImportEquals();\n    }\n    if (\n      this.tokens.matches4(_types.TokenType._import, _types.TokenType.name, _types.TokenType.name, _types.TokenType.eq) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._type)\n    ) {\n      // import type T = require('T')\n      this.tokens.removeInitialToken();\n      // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.\n      for (let i = 0; i < 7; i++) {\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.eq)) {\n      this.tokens.replaceToken(\"module.exports\");\n      return true;\n    }\n    if (\n      this.tokens.matches5(_types.TokenType._export, _types.TokenType._import, _types.TokenType.name, _types.TokenType.name, _types.TokenType.eq) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, _keywords.ContextualKeyword._type)\n    ) {\n      // export import type T = require('T')\n      this.tokens.removeInitialToken();\n      // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.\n      for (let i = 0; i < 8; i++) {\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    if (this.tokens.matches1(_types.TokenType._import)) {\n      return this.processImport();\n    }\n    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._default)) {\n      return this.processExportDefault();\n    }\n    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.braceL)) {\n      return this.processNamedExports();\n    }\n    if (\n      this.tokens.matches2(_types.TokenType._export, _types.TokenType.name) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._type)\n    ) {\n      // export type {a};\n      // export type {a as b};\n      // export type {a} from './b';\n      // export type * from './b';\n      // export type * as ns from './b';\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      if (this.tokens.matches1(_types.TokenType.braceL)) {\n        while (!this.tokens.matches1(_types.TokenType.braceR)) {\n          this.tokens.removeToken();\n        }\n        this.tokens.removeToken();\n      } else {\n        // *\n        this.tokens.removeToken();\n        if (this.tokens.matches1(_types.TokenType._as)) {\n          // as\n          this.tokens.removeToken();\n          // ns\n          this.tokens.removeToken();\n        }\n      }\n      // Remove type re-export `... } from './T'`\n      if (\n        this.tokens.matchesContextual(_keywords.ContextualKeyword._from) &&\n        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.string)\n      ) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        _removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0, this.tokens);\n      }\n      return true;\n    }\n    return false;\n  }\n\n   processImportEquals() {\n    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    if (this.isTypeName(importName)) {\n      // If this name is only used as a type, elide the whole import.\n      _elideImportEquals2.default.call(void 0, this.tokens);\n    } else if (this.injectCreateRequireForImportRequire) {\n      // We're using require in an environment (Node ESM) that doesn't provide\n      // it as a global, so generate a helper to import it.\n      // import -> const\n      this.tokens.replaceToken(\"const\");\n      // Foo\n      this.tokens.copyToken();\n      // =\n      this.tokens.copyToken();\n      // require\n      this.tokens.replaceToken(this.helperManager.getHelperName(\"require\"));\n    } else {\n      // Otherwise, just switch `import` to `const`.\n      this.tokens.replaceToken(\"const\");\n    }\n    return true;\n  }\n\n   processImport() {\n    if (this.tokens.matches2(_types.TokenType._import, _types.TokenType.parenL)) {\n      // Dynamic imports don't need to be transformed.\n      return false;\n    }\n\n    const snapshot = this.tokens.snapshot();\n    const allImportsRemoved = this.removeImportTypeBindings();\n    if (allImportsRemoved) {\n      this.tokens.restoreToSnapshot(snapshot);\n      while (!this.tokens.matches1(_types.TokenType.string)) {\n        this.tokens.removeToken();\n      }\n      this.tokens.removeToken();\n      _removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0, this.tokens);\n      if (this.tokens.matches1(_types.TokenType.semi)) {\n        this.tokens.removeToken();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Remove type bindings from this import, leaving the rest of the import intact.\n   *\n   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out\n   * of the replacement operation, so we can return early here.\n   */\n   removeImportTypeBindings() {\n    this.tokens.copyExpectedToken(_types.TokenType._import);\n    if (\n      this.tokens.matchesContextual(_keywords.ContextualKeyword._type) &&\n      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.comma) &&\n      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._from)\n    ) {\n      // This is an \"import type\" statement, so exit early.\n      return true;\n    }\n\n    if (this.tokens.matches1(_types.TokenType.string)) {\n      // This is a bare import, so we should proceed with the import.\n      this.tokens.copyToken();\n      return false;\n    }\n\n    // Skip the \"module\" token in import reflection.\n    if (\n      this.tokens.matchesContextual(_keywords.ContextualKeyword._module) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, _keywords.ContextualKeyword._from)\n    ) {\n      this.tokens.copyToken();\n    }\n\n    let foundNonTypeImport = false;\n    let needsComma = false;\n\n    if (this.tokens.matches1(_types.TokenType.name)) {\n      if (this.isTypeName(this.tokens.identifierName())) {\n        this.tokens.removeToken();\n        if (this.tokens.matches1(_types.TokenType.comma)) {\n          this.tokens.removeToken();\n        }\n      } else {\n        foundNonTypeImport = true;\n        this.tokens.copyToken();\n        if (this.tokens.matches1(_types.TokenType.comma)) {\n          // We're in a statement like:\n          // import A, * as B from './A';\n          // or\n          // import A, {foo} from './A';\n          // where the `A` is being kept. The comma should be removed if an only\n          // if the next part of the import statement is elided, but that's hard\n          // to determine at this point in the code. Instead, always remove it\n          // and set a flag to add it back if necessary.\n          needsComma = true;\n          this.tokens.removeToken();\n        }\n      }\n    }\n\n    if (this.tokens.matches1(_types.TokenType.star)) {\n      if (this.isTypeName(this.tokens.identifierNameAtRelativeIndex(2))) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n      } else {\n        if (needsComma) {\n          this.tokens.appendCode(\",\");\n        }\n        foundNonTypeImport = true;\n        this.tokens.copyExpectedToken(_types.TokenType.star);\n        this.tokens.copyExpectedToken(_types.TokenType.name);\n        this.tokens.copyExpectedToken(_types.TokenType.name);\n      }\n    } else if (this.tokens.matches1(_types.TokenType.braceL)) {\n      if (needsComma) {\n        this.tokens.appendCode(\",\");\n      }\n      this.tokens.copyToken();\n      while (!this.tokens.matches1(_types.TokenType.braceR)) {\n        const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, this.tokens);\n        if (specifierInfo.isType || this.isTypeName(specifierInfo.rightName)) {\n          while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n            this.tokens.removeToken();\n          }\n          if (this.tokens.matches1(_types.TokenType.comma)) {\n            this.tokens.removeToken();\n          }\n        } else {\n          foundNonTypeImport = true;\n          while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n            this.tokens.copyToken();\n          }\n          if (this.tokens.matches1(_types.TokenType.comma)) {\n            this.tokens.copyToken();\n          }\n        }\n      }\n      this.tokens.copyExpectedToken(_types.TokenType.braceR);\n    }\n\n    return !foundNonTypeImport;\n  }\n\n   isTypeName(name) {\n    return this.isTypeScriptTransformEnabled && !this.nonTypeIdentifiers.has(name);\n  }\n\n   processExportDefault() {\n    if (\n      _shouldElideDefaultExport2.default.call(void 0, this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)\n    ) {\n      // If the exported value is just an identifier and should be elided by TypeScript\n      // rules, then remove it entirely. It will always have the form `export default e`,\n      // where `e` is an identifier.\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n      return true;\n    }\n\n    const alreadyHasName =\n      this.tokens.matches4(_types.TokenType._export, _types.TokenType._default, _types.TokenType._function, _types.TokenType.name) ||\n      // export default async function\n      (this.tokens.matches5(_types.TokenType._export, _types.TokenType._default, _types.TokenType.name, _types.TokenType._function, _types.TokenType.name) &&\n        this.tokens.matchesContextualAtIndex(\n          this.tokens.currentIndex() + 2,\n          _keywords.ContextualKeyword._async,\n        )) ||\n      this.tokens.matches4(_types.TokenType._export, _types.TokenType._default, _types.TokenType._class, _types.TokenType.name) ||\n      this.tokens.matches5(_types.TokenType._export, _types.TokenType._default, _types.TokenType._abstract, _types.TokenType._class, _types.TokenType.name);\n\n    if (!alreadyHasName && this.reactHotLoaderTransformer) {\n      // This is a plain \"export default E\" statement and we need to assign E to a variable.\n      // Change \"export default E\" to \"let _default; export default _default = E\"\n      const defaultVarName = this.nameManager.claimFreeName(\"_default\");\n      this.tokens.replaceToken(`let ${defaultVarName}; export`);\n      this.tokens.copyToken();\n      this.tokens.appendCode(` ${defaultVarName} =`);\n      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * In TypeScript, we need to remove named exports that were never declared or only declared as a\n   * type.\n   */\n   processNamedExports() {\n    if (!this.isTypeScriptTransformEnabled) {\n      return false;\n    }\n    this.tokens.copyExpectedToken(_types.TokenType._export);\n    this.tokens.copyExpectedToken(_types.TokenType.braceL);\n\n    while (!this.tokens.matches1(_types.TokenType.braceR)) {\n      const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, this.tokens);\n      if (specifierInfo.isType || this.shouldElideExportedName(specifierInfo.leftName)) {\n        // Type export, so remove all tokens, including any comma.\n        while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n          this.tokens.removeToken();\n        }\n        if (this.tokens.matches1(_types.TokenType.comma)) {\n          this.tokens.removeToken();\n        }\n      } else {\n        // Non-type export, so copy all tokens, including any comma.\n        while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n          this.tokens.copyToken();\n        }\n        if (this.tokens.matches1(_types.TokenType.comma)) {\n          this.tokens.copyToken();\n        }\n      }\n    }\n    this.tokens.copyExpectedToken(_types.TokenType.braceR);\n    return true;\n  }\n\n  /**\n   * ESM elides all imports with the rule that we only elide if we see that it's\n   * a type and never see it as a value. This is in contrast to CJS, which\n   * elides imports that are completely unknown.\n   */\n   shouldElideExportedName(name) {\n    return (\n      this.isTypeScriptTransformEnabled &&\n      this.declarationInfo.typeDeclarations.has(name) &&\n      !this.declarationInfo.valueDeclarations.has(name)\n    );\n  }\n} exports.default = ESMImportTransformer;\n"]}}