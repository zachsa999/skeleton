{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interopRequireDefault,\"_interopRequireDefault\");var _types=require(\"../parser/tokenizer/types\");var _Transformer=require(\"./Transformer\");var _Transformer2=_interopRequireDefault(_Transformer);class OptionalChainingNullishTransformer extends _Transformer2.default{constructor(tokens,nameManager){super();this.tokens=tokens;this.nameManager=nameManager;;}process(){if(this.tokens.matches1(_types.TokenType.nullishCoalescing)){const token2=this.tokens.currentToken();if(this.tokens.tokens[token2.nullishStartIndex].isAsyncOperation){this.tokens.replaceTokenTrimmingLeftWhitespace(\", async () => (\")}else{this.tokens.replaceTokenTrimmingLeftWhitespace(\", () => (\")}return true}if(this.tokens.matches1(_types.TokenType._delete)){const nextToken=this.tokens.tokenAtRelativeIndex(1);if(nextToken.isOptionalChainStart){this.tokens.removeInitialToken();return true}}const token=this.tokens.currentToken();const chainStart=token.subscriptStartIndex;if(chainStart!=null&&this.tokens.tokens[chainStart].isOptionalChainStart&&this.tokens.tokenAtRelativeIndex(-1).type!==_types.TokenType._super){const param=this.nameManager.claimFreeName(\"_\");let arrowStartSnippet;if(chainStart>0&&this.tokens.matches1AtIndex(chainStart-1,_types.TokenType._delete)&&this.isLastSubscriptInChain()){arrowStartSnippet=`${param} => delete ${param}`}else{arrowStartSnippet=`${param} => ${param}`}if(this.tokens.tokens[chainStart].isAsyncOperation){arrowStartSnippet=`async ${arrowStartSnippet}`}if(this.tokens.matches2(_types.TokenType.questionDot,_types.TokenType.parenL)||this.tokens.matches2(_types.TokenType.questionDot,_types.TokenType.lessThan)){if(this.justSkippedSuper()){this.tokens.appendCode(\".bind(this)\")}this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalCall', ${arrowStartSnippet}`)}else if(this.tokens.matches2(_types.TokenType.questionDot,_types.TokenType.bracketL)){this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}`)}else if(this.tokens.matches1(_types.TokenType.questionDot)){this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}.`)}else if(this.tokens.matches1(_types.TokenType.dot)){this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}.`)}else if(this.tokens.matches1(_types.TokenType.bracketL)){this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}[`)}else if(this.tokens.matches1(_types.TokenType.parenL)){if(this.justSkippedSuper()){this.tokens.appendCode(\".bind(this)\")}this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'call', ${arrowStartSnippet}(`)}else{throw new Error(\"Unexpected subscript operator in optional chain.\")}return true}return false}isLastSubscriptInChain(){let depth=0;for(let i=this.tokens.currentIndex()+1;;i++){if(i>=this.tokens.tokens.length){throw new Error(\"Reached the end of the code while finding the end of the access chain.\")}if(this.tokens.tokens[i].isOptionalChainStart){depth++}else if(this.tokens.tokens[i].isOptionalChainEnd){depth--}if(depth<0){return true}if(depth===0&&this.tokens.tokens[i].subscriptStartIndex!=null){return false}}}justSkippedSuper(){let depth=0;let index=this.tokens.currentIndex()-1;while(true){if(index<0){throw new Error(\"Reached the start of the code while finding the start of the access chain.\")}if(this.tokens.tokens[index].isOptionalChainStart){depth--}else if(this.tokens.tokens[index].isOptionalChainEnd){depth++}if(depth<0){return false}if(depth===0&&this.tokens.tokens[index].subscriptStartIndex!=null){return this.tokens.tokens[index-1].type===_types.TokenType._super}index--}}}__name(OptionalChainingNullishTransformer,\"OptionalChainingNullishTransformer\");exports.default=OptionalChainingNullishTransformer;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAG,SAAS,uBAAuB,IAAK,CAAE,OAAO,KAAO,IAAI,WAAa,IAAM,CAAE,QAAS,GAAI,CAAG,CAArF,wDACnF,IAAI,OAAS,QAAQ,2BAA2B,EAEhD,IAAI,aAAe,QAAQ,eAAe,EAAG,IAAI,cAAgB,uBAAuB,YAAY,EAWnG,MAAM,2CAA2C,cAAc,OAAQ,CACtE,YAAa,OAAS,YAAa,CACjC,MAAM,EAAE,KAAK,OAAS,OAAO,KAAK,YAAc,YAAY,CAC9D,CAEA,SAAU,CACR,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,iBAAiB,EAAG,CAC5D,MAAMA,OAAQ,KAAK,OAAO,aAAa,EACvC,GAAI,KAAK,OAAO,OAAOA,OAAM,iBAAiB,EAAE,iBAAkB,CAChE,KAAK,OAAO,mCAAmC,iBAAiB,CAClE,KAAO,CACL,KAAK,OAAO,mCAAmC,WAAW,CAC5D,CACA,MAAO,KACT,CACA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,OAAO,EAAG,CAClD,MAAM,UAAY,KAAK,OAAO,qBAAqB,CAAC,EACpD,GAAI,UAAU,qBAAsB,CAClC,KAAK,OAAO,mBAAmB,EAC/B,MAAO,KACT,CACF,CACA,MAAM,MAAQ,KAAK,OAAO,aAAa,EACvC,MAAM,WAAa,MAAM,oBACzB,GACE,YAAc,MACd,KAAK,OAAO,OAAO,UAAU,EAAE,sBAG/B,KAAK,OAAO,qBAAqB,EAAE,EAAE,OAAS,OAAO,UAAU,OAC/D,CACA,MAAM,MAAQ,KAAK,YAAY,cAAc,GAAG,EAChD,IAAI,kBACJ,GACE,WAAa,GACb,KAAK,OAAO,gBAAgB,WAAa,EAAG,OAAO,UAAU,OAAO,GACpE,KAAK,uBAAuB,EAC5B,CAIA,kBAAoB,GAAG,mBAAmB,OAC5C,KAAO,CACL,kBAAoB,GAAG,YAAY,OACrC,CACA,GAAI,KAAK,OAAO,OAAO,UAAU,EAAE,iBAAkB,CACnD,kBAAoB,SAAS,mBAC/B,CACA,GACE,KAAK,OAAO,SAAS,OAAO,UAAU,YAAa,OAAO,UAAU,MAAM,GAC1E,KAAK,OAAO,SAAS,OAAO,UAAU,YAAa,OAAO,UAAU,QAAQ,EAC5E,CACA,GAAI,KAAK,iBAAiB,EAAG,CAC3B,KAAK,OAAO,WAAW,aAAa,CACtC,CACA,KAAK,OAAO,mCAAmC,qBAAqB,mBAAmB,CACzF,SAAW,KAAK,OAAO,SAAS,OAAO,UAAU,YAAa,OAAO,UAAU,QAAQ,EAAG,CACxF,KAAK,OAAO,mCAAmC,uBAAuB,mBAAmB,CAC3F,SAAW,KAAK,OAAO,SAAS,OAAO,UAAU,WAAW,EAAG,CAC7D,KAAK,OAAO,mCAAmC,uBAAuB,oBAAoB,CAC5F,SAAW,KAAK,OAAO,SAAS,OAAO,UAAU,GAAG,EAAG,CACrD,KAAK,OAAO,mCAAmC,eAAe,oBAAoB,CACpF,SAAW,KAAK,OAAO,SAAS,OAAO,UAAU,QAAQ,EAAG,CAC1D,KAAK,OAAO,mCAAmC,eAAe,oBAAoB,CACpF,SAAW,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,EAAG,CACxD,GAAI,KAAK,iBAAiB,EAAG,CAC3B,KAAK,OAAO,WAAW,aAAa,CACtC,CACA,KAAK,OAAO,mCAAmC,aAAa,oBAAoB,CAClF,KAAO,CACL,MAAM,IAAI,MAAM,kDAAkD,CACpE,CACA,MAAO,KACT,CACA,MAAO,MACT,CAWA,wBAAyB,CACvB,IAAI,MAAQ,EACZ,QAAS,EAAI,KAAK,OAAO,aAAa,EAAI,GAAK,IAAK,CAClD,GAAI,GAAK,KAAK,OAAO,OAAO,OAAQ,CAClC,MAAM,IAAI,MAAM,wEAAwE,CAC1F,CACA,GAAI,KAAK,OAAO,OAAO,CAAC,EAAE,qBAAsB,CAC9C,OACF,SAAW,KAAK,OAAO,OAAO,CAAC,EAAE,mBAAoB,CACnD,OACF,CACA,GAAI,MAAQ,EAAG,CACb,MAAO,KACT,CAGA,GAAI,QAAU,GAAK,KAAK,OAAO,OAAO,CAAC,EAAE,qBAAuB,KAAM,CACpE,MAAO,MACT,CACF,CACF,CASA,kBAAmB,CACjB,IAAI,MAAQ,EACZ,IAAI,MAAQ,KAAK,OAAO,aAAa,EAAI,EACzC,MAAO,KAAM,CACX,GAAI,MAAQ,EAAG,CACb,MAAM,IAAI,MACR,4EACF,CACF,CACA,GAAI,KAAK,OAAO,OAAO,KAAK,EAAE,qBAAsB,CAClD,OACF,SAAW,KAAK,OAAO,OAAO,KAAK,EAAE,mBAAoB,CACvD,OACF,CACA,GAAI,MAAQ,EAAG,CACb,MAAO,MACT,CAGA,GAAI,QAAU,GAAK,KAAK,OAAO,OAAO,KAAK,EAAE,qBAAuB,KAAM,CACxE,OAAO,KAAK,OAAO,OAAO,MAAQ,CAAC,EAAE,OAAS,OAAO,UAAU,MACjE,CACA,OACF,CACF,CACF,CA5IO,gFA4IL,QAAQ,QAAU","names":["token"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/transformers/OptionalChainingNullishTransformer.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar _types = require('../parser/tokenizer/types');\n\nvar _Transformer = require('./Transformer'); var _Transformer2 = _interopRequireDefault(_Transformer);\n\n/**\n * Transformer supporting the optional chaining and nullish coalescing operators.\n *\n * Tech plan here:\n * https://github.com/alangpierce/sucrase/wiki/Sucrase-Optional-Chaining-and-Nullish-Coalescing-Technical-Plan\n *\n * The prefix and suffix code snippets are handled by TokenProcessor, and this transformer handles\n * the operators themselves.\n */\n class OptionalChainingNullishTransformer extends _Transformer2.default {\n  constructor( tokens,  nameManager) {\n    super();this.tokens = tokens;this.nameManager = nameManager;;\n  }\n\n  process() {\n    if (this.tokens.matches1(_types.TokenType.nullishCoalescing)) {\n      const token = this.tokens.currentToken();\n      if (this.tokens.tokens[token.nullishStartIndex].isAsyncOperation) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(\", async () => (\");\n      } else {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(\", () => (\");\n      }\n      return true;\n    }\n    if (this.tokens.matches1(_types.TokenType._delete)) {\n      const nextToken = this.tokens.tokenAtRelativeIndex(1);\n      if (nextToken.isOptionalChainStart) {\n        this.tokens.removeInitialToken();\n        return true;\n      }\n    }\n    const token = this.tokens.currentToken();\n    const chainStart = token.subscriptStartIndex;\n    if (\n      chainStart != null &&\n      this.tokens.tokens[chainStart].isOptionalChainStart &&\n      // Super subscripts can't be optional (since super is never null/undefined), and the syntax\n      // relies on the subscript being intact, so leave this token alone.\n      this.tokens.tokenAtRelativeIndex(-1).type !== _types.TokenType._super\n    ) {\n      const param = this.nameManager.claimFreeName(\"_\");\n      let arrowStartSnippet;\n      if (\n        chainStart > 0 &&\n        this.tokens.matches1AtIndex(chainStart - 1, _types.TokenType._delete) &&\n        this.isLastSubscriptInChain()\n      ) {\n        // Delete operations are special: we already removed the delete keyword, and to still\n        // perform a delete, we need to insert a delete in the very last part of the chain, which\n        // in correct code will always be a property access.\n        arrowStartSnippet = `${param} => delete ${param}`;\n      } else {\n        arrowStartSnippet = `${param} => ${param}`;\n      }\n      if (this.tokens.tokens[chainStart].isAsyncOperation) {\n        arrowStartSnippet = `async ${arrowStartSnippet}`;\n      }\n      if (\n        this.tokens.matches2(_types.TokenType.questionDot, _types.TokenType.parenL) ||\n        this.tokens.matches2(_types.TokenType.questionDot, _types.TokenType.lessThan)\n      ) {\n        if (this.justSkippedSuper()) {\n          this.tokens.appendCode(\".bind(this)\");\n        }\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalCall', ${arrowStartSnippet}`);\n      } else if (this.tokens.matches2(_types.TokenType.questionDot, _types.TokenType.bracketL)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}`);\n      } else if (this.tokens.matches1(_types.TokenType.questionDot)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}.`);\n      } else if (this.tokens.matches1(_types.TokenType.dot)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}.`);\n      } else if (this.tokens.matches1(_types.TokenType.bracketL)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}[`);\n      } else if (this.tokens.matches1(_types.TokenType.parenL)) {\n        if (this.justSkippedSuper()) {\n          this.tokens.appendCode(\".bind(this)\");\n        }\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'call', ${arrowStartSnippet}(`);\n      } else {\n        throw new Error(\"Unexpected subscript operator in optional chain.\");\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Determine if the current token is the last of its chain, so that we know whether it's eligible\n   * to have a delete op inserted.\n   *\n   * We can do this by walking forward until we determine one way or another. Each\n   * isOptionalChainStart token must be paired with exactly one isOptionalChainEnd token after it in\n   * a nesting way, so we can track depth and walk to the end of the chain (the point where the\n   * depth goes negative) and see if any other subscript token is after us in the chain.\n   */\n  isLastSubscriptInChain() {\n    let depth = 0;\n    for (let i = this.tokens.currentIndex() + 1; ; i++) {\n      if (i >= this.tokens.tokens.length) {\n        throw new Error(\"Reached the end of the code while finding the end of the access chain.\");\n      }\n      if (this.tokens.tokens[i].isOptionalChainStart) {\n        depth++;\n      } else if (this.tokens.tokens[i].isOptionalChainEnd) {\n        depth--;\n      }\n      if (depth < 0) {\n        return true;\n      }\n\n      // This subscript token is a later one in the same chain.\n      if (depth === 0 && this.tokens.tokens[i].subscriptStartIndex != null) {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Determine if we are the open-paren in an expression like super.a()?.b.\n   *\n   * We can do this by walking backward to find the previous subscript. If that subscript was\n   * preceded by a super, then we must be the subscript after it, so if this is a call expression,\n   * we'll need to attach the right context.\n   */\n  justSkippedSuper() {\n    let depth = 0;\n    let index = this.tokens.currentIndex() - 1;\n    while (true) {\n      if (index < 0) {\n        throw new Error(\n          \"Reached the start of the code while finding the start of the access chain.\",\n        );\n      }\n      if (this.tokens.tokens[index].isOptionalChainStart) {\n        depth--;\n      } else if (this.tokens.tokens[index].isOptionalChainEnd) {\n        depth++;\n      }\n      if (depth < 0) {\n        return false;\n      }\n\n      // This subscript token is a later one in the same chain.\n      if (depth === 0 && this.tokens.tokens[index].subscriptStartIndex != null) {\n        return this.tokens.tokens[index - 1].type === _types.TokenType._super;\n      }\n      index--;\n    }\n  }\n} exports.default = OptionalChainingNullishTransformer;\n"]}}