{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const SINGLE_QUOTE=\"'\".charCodeAt(0);const DOUBLE_QUOTE='\"'.charCodeAt(0);const BACKSLASH=\"\\\\\".charCodeAt(0);const SLASH=\"/\".charCodeAt(0);const NEWLINE=\"\\n\".charCodeAt(0);const SPACE=\" \".charCodeAt(0);const FEED=\"\\f\".charCodeAt(0);const TAB=\"\t\".charCodeAt(0);const CR=\"\\r\".charCodeAt(0);const OPEN_SQUARE=\"[\".charCodeAt(0);const CLOSE_SQUARE=\"]\".charCodeAt(0);const OPEN_PARENTHESES=\"(\".charCodeAt(0);const CLOSE_PARENTHESES=\")\".charCodeAt(0);const OPEN_CURLY=\"{\".charCodeAt(0);const CLOSE_CURLY=\"}\".charCodeAt(0);const SEMICOLON=\";\".charCodeAt(0);const ASTERISK=\"*\".charCodeAt(0);const COLON=\":\".charCodeAt(0);const AT=\"@\".charCodeAt(0);const RE_AT_END=/[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g;const RE_WORD_END=/[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g;const RE_BAD_BRACKET=/.[\\n\"'(/\\\\]/;const RE_HEX_ESCAPE=/[\\da-f]/i;module.exports=__name(function tokenizer(input,options={}){let css=input.css.valueOf();let ignore=options.ignoreErrors;let code,next,quote,content,escape;let escaped,escapePos,prev,n,currentToken;let length=css.length;let pos=0;let buffer=[];let returned=[];function position(){return pos}__name(position,\"position\");function unclosed(what){throw input.error(\"Unclosed \"+what,pos)}__name(unclosed,\"unclosed\");function endOfFile(){return returned.length===0&&pos>=length}__name(endOfFile,\"endOfFile\");function nextToken(opts){if(returned.length)return returned.pop();if(pos>=length)return;let ignoreUnclosed=opts?opts.ignoreUnclosed:false;code=css.charCodeAt(pos);switch(code){case NEWLINE:case SPACE:case TAB:case CR:case FEED:{next=pos;do{next+=1;code=css.charCodeAt(next)}while(code===SPACE||code===NEWLINE||code===TAB||code===CR||code===FEED);currentToken=[\"space\",css.slice(pos,next)];pos=next-1;break}case OPEN_SQUARE:case CLOSE_SQUARE:case OPEN_CURLY:case CLOSE_CURLY:case COLON:case SEMICOLON:case CLOSE_PARENTHESES:{let controlChar=String.fromCharCode(code);currentToken=[controlChar,controlChar,pos];break}case OPEN_PARENTHESES:{prev=buffer.length?buffer.pop()[1]:\"\";n=css.charCodeAt(pos+1);if(prev===\"url\"&&n!==SINGLE_QUOTE&&n!==DOUBLE_QUOTE&&n!==SPACE&&n!==NEWLINE&&n!==TAB&&n!==FEED&&n!==CR){next=pos;do{escaped=false;next=css.indexOf(\")\",next+1);if(next===-1){if(ignore||ignoreUnclosed){next=pos;break}else{unclosed(\"bracket\")}}escapePos=next;while(css.charCodeAt(escapePos-1)===BACKSLASH){escapePos-=1;escaped=!escaped}}while(escaped);currentToken=[\"brackets\",css.slice(pos,next+1),pos,next];pos=next}else{next=css.indexOf(\")\",pos+1);content=css.slice(pos,next+1);if(next===-1||RE_BAD_BRACKET.test(content)){currentToken=[\"(\",\"(\",pos]}else{currentToken=[\"brackets\",content,pos,next];pos=next}}break}case SINGLE_QUOTE:case DOUBLE_QUOTE:{quote=code===SINGLE_QUOTE?\"'\":'\"';next=pos;do{escaped=false;next=css.indexOf(quote,next+1);if(next===-1){if(ignore||ignoreUnclosed){next=pos+1;break}else{unclosed(\"string\")}}escapePos=next;while(css.charCodeAt(escapePos-1)===BACKSLASH){escapePos-=1;escaped=!escaped}}while(escaped);currentToken=[\"string\",css.slice(pos,next+1),pos,next];pos=next;break}case AT:{RE_AT_END.lastIndex=pos+1;RE_AT_END.test(css);if(RE_AT_END.lastIndex===0){next=css.length-1}else{next=RE_AT_END.lastIndex-2}currentToken=[\"at-word\",css.slice(pos,next+1),pos,next];pos=next;break}case BACKSLASH:{next=pos;escape=true;while(css.charCodeAt(next+1)===BACKSLASH){next+=1;escape=!escape}code=css.charCodeAt(next+1);if(escape&&code!==SLASH&&code!==SPACE&&code!==NEWLINE&&code!==TAB&&code!==CR&&code!==FEED){next+=1;if(RE_HEX_ESCAPE.test(css.charAt(next))){while(RE_HEX_ESCAPE.test(css.charAt(next+1))){next+=1}if(css.charCodeAt(next+1)===SPACE){next+=1}}}currentToken=[\"word\",css.slice(pos,next+1),pos,next];pos=next;break}default:{if(code===SLASH&&css.charCodeAt(pos+1)===ASTERISK){next=css.indexOf(\"*/\",pos+2)+1;if(next===0){if(ignore||ignoreUnclosed){next=css.length}else{unclosed(\"comment\")}}currentToken=[\"comment\",css.slice(pos,next+1),pos,next];pos=next}else{RE_WORD_END.lastIndex=pos+1;RE_WORD_END.test(css);if(RE_WORD_END.lastIndex===0){next=css.length-1}else{next=RE_WORD_END.lastIndex-2}currentToken=[\"word\",css.slice(pos,next+1),pos,next];buffer.push(currentToken);pos=next}break}}pos++;return currentToken}__name(nextToken,\"nextToken\");function back(token){returned.push(token)}__name(back,\"back\");return{back,nextToken,endOfFile,position}},\"tokenizer\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/postcss@8.4.24/node_modules/postcss/lib/tokenize.js"],"sourcesContent":["'use strict'\n\nconst SINGLE_QUOTE = \"'\".charCodeAt(0)\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0)\nconst BACKSLASH = '\\\\'.charCodeAt(0)\nconst SLASH = '/'.charCodeAt(0)\nconst NEWLINE = '\\n'.charCodeAt(0)\nconst SPACE = ' '.charCodeAt(0)\nconst FEED = '\\f'.charCodeAt(0)\nconst TAB = '\\t'.charCodeAt(0)\nconst CR = '\\r'.charCodeAt(0)\nconst OPEN_SQUARE = '['.charCodeAt(0)\nconst CLOSE_SQUARE = ']'.charCodeAt(0)\nconst OPEN_PARENTHESES = '('.charCodeAt(0)\nconst CLOSE_PARENTHESES = ')'.charCodeAt(0)\nconst OPEN_CURLY = '{'.charCodeAt(0)\nconst CLOSE_CURLY = '}'.charCodeAt(0)\nconst SEMICOLON = ';'.charCodeAt(0)\nconst ASTERISK = '*'.charCodeAt(0)\nconst COLON = ':'.charCodeAt(0)\nconst AT = '@'.charCodeAt(0)\n\nconst RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g\nconst RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g\nconst RE_BAD_BRACKET = /.[\\n\"'(/\\\\]/\nconst RE_HEX_ESCAPE = /[\\da-f]/i\n\nmodule.exports = function tokenizer(input, options = {}) {\n  let css = input.css.valueOf()\n  let ignore = options.ignoreErrors\n\n  let code, next, quote, content, escape\n  let escaped, escapePos, prev, n, currentToken\n\n  let length = css.length\n  let pos = 0\n  let buffer = []\n  let returned = []\n\n  function position() {\n    return pos\n  }\n\n  function unclosed(what) {\n    throw input.error('Unclosed ' + what, pos)\n  }\n\n  function endOfFile() {\n    return returned.length === 0 && pos >= length\n  }\n\n  function nextToken(opts) {\n    if (returned.length) return returned.pop()\n    if (pos >= length) return\n\n    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false\n\n    code = css.charCodeAt(pos)\n\n    switch (code) {\n      case NEWLINE:\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED: {\n        next = pos\n        do {\n          next += 1\n          code = css.charCodeAt(next)\n        } while (\n          code === SPACE ||\n          code === NEWLINE ||\n          code === TAB ||\n          code === CR ||\n          code === FEED\n        )\n\n        currentToken = ['space', css.slice(pos, next)]\n        pos = next - 1\n        break\n      }\n\n      case OPEN_SQUARE:\n      case CLOSE_SQUARE:\n      case OPEN_CURLY:\n      case CLOSE_CURLY:\n      case COLON:\n      case SEMICOLON:\n      case CLOSE_PARENTHESES: {\n        let controlChar = String.fromCharCode(code)\n        currentToken = [controlChar, controlChar, pos]\n        break\n      }\n\n      case OPEN_PARENTHESES: {\n        prev = buffer.length ? buffer.pop()[1] : ''\n        n = css.charCodeAt(pos + 1)\n        if (\n          prev === 'url' &&\n          n !== SINGLE_QUOTE &&\n          n !== DOUBLE_QUOTE &&\n          n !== SPACE &&\n          n !== NEWLINE &&\n          n !== TAB &&\n          n !== FEED &&\n          n !== CR\n        ) {\n          next = pos\n          do {\n            escaped = false\n            next = css.indexOf(')', next + 1)\n            if (next === -1) {\n              if (ignore || ignoreUnclosed) {\n                next = pos\n                break\n              } else {\n                unclosed('bracket')\n              }\n            }\n            escapePos = next\n            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n              escapePos -= 1\n              escaped = !escaped\n            }\n          } while (escaped)\n\n          currentToken = ['brackets', css.slice(pos, next + 1), pos, next]\n\n          pos = next\n        } else {\n          next = css.indexOf(')', pos + 1)\n          content = css.slice(pos, next + 1)\n\n          if (next === -1 || RE_BAD_BRACKET.test(content)) {\n            currentToken = ['(', '(', pos]\n          } else {\n            currentToken = ['brackets', content, pos, next]\n            pos = next\n          }\n        }\n\n        break\n      }\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE: {\n        quote = code === SINGLE_QUOTE ? \"'\" : '\"'\n        next = pos\n        do {\n          escaped = false\n          next = css.indexOf(quote, next + 1)\n          if (next === -1) {\n            if (ignore || ignoreUnclosed) {\n              next = pos + 1\n              break\n            } else {\n              unclosed('string')\n            }\n          }\n          escapePos = next\n          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n            escapePos -= 1\n            escaped = !escaped\n          }\n        } while (escaped)\n\n        currentToken = ['string', css.slice(pos, next + 1), pos, next]\n        pos = next\n        break\n      }\n\n      case AT: {\n        RE_AT_END.lastIndex = pos + 1\n        RE_AT_END.test(css)\n        if (RE_AT_END.lastIndex === 0) {\n          next = css.length - 1\n        } else {\n          next = RE_AT_END.lastIndex - 2\n        }\n\n        currentToken = ['at-word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      case BACKSLASH: {\n        next = pos\n        escape = true\n        while (css.charCodeAt(next + 1) === BACKSLASH) {\n          next += 1\n          escape = !escape\n        }\n        code = css.charCodeAt(next + 1)\n        if (\n          escape &&\n          code !== SLASH &&\n          code !== SPACE &&\n          code !== NEWLINE &&\n          code !== TAB &&\n          code !== CR &&\n          code !== FEED\n        ) {\n          next += 1\n          if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n              next += 1\n            }\n            if (css.charCodeAt(next + 1) === SPACE) {\n              next += 1\n            }\n          }\n        }\n\n        currentToken = ['word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      default: {\n        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n          next = css.indexOf('*/', pos + 2) + 1\n          if (next === 0) {\n            if (ignore || ignoreUnclosed) {\n              next = css.length\n            } else {\n              unclosed('comment')\n            }\n          }\n\n          currentToken = ['comment', css.slice(pos, next + 1), pos, next]\n          pos = next\n        } else {\n          RE_WORD_END.lastIndex = pos + 1\n          RE_WORD_END.test(css)\n          if (RE_WORD_END.lastIndex === 0) {\n            next = css.length - 1\n          } else {\n            next = RE_WORD_END.lastIndex - 2\n          }\n\n          currentToken = ['word', css.slice(pos, next + 1), pos, next]\n          buffer.push(currentToken)\n          pos = next\n        }\n\n        break\n      }\n    }\n\n    pos++\n    return currentToken\n  }\n\n  function back(token) {\n    returned.push(token)\n  }\n\n  return {\n    back,\n    nextToken,\n    endOfFile,\n    position\n  }\n}\n"]}}