{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});Object.defineProperty(exports,\"default\",{enumerable:true,get:function(){return expandApplyAtRules}});function partitionRules(root){if(!root.walkAtRules)return;let applyParents=new Set;root.walkAtRules(\"apply\",rule=>{applyParents.add(rule.parent)});if(applyParents.size===0){return}for(let rule of applyParents){let nodeGroups=[];let lastGroup=[];for(let node of rule.nodes){if(node.type===\"atrule\"&&node.name===\"apply\"){if(lastGroup.length>0){nodeGroups.push(lastGroup);lastGroup=[]}nodeGroups.push([node])}else{lastGroup.push(node)}}if(lastGroup.length>0){nodeGroups.push(lastGroup)}if(nodeGroups.length===1){continue}for(let group of[...nodeGroups].reverse()){let clone=rule.clone({nodes:[]});clone.append(group);rule.after(clone)}rule.remove()}}__name(partitionRules,\"partitionRules\");function expandApplyAtRules(){return root=>{partitionRules(root)}}__name(expandApplyAtRules,\"expandApplyAtRules\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CACzC,MAAO,IACX,CAAC,EACD,OAAO,eAAe,QAAS,UAAW,CACtC,WAAY,KACZ,IAAK,UAAW,CACZ,OAAO,kBACX,CACJ,CAAC,EACD,SAAS,eAAe,KAAM,CAC1B,GAAI,CAAC,KAAK,YAAa,OACvB,IAAI,aAAe,IAAI,IACvB,KAAK,YAAY,QAAU,MAAO,CAC9B,aAAa,IAAI,KAAK,MAAM,CAChC,CAAC,EACD,GAAI,aAAa,OAAS,EAAG,CACzB,MACJ,CACA,QAAS,QAAQ,aAAa,CAC1B,IAAI,WAAa,CAAC,EAClB,IAAI,UAAY,CAAC,EACjB,QAAS,QAAQ,KAAK,MAAM,CACxB,GAAI,KAAK,OAAS,UAAY,KAAK,OAAS,QAAS,CACjD,GAAI,UAAU,OAAS,EAAG,CACtB,WAAW,KAAK,SAAS,EACzB,UAAY,CAAC,CACjB,CACA,WAAW,KAAK,CACZ,IACJ,CAAC,CACL,KAAO,CACH,UAAU,KAAK,IAAI,CACvB,CACJ,CACA,GAAI,UAAU,OAAS,EAAG,CACtB,WAAW,KAAK,SAAS,CAC7B,CACA,GAAI,WAAW,SAAW,EAAG,CACzB,QACJ,CACA,QAAS,QAAS,CACd,GAAG,UACP,EAAE,QAAQ,EAAE,CACR,IAAI,MAAQ,KAAK,MAAM,CACnB,MAAO,CAAC,CACZ,CAAC,EACD,MAAM,OAAO,KAAK,EAClB,KAAK,MAAM,KAAK,CACpB,CACA,KAAK,OAAO,CAChB,CACJ,CA1CS,wCA2CT,SAAS,oBAAqB,CAC1B,OAAQ,MAAO,CACX,eAAe,IAAI,CACvB,CACJ,CAJS","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/lib/partitionApplyAtRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return expandApplyAtRules;\n    }\n});\nfunction partitionRules(root) {\n    if (!root.walkAtRules) return;\n    let applyParents = new Set();\n    root.walkAtRules(\"apply\", (rule)=>{\n        applyParents.add(rule.parent);\n    });\n    if (applyParents.size === 0) {\n        return;\n    }\n    for (let rule of applyParents){\n        let nodeGroups = [];\n        let lastGroup = [];\n        for (let node of rule.nodes){\n            if (node.type === \"atrule\" && node.name === \"apply\") {\n                if (lastGroup.length > 0) {\n                    nodeGroups.push(lastGroup);\n                    lastGroup = [];\n                }\n                nodeGroups.push([\n                    node\n                ]);\n            } else {\n                lastGroup.push(node);\n            }\n        }\n        if (lastGroup.length > 0) {\n            nodeGroups.push(lastGroup);\n        }\n        if (nodeGroups.length === 1) {\n            continue;\n        }\n        for (let group of [\n            ...nodeGroups\n        ].reverse()){\n            let clone = rule.clone({\n                nodes: []\n            });\n            clone.append(group);\n            rule.after(clone);\n        }\n        rule.remove();\n    }\n}\nfunction expandApplyAtRules() {\n    return (root)=>{\n        partitionRules(root);\n    };\n}\n"]}}