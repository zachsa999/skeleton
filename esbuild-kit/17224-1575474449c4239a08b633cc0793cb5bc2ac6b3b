{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interopRequireDefault,\"_interopRequireDefault\");var _tokenizer=require(\"../parser/tokenizer\");var _keywords=require(\"../parser/tokenizer/keywords\");var _types=require(\"../parser/tokenizer/types\");var _elideImportEquals=require(\"../util/elideImportEquals\");var _elideImportEquals2=_interopRequireDefault(_elideImportEquals);var _getDeclarationInfo=require(\"../util/getDeclarationInfo\");var _getDeclarationInfo2=_interopRequireDefault(_getDeclarationInfo);var _getImportExportSpecifierInfo=require(\"../util/getImportExportSpecifierInfo\");var _getImportExportSpecifierInfo2=_interopRequireDefault(_getImportExportSpecifierInfo);var _removeMaybeImportAssertion=require(\"../util/removeMaybeImportAssertion\");var _shouldElideDefaultExport=require(\"../util/shouldElideDefaultExport\");var _shouldElideDefaultExport2=_interopRequireDefault(_shouldElideDefaultExport);var _Transformer=require(\"./Transformer\");var _Transformer2=_interopRequireDefault(_Transformer);class CJSImportTransformer extends _Transformer2.default{__init(){this.hadExport=false}__init2(){this.hadNamedExport=false}__init3(){this.hadDefaultExport=false}constructor(rootTransformer,tokens,importProcessor,nameManager,helperManager,reactHotLoaderTransformer,enableLegacyBabel5ModuleInterop,enableLegacyTypeScriptModuleInterop,isTypeScriptTransformEnabled,preserveDynamicImport){super();this.rootTransformer=rootTransformer;this.tokens=tokens;this.importProcessor=importProcessor;this.nameManager=nameManager;this.helperManager=helperManager;this.reactHotLoaderTransformer=reactHotLoaderTransformer;this.enableLegacyBabel5ModuleInterop=enableLegacyBabel5ModuleInterop;this.enableLegacyTypeScriptModuleInterop=enableLegacyTypeScriptModuleInterop;this.isTypeScriptTransformEnabled=isTypeScriptTransformEnabled;this.preserveDynamicImport=preserveDynamicImport;CJSImportTransformer.prototype.__init.call(this);CJSImportTransformer.prototype.__init2.call(this);CJSImportTransformer.prototype.__init3.call(this);;this.declarationInfo=isTypeScriptTransformEnabled?_getDeclarationInfo2.default.call(void 0,tokens):_getDeclarationInfo.EMPTY_DECLARATION_INFO}getPrefixCode(){let prefix=\"\";if(this.hadExport){prefix+='Object.defineProperty(exports, \"__esModule\", {value: true});'}return prefix}getSuffixCode(){if(this.enableLegacyBabel5ModuleInterop&&this.hadDefaultExport&&!this.hadNamedExport){return\"\\nmodule.exports = exports.default;\\n\"}return\"\"}process(){if(this.tokens.matches3(_types.TokenType._import,_types.TokenType.name,_types.TokenType.eq)){return this.processImportEquals()}if(this.tokens.matches1(_types.TokenType._import)){this.processImport();return true}if(this.tokens.matches2(_types.TokenType._export,_types.TokenType.eq)){this.tokens.replaceToken(\"module.exports\");return true}if(this.tokens.matches1(_types.TokenType._export)&&!this.tokens.currentToken().isType){this.hadExport=true;return this.processExport()}if(this.tokens.matches2(_types.TokenType.name,_types.TokenType.postIncDec)){if(this.processPostIncDec()){return true}}if(this.tokens.matches1(_types.TokenType.name)||this.tokens.matches1(_types.TokenType.jsxName)){return this.processIdentifier()}if(this.tokens.matches1(_types.TokenType.eq)){return this.processAssignment()}if(this.tokens.matches1(_types.TokenType.assign)){return this.processComplexAssignment()}if(this.tokens.matches1(_types.TokenType.preIncDec)){return this.processPreIncDec()}return false}processImportEquals(){const importName=this.tokens.identifierNameAtIndex(this.tokens.currentIndex()+1);if(this.importProcessor.isTypeName(importName)){_elideImportEquals2.default.call(void 0,this.tokens)}else{this.tokens.replaceToken(\"const\")}return true}processImport(){if(this.tokens.matches2(_types.TokenType._import,_types.TokenType.parenL)){if(this.preserveDynamicImport){this.tokens.copyToken();return}const requireWrapper=this.enableLegacyTypeScriptModuleInterop?\"\":`${this.helperManager.getHelperName(\"interopRequireWildcard\")}(`;this.tokens.replaceToken(`Promise.resolve().then(() => ${requireWrapper}require`);const contextId=this.tokens.currentToken().contextId;if(contextId==null){throw new Error(\"Expected context ID on dynamic import invocation.\")}this.tokens.copyToken();while(!this.tokens.matchesContextIdAndLabel(_types.TokenType.parenR,contextId)){this.rootTransformer.processToken()}this.tokens.replaceToken(requireWrapper?\")))\":\"))\");return}const wasOnlyTypes=this.removeImportAndDetectIfType();if(wasOnlyTypes){this.tokens.removeToken()}else{const path=this.tokens.stringValue();this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));this.tokens.appendCode(this.importProcessor.claimImportCode(path))}_removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0,this.tokens);if(this.tokens.matches1(_types.TokenType.semi)){this.tokens.removeToken()}}removeImportAndDetectIfType(){this.tokens.removeInitialToken();if(this.tokens.matchesContextual(_keywords.ContextualKeyword._type)&&!this.tokens.matches1AtIndex(this.tokens.currentIndex()+1,_types.TokenType.comma)&&!this.tokens.matchesContextualAtIndex(this.tokens.currentIndex()+1,_keywords.ContextualKeyword._from)){this.removeRemainingImport();return true}if(this.tokens.matches1(_types.TokenType.name)||this.tokens.matches1(_types.TokenType.star)){this.removeRemainingImport();return false}if(this.tokens.matches1(_types.TokenType.string)){return false}let foundNonType=false;while(!this.tokens.matches1(_types.TokenType.string)){if(!foundNonType&&this.tokens.matches1(_types.TokenType.braceL)||this.tokens.matches1(_types.TokenType.comma)){this.tokens.removeToken();if(this.tokens.matches2(_types.TokenType.name,_types.TokenType.comma)||this.tokens.matches2(_types.TokenType.name,_types.TokenType.braceR)||this.tokens.matches4(_types.TokenType.name,_types.TokenType.name,_types.TokenType.name,_types.TokenType.comma)||this.tokens.matches4(_types.TokenType.name,_types.TokenType.name,_types.TokenType.name,_types.TokenType.braceR)){foundNonType=true}}this.tokens.removeToken()}return!foundNonType}removeRemainingImport(){while(!this.tokens.matches1(_types.TokenType.string)){this.tokens.removeToken()}}processIdentifier(){const token=this.tokens.currentToken();if(token.shadowsGlobal){return false}if(token.identifierRole===_tokenizer.IdentifierRole.ObjectShorthand){return this.processObjectShorthand()}if(token.identifierRole!==_tokenizer.IdentifierRole.Access){return false}const replacement=this.importProcessor.getIdentifierReplacement(this.tokens.identifierNameForToken(token));if(!replacement){return false}let possibleOpenParenIndex=this.tokens.currentIndex()+1;while(possibleOpenParenIndex<this.tokens.tokens.length&&this.tokens.tokens[possibleOpenParenIndex].type===_types.TokenType.parenR){possibleOpenParenIndex++}if(this.tokens.tokens[possibleOpenParenIndex].type===_types.TokenType.parenL){if(this.tokens.tokenAtRelativeIndex(1).type===_types.TokenType.parenL&&this.tokens.tokenAtRelativeIndex(-1).type!==_types.TokenType._new){this.tokens.replaceToken(`${replacement}.call(void 0, `);this.tokens.removeToken();this.rootTransformer.processBalancedCode();this.tokens.copyExpectedToken(_types.TokenType.parenR)}else{this.tokens.replaceToken(`(0, ${replacement})`)}}else{this.tokens.replaceToken(replacement)}return true}processObjectShorthand(){const identifier=this.tokens.identifierName();const replacement=this.importProcessor.getIdentifierReplacement(identifier);if(!replacement){return false}this.tokens.replaceToken(`${identifier}: ${replacement}`);return true}processExport(){if(this.tokens.matches2(_types.TokenType._export,_types.TokenType._enum)||this.tokens.matches3(_types.TokenType._export,_types.TokenType._const,_types.TokenType._enum)){return false}if(this.tokens.matches2(_types.TokenType._export,_types.TokenType._default)){this.hadDefaultExport=true;if(this.tokens.matches3(_types.TokenType._export,_types.TokenType._default,_types.TokenType._enum)){return false}this.processExportDefault();return true}this.hadNamedExport=true;if(this.tokens.matches2(_types.TokenType._export,_types.TokenType._var)||this.tokens.matches2(_types.TokenType._export,_types.TokenType._let)||this.tokens.matches2(_types.TokenType._export,_types.TokenType._const)){this.processExportVar();return true}else if(this.tokens.matches2(_types.TokenType._export,_types.TokenType._function)||this.tokens.matches3(_types.TokenType._export,_types.TokenType.name,_types.TokenType._function)){this.processExportFunction();return true}else if(this.tokens.matches2(_types.TokenType._export,_types.TokenType._class)||this.tokens.matches3(_types.TokenType._export,_types.TokenType._abstract,_types.TokenType._class)||this.tokens.matches2(_types.TokenType._export,_types.TokenType.at)){this.processExportClass();return true}else if(this.tokens.matches2(_types.TokenType._export,_types.TokenType.braceL)){this.processExportBindings();return true}else if(this.tokens.matches2(_types.TokenType._export,_types.TokenType.star)){this.processExportStar();return true}else if(this.tokens.matches2(_types.TokenType._export,_types.TokenType.name)&&this.tokens.matchesContextualAtIndex(this.tokens.currentIndex()+1,_keywords.ContextualKeyword._type)){this.tokens.removeInitialToken();this.tokens.removeToken();if(this.tokens.matches1(_types.TokenType.braceL)){while(!this.tokens.matches1(_types.TokenType.braceR)){this.tokens.removeToken()}this.tokens.removeToken()}else{this.tokens.removeToken();if(this.tokens.matches1(_types.TokenType._as)){this.tokens.removeToken();this.tokens.removeToken()}}if(this.tokens.matchesContextual(_keywords.ContextualKeyword._from)&&this.tokens.matches1AtIndex(this.tokens.currentIndex()+1,_types.TokenType.string)){this.tokens.removeToken();this.tokens.removeToken();_removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0,this.tokens)}return true}else{throw new Error(\"Unrecognized export syntax.\")}}processAssignment(){const index=this.tokens.currentIndex();const identifierToken=this.tokens.tokens[index-1];if(identifierToken.isType||identifierToken.type!==_types.TokenType.name){return false}if(identifierToken.shadowsGlobal){return false}if(index>=2&&this.tokens.matches1AtIndex(index-2,_types.TokenType.dot)){return false}if(index>=2&&[_types.TokenType._var,_types.TokenType._let,_types.TokenType._const].includes(this.tokens.tokens[index-2].type)){return false}const assignmentSnippet=this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(identifierToken));if(!assignmentSnippet){return false}this.tokens.copyToken();this.tokens.appendCode(` ${assignmentSnippet} =`);return true}processComplexAssignment(){const index=this.tokens.currentIndex();const identifierToken=this.tokens.tokens[index-1];if(identifierToken.type!==_types.TokenType.name){return false}if(identifierToken.shadowsGlobal){return false}if(index>=2&&this.tokens.matches1AtIndex(index-2,_types.TokenType.dot)){return false}const assignmentSnippet=this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(identifierToken));if(!assignmentSnippet){return false}this.tokens.appendCode(` = ${assignmentSnippet}`);this.tokens.copyToken();return true}processPreIncDec(){const index=this.tokens.currentIndex();const identifierToken=this.tokens.tokens[index+1];if(identifierToken.type!==_types.TokenType.name){return false}if(identifierToken.shadowsGlobal){return false}if(index+2<this.tokens.tokens.length&&(this.tokens.matches1AtIndex(index+2,_types.TokenType.dot)||this.tokens.matches1AtIndex(index+2,_types.TokenType.bracketL)||this.tokens.matches1AtIndex(index+2,_types.TokenType.parenL))){return false}const identifierName=this.tokens.identifierNameForToken(identifierToken);const assignmentSnippet=this.importProcessor.resolveExportBinding(identifierName);if(!assignmentSnippet){return false}this.tokens.appendCode(`${assignmentSnippet} = `);this.tokens.copyToken();return true}processPostIncDec(){const index=this.tokens.currentIndex();const identifierToken=this.tokens.tokens[index];const operatorToken=this.tokens.tokens[index+1];if(identifierToken.type!==_types.TokenType.name){return false}if(identifierToken.shadowsGlobal){return false}if(index>=1&&this.tokens.matches1AtIndex(index-1,_types.TokenType.dot)){return false}const identifierName=this.tokens.identifierNameForToken(identifierToken);const assignmentSnippet=this.importProcessor.resolveExportBinding(identifierName);if(!assignmentSnippet){return false}const operatorCode=this.tokens.rawCodeForToken(operatorToken);const base=this.importProcessor.getIdentifierReplacement(identifierName)||identifierName;if(operatorCode===\"++\"){this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`)}else if(operatorCode===\"--\"){this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`)}else{throw new Error(`Unexpected operator: ${operatorCode}`)}this.tokens.removeToken();return true}processExportDefault(){if(this.tokens.matches4(_types.TokenType._export,_types.TokenType._default,_types.TokenType._function,_types.TokenType.name)||this.tokens.matches5(_types.TokenType._export,_types.TokenType._default,_types.TokenType.name,_types.TokenType._function,_types.TokenType.name)&&this.tokens.matchesContextualAtIndex(this.tokens.currentIndex()+2,_keywords.ContextualKeyword._async)){this.tokens.removeInitialToken();this.tokens.removeToken();const name=this.processNamedFunction();this.tokens.appendCode(` exports.default = ${name};`)}else if(this.tokens.matches4(_types.TokenType._export,_types.TokenType._default,_types.TokenType._class,_types.TokenType.name)||this.tokens.matches5(_types.TokenType._export,_types.TokenType._default,_types.TokenType._abstract,_types.TokenType._class,_types.TokenType.name)||this.tokens.matches3(_types.TokenType._export,_types.TokenType._default,_types.TokenType.at)){this.tokens.removeInitialToken();this.tokens.removeToken();this.copyDecorators();if(this.tokens.matches1(_types.TokenType._abstract)){this.tokens.removeToken()}const name=this.rootTransformer.processNamedClass();this.tokens.appendCode(` exports.default = ${name};`)}else if(_shouldElideDefaultExport2.default.call(void 0,this.isTypeScriptTransformEnabled,this.tokens,this.declarationInfo)){this.tokens.removeInitialToken();this.tokens.removeToken();this.tokens.removeToken()}else if(this.reactHotLoaderTransformer){const defaultVarName=this.nameManager.claimFreeName(\"_default\");this.tokens.replaceToken(`let ${defaultVarName}; exports.`);this.tokens.copyToken();this.tokens.appendCode(` = ${defaultVarName} =`);this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName)}else{this.tokens.replaceToken(\"exports.\");this.tokens.copyToken();this.tokens.appendCode(\" =\")}}copyDecorators(){while(this.tokens.matches1(_types.TokenType.at)){this.tokens.copyToken();if(this.tokens.matches1(_types.TokenType.parenL)){this.tokens.copyExpectedToken(_types.TokenType.parenL);this.rootTransformer.processBalancedCode();this.tokens.copyExpectedToken(_types.TokenType.parenR)}else{this.tokens.copyExpectedToken(_types.TokenType.name);while(this.tokens.matches1(_types.TokenType.dot)){this.tokens.copyExpectedToken(_types.TokenType.dot);this.tokens.copyExpectedToken(_types.TokenType.name)}if(this.tokens.matches1(_types.TokenType.parenL)){this.tokens.copyExpectedToken(_types.TokenType.parenL);this.rootTransformer.processBalancedCode();this.tokens.copyExpectedToken(_types.TokenType.parenR)}}}}processExportVar(){if(this.isSimpleExportVar()){this.processSimpleExportVar()}else{this.processComplexExportVar()}}isSimpleExportVar(){let tokenIndex=this.tokens.currentIndex();tokenIndex++;tokenIndex++;if(!this.tokens.matches1AtIndex(tokenIndex,_types.TokenType.name)){return false}tokenIndex++;while(tokenIndex<this.tokens.tokens.length&&this.tokens.tokens[tokenIndex].isType){tokenIndex++}if(!this.tokens.matches1AtIndex(tokenIndex,_types.TokenType.eq)){return false}return true}processSimpleExportVar(){this.tokens.removeInitialToken();this.tokens.copyToken();const varName=this.tokens.identifierName();while(!this.tokens.matches1(_types.TokenType.eq)){this.rootTransformer.processToken()}const endIndex=this.tokens.currentToken().rhsEndIndex;if(endIndex==null){throw new Error(\"Expected = token with an end index.\")}while(this.tokens.currentIndex()<endIndex){this.rootTransformer.processToken()}this.tokens.appendCode(`; exports.${varName} = ${varName}`)}processComplexExportVar(){this.tokens.removeInitialToken();this.tokens.removeToken();const needsParens=this.tokens.matches1(_types.TokenType.braceL);if(needsParens){this.tokens.appendCode(\"(\")}let depth=0;while(true){if(this.tokens.matches1(_types.TokenType.braceL)||this.tokens.matches1(_types.TokenType.dollarBraceL)||this.tokens.matches1(_types.TokenType.bracketL)){depth++;this.tokens.copyToken()}else if(this.tokens.matches1(_types.TokenType.braceR)||this.tokens.matches1(_types.TokenType.bracketR)){depth--;this.tokens.copyToken()}else if(depth===0&&!this.tokens.matches1(_types.TokenType.name)&&!this.tokens.currentToken().isType){break}else if(this.tokens.matches1(_types.TokenType.eq)){const endIndex=this.tokens.currentToken().rhsEndIndex;if(endIndex==null){throw new Error(\"Expected = token with an end index.\")}while(this.tokens.currentIndex()<endIndex){this.rootTransformer.processToken()}}else{const token=this.tokens.currentToken();if(_tokenizer.isDeclaration.call(void 0,token)){const name=this.tokens.identifierName();let replacement=this.importProcessor.getIdentifierReplacement(name);if(replacement===null){throw new Error(`Expected a replacement for ${name} in \\`export var\\` syntax.`)}if(_tokenizer.isObjectShorthandDeclaration.call(void 0,token)){replacement=`${name}: ${replacement}`}this.tokens.replaceToken(replacement)}else{this.rootTransformer.processToken()}}}if(needsParens){const endIndex=this.tokens.currentToken().rhsEndIndex;if(endIndex==null){throw new Error(\"Expected = token with an end index.\")}while(this.tokens.currentIndex()<endIndex){this.rootTransformer.processToken()}this.tokens.appendCode(\")\")}}processExportFunction(){this.tokens.replaceToken(\"\");const name=this.processNamedFunction();this.tokens.appendCode(` exports.${name} = ${name};`)}processNamedFunction(){if(this.tokens.matches1(_types.TokenType._function)){this.tokens.copyToken()}else if(this.tokens.matches2(_types.TokenType.name,_types.TokenType._function)){if(!this.tokens.matchesContextual(_keywords.ContextualKeyword._async)){throw new Error(\"Expected async keyword in function export.\")}this.tokens.copyToken();this.tokens.copyToken()}if(this.tokens.matches1(_types.TokenType.star)){this.tokens.copyToken()}if(!this.tokens.matches1(_types.TokenType.name)){throw new Error(\"Expected identifier for exported function name.\")}const name=this.tokens.identifierName();this.tokens.copyToken();if(this.tokens.currentToken().isType){this.tokens.removeInitialToken();while(this.tokens.currentToken().isType){this.tokens.removeToken()}}this.tokens.copyExpectedToken(_types.TokenType.parenL);this.rootTransformer.processBalancedCode();this.tokens.copyExpectedToken(_types.TokenType.parenR);this.rootTransformer.processPossibleTypeRange();this.tokens.copyExpectedToken(_types.TokenType.braceL);this.rootTransformer.processBalancedCode();this.tokens.copyExpectedToken(_types.TokenType.braceR);return name}processExportClass(){this.tokens.removeInitialToken();this.copyDecorators();if(this.tokens.matches1(_types.TokenType._abstract)){this.tokens.removeToken()}const name=this.rootTransformer.processNamedClass();this.tokens.appendCode(` exports.${name} = ${name};`)}processExportBindings(){this.tokens.removeInitialToken();this.tokens.removeToken();const exportStatements=[];while(true){if(this.tokens.matches1(_types.TokenType.braceR)){this.tokens.removeToken();break}const specifierInfo=_getImportExportSpecifierInfo2.default.call(void 0,this.tokens);while(this.tokens.currentIndex()<specifierInfo.endIndex){this.tokens.removeToken()}if(!specifierInfo.isType&&!this.shouldElideExportedIdentifier(specifierInfo.leftName)){const localName=specifierInfo.leftName;const exportedName=specifierInfo.rightName;const newLocalName=this.importProcessor.getIdentifierReplacement(localName);exportStatements.push(`exports.${exportedName} = ${newLocalName||localName};`)}if(this.tokens.matches1(_types.TokenType.braceR)){this.tokens.removeToken();break}if(this.tokens.matches2(_types.TokenType.comma,_types.TokenType.braceR)){this.tokens.removeToken();this.tokens.removeToken();break}else if(this.tokens.matches1(_types.TokenType.comma)){this.tokens.removeToken()}else{throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`)}}if(this.tokens.matchesContextual(_keywords.ContextualKeyword._from)){this.tokens.removeToken();const path=this.tokens.stringValue();this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));_removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0,this.tokens)}else{this.tokens.appendCode(exportStatements.join(\" \"))}if(this.tokens.matches1(_types.TokenType.semi)){this.tokens.removeToken()}}processExportStar(){this.tokens.removeInitialToken();while(!this.tokens.matches1(_types.TokenType.string)){this.tokens.removeToken()}const path=this.tokens.stringValue();this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));_removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0,this.tokens);if(this.tokens.matches1(_types.TokenType.semi)){this.tokens.removeToken()}}shouldElideExportedIdentifier(name){return this.isTypeScriptTransformEnabled&&!this.declarationInfo.valueDeclarations.has(name)}}__name(CJSImportTransformer,\"CJSImportTransformer\");exports.default=CJSImportTransformer;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAG,SAAS,uBAAuB,IAAK,CAAE,OAAO,KAAO,IAAI,WAAa,IAAM,CAAE,QAAS,GAAI,CAAG,CAArF,wDAGnF,IAAI,WAAa,QAAQ,qBAAqB,EAC9C,IAAI,UAAY,QAAQ,8BAA8B,EACtD,IAAI,OAAS,QAAQ,2BAA2B,EAEhD,IAAI,mBAAqB,QAAQ,2BAA2B,EAAG,IAAI,oBAAsB,uBAAuB,kBAAkB,EAIlI,IAAI,oBAAsB,QAAQ,4BAA4B,EAAG,IAAI,qBAAuB,uBAAuB,mBAAmB,EACtI,IAAI,8BAAgC,QAAQ,sCAAsC,EAAG,IAAI,+BAAiC,uBAAuB,6BAA6B,EAC9K,IAAI,4BAA8B,QAAQ,oCAAoC,EAC9E,IAAI,0BAA4B,QAAQ,kCAAkC,EAAG,IAAI,2BAA6B,uBAAuB,yBAAyB,EAG9J,IAAI,aAAe,QAAQ,eAAe,EAAG,IAAI,cAAgB,uBAAuB,YAAY,EAKnG,MAAM,6BAA6B,cAAc,OAAQ,CACvD,QAAS,CAAC,KAAK,UAAY,KAAK,CAChC,SAAU,CAAC,KAAK,eAAiB,KAAK,CACtC,SAAU,CAAC,KAAK,iBAAmB,KAAK,CAGzC,YACG,gBACA,OACA,gBACA,YACA,cACA,0BACA,gCACA,oCACA,6BACA,sBACD,CACA,MAAM,EAAE,KAAK,gBAAkB,gBAAgB,KAAK,OAAS,OAAO,KAAK,gBAAkB,gBAAgB,KAAK,YAAc,YAAY,KAAK,cAAgB,cAAc,KAAK,0BAA4B,0BAA0B,KAAK,gCAAkC,gCAAgC,KAAK,oCAAsC,oCAAoC,KAAK,6BAA+B,6BAA6B,KAAK,sBAAwB,sBAAsB,qBAAqB,UAAU,OAAO,KAAK,IAAI,EAAE,qBAAqB,UAAU,QAAQ,KAAK,IAAI,EAAE,qBAAqB,UAAU,QAAQ,KAAK,IAAI,EAAE,CACvoB,KAAK,gBAAkB,6BACnB,qBAAqB,QAAQ,KAAK,OAAQ,MAAM,EAChD,oBAAoB,sBAC1B,CAEA,eAAgB,CACd,IAAI,OAAS,GACb,GAAI,KAAK,UAAW,CAClB,QAAU,8DACZ,CACA,OAAO,MACT,CAEA,eAAgB,CACd,GAAI,KAAK,iCAAmC,KAAK,kBAAoB,CAAC,KAAK,eAAgB,CACzF,MAAO,uCACT,CACA,MAAO,EACT,CAEA,SAAU,CAER,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,KAAM,OAAO,UAAU,EAAE,EAAG,CAC9F,OAAO,KAAK,oBAAoB,CAClC,CACA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,OAAO,EAAG,CAClD,KAAK,cAAc,EACnB,MAAO,KACT,CACA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,EAAE,EAAG,CACvE,KAAK,OAAO,aAAa,gBAAgB,EACzC,MAAO,KACT,CACA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,OAAO,GAAK,CAAC,KAAK,OAAO,aAAa,EAAE,OAAQ,CACxF,KAAK,UAAY,KACjB,OAAO,KAAK,cAAc,CAC5B,CACA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,KAAM,OAAO,UAAU,UAAU,EAAG,CAE5E,GAAI,KAAK,kBAAkB,EAAG,CAC5B,MAAO,KACT,CACF,CACA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,IAAI,GAAK,KAAK,OAAO,SAAS,OAAO,UAAU,OAAO,EAAG,CACjG,OAAO,KAAK,kBAAkB,CAChC,CACA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,EAAE,EAAG,CAC7C,OAAO,KAAK,kBAAkB,CAChC,CACA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,EAAG,CACjD,OAAO,KAAK,yBAAyB,CACvC,CACA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,SAAS,EAAG,CACpD,OAAO,KAAK,iBAAiB,CAC/B,CACA,MAAO,MACT,CAEC,qBAAsB,CACrB,MAAM,WAAa,KAAK,OAAO,sBAAsB,KAAK,OAAO,aAAa,EAAI,CAAC,EACnF,GAAI,KAAK,gBAAgB,WAAW,UAAU,EAAG,CAE/C,oBAAoB,QAAQ,KAAK,OAAQ,KAAK,MAAM,CACtD,KAAO,CAEL,KAAK,OAAO,aAAa,OAAO,CAClC,CACA,MAAO,KACT,CAWC,eAAgB,CACf,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,MAAM,EAAG,CAC3E,GAAI,KAAK,sBAAuB,CAE9B,KAAK,OAAO,UAAU,EACtB,MACF,CACA,MAAM,eAAiB,KAAK,oCACxB,GACA,GAAG,KAAK,cAAc,cAAc,wBAAwB,KAChE,KAAK,OAAO,aAAa,gCAAgC,uBAAuB,EAChF,MAAM,UAAY,KAAK,OAAO,aAAa,EAAE,UAC7C,GAAI,WAAa,KAAM,CACrB,MAAM,IAAI,MAAM,mDAAmD,CACrE,CACA,KAAK,OAAO,UAAU,EACtB,MAAO,CAAC,KAAK,OAAO,yBAAyB,OAAO,UAAU,OAAQ,SAAS,EAAG,CAChF,KAAK,gBAAgB,aAAa,CACpC,CACA,KAAK,OAAO,aAAa,eAAiB,MAAQ,IAAI,EACtD,MACF,CAEA,MAAM,aAAe,KAAK,4BAA4B,EAEtD,GAAI,aAAc,CAChB,KAAK,OAAO,YAAY,CAC1B,KAAO,CACL,MAAM,KAAO,KAAK,OAAO,YAAY,EACrC,KAAK,OAAO,mCAAmC,KAAK,gBAAgB,gBAAgB,IAAI,CAAC,EACzF,KAAK,OAAO,WAAW,KAAK,gBAAgB,gBAAgB,IAAI,CAAC,CACnE,CACA,4BAA4B,2BAA2B,KAAK,OAAQ,KAAK,MAAM,EAC/E,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,IAAI,EAAG,CAC/C,KAAK,OAAO,YAAY,CAC1B,CACF,CAQC,6BAA8B,CAC7B,KAAK,OAAO,mBAAmB,EAC/B,GACE,KAAK,OAAO,kBAAkB,UAAU,kBAAkB,KAAK,GAC/D,CAAC,KAAK,OAAO,gBAAgB,KAAK,OAAO,aAAa,EAAI,EAAG,OAAO,UAAU,KAAK,GACnF,CAAC,KAAK,OAAO,yBAAyB,KAAK,OAAO,aAAa,EAAI,EAAG,UAAU,kBAAkB,KAAK,EACvG,CAEA,KAAK,sBAAsB,EAC3B,MAAO,KACT,CAEA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,IAAI,GAAK,KAAK,OAAO,SAAS,OAAO,UAAU,IAAI,EAAG,CAG9F,KAAK,sBAAsB,EAC3B,MAAO,MACT,CAEA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,EAAG,CAEjD,MAAO,MACT,CAEA,IAAI,aAAe,MACnB,MAAO,CAAC,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,EAAG,CAGrD,GAAK,CAAC,cAAgB,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,GAAM,KAAK,OAAO,SAAS,OAAO,UAAU,KAAK,EAAG,CACpH,KAAK,OAAO,YAAY,EACxB,GACE,KAAK,OAAO,SAAS,OAAO,UAAU,KAAM,OAAO,UAAU,KAAK,GAClE,KAAK,OAAO,SAAS,OAAO,UAAU,KAAM,OAAO,UAAU,MAAM,GACnE,KAAK,OAAO,SAAS,OAAO,UAAU,KAAM,OAAO,UAAU,KAAM,OAAO,UAAU,KAAM,OAAO,UAAU,KAAK,GAChH,KAAK,OAAO,SAAS,OAAO,UAAU,KAAM,OAAO,UAAU,KAAM,OAAO,UAAU,KAAM,OAAO,UAAU,MAAM,EACjH,CACA,aAAe,IACjB,CACF,CACA,KAAK,OAAO,YAAY,CAC1B,CACA,MAAO,CAAC,YACV,CAEC,uBAAwB,CACvB,MAAO,CAAC,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,EAAG,CACrD,KAAK,OAAO,YAAY,CAC1B,CACF,CAEC,mBAAoB,CACnB,MAAM,MAAQ,KAAK,OAAO,aAAa,EACvC,GAAI,MAAM,cAAe,CACvB,MAAO,MACT,CAEA,GAAI,MAAM,iBAAmB,WAAW,eAAe,gBAAiB,CACtE,OAAO,KAAK,uBAAuB,CACrC,CAEA,GAAI,MAAM,iBAAmB,WAAW,eAAe,OAAQ,CAC7D,MAAO,MACT,CACA,MAAM,YAAc,KAAK,gBAAgB,yBACvC,KAAK,OAAO,uBAAuB,KAAK,CAC1C,EACA,GAAI,CAAC,YAAa,CAChB,MAAO,MACT,CAGA,IAAI,uBAAyB,KAAK,OAAO,aAAa,EAAI,EAC1D,MACE,uBAAyB,KAAK,OAAO,OAAO,QAC5C,KAAK,OAAO,OAAO,sBAAsB,EAAE,OAAS,OAAO,UAAU,OACrE,CACA,wBACF,CAKA,GAAI,KAAK,OAAO,OAAO,sBAAsB,EAAE,OAAS,OAAO,UAAU,OAAQ,CAC/E,GACE,KAAK,OAAO,qBAAqB,CAAC,EAAE,OAAS,OAAO,UAAU,QAC9D,KAAK,OAAO,qBAAqB,EAAE,EAAE,OAAS,OAAO,UAAU,KAC/D,CACA,KAAK,OAAO,aAAa,GAAG,2BAA2B,EAEvD,KAAK,OAAO,YAAY,EAExB,KAAK,gBAAgB,oBAAoB,EACzC,KAAK,OAAO,kBAAkB,OAAO,UAAU,MAAM,CACvD,KAAO,CAEL,KAAK,OAAO,aAAa,OAAO,cAAc,CAChD,CACF,KAAO,CACL,KAAK,OAAO,aAAa,WAAW,CACtC,CACA,MAAO,KACT,CAEA,wBAAyB,CACvB,MAAM,WAAa,KAAK,OAAO,eAAe,EAC9C,MAAM,YAAc,KAAK,gBAAgB,yBAAyB,UAAU,EAC5E,GAAI,CAAC,YAAa,CAChB,MAAO,MACT,CACA,KAAK,OAAO,aAAa,GAAG,eAAe,aAAa,EACxD,MAAO,KACT,CAEA,eAAgB,CACd,GACE,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,KAAK,GACrE,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,OAAQ,OAAO,UAAU,KAAK,EAC9F,CAEA,MAAO,MACT,CACA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,QAAQ,EAAG,CAC7E,KAAK,iBAAmB,KACxB,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,SAAU,OAAO,UAAU,KAAK,EAAG,CAGrG,MAAO,MACT,CACA,KAAK,qBAAqB,EAC1B,MAAO,KACT,CACA,KAAK,eAAiB,KACtB,GACE,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,IAAI,GACpE,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,IAAI,GACpE,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,MAAM,EACtE,CACA,KAAK,iBAAiB,EACtB,MAAO,KACT,SACE,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,SAAS,GAEzE,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,KAAM,OAAO,UAAU,SAAS,EAChG,CACA,KAAK,sBAAsB,EAC3B,MAAO,KACT,SACE,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,MAAM,GACtE,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,UAAW,OAAO,UAAU,MAAM,GAClG,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,EAAE,EAClE,CACA,KAAK,mBAAmB,EACxB,MAAO,KACT,SAAW,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,MAAM,EAAG,CAClF,KAAK,sBAAsB,EAC3B,MAAO,KACT,SAAW,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,IAAI,EAAG,CAChF,KAAK,kBAAkB,EACvB,MAAO,KACT,SACE,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,IAAI,GACpE,KAAK,OAAO,yBAAyB,KAAK,OAAO,aAAa,EAAI,EAAG,UAAU,kBAAkB,KAAK,EACtG,CAMA,KAAK,OAAO,mBAAmB,EAC/B,KAAK,OAAO,YAAY,EACxB,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,EAAG,CACjD,MAAO,CAAC,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,EAAG,CACrD,KAAK,OAAO,YAAY,CAC1B,CACA,KAAK,OAAO,YAAY,CAC1B,KAAO,CAEL,KAAK,OAAO,YAAY,EACxB,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,GAAG,EAAG,CAE9C,KAAK,OAAO,YAAY,EAExB,KAAK,OAAO,YAAY,CAC1B,CACF,CAEA,GACE,KAAK,OAAO,kBAAkB,UAAU,kBAAkB,KAAK,GAC/D,KAAK,OAAO,gBAAgB,KAAK,OAAO,aAAa,EAAI,EAAG,OAAO,UAAU,MAAM,EACnF,CACA,KAAK,OAAO,YAAY,EACxB,KAAK,OAAO,YAAY,EACxB,4BAA4B,2BAA2B,KAAK,OAAQ,KAAK,MAAM,CACjF,CACA,MAAO,KACT,KAAO,CACL,MAAM,IAAI,MAAM,6BAA6B,CAC/C,CACF,CAEC,mBAAoB,CACnB,MAAM,MAAQ,KAAK,OAAO,aAAa,EACvC,MAAM,gBAAkB,KAAK,OAAO,OAAO,MAAQ,CAAC,EAGpD,GAAI,gBAAgB,QAAU,gBAAgB,OAAS,OAAO,UAAU,KAAM,CAC5E,MAAO,MACT,CACA,GAAI,gBAAgB,cAAe,CACjC,MAAO,MACT,CACA,GAAI,OAAS,GAAK,KAAK,OAAO,gBAAgB,MAAQ,EAAG,OAAO,UAAU,GAAG,EAAG,CAC9E,MAAO,MACT,CACA,GAAI,OAAS,GAAK,CAAC,OAAO,UAAU,KAAM,OAAO,UAAU,KAAM,OAAO,UAAU,MAAM,EAAE,SAAS,KAAK,OAAO,OAAO,MAAQ,CAAC,EAAE,IAAI,EAAG,CAItI,MAAO,MACT,CACA,MAAM,kBAAoB,KAAK,gBAAgB,qBAC7C,KAAK,OAAO,uBAAuB,eAAe,CACpD,EACA,GAAI,CAAC,kBAAmB,CACtB,MAAO,MACT,CACA,KAAK,OAAO,UAAU,EACtB,KAAK,OAAO,WAAW,IAAI,qBAAqB,EAChD,MAAO,KACT,CAKC,0BAA2B,CAC1B,MAAM,MAAQ,KAAK,OAAO,aAAa,EACvC,MAAM,gBAAkB,KAAK,OAAO,OAAO,MAAQ,CAAC,EACpD,GAAI,gBAAgB,OAAS,OAAO,UAAU,KAAM,CAClD,MAAO,MACT,CACA,GAAI,gBAAgB,cAAe,CACjC,MAAO,MACT,CACA,GAAI,OAAS,GAAK,KAAK,OAAO,gBAAgB,MAAQ,EAAG,OAAO,UAAU,GAAG,EAAG,CAC9E,MAAO,MACT,CACA,MAAM,kBAAoB,KAAK,gBAAgB,qBAC7C,KAAK,OAAO,uBAAuB,eAAe,CACpD,EACA,GAAI,CAAC,kBAAmB,CACtB,MAAO,MACT,CACA,KAAK,OAAO,WAAW,MAAM,mBAAmB,EAChD,KAAK,OAAO,UAAU,EACtB,MAAO,KACT,CAKC,kBAAmB,CAClB,MAAM,MAAQ,KAAK,OAAO,aAAa,EACvC,MAAM,gBAAkB,KAAK,OAAO,OAAO,MAAQ,CAAC,EACpD,GAAI,gBAAgB,OAAS,OAAO,UAAU,KAAM,CAClD,MAAO,MACT,CACA,GAAI,gBAAgB,cAAe,CACjC,MAAO,MACT,CAEA,GACE,MAAQ,EAAI,KAAK,OAAO,OAAO,SAC9B,KAAK,OAAO,gBAAgB,MAAQ,EAAG,OAAO,UAAU,GAAG,GAC1D,KAAK,OAAO,gBAAgB,MAAQ,EAAG,OAAO,UAAU,QAAQ,GAChE,KAAK,OAAO,gBAAgB,MAAQ,EAAG,OAAO,UAAU,MAAM,GAChE,CACA,MAAO,MACT,CACA,MAAM,eAAiB,KAAK,OAAO,uBAAuB,eAAe,EACzE,MAAM,kBAAoB,KAAK,gBAAgB,qBAAqB,cAAc,EAClF,GAAI,CAAC,kBAAmB,CACtB,MAAO,MACT,CACA,KAAK,OAAO,WAAW,GAAG,sBAAsB,EAChD,KAAK,OAAO,UAAU,EACtB,MAAO,KACT,CAMC,mBAAoB,CACnB,MAAM,MAAQ,KAAK,OAAO,aAAa,EACvC,MAAM,gBAAkB,KAAK,OAAO,OAAO,KAAK,EAChD,MAAM,cAAgB,KAAK,OAAO,OAAO,MAAQ,CAAC,EAClD,GAAI,gBAAgB,OAAS,OAAO,UAAU,KAAM,CAClD,MAAO,MACT,CACA,GAAI,gBAAgB,cAAe,CACjC,MAAO,MACT,CACA,GAAI,OAAS,GAAK,KAAK,OAAO,gBAAgB,MAAQ,EAAG,OAAO,UAAU,GAAG,EAAG,CAC9E,MAAO,MACT,CACA,MAAM,eAAiB,KAAK,OAAO,uBAAuB,eAAe,EACzE,MAAM,kBAAoB,KAAK,gBAAgB,qBAAqB,cAAc,EAClF,GAAI,CAAC,kBAAmB,CACtB,MAAO,MACT,CACA,MAAM,aAAe,KAAK,OAAO,gBAAgB,aAAa,EAG9D,MAAM,KAAO,KAAK,gBAAgB,yBAAyB,cAAc,GAAK,eAC9E,GAAI,eAAiB,KAAM,CACzB,KAAK,OAAO,aAAa,IAAI,UAAU,uBAAuB,aAAa,WAAW,CACxF,SAAW,eAAiB,KAAM,CAChC,KAAK,OAAO,aAAa,IAAI,UAAU,uBAAuB,aAAa,WAAW,CACxF,KAAO,CACL,MAAM,IAAI,MAAM,wBAAwB,cAAc,CACxD,CACA,KAAK,OAAO,YAAY,EACxB,MAAO,KACT,CAEC,sBAAuB,CACtB,GACE,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,SAAU,OAAO,UAAU,UAAW,OAAO,UAAU,IAAI,GAE1H,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,SAAU,OAAO,UAAU,KAAM,OAAO,UAAU,UAAW,OAAO,UAAU,IAAI,GACjJ,KAAK,OAAO,yBACV,KAAK,OAAO,aAAa,EAAI,EAC7B,UAAU,kBAAkB,MAC9B,EACF,CACA,KAAK,OAAO,mBAAmB,EAC/B,KAAK,OAAO,YAAY,EAGxB,MAAM,KAAO,KAAK,qBAAqB,EACvC,KAAK,OAAO,WAAW,sBAAsB,OAAO,CACtD,SACE,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,SAAU,OAAO,UAAU,OAAQ,OAAO,UAAU,IAAI,GACxH,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,SAAU,OAAO,UAAU,UAAW,OAAO,UAAU,OAAQ,OAAO,UAAU,IAAI,GACpJ,KAAK,OAAO,SAAS,OAAO,UAAU,QAAS,OAAO,UAAU,SAAU,OAAO,UAAU,EAAE,EAC7F,CACA,KAAK,OAAO,mBAAmB,EAC/B,KAAK,OAAO,YAAY,EACxB,KAAK,eAAe,EACpB,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,SAAS,EAAG,CACpD,KAAK,OAAO,YAAY,CAC1B,CACA,MAAM,KAAO,KAAK,gBAAgB,kBAAkB,EACpD,KAAK,OAAO,WAAW,sBAAsB,OAAO,CAEtD,SACE,2BAA2B,QAAQ,KAAK,OAAQ,KAAK,6BAA8B,KAAK,OAAQ,KAAK,eAAe,EACpH,CAIA,KAAK,OAAO,mBAAmB,EAC/B,KAAK,OAAO,YAAY,EACxB,KAAK,OAAO,YAAY,CAC1B,SAAW,KAAK,0BAA2B,CAGzC,MAAM,eAAiB,KAAK,YAAY,cAAc,UAAU,EAChE,KAAK,OAAO,aAAa,OAAO,0BAA0B,EAC1D,KAAK,OAAO,UAAU,EACtB,KAAK,OAAO,WAAW,MAAM,kBAAkB,EAC/C,KAAK,0BAA0B,8BAA8B,cAAc,CAC7E,KAAO,CAEL,KAAK,OAAO,aAAa,UAAU,EACnC,KAAK,OAAO,UAAU,EACtB,KAAK,OAAO,WAAW,IAAI,CAC7B,CACF,CAEC,gBAAiB,CAChB,MAAO,KAAK,OAAO,SAAS,OAAO,UAAU,EAAE,EAAG,CAChD,KAAK,OAAO,UAAU,EACtB,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,EAAG,CACjD,KAAK,OAAO,kBAAkB,OAAO,UAAU,MAAM,EACrD,KAAK,gBAAgB,oBAAoB,EACzC,KAAK,OAAO,kBAAkB,OAAO,UAAU,MAAM,CACvD,KAAO,CACL,KAAK,OAAO,kBAAkB,OAAO,UAAU,IAAI,EACnD,MAAO,KAAK,OAAO,SAAS,OAAO,UAAU,GAAG,EAAG,CACjD,KAAK,OAAO,kBAAkB,OAAO,UAAU,GAAG,EAClD,KAAK,OAAO,kBAAkB,OAAO,UAAU,IAAI,CACrD,CACA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,EAAG,CACjD,KAAK,OAAO,kBAAkB,OAAO,UAAU,MAAM,EACrD,KAAK,gBAAgB,oBAAoB,EACzC,KAAK,OAAO,kBAAkB,OAAO,UAAU,MAAM,CACvD,CACF,CACF,CACF,CAKC,kBAAmB,CAClB,GAAI,KAAK,kBAAkB,EAAG,CAC5B,KAAK,uBAAuB,CAC9B,KAAO,CACL,KAAK,wBAAwB,CAC/B,CACF,CAOC,mBAAoB,CACnB,IAAI,WAAa,KAAK,OAAO,aAAa,EAE1C,aAEA,aACA,GAAI,CAAC,KAAK,OAAO,gBAAgB,WAAY,OAAO,UAAU,IAAI,EAAG,CACnE,MAAO,MACT,CACA,aACA,MAAO,WAAa,KAAK,OAAO,OAAO,QAAU,KAAK,OAAO,OAAO,UAAU,EAAE,OAAQ,CACtF,YACF,CACA,GAAI,CAAC,KAAK,OAAO,gBAAgB,WAAY,OAAO,UAAU,EAAE,EAAG,CACjE,MAAO,MACT,CACA,MAAO,KACT,CAeC,wBAAyB,CAExB,KAAK,OAAO,mBAAmB,EAE/B,KAAK,OAAO,UAAU,EACtB,MAAM,QAAU,KAAK,OAAO,eAAe,EAE3C,MAAO,CAAC,KAAK,OAAO,SAAS,OAAO,UAAU,EAAE,EAAG,CACjD,KAAK,gBAAgB,aAAa,CACpC,CACA,MAAM,SAAW,KAAK,OAAO,aAAa,EAAE,YAC5C,GAAI,UAAY,KAAM,CACpB,MAAM,IAAI,MAAM,qCAAqC,CACvD,CACA,MAAO,KAAK,OAAO,aAAa,EAAI,SAAU,CAC5C,KAAK,gBAAgB,aAAa,CACpC,CACA,KAAK,OAAO,WAAW,aAAa,aAAa,SAAS,CAC5D,CASC,yBAA0B,CACzB,KAAK,OAAO,mBAAmB,EAC/B,KAAK,OAAO,YAAY,EACxB,MAAM,YAAc,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,EAChE,GAAI,YAAa,CACf,KAAK,OAAO,WAAW,GAAG,CAC5B,CAEA,IAAI,MAAQ,EACZ,MAAO,KAAM,CACX,GACE,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,GAC5C,KAAK,OAAO,SAAS,OAAO,UAAU,YAAY,GAClD,KAAK,OAAO,SAAS,OAAO,UAAU,QAAQ,EAC9C,CACA,QACA,KAAK,OAAO,UAAU,CACxB,SAAW,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,GAAK,KAAK,OAAO,SAAS,OAAO,UAAU,QAAQ,EAAG,CAC3G,QACA,KAAK,OAAO,UAAU,CACxB,SACE,QAAU,GACV,CAAC,KAAK,OAAO,SAAS,OAAO,UAAU,IAAI,GAC3C,CAAC,KAAK,OAAO,aAAa,EAAE,OAC5B,CACA,KACF,SAAW,KAAK,OAAO,SAAS,OAAO,UAAU,EAAE,EAAG,CAGpD,MAAM,SAAW,KAAK,OAAO,aAAa,EAAE,YAC5C,GAAI,UAAY,KAAM,CACpB,MAAM,IAAI,MAAM,qCAAqC,CACvD,CACA,MAAO,KAAK,OAAO,aAAa,EAAI,SAAU,CAC5C,KAAK,gBAAgB,aAAa,CACpC,CACF,KAAO,CACL,MAAM,MAAQ,KAAK,OAAO,aAAa,EACvC,GAAI,WAAW,cAAc,KAAK,OAAQ,KAAK,EAAG,CAChD,MAAM,KAAO,KAAK,OAAO,eAAe,EACxC,IAAI,YAAc,KAAK,gBAAgB,yBAAyB,IAAI,EACpE,GAAI,cAAgB,KAAM,CACxB,MAAM,IAAI,MAAM,8BAA8B,gCAAgC,CAChF,CACA,GAAI,WAAW,6BAA6B,KAAK,OAAQ,KAAK,EAAG,CAC/D,YAAc,GAAG,SAAS,aAC5B,CACA,KAAK,OAAO,aAAa,WAAW,CACtC,KAAO,CACL,KAAK,gBAAgB,aAAa,CACpC,CACF,CACF,CAEA,GAAI,YAAa,CAEf,MAAM,SAAW,KAAK,OAAO,aAAa,EAAE,YAC5C,GAAI,UAAY,KAAM,CACpB,MAAM,IAAI,MAAM,qCAAqC,CACvD,CACA,MAAO,KAAK,OAAO,aAAa,EAAI,SAAU,CAC5C,KAAK,gBAAgB,aAAa,CACpC,CACA,KAAK,OAAO,WAAW,GAAG,CAC5B,CACF,CAQC,uBAAwB,CACvB,KAAK,OAAO,aAAa,EAAE,EAC3B,MAAM,KAAO,KAAK,qBAAqB,EACvC,KAAK,OAAO,WAAW,YAAY,UAAU,OAAO,CACtD,CAKC,sBAAuB,CACtB,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,SAAS,EAAG,CACpD,KAAK,OAAO,UAAU,CACxB,SAAW,KAAK,OAAO,SAAS,OAAO,UAAU,KAAM,OAAO,UAAU,SAAS,EAAG,CAClF,GAAI,CAAC,KAAK,OAAO,kBAAkB,UAAU,kBAAkB,MAAM,EAAG,CACtE,MAAM,IAAI,MAAM,4CAA4C,CAC9D,CACA,KAAK,OAAO,UAAU,EACtB,KAAK,OAAO,UAAU,CACxB,CACA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,IAAI,EAAG,CAC/C,KAAK,OAAO,UAAU,CACxB,CACA,GAAI,CAAC,KAAK,OAAO,SAAS,OAAO,UAAU,IAAI,EAAG,CAChD,MAAM,IAAI,MAAM,iDAAiD,CACnE,CACA,MAAM,KAAO,KAAK,OAAO,eAAe,EACxC,KAAK,OAAO,UAAU,EACtB,GAAI,KAAK,OAAO,aAAa,EAAE,OAAQ,CACrC,KAAK,OAAO,mBAAmB,EAC/B,MAAO,KAAK,OAAO,aAAa,EAAE,OAAQ,CACxC,KAAK,OAAO,YAAY,CAC1B,CACF,CACA,KAAK,OAAO,kBAAkB,OAAO,UAAU,MAAM,EACrD,KAAK,gBAAgB,oBAAoB,EACzC,KAAK,OAAO,kBAAkB,OAAO,UAAU,MAAM,EACrD,KAAK,gBAAgB,yBAAyB,EAC9C,KAAK,OAAO,kBAAkB,OAAO,UAAU,MAAM,EACrD,KAAK,gBAAgB,oBAAoB,EACzC,KAAK,OAAO,kBAAkB,OAAO,UAAU,MAAM,EACrD,OAAO,IACT,CAQC,oBAAqB,CACpB,KAAK,OAAO,mBAAmB,EAC/B,KAAK,eAAe,EACpB,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,SAAS,EAAG,CACpD,KAAK,OAAO,YAAY,CAC1B,CACA,MAAM,KAAO,KAAK,gBAAgB,kBAAkB,EACpD,KAAK,OAAO,WAAW,YAAY,UAAU,OAAO,CACtD,CAiBC,uBAAwB,CACvB,KAAK,OAAO,mBAAmB,EAC/B,KAAK,OAAO,YAAY,EAExB,MAAM,iBAAmB,CAAC,EAC1B,MAAO,KAAM,CACX,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,EAAG,CACjD,KAAK,OAAO,YAAY,EACxB,KACF,CAEA,MAAM,cAAgB,+BAA+B,QAAQ,KAAK,OAAQ,KAAK,MAAM,EACrF,MAAO,KAAK,OAAO,aAAa,EAAI,cAAc,SAAU,CAC1D,KAAK,OAAO,YAAY,CAC1B,CACA,GAAI,CAAC,cAAc,QAAU,CAAC,KAAK,8BAA8B,cAAc,QAAQ,EAAG,CACxF,MAAM,UAAY,cAAc,SAChC,MAAM,aAAe,cAAc,UACnC,MAAM,aAAe,KAAK,gBAAgB,yBAAyB,SAAS,EAC5E,iBAAiB,KAAK,WAAW,kBAAkB,cAAgB,YAAY,CACjF,CAEA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,EAAG,CACjD,KAAK,OAAO,YAAY,EACxB,KACF,CACA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,MAAO,OAAO,UAAU,MAAM,EAAG,CACzE,KAAK,OAAO,YAAY,EACxB,KAAK,OAAO,YAAY,EACxB,KACF,SAAW,KAAK,OAAO,SAAS,OAAO,UAAU,KAAK,EAAG,CACvD,KAAK,OAAO,YAAY,CAC1B,KAAO,CACL,MAAM,IAAI,MAAM,qBAAqB,KAAK,UAAU,KAAK,OAAO,aAAa,CAAC,GAAG,CACnF,CACF,CAEA,GAAI,KAAK,OAAO,kBAAkB,UAAU,kBAAkB,KAAK,EAAG,CAGpE,KAAK,OAAO,YAAY,EACxB,MAAM,KAAO,KAAK,OAAO,YAAY,EACrC,KAAK,OAAO,mCAAmC,KAAK,gBAAgB,gBAAgB,IAAI,CAAC,EACzF,4BAA4B,2BAA2B,KAAK,OAAQ,KAAK,MAAM,CACjF,KAAO,CAEL,KAAK,OAAO,WAAW,iBAAiB,KAAK,GAAG,CAAC,CACnD,CAEA,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,IAAI,EAAG,CAC/C,KAAK,OAAO,YAAY,CAC1B,CACF,CAEC,mBAAoB,CACnB,KAAK,OAAO,mBAAmB,EAC/B,MAAO,CAAC,KAAK,OAAO,SAAS,OAAO,UAAU,MAAM,EAAG,CACrD,KAAK,OAAO,YAAY,CAC1B,CACA,MAAM,KAAO,KAAK,OAAO,YAAY,EACrC,KAAK,OAAO,mCAAmC,KAAK,gBAAgB,gBAAgB,IAAI,CAAC,EACzF,4BAA4B,2BAA2B,KAAK,OAAQ,KAAK,MAAM,EAC/E,GAAI,KAAK,OAAO,SAAS,OAAO,UAAU,IAAI,EAAG,CAC/C,KAAK,OAAO,YAAY,CAC1B,CACF,CAEC,8BAA8B,KAAM,CACnC,OAAO,KAAK,8BAAgC,CAAC,KAAK,gBAAgB,kBAAkB,IAAI,IAAI,CAC9F,CACF,CAp0BO,oDAo0BL,QAAQ,QAAU","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/transformers/CJSImportTransformer.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\nvar _tokenizer = require('../parser/tokenizer');\nvar _keywords = require('../parser/tokenizer/keywords');\nvar _types = require('../parser/tokenizer/types');\n\nvar _elideImportEquals = require('../util/elideImportEquals'); var _elideImportEquals2 = _interopRequireDefault(_elideImportEquals);\n\n\n\nvar _getDeclarationInfo = require('../util/getDeclarationInfo'); var _getDeclarationInfo2 = _interopRequireDefault(_getDeclarationInfo);\nvar _getImportExportSpecifierInfo = require('../util/getImportExportSpecifierInfo'); var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);\nvar _removeMaybeImportAssertion = require('../util/removeMaybeImportAssertion');\nvar _shouldElideDefaultExport = require('../util/shouldElideDefaultExport'); var _shouldElideDefaultExport2 = _interopRequireDefault(_shouldElideDefaultExport);\n\n\nvar _Transformer = require('./Transformer'); var _Transformer2 = _interopRequireDefault(_Transformer);\n\n/**\n * Class for editing import statements when we are transforming to commonjs.\n */\n class CJSImportTransformer extends _Transformer2.default {\n   __init() {this.hadExport = false}\n   __init2() {this.hadNamedExport = false}\n   __init3() {this.hadDefaultExport = false}\n  \n\n  constructor(\n     rootTransformer,\n     tokens,\n     importProcessor,\n     nameManager,\n     helperManager,\n     reactHotLoaderTransformer,\n     enableLegacyBabel5ModuleInterop,\n     enableLegacyTypeScriptModuleInterop,\n     isTypeScriptTransformEnabled,\n     preserveDynamicImport,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.preserveDynamicImport = preserveDynamicImport;CJSImportTransformer.prototype.__init.call(this);CJSImportTransformer.prototype.__init2.call(this);CJSImportTransformer.prototype.__init3.call(this);;\n    this.declarationInfo = isTypeScriptTransformEnabled\n      ? _getDeclarationInfo2.default.call(void 0, tokens)\n      : _getDeclarationInfo.EMPTY_DECLARATION_INFO;\n  }\n\n  getPrefixCode() {\n    let prefix = \"\";\n    if (this.hadExport) {\n      prefix += 'Object.defineProperty(exports, \"__esModule\", {value: true});';\n    }\n    return prefix;\n  }\n\n  getSuffixCode() {\n    if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {\n      return \"\\nmodule.exports = exports.default;\\n\";\n    }\n    return \"\";\n  }\n\n  process() {\n    // TypeScript `import foo = require('foo');` should always just be translated to plain require.\n    if (this.tokens.matches3(_types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)) {\n      return this.processImportEquals();\n    }\n    if (this.tokens.matches1(_types.TokenType._import)) {\n      this.processImport();\n      return true;\n    }\n    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.eq)) {\n      this.tokens.replaceToken(\"module.exports\");\n      return true;\n    }\n    if (this.tokens.matches1(_types.TokenType._export) && !this.tokens.currentToken().isType) {\n      this.hadExport = true;\n      return this.processExport();\n    }\n    if (this.tokens.matches2(_types.TokenType.name, _types.TokenType.postIncDec)) {\n      // Fall through to normal identifier matching if this doesn't apply.\n      if (this.processPostIncDec()) {\n        return true;\n      }\n    }\n    if (this.tokens.matches1(_types.TokenType.name) || this.tokens.matches1(_types.TokenType.jsxName)) {\n      return this.processIdentifier();\n    }\n    if (this.tokens.matches1(_types.TokenType.eq)) {\n      return this.processAssignment();\n    }\n    if (this.tokens.matches1(_types.TokenType.assign)) {\n      return this.processComplexAssignment();\n    }\n    if (this.tokens.matches1(_types.TokenType.preIncDec)) {\n      return this.processPreIncDec();\n    }\n    return false;\n  }\n\n   processImportEquals() {\n    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    if (this.importProcessor.isTypeName(importName)) {\n      // If this name is only used as a type, elide the whole import.\n      _elideImportEquals2.default.call(void 0, this.tokens);\n    } else {\n      // Otherwise, switch `import` to `const`.\n      this.tokens.replaceToken(\"const\");\n    }\n    return true;\n  }\n\n  /**\n   * Transform this:\n   * import foo, {bar} from 'baz';\n   * into\n   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);\n   *\n   * The import code was already generated in the import preprocessing step, so\n   * we just need to look it up.\n   */\n   processImport() {\n    if (this.tokens.matches2(_types.TokenType._import, _types.TokenType.parenL)) {\n      if (this.preserveDynamicImport) {\n        // Bail out, only making progress for this one token.\n        this.tokens.copyToken();\n        return;\n      }\n      const requireWrapper = this.enableLegacyTypeScriptModuleInterop\n        ? \"\"\n        : `${this.helperManager.getHelperName(\"interopRequireWildcard\")}(`;\n      this.tokens.replaceToken(`Promise.resolve().then(() => ${requireWrapper}require`);\n      const contextId = this.tokens.currentToken().contextId;\n      if (contextId == null) {\n        throw new Error(\"Expected context ID on dynamic import invocation.\");\n      }\n      this.tokens.copyToken();\n      while (!this.tokens.matchesContextIdAndLabel(_types.TokenType.parenR, contextId)) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.replaceToken(requireWrapper ? \")))\" : \"))\");\n      return;\n    }\n\n    const wasOnlyTypes = this.removeImportAndDetectIfType();\n\n    if (wasOnlyTypes) {\n      this.tokens.removeToken();\n    } else {\n      const path = this.tokens.stringValue();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n      this.tokens.appendCode(this.importProcessor.claimImportCode(path));\n    }\n    _removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0, this.tokens);\n    if (this.tokens.matches1(_types.TokenType.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n  /**\n   * Erase this import, and return true if it was either of the form \"import type\" or contained only\n   * \"type\" named imports. Such imports should not even do a side-effect import.\n   *\n   * The position should end at the import string.\n   */\n   removeImportAndDetectIfType() {\n    this.tokens.removeInitialToken();\n    if (\n      this.tokens.matchesContextual(_keywords.ContextualKeyword._type) &&\n      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.comma) &&\n      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._from)\n    ) {\n      // This is an \"import type\" statement, so exit early.\n      this.removeRemainingImport();\n      return true;\n    }\n\n    if (this.tokens.matches1(_types.TokenType.name) || this.tokens.matches1(_types.TokenType.star)) {\n      // We have a default import or namespace import, so there must be some\n      // non-type import.\n      this.removeRemainingImport();\n      return false;\n    }\n\n    if (this.tokens.matches1(_types.TokenType.string)) {\n      // This is a bare import, so we should proceed with the import.\n      return false;\n    }\n\n    let foundNonType = false;\n    while (!this.tokens.matches1(_types.TokenType.string)) {\n      // Check if any named imports are of the form \"foo\" or \"foo as bar\", with\n      // no leading \"type\".\n      if ((!foundNonType && this.tokens.matches1(_types.TokenType.braceL)) || this.tokens.matches1(_types.TokenType.comma)) {\n        this.tokens.removeToken();\n        if (\n          this.tokens.matches2(_types.TokenType.name, _types.TokenType.comma) ||\n          this.tokens.matches2(_types.TokenType.name, _types.TokenType.braceR) ||\n          this.tokens.matches4(_types.TokenType.name, _types.TokenType.name, _types.TokenType.name, _types.TokenType.comma) ||\n          this.tokens.matches4(_types.TokenType.name, _types.TokenType.name, _types.TokenType.name, _types.TokenType.braceR)\n        ) {\n          foundNonType = true;\n        }\n      }\n      this.tokens.removeToken();\n    }\n    return !foundNonType;\n  }\n\n   removeRemainingImport() {\n    while (!this.tokens.matches1(_types.TokenType.string)) {\n      this.tokens.removeToken();\n    }\n  }\n\n   processIdentifier() {\n    const token = this.tokens.currentToken();\n    if (token.shadowsGlobal) {\n      return false;\n    }\n\n    if (token.identifierRole === _tokenizer.IdentifierRole.ObjectShorthand) {\n      return this.processObjectShorthand();\n    }\n\n    if (token.identifierRole !== _tokenizer.IdentifierRole.Access) {\n      return false;\n    }\n    const replacement = this.importProcessor.getIdentifierReplacement(\n      this.tokens.identifierNameForToken(token),\n    );\n    if (!replacement) {\n      return false;\n    }\n    // Tolerate any number of closing parens while looking for an opening paren\n    // that indicates a function call.\n    let possibleOpenParenIndex = this.tokens.currentIndex() + 1;\n    while (\n      possibleOpenParenIndex < this.tokens.tokens.length &&\n      this.tokens.tokens[possibleOpenParenIndex].type === _types.TokenType.parenR\n    ) {\n      possibleOpenParenIndex++;\n    }\n    // Avoid treating imported functions as methods of their `exports` object\n    // by using `(0, f)` when the identifier is in a paren expression. Else\n    // use `Function.prototype.call` when the identifier is a guaranteed\n    // function call. When using `call`, pass undefined as the context.\n    if (this.tokens.tokens[possibleOpenParenIndex].type === _types.TokenType.parenL) {\n      if (\n        this.tokens.tokenAtRelativeIndex(1).type === _types.TokenType.parenL &&\n        this.tokens.tokenAtRelativeIndex(-1).type !== _types.TokenType._new\n      ) {\n        this.tokens.replaceToken(`${replacement}.call(void 0, `);\n        // Remove the old paren.\n        this.tokens.removeToken();\n        // Balance out the new paren.\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(_types.TokenType.parenR);\n      } else {\n        // See here: http://2ality.com/2015/12/references.html\n        this.tokens.replaceToken(`(0, ${replacement})`);\n      }\n    } else {\n      this.tokens.replaceToken(replacement);\n    }\n    return true;\n  }\n\n  processObjectShorthand() {\n    const identifier = this.tokens.identifierName();\n    const replacement = this.importProcessor.getIdentifierReplacement(identifier);\n    if (!replacement) {\n      return false;\n    }\n    this.tokens.replaceToken(`${identifier}: ${replacement}`);\n    return true;\n  }\n\n  processExport() {\n    if (\n      this.tokens.matches2(_types.TokenType._export, _types.TokenType._enum) ||\n      this.tokens.matches3(_types.TokenType._export, _types.TokenType._const, _types.TokenType._enum)\n    ) {\n      // Let the TypeScript transform handle it.\n      return false;\n    }\n    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._default)) {\n      this.hadDefaultExport = true;\n      if (this.tokens.matches3(_types.TokenType._export, _types.TokenType._default, _types.TokenType._enum)) {\n        // Flow export default enums need some special handling, so handle them\n        // in that tranform rather than this one.\n        return false;\n      }\n      this.processExportDefault();\n      return true;\n    }\n    this.hadNamedExport = true;\n    if (\n      this.tokens.matches2(_types.TokenType._export, _types.TokenType._var) ||\n      this.tokens.matches2(_types.TokenType._export, _types.TokenType._let) ||\n      this.tokens.matches2(_types.TokenType._export, _types.TokenType._const)\n    ) {\n      this.processExportVar();\n      return true;\n    } else if (\n      this.tokens.matches2(_types.TokenType._export, _types.TokenType._function) ||\n      // export async function\n      this.tokens.matches3(_types.TokenType._export, _types.TokenType.name, _types.TokenType._function)\n    ) {\n      this.processExportFunction();\n      return true;\n    } else if (\n      this.tokens.matches2(_types.TokenType._export, _types.TokenType._class) ||\n      this.tokens.matches3(_types.TokenType._export, _types.TokenType._abstract, _types.TokenType._class) ||\n      this.tokens.matches2(_types.TokenType._export, _types.TokenType.at)\n    ) {\n      this.processExportClass();\n      return true;\n    } else if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.braceL)) {\n      this.processExportBindings();\n      return true;\n    } else if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.star)) {\n      this.processExportStar();\n      return true;\n    } else if (\n      this.tokens.matches2(_types.TokenType._export, _types.TokenType.name) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._type)\n    ) {\n      // export type {a};\n      // export type {a as b};\n      // export type {a} from './b';\n      // export type * from './b';\n      // export type * as ns from './b';\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      if (this.tokens.matches1(_types.TokenType.braceL)) {\n        while (!this.tokens.matches1(_types.TokenType.braceR)) {\n          this.tokens.removeToken();\n        }\n        this.tokens.removeToken();\n      } else {\n        // *\n        this.tokens.removeToken();\n        if (this.tokens.matches1(_types.TokenType._as)) {\n          // as\n          this.tokens.removeToken();\n          // ns\n          this.tokens.removeToken();\n        }\n      }\n      // Remove type re-export `... } from './T'`\n      if (\n        this.tokens.matchesContextual(_keywords.ContextualKeyword._from) &&\n        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.string)\n      ) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        _removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0, this.tokens);\n      }\n      return true;\n    } else {\n      throw new Error(\"Unrecognized export syntax.\");\n    }\n  }\n\n   processAssignment() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index - 1];\n    // If the LHS is a type identifier, this must be a declaration like `let a: b = c;`,\n    // with `b` as the identifier, so nothing needs to be done in that case.\n    if (identifierToken.isType || identifierToken.type !== _types.TokenType.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, _types.TokenType.dot)) {\n      return false;\n    }\n    if (index >= 2 && [_types.TokenType._var, _types.TokenType._let, _types.TokenType._const].includes(this.tokens.tokens[index - 2].type)) {\n      // Declarations don't need an extra assignment. This doesn't avoid the\n      // assignment for comma-separated declarations, but it's still correct\n      // since the assignment is just redundant.\n      return false;\n    }\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(\n      this.tokens.identifierNameForToken(identifierToken),\n    );\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.copyToken();\n    this.tokens.appendCode(` ${assignmentSnippet} =`);\n    return true;\n  }\n\n  /**\n   * Process something like `a += 3`, where `a` might be an exported value.\n   */\n   processComplexAssignment() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index - 1];\n    if (identifierToken.type !== _types.TokenType.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, _types.TokenType.dot)) {\n      return false;\n    }\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(\n      this.tokens.identifierNameForToken(identifierToken),\n    );\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.appendCode(` = ${assignmentSnippet}`);\n    this.tokens.copyToken();\n    return true;\n  }\n\n  /**\n   * Process something like `++a`, where `a` might be an exported value.\n   */\n   processPreIncDec() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index + 1];\n    if (identifierToken.type !== _types.TokenType.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    // Ignore things like ++a.b and ++a[b] and ++a().b.\n    if (\n      index + 2 < this.tokens.tokens.length &&\n      (this.tokens.matches1AtIndex(index + 2, _types.TokenType.dot) ||\n        this.tokens.matches1AtIndex(index + 2, _types.TokenType.bracketL) ||\n        this.tokens.matches1AtIndex(index + 2, _types.TokenType.parenL))\n    ) {\n      return false;\n    }\n    const identifierName = this.tokens.identifierNameForToken(identifierToken);\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.appendCode(`${assignmentSnippet} = `);\n    this.tokens.copyToken();\n    return true;\n  }\n\n  /**\n   * Process something like `a++`, where `a` might be an exported value.\n   * This starts at the `a`, not at the `++`.\n   */\n   processPostIncDec() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index];\n    const operatorToken = this.tokens.tokens[index + 1];\n    if (identifierToken.type !== _types.TokenType.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 1 && this.tokens.matches1AtIndex(index - 1, _types.TokenType.dot)) {\n      return false;\n    }\n    const identifierName = this.tokens.identifierNameForToken(identifierToken);\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);\n    if (!assignmentSnippet) {\n      return false;\n    }\n    const operatorCode = this.tokens.rawCodeForToken(operatorToken);\n    // We might also replace the identifier with something like exports.x, so\n    // do that replacement here as well.\n    const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;\n    if (operatorCode === \"++\") {\n      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);\n    } else if (operatorCode === \"--\") {\n      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);\n    } else {\n      throw new Error(`Unexpected operator: ${operatorCode}`);\n    }\n    this.tokens.removeToken();\n    return true;\n  }\n\n   processExportDefault() {\n    if (\n      this.tokens.matches4(_types.TokenType._export, _types.TokenType._default, _types.TokenType._function, _types.TokenType.name) ||\n      // export default async function\n      (this.tokens.matches5(_types.TokenType._export, _types.TokenType._default, _types.TokenType.name, _types.TokenType._function, _types.TokenType.name) &&\n        this.tokens.matchesContextualAtIndex(\n          this.tokens.currentIndex() + 2,\n          _keywords.ContextualKeyword._async,\n        ))\n    ) {\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      // Named function export case: change it to a top-level function\n      // declaration followed by exports statement.\n      const name = this.processNamedFunction();\n      this.tokens.appendCode(` exports.default = ${name};`);\n    } else if (\n      this.tokens.matches4(_types.TokenType._export, _types.TokenType._default, _types.TokenType._class, _types.TokenType.name) ||\n      this.tokens.matches5(_types.TokenType._export, _types.TokenType._default, _types.TokenType._abstract, _types.TokenType._class, _types.TokenType.name) ||\n      this.tokens.matches3(_types.TokenType._export, _types.TokenType._default, _types.TokenType.at)\n    ) {\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.copyDecorators();\n      if (this.tokens.matches1(_types.TokenType._abstract)) {\n        this.tokens.removeToken();\n      }\n      const name = this.rootTransformer.processNamedClass();\n      this.tokens.appendCode(` exports.default = ${name};`);\n      // After this point, this is a plain \"export default E\" statement.\n    } else if (\n      _shouldElideDefaultExport2.default.call(void 0, this.isTypeScriptTransformEnabled, this.tokens, this.declarationInfo)\n    ) {\n      // If the exported value is just an identifier and should be elided by TypeScript\n      // rules, then remove it entirely. It will always have the form `export default e`,\n      // where `e` is an identifier.\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n    } else if (this.reactHotLoaderTransformer) {\n      // We need to assign E to a variable. Change \"export default E\" to\n      // \"let _default; exports.default = _default = E\"\n      const defaultVarName = this.nameManager.claimFreeName(\"_default\");\n      this.tokens.replaceToken(`let ${defaultVarName}; exports.`);\n      this.tokens.copyToken();\n      this.tokens.appendCode(` = ${defaultVarName} =`);\n      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);\n    } else {\n      // Change \"export default E\" to \"exports.default = E\"\n      this.tokens.replaceToken(\"exports.\");\n      this.tokens.copyToken();\n      this.tokens.appendCode(\" =\");\n    }\n  }\n\n   copyDecorators() {\n    while (this.tokens.matches1(_types.TokenType.at)) {\n      this.tokens.copyToken();\n      if (this.tokens.matches1(_types.TokenType.parenL)) {\n        this.tokens.copyExpectedToken(_types.TokenType.parenL);\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(_types.TokenType.parenR);\n      } else {\n        this.tokens.copyExpectedToken(_types.TokenType.name);\n        while (this.tokens.matches1(_types.TokenType.dot)) {\n          this.tokens.copyExpectedToken(_types.TokenType.dot);\n          this.tokens.copyExpectedToken(_types.TokenType.name);\n        }\n        if (this.tokens.matches1(_types.TokenType.parenL)) {\n          this.tokens.copyExpectedToken(_types.TokenType.parenL);\n          this.rootTransformer.processBalancedCode();\n          this.tokens.copyExpectedToken(_types.TokenType.parenR);\n        }\n      }\n    }\n  }\n\n  /**\n   * Transform a declaration like `export var`, `export let`, or `export const`.\n   */\n   processExportVar() {\n    if (this.isSimpleExportVar()) {\n      this.processSimpleExportVar();\n    } else {\n      this.processComplexExportVar();\n    }\n  }\n\n  /**\n   * Determine if the export is of the form:\n   * export var/let/const [varName] = [expr];\n   * In other words, determine if function name inference might apply.\n   */\n   isSimpleExportVar() {\n    let tokenIndex = this.tokens.currentIndex();\n    // export\n    tokenIndex++;\n    // var/let/const\n    tokenIndex++;\n    if (!this.tokens.matches1AtIndex(tokenIndex, _types.TokenType.name)) {\n      return false;\n    }\n    tokenIndex++;\n    while (tokenIndex < this.tokens.tokens.length && this.tokens.tokens[tokenIndex].isType) {\n      tokenIndex++;\n    }\n    if (!this.tokens.matches1AtIndex(tokenIndex, _types.TokenType.eq)) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Transform an `export var` declaration initializing a single variable.\n   *\n   * For example, this:\n   * export const f = () => {};\n   * becomes this:\n   * const f = () => {}; exports.f = f;\n   *\n   * The variable is unused (e.g. exports.f has the true value of the export).\n   * We need to produce an assignment of this form so that the function will\n   * have an inferred name of \"f\", which wouldn't happen in the more general\n   * case below.\n   */\n   processSimpleExportVar() {\n    // export\n    this.tokens.removeInitialToken();\n    // var/let/const\n    this.tokens.copyToken();\n    const varName = this.tokens.identifierName();\n    // x: number  ->  x\n    while (!this.tokens.matches1(_types.TokenType.eq)) {\n      this.rootTransformer.processToken();\n    }\n    const endIndex = this.tokens.currentToken().rhsEndIndex;\n    if (endIndex == null) {\n      throw new Error(\"Expected = token with an end index.\");\n    }\n    while (this.tokens.currentIndex() < endIndex) {\n      this.rootTransformer.processToken();\n    }\n    this.tokens.appendCode(`; exports.${varName} = ${varName}`);\n  }\n\n  /**\n   * Transform normal declaration exports, including handling destructuring.\n   * For example, this:\n   * export const {x: [a = 2, b], c} = d;\n   * becomes this:\n   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)\n   */\n   processComplexExportVar() {\n    this.tokens.removeInitialToken();\n    this.tokens.removeToken();\n    const needsParens = this.tokens.matches1(_types.TokenType.braceL);\n    if (needsParens) {\n      this.tokens.appendCode(\"(\");\n    }\n\n    let depth = 0;\n    while (true) {\n      if (\n        this.tokens.matches1(_types.TokenType.braceL) ||\n        this.tokens.matches1(_types.TokenType.dollarBraceL) ||\n        this.tokens.matches1(_types.TokenType.bracketL)\n      ) {\n        depth++;\n        this.tokens.copyToken();\n      } else if (this.tokens.matches1(_types.TokenType.braceR) || this.tokens.matches1(_types.TokenType.bracketR)) {\n        depth--;\n        this.tokens.copyToken();\n      } else if (\n        depth === 0 &&\n        !this.tokens.matches1(_types.TokenType.name) &&\n        !this.tokens.currentToken().isType\n      ) {\n        break;\n      } else if (this.tokens.matches1(_types.TokenType.eq)) {\n        // Default values might have assignments in the RHS that we want to ignore, so skip past\n        // them.\n        const endIndex = this.tokens.currentToken().rhsEndIndex;\n        if (endIndex == null) {\n          throw new Error(\"Expected = token with an end index.\");\n        }\n        while (this.tokens.currentIndex() < endIndex) {\n          this.rootTransformer.processToken();\n        }\n      } else {\n        const token = this.tokens.currentToken();\n        if (_tokenizer.isDeclaration.call(void 0, token)) {\n          const name = this.tokens.identifierName();\n          let replacement = this.importProcessor.getIdentifierReplacement(name);\n          if (replacement === null) {\n            throw new Error(`Expected a replacement for ${name} in \\`export var\\` syntax.`);\n          }\n          if (_tokenizer.isObjectShorthandDeclaration.call(void 0, token)) {\n            replacement = `${name}: ${replacement}`;\n          }\n          this.tokens.replaceToken(replacement);\n        } else {\n          this.rootTransformer.processToken();\n        }\n      }\n    }\n\n    if (needsParens) {\n      // Seek to the end of the RHS.\n      const endIndex = this.tokens.currentToken().rhsEndIndex;\n      if (endIndex == null) {\n        throw new Error(\"Expected = token with an end index.\");\n      }\n      while (this.tokens.currentIndex() < endIndex) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.appendCode(\")\");\n    }\n  }\n\n  /**\n   * Transform this:\n   * export function foo() {}\n   * into this:\n   * function foo() {} exports.foo = foo;\n   */\n   processExportFunction() {\n    this.tokens.replaceToken(\"\");\n    const name = this.processNamedFunction();\n    this.tokens.appendCode(` exports.${name} = ${name};`);\n  }\n\n  /**\n   * Skip past a function with a name and return that name.\n   */\n   processNamedFunction() {\n    if (this.tokens.matches1(_types.TokenType._function)) {\n      this.tokens.copyToken();\n    } else if (this.tokens.matches2(_types.TokenType.name, _types.TokenType._function)) {\n      if (!this.tokens.matchesContextual(_keywords.ContextualKeyword._async)) {\n        throw new Error(\"Expected async keyword in function export.\");\n      }\n      this.tokens.copyToken();\n      this.tokens.copyToken();\n    }\n    if (this.tokens.matches1(_types.TokenType.star)) {\n      this.tokens.copyToken();\n    }\n    if (!this.tokens.matches1(_types.TokenType.name)) {\n      throw new Error(\"Expected identifier for exported function name.\");\n    }\n    const name = this.tokens.identifierName();\n    this.tokens.copyToken();\n    if (this.tokens.currentToken().isType) {\n      this.tokens.removeInitialToken();\n      while (this.tokens.currentToken().isType) {\n        this.tokens.removeToken();\n      }\n    }\n    this.tokens.copyExpectedToken(_types.TokenType.parenL);\n    this.rootTransformer.processBalancedCode();\n    this.tokens.copyExpectedToken(_types.TokenType.parenR);\n    this.rootTransformer.processPossibleTypeRange();\n    this.tokens.copyExpectedToken(_types.TokenType.braceL);\n    this.rootTransformer.processBalancedCode();\n    this.tokens.copyExpectedToken(_types.TokenType.braceR);\n    return name;\n  }\n\n  /**\n   * Transform this:\n   * export class A {}\n   * into this:\n   * class A {} exports.A = A;\n   */\n   processExportClass() {\n    this.tokens.removeInitialToken();\n    this.copyDecorators();\n    if (this.tokens.matches1(_types.TokenType._abstract)) {\n      this.tokens.removeToken();\n    }\n    const name = this.rootTransformer.processNamedClass();\n    this.tokens.appendCode(` exports.${name} = ${name};`);\n  }\n\n  /**\n   * Transform this:\n   * export {a, b as c};\n   * into this:\n   * exports.a = a; exports.c = b;\n   *\n   * OR\n   *\n   * Transform this:\n   * export {a, b as c} from './foo';\n   * into the pre-generated Object.defineProperty code from the ImportProcessor.\n   *\n   * For the first case, if the TypeScript transform is enabled, we need to skip\n   * exports that are only defined as types.\n   */\n   processExportBindings() {\n    this.tokens.removeInitialToken();\n    this.tokens.removeToken();\n\n    const exportStatements = [];\n    while (true) {\n      if (this.tokens.matches1(_types.TokenType.braceR)) {\n        this.tokens.removeToken();\n        break;\n      }\n\n      const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, this.tokens);\n      while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n        this.tokens.removeToken();\n      }\n      if (!specifierInfo.isType && !this.shouldElideExportedIdentifier(specifierInfo.leftName)) {\n        const localName = specifierInfo.leftName;\n        const exportedName = specifierInfo.rightName;\n        const newLocalName = this.importProcessor.getIdentifierReplacement(localName);\n        exportStatements.push(`exports.${exportedName} = ${newLocalName || localName};`);\n      }\n\n      if (this.tokens.matches1(_types.TokenType.braceR)) {\n        this.tokens.removeToken();\n        break;\n      }\n      if (this.tokens.matches2(_types.TokenType.comma, _types.TokenType.braceR)) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        break;\n      } else if (this.tokens.matches1(_types.TokenType.comma)) {\n        this.tokens.removeToken();\n      } else {\n        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);\n      }\n    }\n\n    if (this.tokens.matchesContextual(_keywords.ContextualKeyword._from)) {\n      // This is an export...from, so throw away the normal named export code\n      // and use the Object.defineProperty code from ImportProcessor.\n      this.tokens.removeToken();\n      const path = this.tokens.stringValue();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n      _removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0, this.tokens);\n    } else {\n      // This is a normal named export, so use that.\n      this.tokens.appendCode(exportStatements.join(\" \"));\n    }\n\n    if (this.tokens.matches1(_types.TokenType.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n   processExportStar() {\n    this.tokens.removeInitialToken();\n    while (!this.tokens.matches1(_types.TokenType.string)) {\n      this.tokens.removeToken();\n    }\n    const path = this.tokens.stringValue();\n    this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n    _removeMaybeImportAssertion.removeMaybeImportAssertion.call(void 0, this.tokens);\n    if (this.tokens.matches1(_types.TokenType.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n   shouldElideExportedIdentifier(name) {\n    return this.isTypeScriptTransformEnabled && !this.declarationInfo.valueDeclarations.has(name);\n  }\n} exports.default = CJSImportTransformer;\n"]}}