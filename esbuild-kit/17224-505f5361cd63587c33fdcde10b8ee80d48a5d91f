{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _base=require(\"../traverser/base\");var _charcodes=require(\"../util/charcodes\");var _identifier=require(\"../util/identifier\");var _index=require(\"./index\");var _readWordTree=require(\"./readWordTree\");var _types=require(\"./types\");function readWord(){let treePos=0;let code=0;let pos=_base.state.pos;while(pos<_base.input.length){code=_base.input.charCodeAt(pos);if(code<_charcodes.charCodes.lowercaseA||code>_charcodes.charCodes.lowercaseZ){break}const next=_readWordTree.READ_WORD_TREE[treePos+(code-_charcodes.charCodes.lowercaseA)+1];if(next===-1){break}else{treePos=next;pos++}}const keywordValue=_readWordTree.READ_WORD_TREE[treePos];if(keywordValue>-1&&!_identifier.IS_IDENTIFIER_CHAR[code]){_base.state.pos=pos;if(keywordValue&1){_index.finishToken.call(void 0,keywordValue>>>1)}else{_index.finishToken.call(void 0,_types.TokenType.name,keywordValue>>>1)}return}while(pos<_base.input.length){const ch=_base.input.charCodeAt(pos);if(_identifier.IS_IDENTIFIER_CHAR[ch]){pos++}else if(ch===_charcodes.charCodes.backslash){pos+=2;if(_base.input.charCodeAt(pos)===_charcodes.charCodes.leftCurlyBrace){while(pos<_base.input.length&&_base.input.charCodeAt(pos)!==_charcodes.charCodes.rightCurlyBrace){pos++}pos++}}else if(ch===_charcodes.charCodes.atSign&&_base.input.charCodeAt(pos+1)===_charcodes.charCodes.atSign){pos+=2}else{break}}_base.state.pos=pos;_index.finishToken.call(void 0,_types.TokenType.name)}__name(readWord,\"readWord\");exports.default=readWord;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAAE,IAAI,MAAQ,QAAQ,mBAAmB,EAChH,IAAI,WAAa,QAAQ,mBAAmB,EAC5C,IAAI,YAAc,QAAQ,oBAAoB,EAC9C,IAAI,OAAS,QAAQ,SAAS,EAC9B,IAAI,cAAgB,QAAQ,gBAAgB,EAC5C,IAAI,OAAS,QAAQ,SAAS,EAQ7B,SAAS,UAAW,CACnB,IAAI,QAAU,EACd,IAAI,KAAO,EACX,IAAI,IAAM,MAAM,MAAM,IACtB,MAAO,IAAM,MAAM,MAAM,OAAQ,CAC/B,KAAO,MAAM,MAAM,WAAW,GAAG,EACjC,GAAI,KAAO,WAAW,UAAU,YAAc,KAAO,WAAW,UAAU,WAAY,CACpF,KACF,CACA,MAAM,KAAO,cAAc,eAAe,SAAW,KAAO,WAAW,UAAU,YAAc,CAAC,EAChG,GAAI,OAAS,GAAI,CACf,KACF,KAAO,CACL,QAAU,KACV,KACF,CACF,CAEA,MAAM,aAAe,cAAc,eAAe,OAAO,EACzD,GAAI,aAAe,IAAM,CAAC,YAAY,mBAAmB,IAAI,EAAG,CAC9D,MAAM,MAAM,IAAM,IAClB,GAAI,aAAe,EAAG,CACpB,OAAO,YAAY,KAAK,OAAQ,eAAiB,CAAC,CACpD,KAAO,CACL,OAAO,YAAY,KAAK,OAAQ,OAAO,UAAU,KAAM,eAAiB,CAAC,CAC3E,CACA,MACF,CAEA,MAAO,IAAM,MAAM,MAAM,OAAQ,CAC/B,MAAM,GAAK,MAAM,MAAM,WAAW,GAAG,EACrC,GAAI,YAAY,mBAAmB,EAAE,EAAG,CACtC,KACF,SAAW,KAAO,WAAW,UAAU,UAAW,CAEhD,KAAO,EACP,GAAI,MAAM,MAAM,WAAW,GAAG,IAAM,WAAW,UAAU,eAAgB,CACvE,MAAO,IAAM,MAAM,MAAM,QAAU,MAAM,MAAM,WAAW,GAAG,IAAM,WAAW,UAAU,gBAAiB,CACvG,KACF,CACA,KACF,CACF,SAAW,KAAO,WAAW,UAAU,QAAU,MAAM,MAAM,WAAW,IAAM,CAAC,IAAM,WAAW,UAAU,OAAQ,CAChH,KAAO,CACT,KAAO,CACL,KACF,CACF,CACA,MAAM,MAAM,IAAM,IAClB,OAAO,YAAY,KAAK,OAAQ,OAAO,UAAU,IAAI,CACvD,CAlDU,4BAkDR,QAAQ,QAAU","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/parser/tokenizer/readWord.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});var _base = require('../traverser/base');\nvar _charcodes = require('../util/charcodes');\nvar _identifier = require('../util/identifier');\nvar _index = require('./index');\nvar _readWordTree = require('./readWordTree');\nvar _types = require('./types');\n\n/**\n * Read an identifier, producing either a name token or matching on one of the existing keywords.\n * For performance, we pre-generate big decision tree that we traverse. Each node represents a\n * prefix and has 27 values, where the first value is the token or contextual token, if any (-1 if\n * not), and the other 26 values are the transitions to other nodes, or -1 to stop.\n */\n function readWord() {\n  let treePos = 0;\n  let code = 0;\n  let pos = _base.state.pos;\n  while (pos < _base.input.length) {\n    code = _base.input.charCodeAt(pos);\n    if (code < _charcodes.charCodes.lowercaseA || code > _charcodes.charCodes.lowercaseZ) {\n      break;\n    }\n    const next = _readWordTree.READ_WORD_TREE[treePos + (code - _charcodes.charCodes.lowercaseA) + 1];\n    if (next === -1) {\n      break;\n    } else {\n      treePos = next;\n      pos++;\n    }\n  }\n\n  const keywordValue = _readWordTree.READ_WORD_TREE[treePos];\n  if (keywordValue > -1 && !_identifier.IS_IDENTIFIER_CHAR[code]) {\n    _base.state.pos = pos;\n    if (keywordValue & 1) {\n      _index.finishToken.call(void 0, keywordValue >>> 1);\n    } else {\n      _index.finishToken.call(void 0, _types.TokenType.name, keywordValue >>> 1);\n    }\n    return;\n  }\n\n  while (pos < _base.input.length) {\n    const ch = _base.input.charCodeAt(pos);\n    if (_identifier.IS_IDENTIFIER_CHAR[ch]) {\n      pos++;\n    } else if (ch === _charcodes.charCodes.backslash) {\n      // \\u\n      pos += 2;\n      if (_base.input.charCodeAt(pos) === _charcodes.charCodes.leftCurlyBrace) {\n        while (pos < _base.input.length && _base.input.charCodeAt(pos) !== _charcodes.charCodes.rightCurlyBrace) {\n          pos++;\n        }\n        pos++;\n      }\n    } else if (ch === _charcodes.charCodes.atSign && _base.input.charCodeAt(pos + 1) === _charcodes.charCodes.atSign) {\n      pos += 2;\n    } else {\n      break;\n    }\n  }\n  _base.state.pos = pos;\n  _index.finishToken.call(void 0, _types.TokenType.name);\n} exports.default = readWord;\n"]}}