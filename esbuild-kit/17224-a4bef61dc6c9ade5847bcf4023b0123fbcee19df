{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});Object.defineProperty(exports,\"default\",{enumerable:true,get:function(){return collapseAdjacentRules}});let comparisonMap={atrule:[\"name\",\"params\"],rule:[\"selector\"]};let types=new Set(Object.keys(comparisonMap));function collapseAdjacentRules(){function collapseRulesIn(root){let currentRule=null;root.each(node=>{if(!types.has(node.type)){currentRule=null;return}if(currentRule===null){currentRule=node;return}let properties=comparisonMap[node.type];var _node_property,_currentRule_property;if(node.type===\"atrule\"&&node.name===\"font-face\"){currentRule=node}else if(properties.every(property=>((_node_property=node[property])!==null&&_node_property!==void 0?_node_property:\"\").replace(/\\s+/g,\" \")===((_currentRule_property=currentRule[property])!==null&&_currentRule_property!==void 0?_currentRule_property:\"\").replace(/\\s+/g,\" \"))){if(node.nodes){currentRule.append(node.nodes)}node.remove()}else{currentRule=node}});root.each(node=>{if(node.type===\"atrule\"){collapseRulesIn(node)}})}__name(collapseRulesIn,\"collapseRulesIn\");return root=>{collapseRulesIn(root)}}__name(collapseAdjacentRules,\"collapseAdjacentRules\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CACzC,MAAO,IACX,CAAC,EACD,OAAO,eAAe,QAAS,UAAW,CACtC,WAAY,KACZ,IAAK,UAAW,CACZ,OAAO,qBACX,CACJ,CAAC,EACD,IAAI,cAAgB,CAChB,OAAQ,CACJ,OACA,QACJ,EACA,KAAM,CACF,UACJ,CACJ,EACA,IAAI,MAAQ,IAAI,IAAI,OAAO,KAAK,aAAa,CAAC,EAC9C,SAAS,uBAAwB,CAC7B,SAAS,gBAAgB,KAAM,CAC3B,IAAI,YAAc,KAClB,KAAK,KAAM,MAAO,CACd,GAAI,CAAC,MAAM,IAAI,KAAK,IAAI,EAAG,CACvB,YAAc,KACd,MACJ,CACA,GAAI,cAAgB,KAAM,CACtB,YAAc,KACd,MACJ,CACA,IAAI,WAAa,cAAc,KAAK,IAAI,EACxC,IAAI,eAAgB,sBACpB,GAAI,KAAK,OAAS,UAAY,KAAK,OAAS,YAAa,CACrD,YAAc,IAClB,SAAW,WAAW,MAAO,YAAa,eAAiB,KAAK,QAAQ,KAAO,MAAQ,iBAAmB,OAAS,eAAiB,IAAI,QAAQ,OAAQ,GAAG,MAAQ,sBAAwB,YAAY,QAAQ,KAAO,MAAQ,wBAA0B,OAAS,sBAAwB,IAAI,QAAQ,OAAQ,GAAG,CAAC,EAAG,CAEhT,GAAI,KAAK,MAAO,CACZ,YAAY,OAAO,KAAK,KAAK,CACjC,CACA,KAAK,OAAO,CAChB,KAAO,CACH,YAAc,IAClB,CACJ,CAAC,EAMD,KAAK,KAAM,MAAO,CACd,GAAI,KAAK,OAAS,SAAU,CACxB,gBAAgB,IAAI,CACxB,CACJ,CAAC,CACL,CAnCS,0CAoCT,OAAQ,MAAO,CACX,gBAAgB,IAAI,CACxB,CACJ,CAxCS","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/lib/collapseAdjacentRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return collapseAdjacentRules;\n    }\n});\nlet comparisonMap = {\n    atrule: [\n        \"name\",\n        \"params\"\n    ],\n    rule: [\n        \"selector\"\n    ]\n};\nlet types = new Set(Object.keys(comparisonMap));\nfunction collapseAdjacentRules() {\n    function collapseRulesIn(root) {\n        let currentRule = null;\n        root.each((node)=>{\n            if (!types.has(node.type)) {\n                currentRule = null;\n                return;\n            }\n            if (currentRule === null) {\n                currentRule = node;\n                return;\n            }\n            let properties = comparisonMap[node.type];\n            var _node_property, _currentRule_property;\n            if (node.type === \"atrule\" && node.name === \"font-face\") {\n                currentRule = node;\n            } else if (properties.every((property)=>((_node_property = node[property]) !== null && _node_property !== void 0 ? _node_property : \"\").replace(/\\s+/g, \" \") === ((_currentRule_property = currentRule[property]) !== null && _currentRule_property !== void 0 ? _currentRule_property : \"\").replace(/\\s+/g, \" \"))) {\n                // An AtRule may not have children (for example if we encounter duplicate @import url(â€¦) rules)\n                if (node.nodes) {\n                    currentRule.append(node.nodes);\n                }\n                node.remove();\n            } else {\n                currentRule = node;\n            }\n        });\n        // After we've collapsed adjacent rules & at-rules, we need to collapse\n        // adjacent rules & at-rules that are children of at-rules.\n        // We do not care about nesting rules because Tailwind CSS\n        // explicitly does not handle rule nesting on its own as\n        // the user is expected to use a nesting plugin\n        root.each((node)=>{\n            if (node.type === \"atrule\") {\n                collapseRulesIn(node);\n            }\n        });\n    }\n    return (root)=>{\n        collapseRulesIn(root);\n    };\n}\n"]}}