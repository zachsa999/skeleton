{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});Object.defineProperty(exports,\"default\",{enumerable:true,get:function(){return parseAnimationValue}});const DIRECTIONS=new Set([\"normal\",\"reverse\",\"alternate\",\"alternate-reverse\"]);const PLAY_STATES=new Set([\"running\",\"paused\"]);const FILL_MODES=new Set([\"none\",\"forwards\",\"backwards\",\"both\"]);const ITERATION_COUNTS=new Set([\"infinite\"]);const TIMINGS=new Set([\"linear\",\"ease\",\"ease-in\",\"ease-out\",\"ease-in-out\",\"step-start\",\"step-end\"]);const TIMING_FNS=[\"cubic-bezier\",\"steps\"];const COMMA=/\\,(?![^(]*\\))/g;const SPACE=/\\ +(?![^(]*\\))/g;const TIME=/^(-?[\\d.]+m?s)$/;const DIGIT=/^(\\d+)$/;function parseAnimationValue(input){let animations=input.split(COMMA);return animations.map(animation=>{let value=animation.trim();let result={value};let parts=value.split(SPACE);let seen=new Set;for(let part of parts){if(!seen.has(\"DIRECTIONS\")&&DIRECTIONS.has(part)){result.direction=part;seen.add(\"DIRECTIONS\")}else if(!seen.has(\"PLAY_STATES\")&&PLAY_STATES.has(part)){result.playState=part;seen.add(\"PLAY_STATES\")}else if(!seen.has(\"FILL_MODES\")&&FILL_MODES.has(part)){result.fillMode=part;seen.add(\"FILL_MODES\")}else if(!seen.has(\"ITERATION_COUNTS\")&&(ITERATION_COUNTS.has(part)||DIGIT.test(part))){result.iterationCount=part;seen.add(\"ITERATION_COUNTS\")}else if(!seen.has(\"TIMING_FUNCTION\")&&TIMINGS.has(part)){result.timingFunction=part;seen.add(\"TIMING_FUNCTION\")}else if(!seen.has(\"TIMING_FUNCTION\")&&TIMING_FNS.some(f=>part.startsWith(`${f}(`))){result.timingFunction=part;seen.add(\"TIMING_FUNCTION\")}else if(!seen.has(\"DURATION\")&&TIME.test(part)){result.duration=part;seen.add(\"DURATION\")}else if(!seen.has(\"DELAY\")&&TIME.test(part)){result.delay=part;seen.add(\"DELAY\")}else if(!seen.has(\"NAME\")){result.name=part;seen.add(\"NAME\")}else{if(!result.unknown)result.unknown=[];result.unknown.push(part)}}return result})}__name(parseAnimationValue,\"parseAnimationValue\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CACzC,MAAO,IACX,CAAC,EACD,OAAO,eAAe,QAAS,UAAW,CACtC,WAAY,KACZ,IAAK,UAAW,CACZ,OAAO,mBACX,CACJ,CAAC,EACD,MAAM,WAAa,IAAI,IAAI,CACvB,SACA,UACA,YACA,mBACJ,CAAC,EACD,MAAM,YAAc,IAAI,IAAI,CACxB,UACA,QACJ,CAAC,EACD,MAAM,WAAa,IAAI,IAAI,CACvB,OACA,WACA,YACA,MACJ,CAAC,EACD,MAAM,iBAAmB,IAAI,IAAI,CAC7B,UACJ,CAAC,EACD,MAAM,QAAU,IAAI,IAAI,CACpB,SACA,OACA,UACA,WACA,cACA,aACA,UACJ,CAAC,EACD,MAAM,WAAa,CACf,eACA,OACJ,EACA,MAAM,MAAQ,iBAEd,MAAM,MAAQ,kBAEd,MAAM,KAAO,kBACb,MAAM,MAAQ,UACd,SAAS,oBAAoB,MAAO,CAChC,IAAI,WAAa,MAAM,MAAM,KAAK,EAClC,OAAO,WAAW,IAAK,WAAY,CAC/B,IAAI,MAAQ,UAAU,KAAK,EAC3B,IAAI,OAAS,CACT,KACJ,EACA,IAAI,MAAQ,MAAM,MAAM,KAAK,EAC7B,IAAI,KAAO,IAAI,IACf,QAAS,QAAQ,MAAM,CACnB,GAAI,CAAC,KAAK,IAAI,YAAY,GAAK,WAAW,IAAI,IAAI,EAAG,CACjD,OAAO,UAAY,KACnB,KAAK,IAAI,YAAY,CACzB,SAAW,CAAC,KAAK,IAAI,aAAa,GAAK,YAAY,IAAI,IAAI,EAAG,CAC1D,OAAO,UAAY,KACnB,KAAK,IAAI,aAAa,CAC1B,SAAW,CAAC,KAAK,IAAI,YAAY,GAAK,WAAW,IAAI,IAAI,EAAG,CACxD,OAAO,SAAW,KAClB,KAAK,IAAI,YAAY,CACzB,SAAW,CAAC,KAAK,IAAI,kBAAkB,IAAM,iBAAiB,IAAI,IAAI,GAAK,MAAM,KAAK,IAAI,GAAI,CAC1F,OAAO,eAAiB,KACxB,KAAK,IAAI,kBAAkB,CAC/B,SAAW,CAAC,KAAK,IAAI,iBAAiB,GAAK,QAAQ,IAAI,IAAI,EAAG,CAC1D,OAAO,eAAiB,KACxB,KAAK,IAAI,iBAAiB,CAC9B,SAAW,CAAC,KAAK,IAAI,iBAAiB,GAAK,WAAW,KAAM,GAAI,KAAK,WAAW,GAAG,IAAI,CAAC,EAAG,CACvF,OAAO,eAAiB,KACxB,KAAK,IAAI,iBAAiB,CAC9B,SAAW,CAAC,KAAK,IAAI,UAAU,GAAK,KAAK,KAAK,IAAI,EAAG,CACjD,OAAO,SAAW,KAClB,KAAK,IAAI,UAAU,CACvB,SAAW,CAAC,KAAK,IAAI,OAAO,GAAK,KAAK,KAAK,IAAI,EAAG,CAC9C,OAAO,MAAQ,KACf,KAAK,IAAI,OAAO,CACpB,SAAW,CAAC,KAAK,IAAI,MAAM,EAAG,CAC1B,OAAO,KAAO,KACd,KAAK,IAAI,MAAM,CACnB,KAAO,CACH,GAAI,CAAC,OAAO,QAAS,OAAO,QAAU,CAAC,EACvC,OAAO,QAAQ,KAAK,IAAI,CAC5B,CACJ,CACA,OAAO,MACX,CAAC,CACL,CA5CS","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/util/parseAnimationValue.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return parseAnimationValue;\n    }\n});\nconst DIRECTIONS = new Set([\n    \"normal\",\n    \"reverse\",\n    \"alternate\",\n    \"alternate-reverse\"\n]);\nconst PLAY_STATES = new Set([\n    \"running\",\n    \"paused\"\n]);\nconst FILL_MODES = new Set([\n    \"none\",\n    \"forwards\",\n    \"backwards\",\n    \"both\"\n]);\nconst ITERATION_COUNTS = new Set([\n    \"infinite\"\n]);\nconst TIMINGS = new Set([\n    \"linear\",\n    \"ease\",\n    \"ease-in\",\n    \"ease-out\",\n    \"ease-in-out\",\n    \"step-start\",\n    \"step-end\"\n]);\nconst TIMING_FNS = [\n    \"cubic-bezier\",\n    \"steps\"\n];\nconst COMMA = /\\,(?![^(]*\\))/g // Comma separator that is not located between brackets. E.g.: `cubiz-bezier(a, b, c)` these don't count.\n;\nconst SPACE = /\\ +(?![^(]*\\))/g // Similar to the one above, but with spaces instead.\n;\nconst TIME = /^(-?[\\d.]+m?s)$/;\nconst DIGIT = /^(\\d+)$/;\nfunction parseAnimationValue(input) {\n    let animations = input.split(COMMA);\n    return animations.map((animation)=>{\n        let value = animation.trim();\n        let result = {\n            value\n        };\n        let parts = value.split(SPACE);\n        let seen = new Set();\n        for (let part of parts){\n            if (!seen.has(\"DIRECTIONS\") && DIRECTIONS.has(part)) {\n                result.direction = part;\n                seen.add(\"DIRECTIONS\");\n            } else if (!seen.has(\"PLAY_STATES\") && PLAY_STATES.has(part)) {\n                result.playState = part;\n                seen.add(\"PLAY_STATES\");\n            } else if (!seen.has(\"FILL_MODES\") && FILL_MODES.has(part)) {\n                result.fillMode = part;\n                seen.add(\"FILL_MODES\");\n            } else if (!seen.has(\"ITERATION_COUNTS\") && (ITERATION_COUNTS.has(part) || DIGIT.test(part))) {\n                result.iterationCount = part;\n                seen.add(\"ITERATION_COUNTS\");\n            } else if (!seen.has(\"TIMING_FUNCTION\") && TIMINGS.has(part)) {\n                result.timingFunction = part;\n                seen.add(\"TIMING_FUNCTION\");\n            } else if (!seen.has(\"TIMING_FUNCTION\") && TIMING_FNS.some((f)=>part.startsWith(`${f}(`))) {\n                result.timingFunction = part;\n                seen.add(\"TIMING_FUNCTION\");\n            } else if (!seen.has(\"DURATION\") && TIME.test(part)) {\n                result.duration = part;\n                seen.add(\"DURATION\");\n            } else if (!seen.has(\"DELAY\") && TIME.test(part)) {\n                result.delay = part;\n                seen.add(\"DELAY\");\n            } else if (!seen.has(\"NAME\")) {\n                result.name = part;\n                seen.add(\"NAME\");\n            } else {\n                if (!result.unknown) result.unknown = [];\n                result.unknown.push(part);\n            }\n        }\n        return result;\n    });\n}\n"]}}