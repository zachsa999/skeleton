{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});Object.defineProperty(exports,\"splitAtTopLevelOnly\",{enumerable:true,get:function(){return splitAtTopLevelOnly}});function splitAtTopLevelOnly(input,separator){let stack=[];let parts=[];let lastPos=0;let isEscaped=false;for(let idx=0;idx<input.length;idx++){let char=input[idx];if(stack.length===0&&char===separator[0]&&!isEscaped){if(separator.length===1||input.slice(idx,idx+separator.length)===separator){parts.push(input.slice(lastPos,idx));lastPos=idx+separator.length}}if(isEscaped){isEscaped=false}else if(char===\"\\\\\"){isEscaped=true}if(char===\"(\"||char===\"[\"||char===\"{\"){stack.push(char)}else if(char===\")\"&&stack[stack.length-1]===\"(\"||char===\"]\"&&stack[stack.length-1]===\"[\"||char===\"}\"&&stack[stack.length-1]===\"{\"){stack.pop()}}parts.push(input.slice(lastPos));return parts}__name(splitAtTopLevelOnly,\"splitAtTopLevelOnly\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAeA,OAAO,eAAe,QAAS,aAAc,CACzC,MAAO,IACX,CAAC,EACD,OAAO,eAAe,QAAS,sBAAuB,CAClD,WAAY,KACZ,IAAK,UAAW,CACZ,OAAO,mBACX,CACJ,CAAC,EACD,SAAS,oBAAoB,MAAO,UAAW,CAC3C,IAAI,MAAQ,CAAC,EACb,IAAI,MAAQ,CAAC,EACb,IAAI,QAAU,EACd,IAAI,UAAY,MAChB,QAAQ,IAAM,EAAG,IAAM,MAAM,OAAQ,MAAM,CACvC,IAAI,KAAO,MAAM,GAAG,EACpB,GAAI,MAAM,SAAW,GAAK,OAAS,UAAU,CAAC,GAAK,CAAC,UAAW,CAC3D,GAAI,UAAU,SAAW,GAAK,MAAM,MAAM,IAAK,IAAM,UAAU,MAAM,IAAM,UAAW,CAClF,MAAM,KAAK,MAAM,MAAM,QAAS,GAAG,CAAC,EACpC,QAAU,IAAM,UAAU,MAC9B,CACJ,CACA,GAAI,UAAW,CACX,UAAY,KAChB,SAAW,OAAS,KAAM,CACtB,UAAY,IAChB,CACA,GAAI,OAAS,KAAO,OAAS,KAAO,OAAS,IAAK,CAC9C,MAAM,KAAK,IAAI,CACnB,SAAW,OAAS,KAAO,MAAM,MAAM,OAAS,CAAC,IAAM,KAAO,OAAS,KAAO,MAAM,MAAM,OAAS,CAAC,IAAM,KAAO,OAAS,KAAO,MAAM,MAAM,OAAS,CAAC,IAAM,IAAK,CAC9J,MAAM,IAAI,CACd,CACJ,CACA,MAAM,KAAK,MAAM,MAAM,OAAO,CAAC,EAC/B,OAAO,KACX,CA1BS","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/util/splitAtTopLevelOnly.js"],"sourcesContent":["/**\n * This splits a string on a top-level character.\n *\n * Regex doesn't support recursion (at least not the JS-flavored version).\n * So we have to use a tiny state machine to keep track of paren placement.\n *\n * Expected behavior using commas:\n * var(--a, 0 0 1px rgb(0, 0, 0)), 0 0 1px rgb(0, 0, 0)\n *       ─┬─             ┬  ┬    ┬\n *        x              x  x    ╰──────── Split because top-level\n *        ╰──────────────┴──┴───────────── Ignored b/c inside >= 1 levels of parens\n *\n * @param {string} input\n * @param {string} separator\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"splitAtTopLevelOnly\", {\n    enumerable: true,\n    get: function() {\n        return splitAtTopLevelOnly;\n    }\n});\nfunction splitAtTopLevelOnly(input, separator) {\n    let stack = [];\n    let parts = [];\n    let lastPos = 0;\n    let isEscaped = false;\n    for(let idx = 0; idx < input.length; idx++){\n        let char = input[idx];\n        if (stack.length === 0 && char === separator[0] && !isEscaped) {\n            if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {\n                parts.push(input.slice(lastPos, idx));\n                lastPos = idx + separator.length;\n            }\n        }\n        if (isEscaped) {\n            isEscaped = false;\n        } else if (char === \"\\\\\") {\n            isEscaped = true;\n        }\n        if (char === \"(\" || char === \"[\" || char === \"{\") {\n            stack.push(char);\n        } else if (char === \")\" && stack[stack.length - 1] === \"(\" || char === \"]\" && stack[stack.length - 1] === \"[\" || char === \"}\" && stack[stack.length - 1] === \"{\") {\n            stack.pop();\n        }\n    }\n    parts.push(input.slice(lastPos));\n    return parts;\n}\n"]}}