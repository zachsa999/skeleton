{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const path=require(\"path\");const scan=require(\"./scan\");const parse=require(\"./parse\");const utils=require(\"./utils\");const constants=require(\"./constants\");const isObject=__name(val=>val&&typeof val===\"object\"&&!Array.isArray(val),\"isObject\");const picomatch=__name((glob,options,returnState=false)=>{if(Array.isArray(glob)){const fns=glob.map(input=>picomatch(input,options,returnState));const arrayMatcher=__name(str=>{for(const isMatch of fns){const state2=isMatch(str);if(state2)return state2}return false},\"arrayMatcher\");return arrayMatcher}const isState=isObject(glob)&&glob.tokens&&glob.input;if(glob===\"\"||typeof glob!==\"string\"&&!isState){throw new TypeError(\"Expected pattern to be a non-empty string\")}const opts=options||{};const posix=utils.isWindows(options);const regex=isState?picomatch.compileRe(glob,options):picomatch.makeRe(glob,options,false,true);const state=regex.state;delete regex.state;let isIgnored=__name(()=>false,\"isIgnored\");if(opts.ignore){const ignoreOpts={...options,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(opts.ignore,ignoreOpts,returnState)}const matcher=__name((input,returnObject=false)=>{const{isMatch,match,output}=picomatch.test(input,regex,options,{glob,posix});const result={glob,state,regex,posix,input,output,match,isMatch};if(typeof opts.onResult===\"function\"){opts.onResult(result)}if(isMatch===false){result.isMatch=false;return returnObject?result:false}if(isIgnored(input)){if(typeof opts.onIgnore===\"function\"){opts.onIgnore(result)}result.isMatch=false;return returnObject?result:false}if(typeof opts.onMatch===\"function\"){opts.onMatch(result)}return returnObject?result:true},\"matcher\");if(returnState){matcher.state=state}return matcher},\"picomatch\");picomatch.test=(input,regex,options,{glob,posix}={})=>{if(typeof input!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(input===\"\"){return{isMatch:false,output:\"\"}}const opts=options||{};const format=opts.format||(posix?utils.toPosixSlashes:null);let match=input===glob;let output=match&&format?format(input):input;if(match===false){output=format?format(input):input;match=output===glob}if(match===false||opts.capture===true){if(opts.matchBase===true||opts.basename===true){match=picomatch.matchBase(input,regex,options,posix)}else{match=regex.exec(output)}}return{isMatch:Boolean(match),match,output}};picomatch.matchBase=(input,glob,options,posix=utils.isWindows(options))=>{const regex=glob instanceof RegExp?glob:picomatch.makeRe(glob,options);return regex.test(path.basename(input))};picomatch.isMatch=(str,patterns,options)=>picomatch(patterns,options)(str);picomatch.parse=(pattern,options)=>{if(Array.isArray(pattern))return pattern.map(p=>picomatch.parse(p,options));return parse(pattern,{...options,fastpaths:false})};picomatch.scan=(input,options)=>scan(input,options);picomatch.compileRe=(state,options,returnOutput=false,returnState=false)=>{if(returnOutput===true){return state.output}const opts=options||{};const prepend=opts.contains?\"\":\"^\";const append=opts.contains?\"\":\"$\";let source=`${prepend}(?:${state.output})${append}`;if(state&&state.negated===true){source=`^(?!${source}).*$`}const regex=picomatch.toRegex(source,options);if(returnState===true){regex.state=state}return regex};picomatch.makeRe=(input,options={},returnOutput=false,returnState=false)=>{if(!input||typeof input!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}let parsed={negated:false,fastpaths:true};if(options.fastpaths!==false&&(input[0]===\".\"||input[0]===\"*\")){parsed.output=parse.fastpaths(input,options)}if(!parsed.output){parsed=parse(input,options)}return picomatch.compileRe(parsed,options,returnOutput,returnState)};picomatch.toRegex=(source,options)=>{try{const opts=options||{};return new RegExp(source,opts.flags||(opts.nocase?\"i\":\"\"))}catch(err){if(options&&options.debug===true)throw err;return/$^/}};picomatch.constants=constants;module.exports=picomatch;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["state"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js"],"sourcesContent":["'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let parsed = { negated: false, fastpaths: true };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n"]}}