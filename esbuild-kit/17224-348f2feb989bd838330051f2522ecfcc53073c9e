{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});let{isClean,my}=require(\"./symbols\");let Declaration=require(\"./declaration\");let Comment=require(\"./comment\");let Node=require(\"./node\");let parse,Rule,AtRule,Root;function cleanSource(nodes){return nodes.map(i=>{if(i.nodes)i.nodes=cleanSource(i.nodes);delete i.source;return i})}__name(cleanSource,\"cleanSource\");function markDirtyUp(node){node[isClean]=false;if(node.proxyOf.nodes){for(let i of node.proxyOf.nodes){markDirtyUp(i)}}}__name(markDirtyUp,\"markDirtyUp\");class Container extends Node{push(child){child.parent=this;this.proxyOf.nodes.push(child);return this}each(callback){if(!this.proxyOf.nodes)return void 0;let iterator=this.getIterator();let index,result;while(this.indexes[iterator]<this.proxyOf.nodes.length){index=this.indexes[iterator];result=callback(this.proxyOf.nodes[index],index);if(result===false)break;this.indexes[iterator]+=1}delete this.indexes[iterator];return result}walk(callback){return this.each((child,i)=>{let result;try{result=callback(child,i)}catch(e){throw child.addToError(e)}if(result!==false&&child.walk){result=child.walk(callback)}return result})}walkDecls(prop,callback){if(!callback){callback=prop;return this.walk((child,i)=>{if(child.type===\"decl\"){return callback(child,i)}})}if(prop instanceof RegExp){return this.walk((child,i)=>{if(child.type===\"decl\"&&prop.test(child.prop)){return callback(child,i)}})}return this.walk((child,i)=>{if(child.type===\"decl\"&&child.prop===prop){return callback(child,i)}})}walkRules(selector,callback){if(!callback){callback=selector;return this.walk((child,i)=>{if(child.type===\"rule\"){return callback(child,i)}})}if(selector instanceof RegExp){return this.walk((child,i)=>{if(child.type===\"rule\"&&selector.test(child.selector)){return callback(child,i)}})}return this.walk((child,i)=>{if(child.type===\"rule\"&&child.selector===selector){return callback(child,i)}})}walkAtRules(name,callback){if(!callback){callback=name;return this.walk((child,i)=>{if(child.type===\"atrule\"){return callback(child,i)}})}if(name instanceof RegExp){return this.walk((child,i)=>{if(child.type===\"atrule\"&&name.test(child.name)){return callback(child,i)}})}return this.walk((child,i)=>{if(child.type===\"atrule\"&&child.name===name){return callback(child,i)}})}walkComments(callback){return this.walk((child,i)=>{if(child.type===\"comment\"){return callback(child,i)}})}append(...children){for(let child of children){let nodes=this.normalize(child,this.last);for(let node of nodes)this.proxyOf.nodes.push(node)}this.markDirty();return this}prepend(...children){children=children.reverse();for(let child of children){let nodes=this.normalize(child,this.first,\"prepend\").reverse();for(let node of nodes)this.proxyOf.nodes.unshift(node);for(let id in this.indexes){this.indexes[id]=this.indexes[id]+nodes.length}}this.markDirty();return this}cleanRaws(keepBetween){super.cleanRaws(keepBetween);if(this.nodes){for(let node of this.nodes)node.cleanRaws(keepBetween)}}insertBefore(exist,add){let existIndex=this.index(exist);let type=existIndex===0?\"prepend\":false;let nodes=this.normalize(add,this.proxyOf.nodes[existIndex],type).reverse();existIndex=this.index(exist);for(let node of nodes)this.proxyOf.nodes.splice(existIndex,0,node);let index;for(let id in this.indexes){index=this.indexes[id];if(existIndex<=index){this.indexes[id]=index+nodes.length}}this.markDirty();return this}insertAfter(exist,add){let existIndex=this.index(exist);let nodes=this.normalize(add,this.proxyOf.nodes[existIndex]).reverse();existIndex=this.index(exist);for(let node of nodes)this.proxyOf.nodes.splice(existIndex+1,0,node);let index;for(let id in this.indexes){index=this.indexes[id];if(existIndex<index){this.indexes[id]=index+nodes.length}}this.markDirty();return this}removeChild(child){child=this.index(child);this.proxyOf.nodes[child].parent=void 0;this.proxyOf.nodes.splice(child,1);let index;for(let id in this.indexes){index=this.indexes[id];if(index>=child){this.indexes[id]=index-1}}this.markDirty();return this}removeAll(){for(let node of this.proxyOf.nodes)node.parent=void 0;this.proxyOf.nodes=[];this.markDirty();return this}replaceValues(pattern,opts,callback){if(!callback){callback=opts;opts={}}this.walkDecls(decl=>{if(opts.props&&!opts.props.includes(decl.prop))return;if(opts.fast&&!decl.value.includes(opts.fast))return;decl.value=decl.value.replace(pattern,callback)});this.markDirty();return this}every(condition){return this.nodes.every(condition)}some(condition){return this.nodes.some(condition)}index(child){if(typeof child===\"number\")return child;if(child.proxyOf)child=child.proxyOf;return this.proxyOf.nodes.indexOf(child)}get first(){if(!this.proxyOf.nodes)return void 0;return this.proxyOf.nodes[0]}get last(){if(!this.proxyOf.nodes)return void 0;return this.proxyOf.nodes[this.proxyOf.nodes.length-1]}normalize(nodes,sample){if(typeof nodes===\"string\"){nodes=cleanSource(parse(nodes).nodes)}else if(Array.isArray(nodes)){nodes=nodes.slice(0);for(let i of nodes){if(i.parent)i.parent.removeChild(i,\"ignore\")}}else if(nodes.type===\"root\"&&this.type!==\"document\"){nodes=nodes.nodes.slice(0);for(let i of nodes){if(i.parent)i.parent.removeChild(i,\"ignore\")}}else if(nodes.type){nodes=[nodes]}else if(nodes.prop){if(typeof nodes.value===\"undefined\"){throw new Error(\"Value field is missed in node creation\")}else if(typeof nodes.value!==\"string\"){nodes.value=String(nodes.value)}nodes=[new Declaration(nodes)]}else if(nodes.selector){nodes=[new Rule(nodes)]}else if(nodes.name){nodes=[new AtRule(nodes)]}else if(nodes.text){nodes=[new Comment(nodes)]}else{throw new Error(\"Unknown node type in node creation\")}let processed=nodes.map(i=>{if(!i[my])Container.rebuild(i);i=i.proxyOf;if(i.parent)i.parent.removeChild(i);if(i[isClean])markDirtyUp(i);if(typeof i.raws.before===\"undefined\"){if(sample&&typeof sample.raws.before!==\"undefined\"){i.raws.before=sample.raws.before.replace(/\\S/g,\"\")}}i.parent=this.proxyOf;return i});return processed}getProxyProcessor(){return{set(node,prop,value){if(node[prop]===value)return true;node[prop]=value;if(prop===\"name\"||prop===\"params\"||prop===\"selector\"){node.markDirty()}return true},get(node,prop){if(prop===\"proxyOf\"){return node}else if(!node[prop]){return node[prop]}else if(prop===\"each\"||typeof prop===\"string\"&&prop.startsWith(\"walk\")){return(...args)=>{return node[prop](...args.map(i=>{if(typeof i===\"function\"){return(child,index)=>i(child.toProxy(),index)}else{return i}}))}}else if(prop===\"every\"||prop===\"some\"){return cb=>{return node[prop]((child,...other)=>cb(child.toProxy(),...other))}}else if(prop===\"root\"){return()=>node.root().toProxy()}else if(prop===\"nodes\"){return node.nodes.map(i=>i.toProxy())}else if(prop===\"first\"||prop===\"last\"){return node[prop].toProxy()}else{return node[prop]}}}}getIterator(){if(!this.lastEach)this.lastEach=0;if(!this.indexes)this.indexes={};this.lastEach+=1;let iterator=this.lastEach;this.indexes[iterator]=0;return iterator}}__name(Container,\"Container\");Container.registerParse=dependant=>{parse=dependant};Container.registerRule=dependant=>{Rule=dependant};Container.registerAtRule=dependant=>{AtRule=dependant};Container.registerRoot=dependant=>{Root=dependant};module.exports=Container;Container.default=Container;Container.rebuild=node=>{if(node.type===\"atrule\"){Object.setPrototypeOf(node,AtRule.prototype)}else if(node.type===\"rule\"){Object.setPrototypeOf(node,Rule.prototype)}else if(node.type===\"decl\"){Object.setPrototypeOf(node,Declaration.prototype)}else if(node.type===\"comment\"){Object.setPrototypeOf(node,Comment.prototype)}else if(node.type===\"root\"){Object.setPrototypeOf(node,Root.prototype)}node[my]=true;if(node.nodes){node.nodes.forEach(child=>{Container.rebuild(child)})}};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/postcss@8.4.24/node_modules/postcss/lib/container.js"],"sourcesContent":["'use strict'\n\nlet { isClean, my } = require('./symbols')\nlet Declaration = require('./declaration')\nlet Comment = require('./comment')\nlet Node = require('./node')\n\nlet parse, Rule, AtRule, Root\n\nfunction cleanSource(nodes) {\n  return nodes.map(i => {\n    if (i.nodes) i.nodes = cleanSource(i.nodes)\n    delete i.source\n    return i\n  })\n}\n\nfunction markDirtyUp(node) {\n  node[isClean] = false\n  if (node.proxyOf.nodes) {\n    for (let i of node.proxyOf.nodes) {\n      markDirtyUp(i)\n    }\n  }\n}\n\nclass Container extends Node {\n  push(child) {\n    child.parent = this\n    this.proxyOf.nodes.push(child)\n    return this\n  }\n\n  each(callback) {\n    if (!this.proxyOf.nodes) return undefined\n    let iterator = this.getIterator()\n\n    let index, result\n    while (this.indexes[iterator] < this.proxyOf.nodes.length) {\n      index = this.indexes[iterator]\n      result = callback(this.proxyOf.nodes[index], index)\n      if (result === false) break\n\n      this.indexes[iterator] += 1\n    }\n\n    delete this.indexes[iterator]\n    return result\n  }\n\n  walk(callback) {\n    return this.each((child, i) => {\n      let result\n      try {\n        result = callback(child, i)\n      } catch (e) {\n        throw child.addToError(e)\n      }\n      if (result !== false && child.walk) {\n        result = child.walk(callback)\n      }\n\n      return result\n    })\n  }\n\n  walkDecls(prop, callback) {\n    if (!callback) {\n      callback = prop\n      return this.walk((child, i) => {\n        if (child.type === 'decl') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (prop instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'decl' && prop.test(child.prop)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'decl' && child.prop === prop) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkRules(selector, callback) {\n    if (!callback) {\n      callback = selector\n\n      return this.walk((child, i) => {\n        if (child.type === 'rule') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (selector instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'rule' && selector.test(child.selector)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'rule' && child.selector === selector) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkAtRules(name, callback) {\n    if (!callback) {\n      callback = name\n      return this.walk((child, i) => {\n        if (child.type === 'atrule') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (name instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'atrule' && name.test(child.name)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'atrule' && child.name === name) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkComments(callback) {\n    return this.walk((child, i) => {\n      if (child.type === 'comment') {\n        return callback(child, i)\n      }\n    })\n  }\n\n  append(...children) {\n    for (let child of children) {\n      let nodes = this.normalize(child, this.last)\n      for (let node of nodes) this.proxyOf.nodes.push(node)\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  prepend(...children) {\n    children = children.reverse()\n    for (let child of children) {\n      let nodes = this.normalize(child, this.first, 'prepend').reverse()\n      for (let node of nodes) this.proxyOf.nodes.unshift(node)\n      for (let id in this.indexes) {\n        this.indexes[id] = this.indexes[id] + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  cleanRaws(keepBetween) {\n    super.cleanRaws(keepBetween)\n    if (this.nodes) {\n      for (let node of this.nodes) node.cleanRaws(keepBetween)\n    }\n  }\n\n  insertBefore(exist, add) {\n    let existIndex = this.index(exist)\n    let type = existIndex === 0 ? 'prepend' : false\n    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse()\n    existIndex = this.index(exist)\n    for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (existIndex <= index) {\n        this.indexes[id] = index + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  insertAfter(exist, add) {\n    let existIndex = this.index(exist)\n    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse()\n    existIndex = this.index(exist)\n    for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (existIndex < index) {\n        this.indexes[id] = index + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  removeChild(child) {\n    child = this.index(child)\n    this.proxyOf.nodes[child].parent = undefined\n    this.proxyOf.nodes.splice(child, 1)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (index >= child) {\n        this.indexes[id] = index - 1\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  removeAll() {\n    for (let node of this.proxyOf.nodes) node.parent = undefined\n    this.proxyOf.nodes = []\n\n    this.markDirty()\n\n    return this\n  }\n\n  replaceValues(pattern, opts, callback) {\n    if (!callback) {\n      callback = opts\n      opts = {}\n    }\n\n    this.walkDecls(decl => {\n      if (opts.props && !opts.props.includes(decl.prop)) return\n      if (opts.fast && !decl.value.includes(opts.fast)) return\n\n      decl.value = decl.value.replace(pattern, callback)\n    })\n\n    this.markDirty()\n\n    return this\n  }\n\n  every(condition) {\n    return this.nodes.every(condition)\n  }\n\n  some(condition) {\n    return this.nodes.some(condition)\n  }\n\n  index(child) {\n    if (typeof child === 'number') return child\n    if (child.proxyOf) child = child.proxyOf\n    return this.proxyOf.nodes.indexOf(child)\n  }\n\n  get first() {\n    if (!this.proxyOf.nodes) return undefined\n    return this.proxyOf.nodes[0]\n  }\n\n  get last() {\n    if (!this.proxyOf.nodes) return undefined\n    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]\n  }\n\n  normalize(nodes, sample) {\n    if (typeof nodes === 'string') {\n      nodes = cleanSource(parse(nodes).nodes)\n    } else if (Array.isArray(nodes)) {\n      nodes = nodes.slice(0)\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore')\n      }\n    } else if (nodes.type === 'root' && this.type !== 'document') {\n      nodes = nodes.nodes.slice(0)\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore')\n      }\n    } else if (nodes.type) {\n      nodes = [nodes]\n    } else if (nodes.prop) {\n      if (typeof nodes.value === 'undefined') {\n        throw new Error('Value field is missed in node creation')\n      } else if (typeof nodes.value !== 'string') {\n        nodes.value = String(nodes.value)\n      }\n      nodes = [new Declaration(nodes)]\n    } else if (nodes.selector) {\n      nodes = [new Rule(nodes)]\n    } else if (nodes.name) {\n      nodes = [new AtRule(nodes)]\n    } else if (nodes.text) {\n      nodes = [new Comment(nodes)]\n    } else {\n      throw new Error('Unknown node type in node creation')\n    }\n\n    let processed = nodes.map(i => {\n      /* c8 ignore next */\n      if (!i[my]) Container.rebuild(i)\n      i = i.proxyOf\n      if (i.parent) i.parent.removeChild(i)\n      if (i[isClean]) markDirtyUp(i)\n      if (typeof i.raws.before === 'undefined') {\n        if (sample && typeof sample.raws.before !== 'undefined') {\n          i.raws.before = sample.raws.before.replace(/\\S/g, '')\n        }\n      }\n      i.parent = this.proxyOf\n      return i\n    })\n\n    return processed\n  }\n\n  getProxyProcessor() {\n    return {\n      set(node, prop, value) {\n        if (node[prop] === value) return true\n        node[prop] = value\n        if (prop === 'name' || prop === 'params' || prop === 'selector') {\n          node.markDirty()\n        }\n        return true\n      },\n\n      get(node, prop) {\n        if (prop === 'proxyOf') {\n          return node\n        } else if (!node[prop]) {\n          return node[prop]\n        } else if (\n          prop === 'each' ||\n          (typeof prop === 'string' && prop.startsWith('walk'))\n        ) {\n          return (...args) => {\n            return node[prop](\n              ...args.map(i => {\n                if (typeof i === 'function') {\n                  return (child, index) => i(child.toProxy(), index)\n                } else {\n                  return i\n                }\n              })\n            )\n          }\n        } else if (prop === 'every' || prop === 'some') {\n          return cb => {\n            return node[prop]((child, ...other) =>\n              cb(child.toProxy(), ...other)\n            )\n          }\n        } else if (prop === 'root') {\n          return () => node.root().toProxy()\n        } else if (prop === 'nodes') {\n          return node.nodes.map(i => i.toProxy())\n        } else if (prop === 'first' || prop === 'last') {\n          return node[prop].toProxy()\n        } else {\n          return node[prop]\n        }\n      }\n    }\n  }\n\n  getIterator() {\n    if (!this.lastEach) this.lastEach = 0\n    if (!this.indexes) this.indexes = {}\n\n    this.lastEach += 1\n    let iterator = this.lastEach\n    this.indexes[iterator] = 0\n\n    return iterator\n  }\n}\n\nContainer.registerParse = dependant => {\n  parse = dependant\n}\n\nContainer.registerRule = dependant => {\n  Rule = dependant\n}\n\nContainer.registerAtRule = dependant => {\n  AtRule = dependant\n}\n\nContainer.registerRoot = dependant => {\n  Root = dependant\n}\n\nmodule.exports = Container\nContainer.default = Container\n\n/* c8 ignore start */\nContainer.rebuild = node => {\n  if (node.type === 'atrule') {\n    Object.setPrototypeOf(node, AtRule.prototype)\n  } else if (node.type === 'rule') {\n    Object.setPrototypeOf(node, Rule.prototype)\n  } else if (node.type === 'decl') {\n    Object.setPrototypeOf(node, Declaration.prototype)\n  } else if (node.type === 'comment') {\n    Object.setPrototypeOf(node, Comment.prototype)\n  } else if (node.type === 'root') {\n    Object.setPrototypeOf(node, Root.prototype)\n  }\n\n  node[my] = true\n\n  if (node.nodes) {\n    node.nodes.forEach(child => {\n      Container.rebuild(child)\n    })\n  }\n}\n/* c8 ignore stop */\n"]}}