{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:true,get:all[name]})}__name(_export,\"_export\");_export(exports,{updateAllClasses:function(){return updateAllClasses},asValue:function(){return asValue},parseColorFormat:function(){return parseColorFormat},asColor:function(){return asColor},asLookupValue:function(){return asLookupValue},typeMap:function(){return typeMap},coerceValue:function(){return coerceValue},getMatchingTypes:function(){return getMatchingTypes}});const _escapeCommas=_interop_require_default(require(\"./escapeCommas\"));const _withAlphaVariable=require(\"./withAlphaVariable\");const _dataTypes=require(\"./dataTypes\");const _negateValue=_interop_require_default(require(\"./negateValue\"));const _validateFormalSyntax=require(\"./validateFormalSyntax\");const _featureFlags=require(\"../featureFlags.js\");function _interop_require_default(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interop_require_default,\"_interop_require_default\");function updateAllClasses(selectors,updateClass){selectors.walkClasses(sel=>{sel.value=updateClass(sel.value);if(sel.raws&&sel.raws.value){sel.raws.value=(0,_escapeCommas.default)(sel.raws.value)}})}__name(updateAllClasses,\"updateAllClasses\");function resolveArbitraryValue(modifier,validate){if(!isArbitraryValue(modifier)){return void 0}let value=modifier.slice(1,-1);if(!validate(value)){return void 0}return(0,_dataTypes.normalize)(value)}__name(resolveArbitraryValue,\"resolveArbitraryValue\");function asNegativeValue(modifier,lookup={},validate){let positiveValue=lookup[modifier];if(positiveValue!==void 0){return(0,_negateValue.default)(positiveValue)}if(isArbitraryValue(modifier)){let resolved=resolveArbitraryValue(modifier,validate);if(resolved===void 0){return void 0}return(0,_negateValue.default)(resolved)}}__name(asNegativeValue,\"asNegativeValue\");function asValue(modifier,options={},{validate=__name(()=>true,\"validate\")}={}){var _options_values;let value=(_options_values=options.values)===null||_options_values===void 0?void 0:_options_values[modifier];if(value!==void 0){return value}if(options.supportsNegativeValues&&modifier.startsWith(\"-\")){return asNegativeValue(modifier.slice(1),options.values,validate)}return resolveArbitraryValue(modifier,validate)}__name(asValue,\"asValue\");function isArbitraryValue(input){return input.startsWith(\"[\")&&input.endsWith(\"]\")}__name(isArbitraryValue,\"isArbitraryValue\");function splitUtilityModifier(modifier){let slashIdx=modifier.lastIndexOf(\"/\");if(slashIdx===-1||slashIdx===modifier.length-1){return[modifier,void 0]}let arbitrary=isArbitraryValue(modifier);if(arbitrary&&!modifier.includes(\"]/[\")){return[modifier,void 0]}return[modifier.slice(0,slashIdx),modifier.slice(slashIdx+1)]}__name(splitUtilityModifier,\"splitUtilityModifier\");function parseColorFormat(value){if(typeof value===\"string\"&&value.includes(\"<alpha-value>\")){let oldValue=value;return({opacityValue=1})=>oldValue.replace(\"<alpha-value>\",opacityValue)}return value}__name(parseColorFormat,\"parseColorFormat\");function unwrapArbitraryModifier(modifier){return(0,_dataTypes.normalize)(modifier.slice(1,-1))}__name(unwrapArbitraryModifier,\"unwrapArbitraryModifier\");function asColor(modifier,options={},{tailwindConfig={}}={}){var _options_values;if(((_options_values=options.values)===null||_options_values===void 0?void 0:_options_values[modifier])!==void 0){var _options_values1;return parseColorFormat((_options_values1=options.values)===null||_options_values1===void 0?void 0:_options_values1[modifier])}let[color,alpha]=splitUtilityModifier(modifier);if(alpha!==void 0){var _options_values2,_tailwindConfig_theme,_tailwindConfig_theme_opacity;var _options_values_color;let normalizedColor=(_options_values_color=(_options_values2=options.values)===null||_options_values2===void 0?void 0:_options_values2[color])!==null&&_options_values_color!==void 0?_options_values_color:isArbitraryValue(color)?color.slice(1,-1):void 0;if(normalizedColor===void 0){return void 0}normalizedColor=parseColorFormat(normalizedColor);if(isArbitraryValue(alpha)){return(0,_withAlphaVariable.withAlphaValue)(normalizedColor,unwrapArbitraryModifier(alpha))}if(((_tailwindConfig_theme=tailwindConfig.theme)===null||_tailwindConfig_theme===void 0?void 0:(_tailwindConfig_theme_opacity=_tailwindConfig_theme.opacity)===null||_tailwindConfig_theme_opacity===void 0?void 0:_tailwindConfig_theme_opacity[alpha])===void 0){return void 0}return(0,_withAlphaVariable.withAlphaValue)(normalizedColor,tailwindConfig.theme.opacity[alpha])}return asValue(modifier,options,{validate:_dataTypes.color})}__name(asColor,\"asColor\");function asLookupValue(modifier,options={}){var _options_values;return(_options_values=options.values)===null||_options_values===void 0?void 0:_options_values[modifier]}__name(asLookupValue,\"asLookupValue\");function guess(validate){return(modifier,options)=>{return asValue(modifier,options,{validate})}}__name(guess,\"guess\");let typeMap={any:asValue,color:asColor,url:guess(_dataTypes.url),image:guess(_dataTypes.image),length:guess(_dataTypes.length),percentage:guess(_dataTypes.percentage),position:guess(_dataTypes.position),lookup:asLookupValue,\"generic-name\":guess(_dataTypes.genericName),\"family-name\":guess(_dataTypes.familyName),number:guess(_dataTypes.number),\"line-width\":guess(_dataTypes.lineWidth),\"absolute-size\":guess(_dataTypes.absoluteSize),\"relative-size\":guess(_dataTypes.relativeSize),shadow:guess(_dataTypes.shadow),size:guess(_validateFormalSyntax.backgroundSize)};let supportedTypes=Object.keys(typeMap);function splitAtFirst(input,delim){let idx=input.indexOf(delim);if(idx===-1)return[void 0,input];return[input.slice(0,idx),input.slice(idx+1)]}__name(splitAtFirst,\"splitAtFirst\");function coerceValue(types,modifier,options,tailwindConfig){if(options.values&&modifier in options.values){for(let{type}of types!==null&&types!==void 0?types:[]){let result=typeMap[type](modifier,options,{tailwindConfig});if(result===void 0){continue}return[result,type,null]}}if(isArbitraryValue(modifier)){let arbitraryValue=modifier.slice(1,-1);let[explicitType,value]=splitAtFirst(arbitraryValue,\":\");if(!/^[\\w-_]+$/g.test(explicitType)){value=arbitraryValue}else if(explicitType!==void 0&&!supportedTypes.includes(explicitType)){return[]}if(value.length>0&&supportedTypes.includes(explicitType)){return[asValue(`[${value}]`,options),explicitType,null]}}let matches=getMatchingTypes(types,modifier,options,tailwindConfig);for(let match of matches){return match}return[]}__name(coerceValue,\"coerceValue\");function*getMatchingTypes(types,rawModifier,options,tailwindConfig){let modifiersEnabled=(0,_featureFlags.flagEnabled)(tailwindConfig,\"generalizedModifiers\");let[modifier,utilityModifier]=splitUtilityModifier(rawModifier);let canUseUtilityModifier=modifiersEnabled&&options.modifiers!=null&&(options.modifiers===\"any\"||typeof options.modifiers===\"object\"&&(utilityModifier&&isArbitraryValue(utilityModifier)||utilityModifier in options.modifiers));if(!canUseUtilityModifier){modifier=rawModifier;utilityModifier=void 0}if(utilityModifier!==void 0&&modifier===\"\"){modifier=\"DEFAULT\"}if(utilityModifier!==void 0){if(typeof options.modifiers===\"object\"){var _options_modifiers;var _options_modifiers_utilityModifier;let configValue=(_options_modifiers_utilityModifier=(_options_modifiers=options.modifiers)===null||_options_modifiers===void 0?void 0:_options_modifiers[utilityModifier])!==null&&_options_modifiers_utilityModifier!==void 0?_options_modifiers_utilityModifier:null;if(configValue!==null){utilityModifier=configValue}else if(isArbitraryValue(utilityModifier)){utilityModifier=unwrapArbitraryModifier(utilityModifier)}}}for(let{type}of types!==null&&types!==void 0?types:[]){let result=typeMap[type](modifier,options,{tailwindConfig});if(result===void 0){continue}yield[result,type,utilityModifier!==null&&utilityModifier!==void 0?utilityModifier:null]}}__name(getMatchingTypes,\"getMatchingTypes\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/util/pluginUtils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    updateAllClasses: function() {\n        return updateAllClasses;\n    },\n    asValue: function() {\n        return asValue;\n    },\n    parseColorFormat: function() {\n        return parseColorFormat;\n    },\n    asColor: function() {\n        return asColor;\n    },\n    asLookupValue: function() {\n        return asLookupValue;\n    },\n    typeMap: function() {\n        return typeMap;\n    },\n    coerceValue: function() {\n        return coerceValue;\n    },\n    getMatchingTypes: function() {\n        return getMatchingTypes;\n    }\n});\nconst _escapeCommas = /*#__PURE__*/ _interop_require_default(require(\"./escapeCommas\"));\nconst _withAlphaVariable = require(\"./withAlphaVariable\");\nconst _dataTypes = require(\"./dataTypes\");\nconst _negateValue = /*#__PURE__*/ _interop_require_default(require(\"./negateValue\"));\nconst _validateFormalSyntax = require(\"./validateFormalSyntax\");\nconst _featureFlags = require(\"../featureFlags.js\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction updateAllClasses(selectors, updateClass) {\n    selectors.walkClasses((sel)=>{\n        sel.value = updateClass(sel.value);\n        if (sel.raws && sel.raws.value) {\n            sel.raws.value = (0, _escapeCommas.default)(sel.raws.value);\n        }\n    });\n}\nfunction resolveArbitraryValue(modifier, validate) {\n    if (!isArbitraryValue(modifier)) {\n        return undefined;\n    }\n    let value = modifier.slice(1, -1);\n    if (!validate(value)) {\n        return undefined;\n    }\n    return (0, _dataTypes.normalize)(value);\n}\nfunction asNegativeValue(modifier, lookup = {}, validate) {\n    let positiveValue = lookup[modifier];\n    if (positiveValue !== undefined) {\n        return (0, _negateValue.default)(positiveValue);\n    }\n    if (isArbitraryValue(modifier)) {\n        let resolved = resolveArbitraryValue(modifier, validate);\n        if (resolved === undefined) {\n            return undefined;\n        }\n        return (0, _negateValue.default)(resolved);\n    }\n}\nfunction asValue(modifier, options = {}, { validate =()=>true  } = {}) {\n    var _options_values;\n    let value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];\n    if (value !== undefined) {\n        return value;\n    }\n    if (options.supportsNegativeValues && modifier.startsWith(\"-\")) {\n        return asNegativeValue(modifier.slice(1), options.values, validate);\n    }\n    return resolveArbitraryValue(modifier, validate);\n}\nfunction isArbitraryValue(input) {\n    return input.startsWith(\"[\") && input.endsWith(\"]\");\n}\nfunction splitUtilityModifier(modifier) {\n    let slashIdx = modifier.lastIndexOf(\"/\");\n    if (slashIdx === -1 || slashIdx === modifier.length - 1) {\n        return [\n            modifier,\n            undefined\n        ];\n    }\n    let arbitrary = isArbitraryValue(modifier);\n    // The modifier could be of the form `[foo]/[bar]`\n    // We want to handle this case properly\n    // without affecting `[foo/bar]`\n    if (arbitrary && !modifier.includes(\"]/[\")) {\n        return [\n            modifier,\n            undefined\n        ];\n    }\n    return [\n        modifier.slice(0, slashIdx),\n        modifier.slice(slashIdx + 1)\n    ];\n}\nfunction parseColorFormat(value) {\n    if (typeof value === \"string\" && value.includes(\"<alpha-value>\")) {\n        let oldValue = value;\n        return ({ opacityValue =1  })=>oldValue.replace(\"<alpha-value>\", opacityValue);\n    }\n    return value;\n}\nfunction unwrapArbitraryModifier(modifier) {\n    return (0, _dataTypes.normalize)(modifier.slice(1, -1));\n}\nfunction asColor(modifier, options = {}, { tailwindConfig ={}  } = {}) {\n    var _options_values;\n    if (((_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier]) !== undefined) {\n        var _options_values1;\n        return parseColorFormat((_options_values1 = options.values) === null || _options_values1 === void 0 ? void 0 : _options_values1[modifier]);\n    }\n    // TODO: Hoist this up to getMatchingTypes or something\n    // We do this here because we need the alpha value (if any)\n    let [color, alpha] = splitUtilityModifier(modifier);\n    if (alpha !== undefined) {\n        var _options_values2, _tailwindConfig_theme, _tailwindConfig_theme_opacity;\n        var _options_values_color;\n        let normalizedColor = (_options_values_color = (_options_values2 = options.values) === null || _options_values2 === void 0 ? void 0 : _options_values2[color]) !== null && _options_values_color !== void 0 ? _options_values_color : isArbitraryValue(color) ? color.slice(1, -1) : undefined;\n        if (normalizedColor === undefined) {\n            return undefined;\n        }\n        normalizedColor = parseColorFormat(normalizedColor);\n        if (isArbitraryValue(alpha)) {\n            return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, unwrapArbitraryModifier(alpha));\n        }\n        if (((_tailwindConfig_theme = tailwindConfig.theme) === null || _tailwindConfig_theme === void 0 ? void 0 : (_tailwindConfig_theme_opacity = _tailwindConfig_theme.opacity) === null || _tailwindConfig_theme_opacity === void 0 ? void 0 : _tailwindConfig_theme_opacity[alpha]) === undefined) {\n            return undefined;\n        }\n        return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, tailwindConfig.theme.opacity[alpha]);\n    }\n    return asValue(modifier, options, {\n        validate: _dataTypes.color\n    });\n}\nfunction asLookupValue(modifier, options = {}) {\n    var _options_values;\n    return (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];\n}\nfunction guess(validate) {\n    return (modifier, options)=>{\n        return asValue(modifier, options, {\n            validate\n        });\n    };\n}\nlet typeMap = {\n    any: asValue,\n    color: asColor,\n    url: guess(_dataTypes.url),\n    image: guess(_dataTypes.image),\n    length: guess(_dataTypes.length),\n    percentage: guess(_dataTypes.percentage),\n    position: guess(_dataTypes.position),\n    lookup: asLookupValue,\n    \"generic-name\": guess(_dataTypes.genericName),\n    \"family-name\": guess(_dataTypes.familyName),\n    number: guess(_dataTypes.number),\n    \"line-width\": guess(_dataTypes.lineWidth),\n    \"absolute-size\": guess(_dataTypes.absoluteSize),\n    \"relative-size\": guess(_dataTypes.relativeSize),\n    shadow: guess(_dataTypes.shadow),\n    size: guess(_validateFormalSyntax.backgroundSize)\n};\nlet supportedTypes = Object.keys(typeMap);\nfunction splitAtFirst(input, delim) {\n    let idx = input.indexOf(delim);\n    if (idx === -1) return [\n        undefined,\n        input\n    ];\n    return [\n        input.slice(0, idx),\n        input.slice(idx + 1)\n    ];\n}\nfunction coerceValue(types, modifier, options, tailwindConfig) {\n    if (options.values && modifier in options.values) {\n        for (let { type  } of types !== null && types !== void 0 ? types : []){\n            let result = typeMap[type](modifier, options, {\n                tailwindConfig\n            });\n            if (result === undefined) {\n                continue;\n            }\n            return [\n                result,\n                type,\n                null\n            ];\n        }\n    }\n    if (isArbitraryValue(modifier)) {\n        let arbitraryValue = modifier.slice(1, -1);\n        let [explicitType, value] = splitAtFirst(arbitraryValue, \":\");\n        // It could be that this resolves to `url(https` which is not a valid\n        // identifier. We currently only support \"simple\" words with dashes or\n        // underscores. E.g.: family-name\n        if (!/^[\\w-_]+$/g.test(explicitType)) {\n            value = arbitraryValue;\n        } else if (explicitType !== undefined && !supportedTypes.includes(explicitType)) {\n            return [];\n        }\n        if (value.length > 0 && supportedTypes.includes(explicitType)) {\n            return [\n                asValue(`[${value}]`, options),\n                explicitType,\n                null\n            ];\n        }\n    }\n    let matches = getMatchingTypes(types, modifier, options, tailwindConfig);\n    // Find first matching type\n    for (let match of matches){\n        return match;\n    }\n    return [];\n}\nfunction* getMatchingTypes(types, rawModifier, options, tailwindConfig) {\n    let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n    let [modifier, utilityModifier] = splitUtilityModifier(rawModifier);\n    let canUseUtilityModifier = modifiersEnabled && options.modifiers != null && (options.modifiers === \"any\" || typeof options.modifiers === \"object\" && (utilityModifier && isArbitraryValue(utilityModifier) || utilityModifier in options.modifiers));\n    if (!canUseUtilityModifier) {\n        modifier = rawModifier;\n        utilityModifier = undefined;\n    }\n    if (utilityModifier !== undefined && modifier === \"\") {\n        modifier = \"DEFAULT\";\n    }\n    // Check the full value first\n    // TODO: Move to asValueâ€¦ somehow\n    if (utilityModifier !== undefined) {\n        if (typeof options.modifiers === \"object\") {\n            var _options_modifiers;\n            var _options_modifiers_utilityModifier;\n            let configValue = (_options_modifiers_utilityModifier = (_options_modifiers = options.modifiers) === null || _options_modifiers === void 0 ? void 0 : _options_modifiers[utilityModifier]) !== null && _options_modifiers_utilityModifier !== void 0 ? _options_modifiers_utilityModifier : null;\n            if (configValue !== null) {\n                utilityModifier = configValue;\n            } else if (isArbitraryValue(utilityModifier)) {\n                utilityModifier = unwrapArbitraryModifier(utilityModifier);\n            }\n        }\n    }\n    for (let { type  } of types !== null && types !== void 0 ? types : []){\n        let result = typeMap[type](modifier, options, {\n            tailwindConfig\n        });\n        if (result === undefined) {\n            continue;\n        }\n        yield [\n            result,\n            type,\n            utilityModifier !== null && utilityModifier !== void 0 ? utilityModifier : null\n        ];\n    }\n}\n"]}}