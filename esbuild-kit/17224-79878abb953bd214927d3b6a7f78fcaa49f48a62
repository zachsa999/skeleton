{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:true,get:all[name]})}__name(_export,\"_export\");_export(exports,{pattern:function(){return pattern},withoutCapturing:function(){return withoutCapturing},any:function(){return any},optional:function(){return optional},zeroOrMore:function(){return zeroOrMore},nestedBrackets:function(){return nestedBrackets},escape:function(){return escape}});const REGEX_SPECIAL=/[\\\\^$.*+?()[\\]{}|]/g;const REGEX_HAS_SPECIAL=RegExp(REGEX_SPECIAL.source);function toSource(source){source=Array.isArray(source)?source:[source];source=source.map(item=>item instanceof RegExp?item.source:item);return source.join(\"\")}__name(toSource,\"toSource\");function pattern(source){return new RegExp(toSource(source),\"g\")}__name(pattern,\"pattern\");function withoutCapturing(source){return new RegExp(`(?:${toSource(source)})`,\"g\")}__name(withoutCapturing,\"withoutCapturing\");function any(sources){return`(?:${sources.map(toSource).join(\"|\")})`}__name(any,\"any\");function optional(source){return`(?:${toSource(source)})?`}__name(optional,\"optional\");function zeroOrMore(source){return`(?:${toSource(source)})*`}__name(zeroOrMore,\"zeroOrMore\");function nestedBrackets(open,close,depth=1){return withoutCapturing([escape(open),/[^\\s]*/,depth===1?`[^${escape(open)}${escape(close)}s]*`:any([`[^${escape(open)}${escape(close)}s]*`,nestedBrackets(open,close,depth-1)]),/[^\\s]*/,escape(close)])}__name(nestedBrackets,\"nestedBrackets\");function escape(string){return string&&REGEX_HAS_SPECIAL.test(string)?string.replace(REGEX_SPECIAL,\"\\\\$&\"):string||\"\"}__name(escape,\"escape\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CACzC,MAAO,IACX,CAAC,EACD,SAAS,QAAQ,OAAQ,IAAK,CAC1B,QAAQ,QAAQ,IAAI,OAAO,eAAe,OAAQ,KAAM,CACpD,WAAY,KACZ,IAAK,IAAI,IAAI,CACjB,CAAC,CACL,CALS,0BAMT,QAAQ,QAAS,CACb,QAAS,UAAW,CAChB,OAAO,OACX,EACA,iBAAkB,UAAW,CACzB,OAAO,gBACX,EACA,IAAK,UAAW,CACZ,OAAO,GACX,EACA,SAAU,UAAW,CACjB,OAAO,QACX,EACA,WAAY,UAAW,CACnB,OAAO,UACX,EACA,eAAgB,UAAW,CACvB,OAAO,cACX,EACA,OAAQ,UAAW,CACf,OAAO,MACX,CACJ,CAAC,EACD,MAAM,cAAgB,sBACtB,MAAM,kBAAoB,OAAO,cAAc,MAAM,EAGjD,SAAS,SAAS,OAAQ,CAC1B,OAAS,MAAM,QAAQ,MAAM,EAAI,OAAS,CACtC,MACJ,EACA,OAAS,OAAO,IAAK,MAAO,gBAAgB,OAAS,KAAK,OAAS,IAAI,EACvE,OAAO,OAAO,KAAK,EAAE,CACzB,CANa,4BAOb,SAAS,QAAQ,OAAQ,CACrB,OAAO,IAAI,OAAO,SAAS,MAAM,EAAG,GAAG,CAC3C,CAFS,0BAGT,SAAS,iBAAiB,OAAQ,CAC9B,OAAO,IAAI,OAAO,MAAM,SAAS,MAAM,KAAM,GAAG,CACpD,CAFS,4CAGT,SAAS,IAAI,QAAS,CAClB,MAAO,MAAM,QAAQ,IAAI,QAAQ,EAAE,KAAK,GAAG,IAC/C,CAFS,kBAGT,SAAS,SAAS,OAAQ,CACtB,MAAO,MAAM,SAAS,MAAM,KAChC,CAFS,4BAGT,SAAS,WAAW,OAAQ,CACxB,MAAO,MAAM,SAAS,MAAM,KAChC,CAFS,gCAGT,SAAS,eAAe,KAAM,MAAO,MAAQ,EAAG,CAC5C,OAAO,iBAAiB,CACpB,OAAO,IAAI,EACX,SACA,QAAU,EAAI,KAAK,OAAO,IAAI,IAAI,OAAO,KAAK,OAAU,IAAI,CACxD,KAAK,OAAO,IAAI,IAAI,OAAO,KAAK,OAChC,eAAe,KAAM,MAAO,MAAQ,CAAC,CACzC,CAAC,EACD,SACA,OAAO,KAAK,CAChB,CAAC,CACL,CAXS,wCAYT,SAAS,OAAO,OAAQ,CACpB,OAAO,QAAU,kBAAkB,KAAK,MAAM,EAAI,OAAO,QAAQ,cAAe,MAAM,EAAI,QAAU,EACxG,CAFS","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/lib/regex.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    pattern: function() {\n        return pattern;\n    },\n    withoutCapturing: function() {\n        return withoutCapturing;\n    },\n    any: function() {\n        return any;\n    },\n    optional: function() {\n        return optional;\n    },\n    zeroOrMore: function() {\n        return zeroOrMore;\n    },\n    nestedBrackets: function() {\n        return nestedBrackets;\n    },\n    escape: function() {\n        return escape;\n    }\n});\nconst REGEX_SPECIAL = /[\\\\^$.*+?()[\\]{}|]/g;\nconst REGEX_HAS_SPECIAL = RegExp(REGEX_SPECIAL.source);\n/**\n * @param {string|RegExp|Array<string|RegExp>} source\n */ function toSource(source) {\n    source = Array.isArray(source) ? source : [\n        source\n    ];\n    source = source.map((item)=>item instanceof RegExp ? item.source : item);\n    return source.join(\"\");\n}\nfunction pattern(source) {\n    return new RegExp(toSource(source), \"g\");\n}\nfunction withoutCapturing(source) {\n    return new RegExp(`(?:${toSource(source)})`, \"g\");\n}\nfunction any(sources) {\n    return `(?:${sources.map(toSource).join(\"|\")})`;\n}\nfunction optional(source) {\n    return `(?:${toSource(source)})?`;\n}\nfunction zeroOrMore(source) {\n    return `(?:${toSource(source)})*`;\n}\nfunction nestedBrackets(open, close, depth = 1) {\n    return withoutCapturing([\n        escape(open),\n        /[^\\s]*/,\n        depth === 1 ? `[^${escape(open)}${escape(close)}\\s]*` : any([\n            `[^${escape(open)}${escape(close)}\\s]*`,\n            nestedBrackets(open, close, depth - 1)\n        ]),\n        /[^\\s]*/,\n        escape(close)\n    ]);\n}\nfunction escape(string) {\n    return string && REGEX_HAS_SPECIAL.test(string) ? string.replace(REGEX_SPECIAL, \"\\\\$&\") : string || \"\";\n}\n"]}}