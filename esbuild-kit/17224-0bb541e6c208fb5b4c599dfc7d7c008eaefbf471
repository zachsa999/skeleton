{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _index=require(\"../tokenizer/index\");var _keywords=require(\"../tokenizer/keywords\");var _types=require(\"../tokenizer/types\");var _base=require(\"../traverser/base\");var _expression=require(\"../traverser/expression\");var _lval=require(\"../traverser/lval\");var _statement=require(\"../traverser/statement\");var _util=require(\"../traverser/util\");var _jsx=require(\"./jsx\");function tsIsIdentifier(){return _index.match.call(void 0,_types.TokenType.name)}__name(tsIsIdentifier,\"tsIsIdentifier\");function isLiteralPropertyName(){return _index.match.call(void 0,_types.TokenType.name)||Boolean(_base.state.type&_types.TokenType.IS_KEYWORD)||_index.match.call(void 0,_types.TokenType.string)||_index.match.call(void 0,_types.TokenType.num)||_index.match.call(void 0,_types.TokenType.bigint)||_index.match.call(void 0,_types.TokenType.decimal)}__name(isLiteralPropertyName,\"isLiteralPropertyName\");function tsNextTokenCanFollowModifier(){const snapshot=_base.state.snapshot();_index.next.call(void 0);const canFollowModifier=(_index.match.call(void 0,_types.TokenType.bracketL)||_index.match.call(void 0,_types.TokenType.braceL)||_index.match.call(void 0,_types.TokenType.star)||_index.match.call(void 0,_types.TokenType.ellipsis)||_index.match.call(void 0,_types.TokenType.hash)||isLiteralPropertyName())&&!_util.hasPrecedingLineBreak.call(void 0);if(canFollowModifier){return true}else{_base.state.restoreFromSnapshot(snapshot);return false}}__name(tsNextTokenCanFollowModifier,\"tsNextTokenCanFollowModifier\");function tsParseModifiers(allowedModifiers){while(true){const modifier=tsParseModifier(allowedModifiers);if(modifier===null){break}}}__name(tsParseModifiers,\"tsParseModifiers\");exports.tsParseModifiers=tsParseModifiers;function tsParseModifier(allowedModifiers){if(!_index.match.call(void 0,_types.TokenType.name)){return null}const modifier=_base.state.contextualKeyword;if(allowedModifiers.indexOf(modifier)!==-1&&tsNextTokenCanFollowModifier()){switch(modifier){case _keywords.ContextualKeyword._readonly:_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._readonly;break;case _keywords.ContextualKeyword._abstract:_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._abstract;break;case _keywords.ContextualKeyword._static:_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._static;break;case _keywords.ContextualKeyword._public:_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._public;break;case _keywords.ContextualKeyword._private:_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._private;break;case _keywords.ContextualKeyword._protected:_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._protected;break;case _keywords.ContextualKeyword._override:_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._override;break;case _keywords.ContextualKeyword._declare:_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._declare;break;default:break}return modifier}return null}__name(tsParseModifier,\"tsParseModifier\");exports.tsParseModifier=tsParseModifier;function tsParseEntityName(){_expression.parseIdentifier.call(void 0);while(_index.eat.call(void 0,_types.TokenType.dot)){_expression.parseIdentifier.call(void 0)}}__name(tsParseEntityName,\"tsParseEntityName\");function tsParseTypeReference(){tsParseEntityName();if(!_util.hasPrecedingLineBreak.call(void 0)&&_index.match.call(void 0,_types.TokenType.lessThan)){tsParseTypeArguments()}}__name(tsParseTypeReference,\"tsParseTypeReference\");function tsParseThisTypePredicate(){_index.next.call(void 0);tsParseTypeAnnotation()}__name(tsParseThisTypePredicate,\"tsParseThisTypePredicate\");function tsParseThisTypeNode(){_index.next.call(void 0)}__name(tsParseThisTypeNode,\"tsParseThisTypeNode\");function tsParseTypeQuery(){_util.expect.call(void 0,_types.TokenType._typeof);if(_index.match.call(void 0,_types.TokenType._import)){tsParseImportType()}else{tsParseEntityName()}if(!_util.hasPrecedingLineBreak.call(void 0)&&_index.match.call(void 0,_types.TokenType.lessThan)){tsParseTypeArguments()}}__name(tsParseTypeQuery,\"tsParseTypeQuery\");function tsParseImportType(){_util.expect.call(void 0,_types.TokenType._import);_util.expect.call(void 0,_types.TokenType.parenL);_util.expect.call(void 0,_types.TokenType.string);_util.expect.call(void 0,_types.TokenType.parenR);if(_index.eat.call(void 0,_types.TokenType.dot)){tsParseEntityName()}if(_index.match.call(void 0,_types.TokenType.lessThan)){tsParseTypeArguments()}}__name(tsParseImportType,\"tsParseImportType\");function tsParseTypeParameter(){_index.eat.call(void 0,_types.TokenType._const);const hadIn=_index.eat.call(void 0,_types.TokenType._in);const hadOut=_util.eatContextual.call(void 0,_keywords.ContextualKeyword._out);_index.eat.call(void 0,_types.TokenType._const);if((hadIn||hadOut)&&!_index.match.call(void 0,_types.TokenType.name)){_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType.name}else{_expression.parseIdentifier.call(void 0)}if(_index.eat.call(void 0,_types.TokenType._extends)){tsParseType()}if(_index.eat.call(void 0,_types.TokenType.eq)){tsParseType()}}__name(tsParseTypeParameter,\"tsParseTypeParameter\");function tsTryParseTypeParameters(){if(_index.match.call(void 0,_types.TokenType.lessThan)){tsParseTypeParameters()}}__name(tsTryParseTypeParameters,\"tsTryParseTypeParameters\");exports.tsTryParseTypeParameters=tsTryParseTypeParameters;function tsParseTypeParameters(){const oldIsType=_index.pushTypeContext.call(void 0,0);if(_index.match.call(void 0,_types.TokenType.lessThan)||_index.match.call(void 0,_types.TokenType.typeParameterStart)){_index.next.call(void 0)}else{_util.unexpected.call(void 0)}while(!_index.eat.call(void 0,_types.TokenType.greaterThan)&&!_base.state.error){tsParseTypeParameter();_index.eat.call(void 0,_types.TokenType.comma)}_index.popTypeContext.call(void 0,oldIsType)}__name(tsParseTypeParameters,\"tsParseTypeParameters\");function tsFillSignature(returnToken){const returnTokenRequired=returnToken===_types.TokenType.arrow;tsTryParseTypeParameters();_util.expect.call(void 0,_types.TokenType.parenL);_base.state.scopeDepth++;tsParseBindingListForSignature(false);_base.state.scopeDepth--;if(returnTokenRequired){tsParseTypeOrTypePredicateAnnotation(returnToken)}else if(_index.match.call(void 0,returnToken)){tsParseTypeOrTypePredicateAnnotation(returnToken)}}__name(tsFillSignature,\"tsFillSignature\");function tsParseBindingListForSignature(isBlockScope){_lval.parseBindingList.call(void 0,_types.TokenType.parenR,isBlockScope)}__name(tsParseBindingListForSignature,\"tsParseBindingListForSignature\");function tsParseTypeMemberSemicolon(){if(!_index.eat.call(void 0,_types.TokenType.comma)){_util.semicolon.call(void 0)}}__name(tsParseTypeMemberSemicolon,\"tsParseTypeMemberSemicolon\");function tsParseSignatureMember(){tsFillSignature(_types.TokenType.colon);tsParseTypeMemberSemicolon()}__name(tsParseSignatureMember,\"tsParseSignatureMember\");function tsIsUnambiguouslyIndexSignature(){const snapshot=_base.state.snapshot();_index.next.call(void 0);const isIndexSignature=_index.eat.call(void 0,_types.TokenType.name)&&_index.match.call(void 0,_types.TokenType.colon);_base.state.restoreFromSnapshot(snapshot);return isIndexSignature}__name(tsIsUnambiguouslyIndexSignature,\"tsIsUnambiguouslyIndexSignature\");function tsTryParseIndexSignature(){if(!(_index.match.call(void 0,_types.TokenType.bracketL)&&tsIsUnambiguouslyIndexSignature())){return false}const oldIsType=_index.pushTypeContext.call(void 0,0);_util.expect.call(void 0,_types.TokenType.bracketL);_expression.parseIdentifier.call(void 0);tsParseTypeAnnotation();_util.expect.call(void 0,_types.TokenType.bracketR);tsTryParseTypeAnnotation();tsParseTypeMemberSemicolon();_index.popTypeContext.call(void 0,oldIsType);return true}__name(tsTryParseIndexSignature,\"tsTryParseIndexSignature\");function tsParsePropertyOrMethodSignature(isReadonly){_index.eat.call(void 0,_types.TokenType.question);if(!isReadonly&&(_index.match.call(void 0,_types.TokenType.parenL)||_index.match.call(void 0,_types.TokenType.lessThan))){tsFillSignature(_types.TokenType.colon);tsParseTypeMemberSemicolon()}else{tsTryParseTypeAnnotation();tsParseTypeMemberSemicolon()}}__name(tsParsePropertyOrMethodSignature,\"tsParsePropertyOrMethodSignature\");function tsParseTypeMember(){if(_index.match.call(void 0,_types.TokenType.parenL)||_index.match.call(void 0,_types.TokenType.lessThan)){tsParseSignatureMember();return}if(_index.match.call(void 0,_types.TokenType._new)){_index.next.call(void 0);if(_index.match.call(void 0,_types.TokenType.parenL)||_index.match.call(void 0,_types.TokenType.lessThan)){tsParseSignatureMember()}else{tsParsePropertyOrMethodSignature(false)}return}const readonly=!!tsParseModifier([_keywords.ContextualKeyword._readonly]);const found=tsTryParseIndexSignature();if(found){return}if((_util.isContextual.call(void 0,_keywords.ContextualKeyword._get)||_util.isContextual.call(void 0,_keywords.ContextualKeyword._set))&&tsNextTokenCanFollowModifier()){}_expression.parsePropertyName.call(void 0,-1);tsParsePropertyOrMethodSignature(readonly)}__name(tsParseTypeMember,\"tsParseTypeMember\");function tsParseTypeLiteral(){tsParseObjectTypeMembers()}__name(tsParseTypeLiteral,\"tsParseTypeLiteral\");function tsParseObjectTypeMembers(){_util.expect.call(void 0,_types.TokenType.braceL);while(!_index.eat.call(void 0,_types.TokenType.braceR)&&!_base.state.error){tsParseTypeMember()}}__name(tsParseObjectTypeMembers,\"tsParseObjectTypeMembers\");function tsLookaheadIsStartOfMappedType(){const snapshot=_base.state.snapshot();const isStartOfMappedType=tsIsStartOfMappedType();_base.state.restoreFromSnapshot(snapshot);return isStartOfMappedType}__name(tsLookaheadIsStartOfMappedType,\"tsLookaheadIsStartOfMappedType\");function tsIsStartOfMappedType(){_index.next.call(void 0);if(_index.eat.call(void 0,_types.TokenType.plus)||_index.eat.call(void 0,_types.TokenType.minus)){return _util.isContextual.call(void 0,_keywords.ContextualKeyword._readonly)}if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._readonly)){_index.next.call(void 0)}if(!_index.match.call(void 0,_types.TokenType.bracketL)){return false}_index.next.call(void 0);if(!tsIsIdentifier()){return false}_index.next.call(void 0);return _index.match.call(void 0,_types.TokenType._in)}__name(tsIsStartOfMappedType,\"tsIsStartOfMappedType\");function tsParseMappedTypeParameter(){_expression.parseIdentifier.call(void 0);_util.expect.call(void 0,_types.TokenType._in);tsParseType()}__name(tsParseMappedTypeParameter,\"tsParseMappedTypeParameter\");function tsParseMappedType(){_util.expect.call(void 0,_types.TokenType.braceL);if(_index.match.call(void 0,_types.TokenType.plus)||_index.match.call(void 0,_types.TokenType.minus)){_index.next.call(void 0);_util.expectContextual.call(void 0,_keywords.ContextualKeyword._readonly)}else{_util.eatContextual.call(void 0,_keywords.ContextualKeyword._readonly)}_util.expect.call(void 0,_types.TokenType.bracketL);tsParseMappedTypeParameter();if(_util.eatContextual.call(void 0,_keywords.ContextualKeyword._as)){tsParseType()}_util.expect.call(void 0,_types.TokenType.bracketR);if(_index.match.call(void 0,_types.TokenType.plus)||_index.match.call(void 0,_types.TokenType.minus)){_index.next.call(void 0);_util.expect.call(void 0,_types.TokenType.question)}else{_index.eat.call(void 0,_types.TokenType.question)}tsTryParseType();_util.semicolon.call(void 0);_util.expect.call(void 0,_types.TokenType.braceR)}__name(tsParseMappedType,\"tsParseMappedType\");function tsParseTupleType(){_util.expect.call(void 0,_types.TokenType.bracketL);while(!_index.eat.call(void 0,_types.TokenType.bracketR)&&!_base.state.error){tsParseTupleElementType();_index.eat.call(void 0,_types.TokenType.comma)}}__name(tsParseTupleType,\"tsParseTupleType\");function tsParseTupleElementType(){if(_index.eat.call(void 0,_types.TokenType.ellipsis)){tsParseType()}else{tsParseType();_index.eat.call(void 0,_types.TokenType.question)}if(_index.eat.call(void 0,_types.TokenType.colon)){tsParseType()}}__name(tsParseTupleElementType,\"tsParseTupleElementType\");function tsParseParenthesizedType(){_util.expect.call(void 0,_types.TokenType.parenL);tsParseType();_util.expect.call(void 0,_types.TokenType.parenR)}__name(tsParseParenthesizedType,\"tsParseParenthesizedType\");function tsParseTemplateLiteralType(){_index.nextTemplateToken.call(void 0);_index.nextTemplateToken.call(void 0);while(!_index.match.call(void 0,_types.TokenType.backQuote)&&!_base.state.error){_util.expect.call(void 0,_types.TokenType.dollarBraceL);tsParseType();_index.nextTemplateToken.call(void 0);_index.nextTemplateToken.call(void 0)}_index.next.call(void 0)}__name(tsParseTemplateLiteralType,\"tsParseTemplateLiteralType\");var FunctionType;(function(FunctionType2){const TSFunctionType=0;FunctionType2[FunctionType2[\"TSFunctionType\"]=TSFunctionType]=\"TSFunctionType\";const TSConstructorType=TSFunctionType+1;FunctionType2[FunctionType2[\"TSConstructorType\"]=TSConstructorType]=\"TSConstructorType\";const TSAbstractConstructorType=TSConstructorType+1;FunctionType2[FunctionType2[\"TSAbstractConstructorType\"]=TSAbstractConstructorType]=\"TSAbstractConstructorType\"})(FunctionType||(FunctionType={}));function tsParseFunctionOrConstructorType(type){if(type===FunctionType.TSAbstractConstructorType){_util.expectContextual.call(void 0,_keywords.ContextualKeyword._abstract)}if(type===FunctionType.TSConstructorType||type===FunctionType.TSAbstractConstructorType){_util.expect.call(void 0,_types.TokenType._new)}const oldInDisallowConditionalTypesContext=_base.state.inDisallowConditionalTypesContext;_base.state.inDisallowConditionalTypesContext=false;tsFillSignature(_types.TokenType.arrow);_base.state.inDisallowConditionalTypesContext=oldInDisallowConditionalTypesContext}__name(tsParseFunctionOrConstructorType,\"tsParseFunctionOrConstructorType\");function tsParseNonArrayType(){switch(_base.state.type){case _types.TokenType.name:tsParseTypeReference();return;case _types.TokenType._void:case _types.TokenType._null:_index.next.call(void 0);return;case _types.TokenType.string:case _types.TokenType.num:case _types.TokenType.bigint:case _types.TokenType.decimal:case _types.TokenType._true:case _types.TokenType._false:_expression.parseLiteral.call(void 0);return;case _types.TokenType.minus:_index.next.call(void 0);_expression.parseLiteral.call(void 0);return;case _types.TokenType._this:{tsParseThisTypeNode();if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._is)&&!_util.hasPrecedingLineBreak.call(void 0)){tsParseThisTypePredicate()}return}case _types.TokenType._typeof:tsParseTypeQuery();return;case _types.TokenType._import:tsParseImportType();return;case _types.TokenType.braceL:if(tsLookaheadIsStartOfMappedType()){tsParseMappedType()}else{tsParseTypeLiteral()}return;case _types.TokenType.bracketL:tsParseTupleType();return;case _types.TokenType.parenL:tsParseParenthesizedType();return;case _types.TokenType.backQuote:tsParseTemplateLiteralType();return;default:if(_base.state.type&_types.TokenType.IS_KEYWORD){_index.next.call(void 0);_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType.name;return}break}_util.unexpected.call(void 0)}__name(tsParseNonArrayType,\"tsParseNonArrayType\");function tsParseArrayTypeOrHigher(){tsParseNonArrayType();while(!_util.hasPrecedingLineBreak.call(void 0)&&_index.eat.call(void 0,_types.TokenType.bracketL)){if(!_index.eat.call(void 0,_types.TokenType.bracketR)){tsParseType();_util.expect.call(void 0,_types.TokenType.bracketR)}}}__name(tsParseArrayTypeOrHigher,\"tsParseArrayTypeOrHigher\");function tsParseInferType(){_util.expectContextual.call(void 0,_keywords.ContextualKeyword._infer);_expression.parseIdentifier.call(void 0);if(_index.match.call(void 0,_types.TokenType._extends)){const snapshot=_base.state.snapshot();_util.expect.call(void 0,_types.TokenType._extends);const oldInDisallowConditionalTypesContext=_base.state.inDisallowConditionalTypesContext;_base.state.inDisallowConditionalTypesContext=true;tsParseType();_base.state.inDisallowConditionalTypesContext=oldInDisallowConditionalTypesContext;if(_base.state.error||!_base.state.inDisallowConditionalTypesContext&&_index.match.call(void 0,_types.TokenType.question)){_base.state.restoreFromSnapshot(snapshot)}}}__name(tsParseInferType,\"tsParseInferType\");function tsParseTypeOperatorOrHigher(){if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._keyof)||_util.isContextual.call(void 0,_keywords.ContextualKeyword._unique)||_util.isContextual.call(void 0,_keywords.ContextualKeyword._readonly)){_index.next.call(void 0);tsParseTypeOperatorOrHigher()}else if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._infer)){tsParseInferType()}else{const oldInDisallowConditionalTypesContext=_base.state.inDisallowConditionalTypesContext;_base.state.inDisallowConditionalTypesContext=false;tsParseArrayTypeOrHigher();_base.state.inDisallowConditionalTypesContext=oldInDisallowConditionalTypesContext}}__name(tsParseTypeOperatorOrHigher,\"tsParseTypeOperatorOrHigher\");function tsParseIntersectionTypeOrHigher(){_index.eat.call(void 0,_types.TokenType.bitwiseAND);tsParseTypeOperatorOrHigher();if(_index.match.call(void 0,_types.TokenType.bitwiseAND)){while(_index.eat.call(void 0,_types.TokenType.bitwiseAND)){tsParseTypeOperatorOrHigher()}}}__name(tsParseIntersectionTypeOrHigher,\"tsParseIntersectionTypeOrHigher\");function tsParseUnionTypeOrHigher(){_index.eat.call(void 0,_types.TokenType.bitwiseOR);tsParseIntersectionTypeOrHigher();if(_index.match.call(void 0,_types.TokenType.bitwiseOR)){while(_index.eat.call(void 0,_types.TokenType.bitwiseOR)){tsParseIntersectionTypeOrHigher()}}}__name(tsParseUnionTypeOrHigher,\"tsParseUnionTypeOrHigher\");function tsIsStartOfFunctionType(){if(_index.match.call(void 0,_types.TokenType.lessThan)){return true}return _index.match.call(void 0,_types.TokenType.parenL)&&tsLookaheadIsUnambiguouslyStartOfFunctionType()}__name(tsIsStartOfFunctionType,\"tsIsStartOfFunctionType\");function tsSkipParameterStart(){if(_index.match.call(void 0,_types.TokenType.name)||_index.match.call(void 0,_types.TokenType._this)){_index.next.call(void 0);return true}if(_index.match.call(void 0,_types.TokenType.braceL)||_index.match.call(void 0,_types.TokenType.bracketL)){let depth=1;_index.next.call(void 0);while(depth>0&&!_base.state.error){if(_index.match.call(void 0,_types.TokenType.braceL)||_index.match.call(void 0,_types.TokenType.bracketL)){depth++}else if(_index.match.call(void 0,_types.TokenType.braceR)||_index.match.call(void 0,_types.TokenType.bracketR)){depth--}_index.next.call(void 0)}return true}return false}__name(tsSkipParameterStart,\"tsSkipParameterStart\");function tsLookaheadIsUnambiguouslyStartOfFunctionType(){const snapshot=_base.state.snapshot();const isUnambiguouslyStartOfFunctionType=tsIsUnambiguouslyStartOfFunctionType();_base.state.restoreFromSnapshot(snapshot);return isUnambiguouslyStartOfFunctionType}__name(tsLookaheadIsUnambiguouslyStartOfFunctionType,\"tsLookaheadIsUnambiguouslyStartOfFunctionType\");function tsIsUnambiguouslyStartOfFunctionType(){_index.next.call(void 0);if(_index.match.call(void 0,_types.TokenType.parenR)||_index.match.call(void 0,_types.TokenType.ellipsis)){return true}if(tsSkipParameterStart()){if(_index.match.call(void 0,_types.TokenType.colon)||_index.match.call(void 0,_types.TokenType.comma)||_index.match.call(void 0,_types.TokenType.question)||_index.match.call(void 0,_types.TokenType.eq)){return true}if(_index.match.call(void 0,_types.TokenType.parenR)){_index.next.call(void 0);if(_index.match.call(void 0,_types.TokenType.arrow)){return true}}}return false}__name(tsIsUnambiguouslyStartOfFunctionType,\"tsIsUnambiguouslyStartOfFunctionType\");function tsParseTypeOrTypePredicateAnnotation(returnToken){const oldIsType=_index.pushTypeContext.call(void 0,0);_util.expect.call(void 0,returnToken);const finishedReturn=tsParseTypePredicateOrAssertsPrefix();if(!finishedReturn){tsParseType()}_index.popTypeContext.call(void 0,oldIsType)}__name(tsParseTypeOrTypePredicateAnnotation,\"tsParseTypeOrTypePredicateAnnotation\");function tsTryParseTypeOrTypePredicateAnnotation(){if(_index.match.call(void 0,_types.TokenType.colon)){tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon)}}__name(tsTryParseTypeOrTypePredicateAnnotation,\"tsTryParseTypeOrTypePredicateAnnotation\");function tsTryParseTypeAnnotation(){if(_index.match.call(void 0,_types.TokenType.colon)){tsParseTypeAnnotation()}}__name(tsTryParseTypeAnnotation,\"tsTryParseTypeAnnotation\");exports.tsTryParseTypeAnnotation=tsTryParseTypeAnnotation;function tsTryParseType(){if(_index.eat.call(void 0,_types.TokenType.colon)){tsParseType()}}__name(tsTryParseType,\"tsTryParseType\");function tsParseTypePredicateOrAssertsPrefix(){const snapshot=_base.state.snapshot();if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._asserts)){_index.next.call(void 0);if(_util.eatContextual.call(void 0,_keywords.ContextualKeyword._is)){tsParseType();return true}else if(tsIsIdentifier()||_index.match.call(void 0,_types.TokenType._this)){_index.next.call(void 0);if(_util.eatContextual.call(void 0,_keywords.ContextualKeyword._is)){tsParseType()}return true}else{_base.state.restoreFromSnapshot(snapshot);return false}}else if(tsIsIdentifier()||_index.match.call(void 0,_types.TokenType._this)){_index.next.call(void 0);if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._is)&&!_util.hasPrecedingLineBreak.call(void 0)){_index.next.call(void 0);tsParseType();return true}else{_base.state.restoreFromSnapshot(snapshot);return false}}return false}__name(tsParseTypePredicateOrAssertsPrefix,\"tsParseTypePredicateOrAssertsPrefix\");function tsParseTypeAnnotation(){const oldIsType=_index.pushTypeContext.call(void 0,0);_util.expect.call(void 0,_types.TokenType.colon);tsParseType();_index.popTypeContext.call(void 0,oldIsType)}__name(tsParseTypeAnnotation,\"tsParseTypeAnnotation\");exports.tsParseTypeAnnotation=tsParseTypeAnnotation;function tsParseType(){tsParseNonConditionalType();if(_base.state.inDisallowConditionalTypesContext||_util.hasPrecedingLineBreak.call(void 0)||!_index.eat.call(void 0,_types.TokenType._extends)){return}const oldInDisallowConditionalTypesContext=_base.state.inDisallowConditionalTypesContext;_base.state.inDisallowConditionalTypesContext=true;tsParseNonConditionalType();_base.state.inDisallowConditionalTypesContext=oldInDisallowConditionalTypesContext;_util.expect.call(void 0,_types.TokenType.question);tsParseType();_util.expect.call(void 0,_types.TokenType.colon);tsParseType()}__name(tsParseType,\"tsParseType\");exports.tsParseType=tsParseType;function isAbstractConstructorSignature(){return _util.isContextual.call(void 0,_keywords.ContextualKeyword._abstract)&&_index.lookaheadType.call(void 0)===_types.TokenType._new}__name(isAbstractConstructorSignature,\"isAbstractConstructorSignature\");function tsParseNonConditionalType(){if(tsIsStartOfFunctionType()){tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);return}if(_index.match.call(void 0,_types.TokenType._new)){tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);return}else if(isAbstractConstructorSignature()){tsParseFunctionOrConstructorType(FunctionType.TSAbstractConstructorType);return}tsParseUnionTypeOrHigher()}__name(tsParseNonConditionalType,\"tsParseNonConditionalType\");exports.tsParseNonConditionalType=tsParseNonConditionalType;function tsParseTypeAssertion(){const oldIsType=_index.pushTypeContext.call(void 0,1);tsParseType();_util.expect.call(void 0,_types.TokenType.greaterThan);_index.popTypeContext.call(void 0,oldIsType);_expression.parseMaybeUnary.call(void 0)}__name(tsParseTypeAssertion,\"tsParseTypeAssertion\");exports.tsParseTypeAssertion=tsParseTypeAssertion;function tsTryParseJSXTypeArgument(){if(_index.eat.call(void 0,_types.TokenType.jsxTagStart)){_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType.typeParameterStart;const oldIsType=_index.pushTypeContext.call(void 0,1);while(!_index.match.call(void 0,_types.TokenType.greaterThan)&&!_base.state.error){tsParseType();_index.eat.call(void 0,_types.TokenType.comma)}_jsx.nextJSXTagToken.call(void 0);_index.popTypeContext.call(void 0,oldIsType)}}__name(tsTryParseJSXTypeArgument,\"tsTryParseJSXTypeArgument\");exports.tsTryParseJSXTypeArgument=tsTryParseJSXTypeArgument;function tsParseHeritageClause(){while(!_index.match.call(void 0,_types.TokenType.braceL)&&!_base.state.error){tsParseExpressionWithTypeArguments();_index.eat.call(void 0,_types.TokenType.comma)}}__name(tsParseHeritageClause,\"tsParseHeritageClause\");function tsParseExpressionWithTypeArguments(){tsParseEntityName();if(_index.match.call(void 0,_types.TokenType.lessThan)){tsParseTypeArguments()}}__name(tsParseExpressionWithTypeArguments,\"tsParseExpressionWithTypeArguments\");function tsParseInterfaceDeclaration(){_lval.parseBindingIdentifier.call(void 0,false);tsTryParseTypeParameters();if(_index.eat.call(void 0,_types.TokenType._extends)){tsParseHeritageClause()}tsParseObjectTypeMembers()}__name(tsParseInterfaceDeclaration,\"tsParseInterfaceDeclaration\");function tsParseTypeAliasDeclaration(){_lval.parseBindingIdentifier.call(void 0,false);tsTryParseTypeParameters();_util.expect.call(void 0,_types.TokenType.eq);tsParseType();_util.semicolon.call(void 0)}__name(tsParseTypeAliasDeclaration,\"tsParseTypeAliasDeclaration\");function tsParseEnumMember(){if(_index.match.call(void 0,_types.TokenType.string)){_expression.parseLiteral.call(void 0)}else{_expression.parseIdentifier.call(void 0)}if(_index.eat.call(void 0,_types.TokenType.eq)){const eqIndex=_base.state.tokens.length-1;_expression.parseMaybeAssign.call(void 0);_base.state.tokens[eqIndex].rhsEndIndex=_base.state.tokens.length}}__name(tsParseEnumMember,\"tsParseEnumMember\");function tsParseEnumDeclaration(){_lval.parseBindingIdentifier.call(void 0,false);_util.expect.call(void 0,_types.TokenType.braceL);while(!_index.eat.call(void 0,_types.TokenType.braceR)&&!_base.state.error){tsParseEnumMember();_index.eat.call(void 0,_types.TokenType.comma)}}__name(tsParseEnumDeclaration,\"tsParseEnumDeclaration\");function tsParseModuleBlock(){_util.expect.call(void 0,_types.TokenType.braceL);_statement.parseBlockBody.call(void 0,_types.TokenType.braceR)}__name(tsParseModuleBlock,\"tsParseModuleBlock\");function tsParseModuleOrNamespaceDeclaration(){_lval.parseBindingIdentifier.call(void 0,false);if(_index.eat.call(void 0,_types.TokenType.dot)){tsParseModuleOrNamespaceDeclaration()}else{tsParseModuleBlock()}}__name(tsParseModuleOrNamespaceDeclaration,\"tsParseModuleOrNamespaceDeclaration\");function tsParseAmbientExternalModuleDeclaration(){if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._global)){_expression.parseIdentifier.call(void 0)}else if(_index.match.call(void 0,_types.TokenType.string)){_expression.parseExprAtom.call(void 0)}else{_util.unexpected.call(void 0)}if(_index.match.call(void 0,_types.TokenType.braceL)){tsParseModuleBlock()}else{_util.semicolon.call(void 0)}}__name(tsParseAmbientExternalModuleDeclaration,\"tsParseAmbientExternalModuleDeclaration\");function tsParseImportEqualsDeclaration(){_lval.parseImportedIdentifier.call(void 0);_util.expect.call(void 0,_types.TokenType.eq);tsParseModuleReference();_util.semicolon.call(void 0)}__name(tsParseImportEqualsDeclaration,\"tsParseImportEqualsDeclaration\");exports.tsParseImportEqualsDeclaration=tsParseImportEqualsDeclaration;function tsIsExternalModuleReference(){return _util.isContextual.call(void 0,_keywords.ContextualKeyword._require)&&_index.lookaheadType.call(void 0)===_types.TokenType.parenL}__name(tsIsExternalModuleReference,\"tsIsExternalModuleReference\");function tsParseModuleReference(){if(tsIsExternalModuleReference()){tsParseExternalModuleReference()}else{tsParseEntityName()}}__name(tsParseModuleReference,\"tsParseModuleReference\");function tsParseExternalModuleReference(){_util.expectContextual.call(void 0,_keywords.ContextualKeyword._require);_util.expect.call(void 0,_types.TokenType.parenL);if(!_index.match.call(void 0,_types.TokenType.string)){_util.unexpected.call(void 0)}_expression.parseLiteral.call(void 0);_util.expect.call(void 0,_types.TokenType.parenR)}__name(tsParseExternalModuleReference,\"tsParseExternalModuleReference\");function tsTryParseDeclare(){if(_util.isLineTerminator.call(void 0)){return false}switch(_base.state.type){case _types.TokenType._function:{const oldIsType=_index.pushTypeContext.call(void 0,1);_index.next.call(void 0);const functionStart=_base.state.start;_statement.parseFunction.call(void 0,functionStart,true);_index.popTypeContext.call(void 0,oldIsType);return true}case _types.TokenType._class:{const oldIsType=_index.pushTypeContext.call(void 0,1);_statement.parseClass.call(void 0,true,false);_index.popTypeContext.call(void 0,oldIsType);return true}case _types.TokenType._const:{if(_index.match.call(void 0,_types.TokenType._const)&&_util.isLookaheadContextual.call(void 0,_keywords.ContextualKeyword._enum)){const oldIsType=_index.pushTypeContext.call(void 0,1);_util.expect.call(void 0,_types.TokenType._const);_util.expectContextual.call(void 0,_keywords.ContextualKeyword._enum);_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._enum;tsParseEnumDeclaration();_index.popTypeContext.call(void 0,oldIsType);return true}}case _types.TokenType._var:case _types.TokenType._let:{const oldIsType=_index.pushTypeContext.call(void 0,1);_statement.parseVarStatement.call(void 0,_base.state.type!==_types.TokenType._var);_index.popTypeContext.call(void 0,oldIsType);return true}case _types.TokenType.name:{const oldIsType=_index.pushTypeContext.call(void 0,1);const contextualKeyword=_base.state.contextualKeyword;let matched=false;if(contextualKeyword===_keywords.ContextualKeyword._global){tsParseAmbientExternalModuleDeclaration();matched=true}else{matched=tsParseDeclaration(contextualKeyword,true)}_index.popTypeContext.call(void 0,oldIsType);return matched}default:return false}}__name(tsTryParseDeclare,\"tsTryParseDeclare\");function tsTryParseExportDeclaration(){return tsParseDeclaration(_base.state.contextualKeyword,true)}__name(tsTryParseExportDeclaration,\"tsTryParseExportDeclaration\");function tsParseExpressionStatement(contextualKeyword){switch(contextualKeyword){case _keywords.ContextualKeyword._declare:{const declareTokenIndex=_base.state.tokens.length-1;const matched=tsTryParseDeclare();if(matched){_base.state.tokens[declareTokenIndex].type=_types.TokenType._declare;return true}break}case _keywords.ContextualKeyword._global:if(_index.match.call(void 0,_types.TokenType.braceL)){tsParseModuleBlock();return true}break;default:return tsParseDeclaration(contextualKeyword,false)}return false}__name(tsParseExpressionStatement,\"tsParseExpressionStatement\");function tsParseDeclaration(contextualKeyword,isBeforeToken){switch(contextualKeyword){case _keywords.ContextualKeyword._abstract:if(tsCheckLineTerminator(isBeforeToken)&&_index.match.call(void 0,_types.TokenType._class)){_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._abstract;_statement.parseClass.call(void 0,true,false);return true}break;case _keywords.ContextualKeyword._enum:if(tsCheckLineTerminator(isBeforeToken)&&_index.match.call(void 0,_types.TokenType.name)){_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._enum;tsParseEnumDeclaration();return true}break;case _keywords.ContextualKeyword._interface:if(tsCheckLineTerminator(isBeforeToken)&&_index.match.call(void 0,_types.TokenType.name)){const oldIsType=_index.pushTypeContext.call(void 0,isBeforeToken?2:1);tsParseInterfaceDeclaration();_index.popTypeContext.call(void 0,oldIsType);return true}break;case _keywords.ContextualKeyword._module:if(tsCheckLineTerminator(isBeforeToken)){if(_index.match.call(void 0,_types.TokenType.string)){const oldIsType=_index.pushTypeContext.call(void 0,isBeforeToken?2:1);tsParseAmbientExternalModuleDeclaration();_index.popTypeContext.call(void 0,oldIsType);return true}else if(_index.match.call(void 0,_types.TokenType.name)){const oldIsType=_index.pushTypeContext.call(void 0,isBeforeToken?2:1);tsParseModuleOrNamespaceDeclaration();_index.popTypeContext.call(void 0,oldIsType);return true}}break;case _keywords.ContextualKeyword._namespace:if(tsCheckLineTerminator(isBeforeToken)&&_index.match.call(void 0,_types.TokenType.name)){const oldIsType=_index.pushTypeContext.call(void 0,isBeforeToken?2:1);tsParseModuleOrNamespaceDeclaration();_index.popTypeContext.call(void 0,oldIsType);return true}break;case _keywords.ContextualKeyword._type:if(tsCheckLineTerminator(isBeforeToken)&&_index.match.call(void 0,_types.TokenType.name)){const oldIsType=_index.pushTypeContext.call(void 0,isBeforeToken?2:1);tsParseTypeAliasDeclaration();_index.popTypeContext.call(void 0,oldIsType);return true}break;default:break}return false}__name(tsParseDeclaration,\"tsParseDeclaration\");function tsCheckLineTerminator(isBeforeToken){if(isBeforeToken){_index.next.call(void 0);return true}else{return!_util.isLineTerminator.call(void 0)}}__name(tsCheckLineTerminator,\"tsCheckLineTerminator\");function tsTryParseGenericAsyncArrowFunction(){const snapshot=_base.state.snapshot();tsParseTypeParameters();_statement.parseFunctionParams.call(void 0);tsTryParseTypeOrTypePredicateAnnotation();_util.expect.call(void 0,_types.TokenType.arrow);if(_base.state.error){_base.state.restoreFromSnapshot(snapshot);return false}_expression.parseFunctionBody.call(void 0,true);return true}__name(tsTryParseGenericAsyncArrowFunction,\"tsTryParseGenericAsyncArrowFunction\");function tsParseTypeArgumentsWithPossibleBitshift(){if(_base.state.type===_types.TokenType.bitShiftL){_base.state.pos-=1;_index.finishToken.call(void 0,_types.TokenType.lessThan)}tsParseTypeArguments()}__name(tsParseTypeArgumentsWithPossibleBitshift,\"tsParseTypeArgumentsWithPossibleBitshift\");function tsParseTypeArguments(){const oldIsType=_index.pushTypeContext.call(void 0,0);_util.expect.call(void 0,_types.TokenType.lessThan);while(!_index.eat.call(void 0,_types.TokenType.greaterThan)&&!_base.state.error){tsParseType();_index.eat.call(void 0,_types.TokenType.comma)}_index.popTypeContext.call(void 0,oldIsType)}__name(tsParseTypeArguments,\"tsParseTypeArguments\");function tsIsDeclarationStart(){if(_index.match.call(void 0,_types.TokenType.name)){switch(_base.state.contextualKeyword){case _keywords.ContextualKeyword._abstract:case _keywords.ContextualKeyword._declare:case _keywords.ContextualKeyword._enum:case _keywords.ContextualKeyword._interface:case _keywords.ContextualKeyword._module:case _keywords.ContextualKeyword._namespace:case _keywords.ContextualKeyword._type:return true;default:break}}return false}__name(tsIsDeclarationStart,\"tsIsDeclarationStart\");exports.tsIsDeclarationStart=tsIsDeclarationStart;function tsParseFunctionBodyAndFinish(functionStart,funcContextId){if(_index.match.call(void 0,_types.TokenType.colon)){tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon)}if(!_index.match.call(void 0,_types.TokenType.braceL)&&_util.isLineTerminator.call(void 0)){let i=_base.state.tokens.length-1;while(i>=0&&(_base.state.tokens[i].start>=functionStart||_base.state.tokens[i].type===_types.TokenType._default||_base.state.tokens[i].type===_types.TokenType._export)){_base.state.tokens[i].isType=true;i--}return}_expression.parseFunctionBody.call(void 0,false,funcContextId)}__name(tsParseFunctionBodyAndFinish,\"tsParseFunctionBodyAndFinish\");exports.tsParseFunctionBodyAndFinish=tsParseFunctionBodyAndFinish;function tsParseSubscript(startTokenIndex,noCalls,stopState){if(!_util.hasPrecedingLineBreak.call(void 0)&&_index.eat.call(void 0,_types.TokenType.bang)){_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType.nonNullAssertion;return}if(_index.match.call(void 0,_types.TokenType.lessThan)||_index.match.call(void 0,_types.TokenType.bitShiftL)){const snapshot=_base.state.snapshot();if(!noCalls&&_expression.atPossibleAsync.call(void 0)){const asyncArrowFn=tsTryParseGenericAsyncArrowFunction();if(asyncArrowFn){return}}tsParseTypeArgumentsWithPossibleBitshift();if(!noCalls&&_index.eat.call(void 0,_types.TokenType.parenL)){_base.state.tokens[_base.state.tokens.length-1].subscriptStartIndex=startTokenIndex;_expression.parseCallExpressionArguments.call(void 0)}else if(_index.match.call(void 0,_types.TokenType.backQuote)){_expression.parseTemplate.call(void 0)}else if(_base.state.type===_types.TokenType.greaterThan||_base.state.type!==_types.TokenType.parenL&&Boolean(_base.state.type&_types.TokenType.IS_EXPRESSION_START)&&!_util.hasPrecedingLineBreak.call(void 0)){_util.unexpected.call(void 0)}if(_base.state.error){_base.state.restoreFromSnapshot(snapshot)}else{return}}else if(!noCalls&&_index.match.call(void 0,_types.TokenType.questionDot)&&_index.lookaheadType.call(void 0)===_types.TokenType.lessThan){_index.next.call(void 0);_base.state.tokens[startTokenIndex].isOptionalChainStart=true;_base.state.tokens[_base.state.tokens.length-1].subscriptStartIndex=startTokenIndex;tsParseTypeArguments();_util.expect.call(void 0,_types.TokenType.parenL);_expression.parseCallExpressionArguments.call(void 0)}_expression.baseParseSubscript.call(void 0,startTokenIndex,noCalls,stopState)}__name(tsParseSubscript,\"tsParseSubscript\");exports.tsParseSubscript=tsParseSubscript;function tsTryParseExport(){if(_index.eat.call(void 0,_types.TokenType._import)){if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._type)&&_index.lookaheadType.call(void 0)!==_types.TokenType.eq){_util.expectContextual.call(void 0,_keywords.ContextualKeyword._type)}tsParseImportEqualsDeclaration();return true}else if(_index.eat.call(void 0,_types.TokenType.eq)){_expression.parseExpression.call(void 0);_util.semicolon.call(void 0);return true}else if(_util.eatContextual.call(void 0,_keywords.ContextualKeyword._as)){_util.expectContextual.call(void 0,_keywords.ContextualKeyword._namespace);_expression.parseIdentifier.call(void 0);_util.semicolon.call(void 0);return true}else{if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._type)){const nextType=_index.lookaheadType.call(void 0);if(nextType===_types.TokenType.braceL||nextType===_types.TokenType.star){_index.next.call(void 0)}}return false}}__name(tsTryParseExport,\"tsTryParseExport\");exports.tsTryParseExport=tsTryParseExport;function tsParseImportSpecifier(){_expression.parseIdentifier.call(void 0);if(_index.match.call(void 0,_types.TokenType.comma)||_index.match.call(void 0,_types.TokenType.braceR)){_base.state.tokens[_base.state.tokens.length-1].identifierRole=_index.IdentifierRole.ImportDeclaration;return}_expression.parseIdentifier.call(void 0);if(_index.match.call(void 0,_types.TokenType.comma)||_index.match.call(void 0,_types.TokenType.braceR)){_base.state.tokens[_base.state.tokens.length-1].identifierRole=_index.IdentifierRole.ImportDeclaration;_base.state.tokens[_base.state.tokens.length-2].isType=true;_base.state.tokens[_base.state.tokens.length-1].isType=true;return}_expression.parseIdentifier.call(void 0);if(_index.match.call(void 0,_types.TokenType.comma)||_index.match.call(void 0,_types.TokenType.braceR)){_base.state.tokens[_base.state.tokens.length-3].identifierRole=_index.IdentifierRole.ImportAccess;_base.state.tokens[_base.state.tokens.length-1].identifierRole=_index.IdentifierRole.ImportDeclaration;return}_expression.parseIdentifier.call(void 0);_base.state.tokens[_base.state.tokens.length-3].identifierRole=_index.IdentifierRole.ImportAccess;_base.state.tokens[_base.state.tokens.length-1].identifierRole=_index.IdentifierRole.ImportDeclaration;_base.state.tokens[_base.state.tokens.length-4].isType=true;_base.state.tokens[_base.state.tokens.length-3].isType=true;_base.state.tokens[_base.state.tokens.length-2].isType=true;_base.state.tokens[_base.state.tokens.length-1].isType=true}__name(tsParseImportSpecifier,\"tsParseImportSpecifier\");exports.tsParseImportSpecifier=tsParseImportSpecifier;function tsParseExportSpecifier(){_expression.parseIdentifier.call(void 0);if(_index.match.call(void 0,_types.TokenType.comma)||_index.match.call(void 0,_types.TokenType.braceR)){_base.state.tokens[_base.state.tokens.length-1].identifierRole=_index.IdentifierRole.ExportAccess;return}_expression.parseIdentifier.call(void 0);if(_index.match.call(void 0,_types.TokenType.comma)||_index.match.call(void 0,_types.TokenType.braceR)){_base.state.tokens[_base.state.tokens.length-1].identifierRole=_index.IdentifierRole.ExportAccess;_base.state.tokens[_base.state.tokens.length-2].isType=true;_base.state.tokens[_base.state.tokens.length-1].isType=true;return}_expression.parseIdentifier.call(void 0);if(_index.match.call(void 0,_types.TokenType.comma)||_index.match.call(void 0,_types.TokenType.braceR)){_base.state.tokens[_base.state.tokens.length-3].identifierRole=_index.IdentifierRole.ExportAccess;return}_expression.parseIdentifier.call(void 0);_base.state.tokens[_base.state.tokens.length-3].identifierRole=_index.IdentifierRole.ExportAccess;_base.state.tokens[_base.state.tokens.length-4].isType=true;_base.state.tokens[_base.state.tokens.length-3].isType=true;_base.state.tokens[_base.state.tokens.length-2].isType=true;_base.state.tokens[_base.state.tokens.length-1].isType=true}__name(tsParseExportSpecifier,\"tsParseExportSpecifier\");exports.tsParseExportSpecifier=tsParseExportSpecifier;function tsTryParseExportDefaultExpression(){if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._abstract)&&_index.lookaheadType.call(void 0)===_types.TokenType._class){_base.state.type=_types.TokenType._abstract;_index.next.call(void 0);_statement.parseClass.call(void 0,true,true);return true}if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._interface)){const oldIsType=_index.pushTypeContext.call(void 0,2);tsParseDeclaration(_keywords.ContextualKeyword._interface,true);_index.popTypeContext.call(void 0,oldIsType);return true}return false}__name(tsTryParseExportDefaultExpression,\"tsTryParseExportDefaultExpression\");exports.tsTryParseExportDefaultExpression=tsTryParseExportDefaultExpression;function tsTryParseStatementContent(){if(_base.state.type===_types.TokenType._const){const ahead=_index.lookaheadTypeAndKeyword.call(void 0);if(ahead.type===_types.TokenType.name&&ahead.contextualKeyword===_keywords.ContextualKeyword._enum){_util.expect.call(void 0,_types.TokenType._const);_util.expectContextual.call(void 0,_keywords.ContextualKeyword._enum);_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._enum;tsParseEnumDeclaration();return true}}return false}__name(tsTryParseStatementContent,\"tsTryParseStatementContent\");exports.tsTryParseStatementContent=tsTryParseStatementContent;function tsTryParseClassMemberWithIsStatic(isStatic){const memberStartIndexAfterStatic=_base.state.tokens.length;tsParseModifiers([_keywords.ContextualKeyword._abstract,_keywords.ContextualKeyword._readonly,_keywords.ContextualKeyword._declare,_keywords.ContextualKeyword._static,_keywords.ContextualKeyword._override]);const modifiersEndIndex=_base.state.tokens.length;const found=tsTryParseIndexSignature();if(found){const memberStartIndex=isStatic?memberStartIndexAfterStatic-1:memberStartIndexAfterStatic;for(let i=memberStartIndex;i<modifiersEndIndex;i++){_base.state.tokens[i].isType=true}return true}return false}__name(tsTryParseClassMemberWithIsStatic,\"tsTryParseClassMemberWithIsStatic\");exports.tsTryParseClassMemberWithIsStatic=tsTryParseClassMemberWithIsStatic;function tsParseIdentifierStatement(contextualKeyword){const matched=tsParseExpressionStatement(contextualKeyword);if(!matched){_util.semicolon.call(void 0)}}__name(tsParseIdentifierStatement,\"tsParseIdentifierStatement\");exports.tsParseIdentifierStatement=tsParseIdentifierStatement;function tsParseExportDeclaration(){const isDeclare=_util.eatContextual.call(void 0,_keywords.ContextualKeyword._declare);if(isDeclare){_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._declare}let matchedDeclaration=false;if(_index.match.call(void 0,_types.TokenType.name)){if(isDeclare){const oldIsType=_index.pushTypeContext.call(void 0,2);matchedDeclaration=tsTryParseExportDeclaration();_index.popTypeContext.call(void 0,oldIsType)}else{matchedDeclaration=tsTryParseExportDeclaration()}}if(!matchedDeclaration){if(isDeclare){const oldIsType=_index.pushTypeContext.call(void 0,2);_statement.parseStatement.call(void 0,true);_index.popTypeContext.call(void 0,oldIsType)}else{_statement.parseStatement.call(void 0,true)}}}__name(tsParseExportDeclaration,\"tsParseExportDeclaration\");exports.tsParseExportDeclaration=tsParseExportDeclaration;function tsAfterParseClassSuper(hasSuper){if(hasSuper&&(_index.match.call(void 0,_types.TokenType.lessThan)||_index.match.call(void 0,_types.TokenType.bitShiftL))){tsParseTypeArgumentsWithPossibleBitshift()}if(_util.eatContextual.call(void 0,_keywords.ContextualKeyword._implements)){_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._implements;const oldIsType=_index.pushTypeContext.call(void 0,1);tsParseHeritageClause();_index.popTypeContext.call(void 0,oldIsType)}}__name(tsAfterParseClassSuper,\"tsAfterParseClassSuper\");exports.tsAfterParseClassSuper=tsAfterParseClassSuper;function tsStartParseObjPropValue(){tsTryParseTypeParameters()}__name(tsStartParseObjPropValue,\"tsStartParseObjPropValue\");exports.tsStartParseObjPropValue=tsStartParseObjPropValue;function tsStartParseFunctionParams(){tsTryParseTypeParameters()}__name(tsStartParseFunctionParams,\"tsStartParseFunctionParams\");exports.tsStartParseFunctionParams=tsStartParseFunctionParams;function tsAfterParseVarHead(){const oldIsType=_index.pushTypeContext.call(void 0,0);if(!_util.hasPrecedingLineBreak.call(void 0)){_index.eat.call(void 0,_types.TokenType.bang)}tsTryParseTypeAnnotation();_index.popTypeContext.call(void 0,oldIsType)}__name(tsAfterParseVarHead,\"tsAfterParseVarHead\");exports.tsAfterParseVarHead=tsAfterParseVarHead;function tsStartParseAsyncArrowFromCallExpression(){if(_index.match.call(void 0,_types.TokenType.colon)){tsParseTypeAnnotation()}}__name(tsStartParseAsyncArrowFromCallExpression,\"tsStartParseAsyncArrowFromCallExpression\");exports.tsStartParseAsyncArrowFromCallExpression=tsStartParseAsyncArrowFromCallExpression;function tsParseMaybeAssign(noIn,isWithinParens){if(_base.isJSXEnabled){return tsParseMaybeAssignWithJSX(noIn,isWithinParens)}else{return tsParseMaybeAssignWithoutJSX(noIn,isWithinParens)}}__name(tsParseMaybeAssign,\"tsParseMaybeAssign\");exports.tsParseMaybeAssign=tsParseMaybeAssign;function tsParseMaybeAssignWithJSX(noIn,isWithinParens){if(!_index.match.call(void 0,_types.TokenType.lessThan)){return _expression.baseParseMaybeAssign.call(void 0,noIn,isWithinParens)}const snapshot=_base.state.snapshot();let wasArrow=_expression.baseParseMaybeAssign.call(void 0,noIn,isWithinParens);if(_base.state.error){_base.state.restoreFromSnapshot(snapshot)}else{return wasArrow}_base.state.type=_types.TokenType.typeParameterStart;tsParseTypeParameters();wasArrow=_expression.baseParseMaybeAssign.call(void 0,noIn,isWithinParens);if(!wasArrow){_util.unexpected.call(void 0)}return wasArrow}__name(tsParseMaybeAssignWithJSX,\"tsParseMaybeAssignWithJSX\");exports.tsParseMaybeAssignWithJSX=tsParseMaybeAssignWithJSX;function tsParseMaybeAssignWithoutJSX(noIn,isWithinParens){if(!_index.match.call(void 0,_types.TokenType.lessThan)){return _expression.baseParseMaybeAssign.call(void 0,noIn,isWithinParens)}const snapshot=_base.state.snapshot();tsParseTypeParameters();const wasArrow=_expression.baseParseMaybeAssign.call(void 0,noIn,isWithinParens);if(!wasArrow){_util.unexpected.call(void 0)}if(_base.state.error){_base.state.restoreFromSnapshot(snapshot)}else{return wasArrow}return _expression.baseParseMaybeAssign.call(void 0,noIn,isWithinParens)}__name(tsParseMaybeAssignWithoutJSX,\"tsParseMaybeAssignWithoutJSX\");exports.tsParseMaybeAssignWithoutJSX=tsParseMaybeAssignWithoutJSX;function tsParseArrow(){if(_index.match.call(void 0,_types.TokenType.colon)){const snapshot=_base.state.snapshot();tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);if(_util.canInsertSemicolon.call(void 0))_util.unexpected.call(void 0);if(!_index.match.call(void 0,_types.TokenType.arrow))_util.unexpected.call(void 0);if(_base.state.error){_base.state.restoreFromSnapshot(snapshot)}}return _index.eat.call(void 0,_types.TokenType.arrow)}__name(tsParseArrow,\"tsParseArrow\");exports.tsParseArrow=tsParseArrow;function tsParseAssignableListItemTypes(){const oldIsType=_index.pushTypeContext.call(void 0,0);_index.eat.call(void 0,_types.TokenType.question);tsTryParseTypeAnnotation();_index.popTypeContext.call(void 0,oldIsType)}__name(tsParseAssignableListItemTypes,\"tsParseAssignableListItemTypes\");exports.tsParseAssignableListItemTypes=tsParseAssignableListItemTypes;function tsParseMaybeDecoratorArguments(){if(_index.match.call(void 0,_types.TokenType.lessThan)||_index.match.call(void 0,_types.TokenType.bitShiftL)){tsParseTypeArgumentsWithPossibleBitshift()}_statement.baseParseMaybeDecoratorArguments.call(void 0)}__name(tsParseMaybeDecoratorArguments,\"tsParseMaybeDecoratorArguments\");exports.tsParseMaybeDecoratorArguments=tsParseMaybeDecoratorArguments;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["FunctionType"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/parser/plugins/typescript.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});\n\n\n\n\n\n\n\n\n\n\nvar _index = require('../tokenizer/index');\nvar _keywords = require('../tokenizer/keywords');\nvar _types = require('../tokenizer/types');\nvar _base = require('../traverser/base');\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar _expression = require('../traverser/expression');\nvar _lval = require('../traverser/lval');\n\n\n\n\n\n\n\n\nvar _statement = require('../traverser/statement');\n\n\n\n\n\n\n\n\n\n\n\nvar _util = require('../traverser/util');\nvar _jsx = require('./jsx');\n\nfunction tsIsIdentifier() {\n  // TODO: actually a bit more complex in TypeScript, but shouldn't matter.\n  // See https://github.com/Microsoft/TypeScript/issues/15008\n  return _index.match.call(void 0, _types.TokenType.name);\n}\n\nfunction isLiteralPropertyName() {\n  return (\n    _index.match.call(void 0, _types.TokenType.name) ||\n    Boolean(_base.state.type & _types.TokenType.IS_KEYWORD) ||\n    _index.match.call(void 0, _types.TokenType.string) ||\n    _index.match.call(void 0, _types.TokenType.num) ||\n    _index.match.call(void 0, _types.TokenType.bigint) ||\n    _index.match.call(void 0, _types.TokenType.decimal)\n  );\n}\n\nfunction tsNextTokenCanFollowModifier() {\n  // Note: TypeScript's implementation is much more complicated because\n  // more things are considered modifiers there.\n  // This implementation only handles modifiers not handled by babylon itself. And \"static\".\n  // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...\n  const snapshot = _base.state.snapshot();\n\n  _index.next.call(void 0, );\n  const canFollowModifier =\n    (_index.match.call(void 0, _types.TokenType.bracketL) ||\n      _index.match.call(void 0, _types.TokenType.braceL) ||\n      _index.match.call(void 0, _types.TokenType.star) ||\n      _index.match.call(void 0, _types.TokenType.ellipsis) ||\n      _index.match.call(void 0, _types.TokenType.hash) ||\n      isLiteralPropertyName()) &&\n    !_util.hasPrecedingLineBreak.call(void 0, );\n\n  if (canFollowModifier) {\n    return true;\n  } else {\n    _base.state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n}\n\n function tsParseModifiers(allowedModifiers) {\n  while (true) {\n    const modifier = tsParseModifier(allowedModifiers);\n    if (modifier === null) {\n      break;\n    }\n  }\n} exports.tsParseModifiers = tsParseModifiers;\n\n/** Parses a modifier matching one the given modifier names. */\n function tsParseModifier(\n  allowedModifiers,\n) {\n  if (!_index.match.call(void 0, _types.TokenType.name)) {\n    return null;\n  }\n\n  const modifier = _base.state.contextualKeyword;\n  if (allowedModifiers.indexOf(modifier) !== -1 && tsNextTokenCanFollowModifier()) {\n    switch (modifier) {\n      case _keywords.ContextualKeyword._readonly:\n        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._readonly;\n        break;\n      case _keywords.ContextualKeyword._abstract:\n        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._abstract;\n        break;\n      case _keywords.ContextualKeyword._static:\n        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._static;\n        break;\n      case _keywords.ContextualKeyword._public:\n        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._public;\n        break;\n      case _keywords.ContextualKeyword._private:\n        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._private;\n        break;\n      case _keywords.ContextualKeyword._protected:\n        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._protected;\n        break;\n      case _keywords.ContextualKeyword._override:\n        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._override;\n        break;\n      case _keywords.ContextualKeyword._declare:\n        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._declare;\n        break;\n      default:\n        break;\n    }\n    return modifier;\n  }\n  return null;\n} exports.tsParseModifier = tsParseModifier;\n\nfunction tsParseEntityName() {\n  _expression.parseIdentifier.call(void 0, );\n  while (_index.eat.call(void 0, _types.TokenType.dot)) {\n    _expression.parseIdentifier.call(void 0, );\n  }\n}\n\nfunction tsParseTypeReference() {\n  tsParseEntityName();\n  if (!_util.hasPrecedingLineBreak.call(void 0, ) && _index.match.call(void 0, _types.TokenType.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseThisTypePredicate() {\n  _index.next.call(void 0, );\n  tsParseTypeAnnotation();\n}\n\nfunction tsParseThisTypeNode() {\n  _index.next.call(void 0, );\n}\n\nfunction tsParseTypeQuery() {\n  _util.expect.call(void 0, _types.TokenType._typeof);\n  if (_index.match.call(void 0, _types.TokenType._import)) {\n    tsParseImportType();\n  } else {\n    tsParseEntityName();\n  }\n  if (!_util.hasPrecedingLineBreak.call(void 0, ) && _index.match.call(void 0, _types.TokenType.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseImportType() {\n  _util.expect.call(void 0, _types.TokenType._import);\n  _util.expect.call(void 0, _types.TokenType.parenL);\n  _util.expect.call(void 0, _types.TokenType.string);\n  _util.expect.call(void 0, _types.TokenType.parenR);\n  if (_index.eat.call(void 0, _types.TokenType.dot)) {\n    tsParseEntityName();\n  }\n  if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseTypeParameter() {\n  _index.eat.call(void 0, _types.TokenType._const);\n  const hadIn = _index.eat.call(void 0, _types.TokenType._in);\n  const hadOut = _util.eatContextual.call(void 0, _keywords.ContextualKeyword._out);\n  _index.eat.call(void 0, _types.TokenType._const);\n  if ((hadIn || hadOut) && !_index.match.call(void 0, _types.TokenType.name)) {\n    // The \"in\" or \"out\" keyword must have actually been the type parameter\n    // name, so set it as the name.\n    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;\n  } else {\n    _expression.parseIdentifier.call(void 0, );\n  }\n\n  if (_index.eat.call(void 0, _types.TokenType._extends)) {\n    tsParseType();\n  }\n  if (_index.eat.call(void 0, _types.TokenType.eq)) {\n    tsParseType();\n  }\n}\n\n function tsTryParseTypeParameters() {\n  if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n    tsParseTypeParameters();\n  }\n} exports.tsTryParseTypeParameters = tsTryParseTypeParameters;\n\nfunction tsParseTypeParameters() {\n  const oldIsType = _index.pushTypeContext.call(void 0, 0);\n  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.typeParameterStart)) {\n    _index.next.call(void 0, );\n  } else {\n    _util.unexpected.call(void 0, );\n  }\n\n  while (!_index.eat.call(void 0, _types.TokenType.greaterThan) && !_base.state.error) {\n    tsParseTypeParameter();\n    _index.eat.call(void 0, _types.TokenType.comma);\n  }\n  _index.popTypeContext.call(void 0, oldIsType);\n}\n\n// Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,\n// but here it's always false, because this is only used for types.\nfunction tsFillSignature(returnToken) {\n  // Arrow fns *must* have return token (`=>`). Normal functions can omit it.\n  const returnTokenRequired = returnToken === _types.TokenType.arrow;\n  tsTryParseTypeParameters();\n  _util.expect.call(void 0, _types.TokenType.parenL);\n  // Create a scope even though we're doing type parsing so we don't accidentally\n  // treat params as top-level bindings.\n  _base.state.scopeDepth++;\n  tsParseBindingListForSignature(false /* isBlockScope */);\n  _base.state.scopeDepth--;\n  if (returnTokenRequired) {\n    tsParseTypeOrTypePredicateAnnotation(returnToken);\n  } else if (_index.match.call(void 0, returnToken)) {\n    tsParseTypeOrTypePredicateAnnotation(returnToken);\n  }\n}\n\nfunction tsParseBindingListForSignature(isBlockScope) {\n  _lval.parseBindingList.call(void 0, _types.TokenType.parenR, isBlockScope);\n}\n\nfunction tsParseTypeMemberSemicolon() {\n  if (!_index.eat.call(void 0, _types.TokenType.comma)) {\n    _util.semicolon.call(void 0, );\n  }\n}\n\nfunction tsParseSignatureMember() {\n  tsFillSignature(_types.TokenType.colon);\n  tsParseTypeMemberSemicolon();\n}\n\nfunction tsIsUnambiguouslyIndexSignature() {\n  const snapshot = _base.state.snapshot();\n  _index.next.call(void 0, ); // Skip '{'\n  const isIndexSignature = _index.eat.call(void 0, _types.TokenType.name) && _index.match.call(void 0, _types.TokenType.colon);\n  _base.state.restoreFromSnapshot(snapshot);\n  return isIndexSignature;\n}\n\nfunction tsTryParseIndexSignature() {\n  if (!(_index.match.call(void 0, _types.TokenType.bracketL) && tsIsUnambiguouslyIndexSignature())) {\n    return false;\n  }\n\n  const oldIsType = _index.pushTypeContext.call(void 0, 0);\n\n  _util.expect.call(void 0, _types.TokenType.bracketL);\n  _expression.parseIdentifier.call(void 0, );\n  tsParseTypeAnnotation();\n  _util.expect.call(void 0, _types.TokenType.bracketR);\n\n  tsTryParseTypeAnnotation();\n  tsParseTypeMemberSemicolon();\n\n  _index.popTypeContext.call(void 0, oldIsType);\n  return true;\n}\n\nfunction tsParsePropertyOrMethodSignature(isReadonly) {\n  _index.eat.call(void 0, _types.TokenType.question);\n\n  if (!isReadonly && (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan))) {\n    tsFillSignature(_types.TokenType.colon);\n    tsParseTypeMemberSemicolon();\n  } else {\n    tsTryParseTypeAnnotation();\n    tsParseTypeMemberSemicolon();\n  }\n}\n\nfunction tsParseTypeMember() {\n  if (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan)) {\n    // call signature\n    tsParseSignatureMember();\n    return;\n  }\n  if (_index.match.call(void 0, _types.TokenType._new)) {\n    _index.next.call(void 0, );\n    if (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan)) {\n      // constructor signature\n      tsParseSignatureMember();\n    } else {\n      tsParsePropertyOrMethodSignature(false);\n    }\n    return;\n  }\n  const readonly = !!tsParseModifier([_keywords.ContextualKeyword._readonly]);\n\n  const found = tsTryParseIndexSignature();\n  if (found) {\n    return;\n  }\n  if (\n    (_util.isContextual.call(void 0, _keywords.ContextualKeyword._get) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._set)) &&\n    tsNextTokenCanFollowModifier()\n  ) {\n    // This is a getter/setter on a type. The tsNextTokenCanFollowModifier\n    // function already called next() for us, so continue parsing the name.\n  }\n  _expression.parsePropertyName.call(void 0, -1 /* Types don't need context IDs. */);\n  tsParsePropertyOrMethodSignature(readonly);\n}\n\nfunction tsParseTypeLiteral() {\n  tsParseObjectTypeMembers();\n}\n\nfunction tsParseObjectTypeMembers() {\n  _util.expect.call(void 0, _types.TokenType.braceL);\n  while (!_index.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {\n    tsParseTypeMember();\n  }\n}\n\nfunction tsLookaheadIsStartOfMappedType() {\n  const snapshot = _base.state.snapshot();\n  const isStartOfMappedType = tsIsStartOfMappedType();\n  _base.state.restoreFromSnapshot(snapshot);\n  return isStartOfMappedType;\n}\n\nfunction tsIsStartOfMappedType() {\n  _index.next.call(void 0, );\n  if (_index.eat.call(void 0, _types.TokenType.plus) || _index.eat.call(void 0, _types.TokenType.minus)) {\n    return _util.isContextual.call(void 0, _keywords.ContextualKeyword._readonly);\n  }\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._readonly)) {\n    _index.next.call(void 0, );\n  }\n  if (!_index.match.call(void 0, _types.TokenType.bracketL)) {\n    return false;\n  }\n  _index.next.call(void 0, );\n  if (!tsIsIdentifier()) {\n    return false;\n  }\n  _index.next.call(void 0, );\n  return _index.match.call(void 0, _types.TokenType._in);\n}\n\nfunction tsParseMappedTypeParameter() {\n  _expression.parseIdentifier.call(void 0, );\n  _util.expect.call(void 0, _types.TokenType._in);\n  tsParseType();\n}\n\nfunction tsParseMappedType() {\n  _util.expect.call(void 0, _types.TokenType.braceL);\n  if (_index.match.call(void 0, _types.TokenType.plus) || _index.match.call(void 0, _types.TokenType.minus)) {\n    _index.next.call(void 0, );\n    _util.expectContextual.call(void 0, _keywords.ContextualKeyword._readonly);\n  } else {\n    _util.eatContextual.call(void 0, _keywords.ContextualKeyword._readonly);\n  }\n  _util.expect.call(void 0, _types.TokenType.bracketL);\n  tsParseMappedTypeParameter();\n  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as)) {\n    tsParseType();\n  }\n  _util.expect.call(void 0, _types.TokenType.bracketR);\n  if (_index.match.call(void 0, _types.TokenType.plus) || _index.match.call(void 0, _types.TokenType.minus)) {\n    _index.next.call(void 0, );\n    _util.expect.call(void 0, _types.TokenType.question);\n  } else {\n    _index.eat.call(void 0, _types.TokenType.question);\n  }\n  tsTryParseType();\n  _util.semicolon.call(void 0, );\n  _util.expect.call(void 0, _types.TokenType.braceR);\n}\n\nfunction tsParseTupleType() {\n  _util.expect.call(void 0, _types.TokenType.bracketL);\n  while (!_index.eat.call(void 0, _types.TokenType.bracketR) && !_base.state.error) {\n    // Do not validate presence of either none or only labeled elements\n    tsParseTupleElementType();\n    _index.eat.call(void 0, _types.TokenType.comma);\n  }\n}\n\nfunction tsParseTupleElementType() {\n  // parses `...TsType[]`\n  if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {\n    tsParseType();\n  } else {\n    // parses `TsType?`\n    tsParseType();\n    _index.eat.call(void 0, _types.TokenType.question);\n  }\n\n  // The type we parsed above was actually a label\n  if (_index.eat.call(void 0, _types.TokenType.colon)) {\n    // Labeled tuple types must affix the label with `...` or `?`, so no need to handle those here\n    tsParseType();\n  }\n}\n\nfunction tsParseParenthesizedType() {\n  _util.expect.call(void 0, _types.TokenType.parenL);\n  tsParseType();\n  _util.expect.call(void 0, _types.TokenType.parenR);\n}\n\nfunction tsParseTemplateLiteralType() {\n  // Finish `, read quasi\n  _index.nextTemplateToken.call(void 0, );\n  // Finish quasi, read ${\n  _index.nextTemplateToken.call(void 0, );\n  while (!_index.match.call(void 0, _types.TokenType.backQuote) && !_base.state.error) {\n    _util.expect.call(void 0, _types.TokenType.dollarBraceL);\n    tsParseType();\n    // Finish }, read quasi\n    _index.nextTemplateToken.call(void 0, );\n    // Finish quasi, read either ${ or `\n    _index.nextTemplateToken.call(void 0, );\n  }\n  _index.next.call(void 0, );\n}\n\nvar FunctionType; (function (FunctionType) {\n  const TSFunctionType = 0; FunctionType[FunctionType[\"TSFunctionType\"] = TSFunctionType] = \"TSFunctionType\";\n  const TSConstructorType = TSFunctionType + 1; FunctionType[FunctionType[\"TSConstructorType\"] = TSConstructorType] = \"TSConstructorType\";\n  const TSAbstractConstructorType = TSConstructorType + 1; FunctionType[FunctionType[\"TSAbstractConstructorType\"] = TSAbstractConstructorType] = \"TSAbstractConstructorType\";\n})(FunctionType || (FunctionType = {}));\n\nfunction tsParseFunctionOrConstructorType(type) {\n  if (type === FunctionType.TSAbstractConstructorType) {\n    _util.expectContextual.call(void 0, _keywords.ContextualKeyword._abstract);\n  }\n  if (type === FunctionType.TSConstructorType || type === FunctionType.TSAbstractConstructorType) {\n    _util.expect.call(void 0, _types.TokenType._new);\n  }\n  const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;\n  _base.state.inDisallowConditionalTypesContext = false;\n  tsFillSignature(_types.TokenType.arrow);\n  _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n}\n\nfunction tsParseNonArrayType() {\n  switch (_base.state.type) {\n    case _types.TokenType.name:\n      tsParseTypeReference();\n      return;\n    case _types.TokenType._void:\n    case _types.TokenType._null:\n      _index.next.call(void 0, );\n      return;\n    case _types.TokenType.string:\n    case _types.TokenType.num:\n    case _types.TokenType.bigint:\n    case _types.TokenType.decimal:\n    case _types.TokenType._true:\n    case _types.TokenType._false:\n      _expression.parseLiteral.call(void 0, );\n      return;\n    case _types.TokenType.minus:\n      _index.next.call(void 0, );\n      _expression.parseLiteral.call(void 0, );\n      return;\n    case _types.TokenType._this: {\n      tsParseThisTypeNode();\n      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._is) && !_util.hasPrecedingLineBreak.call(void 0, )) {\n        tsParseThisTypePredicate();\n      }\n      return;\n    }\n    case _types.TokenType._typeof:\n      tsParseTypeQuery();\n      return;\n    case _types.TokenType._import:\n      tsParseImportType();\n      return;\n    case _types.TokenType.braceL:\n      if (tsLookaheadIsStartOfMappedType()) {\n        tsParseMappedType();\n      } else {\n        tsParseTypeLiteral();\n      }\n      return;\n    case _types.TokenType.bracketL:\n      tsParseTupleType();\n      return;\n    case _types.TokenType.parenL:\n      tsParseParenthesizedType();\n      return;\n    case _types.TokenType.backQuote:\n      tsParseTemplateLiteralType();\n      return;\n    default:\n      if (_base.state.type & _types.TokenType.IS_KEYWORD) {\n        _index.next.call(void 0, );\n        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;\n        return;\n      }\n      break;\n  }\n\n  _util.unexpected.call(void 0, );\n}\n\nfunction tsParseArrayTypeOrHigher() {\n  tsParseNonArrayType();\n  while (!_util.hasPrecedingLineBreak.call(void 0, ) && _index.eat.call(void 0, _types.TokenType.bracketL)) {\n    if (!_index.eat.call(void 0, _types.TokenType.bracketR)) {\n      // If we hit ] immediately, this is an array type, otherwise it's an indexed access type.\n      tsParseType();\n      _util.expect.call(void 0, _types.TokenType.bracketR);\n    }\n  }\n}\n\nfunction tsParseInferType() {\n  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._infer);\n  _expression.parseIdentifier.call(void 0, );\n  if (_index.match.call(void 0, _types.TokenType._extends)) {\n    // Infer type constraints introduce an ambiguity about whether the \"extends\"\n    // is a constraint for this infer type or is another conditional type.\n    const snapshot = _base.state.snapshot();\n    _util.expect.call(void 0, _types.TokenType._extends);\n    const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;\n    _base.state.inDisallowConditionalTypesContext = true;\n    tsParseType();\n    _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    if (_base.state.error || (!_base.state.inDisallowConditionalTypesContext && _index.match.call(void 0, _types.TokenType.question))) {\n      _base.state.restoreFromSnapshot(snapshot);\n    }\n  }\n}\n\nfunction tsParseTypeOperatorOrHigher() {\n  if (\n    _util.isContextual.call(void 0, _keywords.ContextualKeyword._keyof) ||\n    _util.isContextual.call(void 0, _keywords.ContextualKeyword._unique) ||\n    _util.isContextual.call(void 0, _keywords.ContextualKeyword._readonly)\n  ) {\n    _index.next.call(void 0, );\n    tsParseTypeOperatorOrHigher();\n  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._infer)) {\n    tsParseInferType();\n  } else {\n    const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;\n    _base.state.inDisallowConditionalTypesContext = false;\n    tsParseArrayTypeOrHigher();\n    _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n  }\n}\n\nfunction tsParseIntersectionTypeOrHigher() {\n  _index.eat.call(void 0, _types.TokenType.bitwiseAND);\n  tsParseTypeOperatorOrHigher();\n  if (_index.match.call(void 0, _types.TokenType.bitwiseAND)) {\n    while (_index.eat.call(void 0, _types.TokenType.bitwiseAND)) {\n      tsParseTypeOperatorOrHigher();\n    }\n  }\n}\n\nfunction tsParseUnionTypeOrHigher() {\n  _index.eat.call(void 0, _types.TokenType.bitwiseOR);\n  tsParseIntersectionTypeOrHigher();\n  if (_index.match.call(void 0, _types.TokenType.bitwiseOR)) {\n    while (_index.eat.call(void 0, _types.TokenType.bitwiseOR)) {\n      tsParseIntersectionTypeOrHigher();\n    }\n  }\n}\n\nfunction tsIsStartOfFunctionType() {\n  if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n    return true;\n  }\n  return _index.match.call(void 0, _types.TokenType.parenL) && tsLookaheadIsUnambiguouslyStartOfFunctionType();\n}\n\nfunction tsSkipParameterStart() {\n  if (_index.match.call(void 0, _types.TokenType.name) || _index.match.call(void 0, _types.TokenType._this)) {\n    _index.next.call(void 0, );\n    return true;\n  }\n  // If this is a possible array/object destructure, walk to the matching bracket/brace.\n  // The next token after will tell us definitively whether this is a function param.\n  if (_index.match.call(void 0, _types.TokenType.braceL) || _index.match.call(void 0, _types.TokenType.bracketL)) {\n    let depth = 1;\n    _index.next.call(void 0, );\n    while (depth > 0 && !_base.state.error) {\n      if (_index.match.call(void 0, _types.TokenType.braceL) || _index.match.call(void 0, _types.TokenType.bracketL)) {\n        depth++;\n      } else if (_index.match.call(void 0, _types.TokenType.braceR) || _index.match.call(void 0, _types.TokenType.bracketR)) {\n        depth--;\n      }\n      _index.next.call(void 0, );\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction tsLookaheadIsUnambiguouslyStartOfFunctionType() {\n  const snapshot = _base.state.snapshot();\n  const isUnambiguouslyStartOfFunctionType = tsIsUnambiguouslyStartOfFunctionType();\n  _base.state.restoreFromSnapshot(snapshot);\n  return isUnambiguouslyStartOfFunctionType;\n}\n\nfunction tsIsUnambiguouslyStartOfFunctionType() {\n  _index.next.call(void 0, );\n  if (_index.match.call(void 0, _types.TokenType.parenR) || _index.match.call(void 0, _types.TokenType.ellipsis)) {\n    // ( )\n    // ( ...\n    return true;\n  }\n  if (tsSkipParameterStart()) {\n    if (_index.match.call(void 0, _types.TokenType.colon) || _index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.question) || _index.match.call(void 0, _types.TokenType.eq)) {\n      // ( xxx :\n      // ( xxx ,\n      // ( xxx ?\n      // ( xxx =\n      return true;\n    }\n    if (_index.match.call(void 0, _types.TokenType.parenR)) {\n      _index.next.call(void 0, );\n      if (_index.match.call(void 0, _types.TokenType.arrow)) {\n        // ( xxx ) =>\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction tsParseTypeOrTypePredicateAnnotation(returnToken) {\n  const oldIsType = _index.pushTypeContext.call(void 0, 0);\n  _util.expect.call(void 0, returnToken);\n  const finishedReturn = tsParseTypePredicateOrAssertsPrefix();\n  if (!finishedReturn) {\n    tsParseType();\n  }\n  _index.popTypeContext.call(void 0, oldIsType);\n}\n\nfunction tsTryParseTypeOrTypePredicateAnnotation() {\n  if (_index.match.call(void 0, _types.TokenType.colon)) {\n    tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);\n  }\n}\n\n function tsTryParseTypeAnnotation() {\n  if (_index.match.call(void 0, _types.TokenType.colon)) {\n    tsParseTypeAnnotation();\n  }\n} exports.tsTryParseTypeAnnotation = tsTryParseTypeAnnotation;\n\nfunction tsTryParseType() {\n  if (_index.eat.call(void 0, _types.TokenType.colon)) {\n    tsParseType();\n  }\n}\n\n/**\n * Detect a few special return syntax cases: `x is T`, `asserts x`, `asserts x is T`,\n * `asserts this is T`.\n *\n * Returns true if we parsed the return type, false if there's still a type to be parsed.\n */\nfunction tsParseTypePredicateOrAssertsPrefix() {\n  const snapshot = _base.state.snapshot();\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._asserts)) {\n    // Normally this is `asserts x is T`, but at this point, it might be `asserts is T` (a user-\n    // defined type guard on the `asserts` variable) or just a type called `asserts`.\n    _index.next.call(void 0, );\n    if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._is)) {\n      // If we see `asserts is`, then this must be of the form `asserts is T`, since\n      // `asserts is is T` isn't valid.\n      tsParseType();\n      return true;\n    } else if (tsIsIdentifier() || _index.match.call(void 0, _types.TokenType._this)) {\n      _index.next.call(void 0, );\n      if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._is)) {\n        // If we see `is`, then this is `asserts x is T`. Otherwise, it's `asserts x`.\n        tsParseType();\n      }\n      return true;\n    } else {\n      // Regular type, so bail out and start type parsing from scratch.\n      _base.state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  } else if (tsIsIdentifier() || _index.match.call(void 0, _types.TokenType._this)) {\n    // This is a regular identifier, which may or may not have \"is\" after it.\n    _index.next.call(void 0, );\n    if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._is) && !_util.hasPrecedingLineBreak.call(void 0, )) {\n      _index.next.call(void 0, );\n      tsParseType();\n      return true;\n    } else {\n      // Regular type, so bail out and start type parsing from scratch.\n      _base.state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  }\n  return false;\n}\n\n function tsParseTypeAnnotation() {\n  const oldIsType = _index.pushTypeContext.call(void 0, 0);\n  _util.expect.call(void 0, _types.TokenType.colon);\n  tsParseType();\n  _index.popTypeContext.call(void 0, oldIsType);\n} exports.tsParseTypeAnnotation = tsParseTypeAnnotation;\n\n function tsParseType() {\n  tsParseNonConditionalType();\n  if (_base.state.inDisallowConditionalTypesContext || _util.hasPrecedingLineBreak.call(void 0, ) || !_index.eat.call(void 0, _types.TokenType._extends)) {\n    return;\n  }\n  // extends type\n  const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;\n  _base.state.inDisallowConditionalTypesContext = true;\n  tsParseNonConditionalType();\n  _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n\n  _util.expect.call(void 0, _types.TokenType.question);\n  // true type\n  tsParseType();\n  _util.expect.call(void 0, _types.TokenType.colon);\n  // false type\n  tsParseType();\n} exports.tsParseType = tsParseType;\n\nfunction isAbstractConstructorSignature() {\n  return _util.isContextual.call(void 0, _keywords.ContextualKeyword._abstract) && _index.lookaheadType.call(void 0, ) === _types.TokenType._new;\n}\n\n function tsParseNonConditionalType() {\n  if (tsIsStartOfFunctionType()) {\n    tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);\n    return;\n  }\n  if (_index.match.call(void 0, _types.TokenType._new)) {\n    // As in `new () => Date`\n    tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);\n    return;\n  } else if (isAbstractConstructorSignature()) {\n    // As in `abstract new () => Date`\n    tsParseFunctionOrConstructorType(FunctionType.TSAbstractConstructorType);\n    return;\n  }\n  tsParseUnionTypeOrHigher();\n} exports.tsParseNonConditionalType = tsParseNonConditionalType;\n\n function tsParseTypeAssertion() {\n  const oldIsType = _index.pushTypeContext.call(void 0, 1);\n  tsParseType();\n  _util.expect.call(void 0, _types.TokenType.greaterThan);\n  _index.popTypeContext.call(void 0, oldIsType);\n  _expression.parseMaybeUnary.call(void 0, );\n} exports.tsParseTypeAssertion = tsParseTypeAssertion;\n\n function tsTryParseJSXTypeArgument() {\n  if (_index.eat.call(void 0, _types.TokenType.jsxTagStart)) {\n    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.typeParameterStart;\n    const oldIsType = _index.pushTypeContext.call(void 0, 1);\n    while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error) {\n      tsParseType();\n      _index.eat.call(void 0, _types.TokenType.comma);\n    }\n    // Process >, but the one after needs to be parsed JSX-style.\n    _jsx.nextJSXTagToken.call(void 0, );\n    _index.popTypeContext.call(void 0, oldIsType);\n  }\n} exports.tsTryParseJSXTypeArgument = tsTryParseJSXTypeArgument;\n\nfunction tsParseHeritageClause() {\n  while (!_index.match.call(void 0, _types.TokenType.braceL) && !_base.state.error) {\n    tsParseExpressionWithTypeArguments();\n    _index.eat.call(void 0, _types.TokenType.comma);\n  }\n}\n\nfunction tsParseExpressionWithTypeArguments() {\n  // Note: TS uses parseLeftHandSideExpressionOrHigher,\n  // then has grammar errors later if it's not an EntityName.\n  tsParseEntityName();\n  if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseInterfaceDeclaration() {\n  _lval.parseBindingIdentifier.call(void 0, false);\n  tsTryParseTypeParameters();\n  if (_index.eat.call(void 0, _types.TokenType._extends)) {\n    tsParseHeritageClause();\n  }\n  tsParseObjectTypeMembers();\n}\n\nfunction tsParseTypeAliasDeclaration() {\n  _lval.parseBindingIdentifier.call(void 0, false);\n  tsTryParseTypeParameters();\n  _util.expect.call(void 0, _types.TokenType.eq);\n  tsParseType();\n  _util.semicolon.call(void 0, );\n}\n\nfunction tsParseEnumMember() {\n  // Computed property names are grammar errors in an enum, so accept just string literal or identifier.\n  if (_index.match.call(void 0, _types.TokenType.string)) {\n    _expression.parseLiteral.call(void 0, );\n  } else {\n    _expression.parseIdentifier.call(void 0, );\n  }\n  if (_index.eat.call(void 0, _types.TokenType.eq)) {\n    const eqIndex = _base.state.tokens.length - 1;\n    _expression.parseMaybeAssign.call(void 0, );\n    _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;\n  }\n}\n\nfunction tsParseEnumDeclaration() {\n  _lval.parseBindingIdentifier.call(void 0, false);\n  _util.expect.call(void 0, _types.TokenType.braceL);\n  while (!_index.eat.call(void 0, _types.TokenType.braceR) && !_base.state.error) {\n    tsParseEnumMember();\n    _index.eat.call(void 0, _types.TokenType.comma);\n  }\n}\n\nfunction tsParseModuleBlock() {\n  _util.expect.call(void 0, _types.TokenType.braceL);\n  _statement.parseBlockBody.call(void 0, /* end */ _types.TokenType.braceR);\n}\n\nfunction tsParseModuleOrNamespaceDeclaration() {\n  _lval.parseBindingIdentifier.call(void 0, false);\n  if (_index.eat.call(void 0, _types.TokenType.dot)) {\n    tsParseModuleOrNamespaceDeclaration();\n  } else {\n    tsParseModuleBlock();\n  }\n}\n\nfunction tsParseAmbientExternalModuleDeclaration() {\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._global)) {\n    _expression.parseIdentifier.call(void 0, );\n  } else if (_index.match.call(void 0, _types.TokenType.string)) {\n    _expression.parseExprAtom.call(void 0, );\n  } else {\n    _util.unexpected.call(void 0, );\n  }\n\n  if (_index.match.call(void 0, _types.TokenType.braceL)) {\n    tsParseModuleBlock();\n  } else {\n    _util.semicolon.call(void 0, );\n  }\n}\n\n function tsParseImportEqualsDeclaration() {\n  _lval.parseImportedIdentifier.call(void 0, );\n  _util.expect.call(void 0, _types.TokenType.eq);\n  tsParseModuleReference();\n  _util.semicolon.call(void 0, );\n} exports.tsParseImportEqualsDeclaration = tsParseImportEqualsDeclaration;\n\nfunction tsIsExternalModuleReference() {\n  return _util.isContextual.call(void 0, _keywords.ContextualKeyword._require) && _index.lookaheadType.call(void 0, ) === _types.TokenType.parenL;\n}\n\nfunction tsParseModuleReference() {\n  if (tsIsExternalModuleReference()) {\n    tsParseExternalModuleReference();\n  } else {\n    tsParseEntityName();\n  }\n}\n\nfunction tsParseExternalModuleReference() {\n  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._require);\n  _util.expect.call(void 0, _types.TokenType.parenL);\n  if (!_index.match.call(void 0, _types.TokenType.string)) {\n    _util.unexpected.call(void 0, );\n  }\n  _expression.parseLiteral.call(void 0, );\n  _util.expect.call(void 0, _types.TokenType.parenR);\n}\n\n// Utilities\n\n// Returns true if a statement matched.\nfunction tsTryParseDeclare() {\n  if (_util.isLineTerminator.call(void 0, )) {\n    return false;\n  }\n  switch (_base.state.type) {\n    case _types.TokenType._function: {\n      const oldIsType = _index.pushTypeContext.call(void 0, 1);\n      _index.next.call(void 0, );\n      // We don't need to precisely get the function start here, since it's only used to mark\n      // the function as a type if it's bodiless, and it's already a type here.\n      const functionStart = _base.state.start;\n      _statement.parseFunction.call(void 0, functionStart, /* isStatement */ true);\n      _index.popTypeContext.call(void 0, oldIsType);\n      return true;\n    }\n    case _types.TokenType._class: {\n      const oldIsType = _index.pushTypeContext.call(void 0, 1);\n      _statement.parseClass.call(void 0, /* isStatement */ true, /* optionalId */ false);\n      _index.popTypeContext.call(void 0, oldIsType);\n      return true;\n    }\n    case _types.TokenType._const: {\n      if (_index.match.call(void 0, _types.TokenType._const) && _util.isLookaheadContextual.call(void 0, _keywords.ContextualKeyword._enum)) {\n        const oldIsType = _index.pushTypeContext.call(void 0, 1);\n        // `const enum = 0;` not allowed because \"enum\" is a strict mode reserved word.\n        _util.expect.call(void 0, _types.TokenType._const);\n        _util.expectContextual.call(void 0, _keywords.ContextualKeyword._enum);\n        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;\n        tsParseEnumDeclaration();\n        _index.popTypeContext.call(void 0, oldIsType);\n        return true;\n      }\n    }\n    // falls through\n    case _types.TokenType._var:\n    case _types.TokenType._let: {\n      const oldIsType = _index.pushTypeContext.call(void 0, 1);\n      _statement.parseVarStatement.call(void 0, _base.state.type !== _types.TokenType._var);\n      _index.popTypeContext.call(void 0, oldIsType);\n      return true;\n    }\n    case _types.TokenType.name: {\n      const oldIsType = _index.pushTypeContext.call(void 0, 1);\n      const contextualKeyword = _base.state.contextualKeyword;\n      let matched = false;\n      if (contextualKeyword === _keywords.ContextualKeyword._global) {\n        tsParseAmbientExternalModuleDeclaration();\n        matched = true;\n      } else {\n        matched = tsParseDeclaration(contextualKeyword, /* isBeforeToken */ true);\n      }\n      _index.popTypeContext.call(void 0, oldIsType);\n      return matched;\n    }\n    default:\n      return false;\n  }\n}\n\n// Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.\n// Returns true if it matched a declaration.\nfunction tsTryParseExportDeclaration() {\n  return tsParseDeclaration(_base.state.contextualKeyword, /* isBeforeToken */ true);\n}\n\n// Returns true if it matched a statement.\nfunction tsParseExpressionStatement(contextualKeyword) {\n  switch (contextualKeyword) {\n    case _keywords.ContextualKeyword._declare: {\n      const declareTokenIndex = _base.state.tokens.length - 1;\n      const matched = tsTryParseDeclare();\n      if (matched) {\n        _base.state.tokens[declareTokenIndex].type = _types.TokenType._declare;\n        return true;\n      }\n      break;\n    }\n    case _keywords.ContextualKeyword._global:\n      // `global { }` (with no `declare`) may appear inside an ambient module declaration.\n      // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past \"global\".\n      if (_index.match.call(void 0, _types.TokenType.braceL)) {\n        tsParseModuleBlock();\n        return true;\n      }\n      break;\n\n    default:\n      return tsParseDeclaration(contextualKeyword, /* isBeforeToken */ false);\n  }\n  return false;\n}\n\n/**\n * Common code for parsing a declaration.\n *\n * isBeforeToken indicates that the current parser state is at the contextual\n * keyword (and that it is not yet emitted) rather than reading the token after\n * it. When isBeforeToken is true, we may be preceded by an `export` token and\n * should include that token in a type context we create, e.g. to handle\n * `export interface` or `export type`. (This is a bit of a hack and should be\n * cleaned up at some point.)\n *\n * Returns true if it matched a declaration.\n */\nfunction tsParseDeclaration(contextualKeyword, isBeforeToken) {\n  switch (contextualKeyword) {\n    case _keywords.ContextualKeyword._abstract:\n      if (tsCheckLineTerminator(isBeforeToken) && _index.match.call(void 0, _types.TokenType._class)) {\n        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._abstract;\n        _statement.parseClass.call(void 0, /* isStatement */ true, /* optionalId */ false);\n        return true;\n      }\n      break;\n\n    case _keywords.ContextualKeyword._enum:\n      if (tsCheckLineTerminator(isBeforeToken) && _index.match.call(void 0, _types.TokenType.name)) {\n        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;\n        tsParseEnumDeclaration();\n        return true;\n      }\n      break;\n\n    case _keywords.ContextualKeyword._interface:\n      if (tsCheckLineTerminator(isBeforeToken) && _index.match.call(void 0, _types.TokenType.name)) {\n        // `next` is true in \"export\" and \"declare\" contexts, so we want to remove that token\n        // as well.\n        const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);\n        tsParseInterfaceDeclaration();\n        _index.popTypeContext.call(void 0, oldIsType);\n        return true;\n      }\n      break;\n\n    case _keywords.ContextualKeyword._module:\n      if (tsCheckLineTerminator(isBeforeToken)) {\n        if (_index.match.call(void 0, _types.TokenType.string)) {\n          const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);\n          tsParseAmbientExternalModuleDeclaration();\n          _index.popTypeContext.call(void 0, oldIsType);\n          return true;\n        } else if (_index.match.call(void 0, _types.TokenType.name)) {\n          const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);\n          tsParseModuleOrNamespaceDeclaration();\n          _index.popTypeContext.call(void 0, oldIsType);\n          return true;\n        }\n      }\n      break;\n\n    case _keywords.ContextualKeyword._namespace:\n      if (tsCheckLineTerminator(isBeforeToken) && _index.match.call(void 0, _types.TokenType.name)) {\n        const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);\n        tsParseModuleOrNamespaceDeclaration();\n        _index.popTypeContext.call(void 0, oldIsType);\n        return true;\n      }\n      break;\n\n    case _keywords.ContextualKeyword._type:\n      if (tsCheckLineTerminator(isBeforeToken) && _index.match.call(void 0, _types.TokenType.name)) {\n        const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);\n        tsParseTypeAliasDeclaration();\n        _index.popTypeContext.call(void 0, oldIsType);\n        return true;\n      }\n      break;\n\n    default:\n      break;\n  }\n  return false;\n}\n\nfunction tsCheckLineTerminator(isBeforeToken) {\n  if (isBeforeToken) {\n    // Babel checks hasFollowingLineBreak here and returns false, but this\n    // doesn't actually come up, e.g. `export interface` can never be on its own\n    // line in valid code.\n    _index.next.call(void 0, );\n    return true;\n  } else {\n    return !_util.isLineTerminator.call(void 0, );\n  }\n}\n\n// Returns true if there was a generic async arrow function.\nfunction tsTryParseGenericAsyncArrowFunction() {\n  const snapshot = _base.state.snapshot();\n\n  tsParseTypeParameters();\n  _statement.parseFunctionParams.call(void 0, );\n  tsTryParseTypeOrTypePredicateAnnotation();\n  _util.expect.call(void 0, _types.TokenType.arrow);\n\n  if (_base.state.error) {\n    _base.state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n\n  _expression.parseFunctionBody.call(void 0, true);\n  return true;\n}\n\n/**\n * If necessary, hack the tokenizer state so that this bitshift was actually a\n * less-than token, then keep parsing. This should only be used in situations\n * where we restore from snapshot on error (which reverts this change) or\n * where bitshift would be illegal anyway (e.g. in a class \"extends\" clause).\n *\n * This hack is useful to handle situations like foo<<T>() => void>() where\n * there can legitimately be two open-angle-brackets in a row in TS.\n */\nfunction tsParseTypeArgumentsWithPossibleBitshift() {\n  if (_base.state.type === _types.TokenType.bitShiftL) {\n    _base.state.pos -= 1;\n    _index.finishToken.call(void 0, _types.TokenType.lessThan);\n  }\n  tsParseTypeArguments();\n}\n\nfunction tsParseTypeArguments() {\n  const oldIsType = _index.pushTypeContext.call(void 0, 0);\n  _util.expect.call(void 0, _types.TokenType.lessThan);\n  while (!_index.eat.call(void 0, _types.TokenType.greaterThan) && !_base.state.error) {\n    tsParseType();\n    _index.eat.call(void 0, _types.TokenType.comma);\n  }\n  _index.popTypeContext.call(void 0, oldIsType);\n}\n\n function tsIsDeclarationStart() {\n  if (_index.match.call(void 0, _types.TokenType.name)) {\n    switch (_base.state.contextualKeyword) {\n      case _keywords.ContextualKeyword._abstract:\n      case _keywords.ContextualKeyword._declare:\n      case _keywords.ContextualKeyword._enum:\n      case _keywords.ContextualKeyword._interface:\n      case _keywords.ContextualKeyword._module:\n      case _keywords.ContextualKeyword._namespace:\n      case _keywords.ContextualKeyword._type:\n        return true;\n      default:\n        break;\n    }\n  }\n\n  return false;\n} exports.tsIsDeclarationStart = tsIsDeclarationStart;\n\n// ======================================================\n// OVERRIDES\n// ======================================================\n\n function tsParseFunctionBodyAndFinish(functionStart, funcContextId) {\n  // For arrow functions, `parseArrow` handles the return type itself.\n  if (_index.match.call(void 0, _types.TokenType.colon)) {\n    tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);\n  }\n\n  // The original code checked the node type to make sure this function type allows a missing\n  // body, but we skip that to avoid sending around the node type. We instead just use the\n  // allowExpressionBody boolean to make sure it's not an arrow function.\n  if (!_index.match.call(void 0, _types.TokenType.braceL) && _util.isLineTerminator.call(void 0, )) {\n    // Retroactively mark the function declaration as a type.\n    let i = _base.state.tokens.length - 1;\n    while (\n      i >= 0 &&\n      (_base.state.tokens[i].start >= functionStart ||\n        _base.state.tokens[i].type === _types.TokenType._default ||\n        _base.state.tokens[i].type === _types.TokenType._export)\n    ) {\n      _base.state.tokens[i].isType = true;\n      i--;\n    }\n    return;\n  }\n\n  _expression.parseFunctionBody.call(void 0, false, funcContextId);\n} exports.tsParseFunctionBodyAndFinish = tsParseFunctionBodyAndFinish;\n\n function tsParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (!_util.hasPrecedingLineBreak.call(void 0, ) && _index.eat.call(void 0, _types.TokenType.bang)) {\n    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.nonNullAssertion;\n    return;\n  }\n\n  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.bitShiftL)) {\n    // There are number of things we are going to \"maybe\" parse, like type arguments on\n    // tagged template expressions. If any of them fail, walk it back and continue.\n    const snapshot = _base.state.snapshot();\n\n    if (!noCalls && _expression.atPossibleAsync.call(void 0, )) {\n      // Almost certainly this is a generic async function `async <T>() => ...\n      // But it might be a call with a type argument `async<T>();`\n      const asyncArrowFn = tsTryParseGenericAsyncArrowFunction();\n      if (asyncArrowFn) {\n        return;\n      }\n    }\n    tsParseTypeArgumentsWithPossibleBitshift();\n    if (!noCalls && _index.eat.call(void 0, _types.TokenType.parenL)) {\n      // With f<T>(), the subscriptStartIndex marker is on the ( token.\n      _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      _expression.parseCallExpressionArguments.call(void 0, );\n    } else if (_index.match.call(void 0, _types.TokenType.backQuote)) {\n      // Tagged template with a type argument.\n      _expression.parseTemplate.call(void 0, );\n    } else if (\n      // The remaining possible case is an instantiation expression, e.g.\n      // Array<number> . Check for a few cases that would disqualify it and\n      // cause us to bail out.\n      // a<b>>c is not (a<b>)>c, but a<(b>>c)\n      _base.state.type === _types.TokenType.greaterThan ||\n      // a<b>c is (a<b)>c\n      (_base.state.type !== _types.TokenType.parenL &&\n        Boolean(_base.state.type & _types.TokenType.IS_EXPRESSION_START) &&\n        !_util.hasPrecedingLineBreak.call(void 0, ))\n    ) {\n      // Bail out. We have something like a<b>c, which is not an expression with\n      // type arguments but an (a < b) > c comparison.\n      _util.unexpected.call(void 0, );\n    }\n\n    if (_base.state.error) {\n      _base.state.restoreFromSnapshot(snapshot);\n    } else {\n      return;\n    }\n  } else if (!noCalls && _index.match.call(void 0, _types.TokenType.questionDot) && _index.lookaheadType.call(void 0, ) === _types.TokenType.lessThan) {\n    // If we see f?.<, then this must be an optional call with a type argument.\n    _index.next.call(void 0, );\n    _base.state.tokens[startTokenIndex].isOptionalChainStart = true;\n    // With f?.<T>(), the subscriptStartIndex marker is on the ?. token.\n    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n    tsParseTypeArguments();\n    _util.expect.call(void 0, _types.TokenType.parenL);\n    _expression.parseCallExpressionArguments.call(void 0, );\n  }\n  _expression.baseParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);\n} exports.tsParseSubscript = tsParseSubscript;\n\n function tsTryParseExport() {\n  if (_index.eat.call(void 0, _types.TokenType._import)) {\n    // One of these cases:\n    // export import A = B;\n    // export import type A = require(\"A\");\n    if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type) && _index.lookaheadType.call(void 0, ) !== _types.TokenType.eq) {\n      // Eat a `type` token, unless it's actually an identifier name.\n      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);\n    }\n    tsParseImportEqualsDeclaration();\n    return true;\n  } else if (_index.eat.call(void 0, _types.TokenType.eq)) {\n    // `export = x;`\n    _expression.parseExpression.call(void 0, );\n    _util.semicolon.call(void 0, );\n    return true;\n  } else if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as)) {\n    // `export as namespace A;`\n    // See `parseNamespaceExportDeclaration` in TypeScript's own parser\n    _util.expectContextual.call(void 0, _keywords.ContextualKeyword._namespace);\n    _expression.parseIdentifier.call(void 0, );\n    _util.semicolon.call(void 0, );\n    return true;\n  } else {\n    if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {\n      const nextType = _index.lookaheadType.call(void 0, );\n      // export type {foo} from 'a';\n      // export type * from 'a';'\n      // export type * as ns from 'a';'\n      if (nextType === _types.TokenType.braceL || nextType === _types.TokenType.star) {\n        _index.next.call(void 0, );\n      }\n    }\n    return false;\n  }\n} exports.tsTryParseExport = tsTryParseExport;\n\n/**\n * Parse a TS import specifier, which may be prefixed with \"type\" and may be of\n * the form `foo as bar`.\n *\n * The number of identifier-like tokens we see happens to be enough to uniquely\n * identify the form, so simply count the number of identifiers rather than\n * matching the words `type` or `as`. This is particularly important because\n * `type` and `as` could each actually be plain identifiers rather than\n * keywords.\n */\n function tsParseImportSpecifier() {\n  _expression.parseIdentifier.call(void 0, );\n  if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {\n    // import {foo}\n    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;\n    return;\n  }\n  _expression.parseIdentifier.call(void 0, );\n  if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {\n    // import {type foo}\n    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;\n    _base.state.tokens[_base.state.tokens.length - 2].isType = true;\n    _base.state.tokens[_base.state.tokens.length - 1].isType = true;\n    return;\n  }\n  _expression.parseIdentifier.call(void 0, );\n  if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {\n    // import {foo as bar}\n    _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ImportAccess;\n    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;\n    return;\n  }\n  _expression.parseIdentifier.call(void 0, );\n  // import {type foo as bar}\n  _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ImportAccess;\n  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;\n  _base.state.tokens[_base.state.tokens.length - 4].isType = true;\n  _base.state.tokens[_base.state.tokens.length - 3].isType = true;\n  _base.state.tokens[_base.state.tokens.length - 2].isType = true;\n  _base.state.tokens[_base.state.tokens.length - 1].isType = true;\n} exports.tsParseImportSpecifier = tsParseImportSpecifier;\n\n/**\n * Just like named import specifiers, export specifiers can have from 1 to 4\n * tokens, inclusive, and the number of tokens determines the role of each token.\n */\n function tsParseExportSpecifier() {\n  _expression.parseIdentifier.call(void 0, );\n  if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {\n    // export {foo}\n    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ExportAccess;\n    return;\n  }\n  _expression.parseIdentifier.call(void 0, );\n  if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {\n    // export {type foo}\n    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ExportAccess;\n    _base.state.tokens[_base.state.tokens.length - 2].isType = true;\n    _base.state.tokens[_base.state.tokens.length - 1].isType = true;\n    return;\n  }\n  _expression.parseIdentifier.call(void 0, );\n  if (_index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.braceR)) {\n    // export {foo as bar}\n    _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ExportAccess;\n    return;\n  }\n  _expression.parseIdentifier.call(void 0, );\n  // export {type foo as bar}\n  _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ExportAccess;\n  _base.state.tokens[_base.state.tokens.length - 4].isType = true;\n  _base.state.tokens[_base.state.tokens.length - 3].isType = true;\n  _base.state.tokens[_base.state.tokens.length - 2].isType = true;\n  _base.state.tokens[_base.state.tokens.length - 1].isType = true;\n} exports.tsParseExportSpecifier = tsParseExportSpecifier;\n\n function tsTryParseExportDefaultExpression() {\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._abstract) && _index.lookaheadType.call(void 0, ) === _types.TokenType._class) {\n    _base.state.type = _types.TokenType._abstract;\n    _index.next.call(void 0, ); // Skip \"abstract\"\n    _statement.parseClass.call(void 0, true, true);\n    return true;\n  }\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {\n    // Make sure \"export default\" are considered type tokens so the whole thing is removed.\n    const oldIsType = _index.pushTypeContext.call(void 0, 2);\n    tsParseDeclaration(_keywords.ContextualKeyword._interface, true);\n    _index.popTypeContext.call(void 0, oldIsType);\n    return true;\n  }\n  return false;\n} exports.tsTryParseExportDefaultExpression = tsTryParseExportDefaultExpression;\n\n function tsTryParseStatementContent() {\n  if (_base.state.type === _types.TokenType._const) {\n    const ahead = _index.lookaheadTypeAndKeyword.call(void 0, );\n    if (ahead.type === _types.TokenType.name && ahead.contextualKeyword === _keywords.ContextualKeyword._enum) {\n      _util.expect.call(void 0, _types.TokenType._const);\n      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._enum);\n      _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;\n      tsParseEnumDeclaration();\n      return true;\n    }\n  }\n  return false;\n} exports.tsTryParseStatementContent = tsTryParseStatementContent;\n\n function tsTryParseClassMemberWithIsStatic(isStatic) {\n  const memberStartIndexAfterStatic = _base.state.tokens.length;\n  tsParseModifiers([\n    _keywords.ContextualKeyword._abstract,\n    _keywords.ContextualKeyword._readonly,\n    _keywords.ContextualKeyword._declare,\n    _keywords.ContextualKeyword._static,\n    _keywords.ContextualKeyword._override,\n  ]);\n\n  const modifiersEndIndex = _base.state.tokens.length;\n  const found = tsTryParseIndexSignature();\n  if (found) {\n    // Index signatures are type declarations, so set the modifier tokens as\n    // type tokens. Most tokens could be assumed to be type tokens, but `static`\n    // is ambiguous unless we set it explicitly here.\n    const memberStartIndex = isStatic\n      ? memberStartIndexAfterStatic - 1\n      : memberStartIndexAfterStatic;\n    for (let i = memberStartIndex; i < modifiersEndIndex; i++) {\n      _base.state.tokens[i].isType = true;\n    }\n    return true;\n  }\n  return false;\n} exports.tsTryParseClassMemberWithIsStatic = tsTryParseClassMemberWithIsStatic;\n\n// Note: The reason we do this in `parseIdentifierStatement` and not `parseStatement`\n// is that e.g. `type()` is valid JS, so we must try parsing that first.\n// If it's really a type, we will parse `type` as the statement, and can correct it here\n// by parsing the rest.\n function tsParseIdentifierStatement(contextualKeyword) {\n  const matched = tsParseExpressionStatement(contextualKeyword);\n  if (!matched) {\n    _util.semicolon.call(void 0, );\n  }\n} exports.tsParseIdentifierStatement = tsParseIdentifierStatement;\n\n function tsParseExportDeclaration() {\n  // \"export declare\" is equivalent to just \"export\".\n  const isDeclare = _util.eatContextual.call(void 0, _keywords.ContextualKeyword._declare);\n  if (isDeclare) {\n    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._declare;\n  }\n\n  let matchedDeclaration = false;\n  if (_index.match.call(void 0, _types.TokenType.name)) {\n    if (isDeclare) {\n      const oldIsType = _index.pushTypeContext.call(void 0, 2);\n      matchedDeclaration = tsTryParseExportDeclaration();\n      _index.popTypeContext.call(void 0, oldIsType);\n    } else {\n      matchedDeclaration = tsTryParseExportDeclaration();\n    }\n  }\n  if (!matchedDeclaration) {\n    if (isDeclare) {\n      const oldIsType = _index.pushTypeContext.call(void 0, 2);\n      _statement.parseStatement.call(void 0, true);\n      _index.popTypeContext.call(void 0, oldIsType);\n    } else {\n      _statement.parseStatement.call(void 0, true);\n    }\n  }\n} exports.tsParseExportDeclaration = tsParseExportDeclaration;\n\n function tsAfterParseClassSuper(hasSuper) {\n  if (hasSuper && (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.bitShiftL))) {\n    tsParseTypeArgumentsWithPossibleBitshift();\n  }\n  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._implements)) {\n    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._implements;\n    const oldIsType = _index.pushTypeContext.call(void 0, 1);\n    tsParseHeritageClause();\n    _index.popTypeContext.call(void 0, oldIsType);\n  }\n} exports.tsAfterParseClassSuper = tsAfterParseClassSuper;\n\n function tsStartParseObjPropValue() {\n  tsTryParseTypeParameters();\n} exports.tsStartParseObjPropValue = tsStartParseObjPropValue;\n\n function tsStartParseFunctionParams() {\n  tsTryParseTypeParameters();\n} exports.tsStartParseFunctionParams = tsStartParseFunctionParams;\n\n// `let x: number;`\n function tsAfterParseVarHead() {\n  const oldIsType = _index.pushTypeContext.call(void 0, 0);\n  if (!_util.hasPrecedingLineBreak.call(void 0, )) {\n    _index.eat.call(void 0, _types.TokenType.bang);\n  }\n  tsTryParseTypeAnnotation();\n  _index.popTypeContext.call(void 0, oldIsType);\n} exports.tsAfterParseVarHead = tsAfterParseVarHead;\n\n// parse the return type of an async arrow function - let foo = (async (): number => {});\n function tsStartParseAsyncArrowFromCallExpression() {\n  if (_index.match.call(void 0, _types.TokenType.colon)) {\n    tsParseTypeAnnotation();\n  }\n} exports.tsStartParseAsyncArrowFromCallExpression = tsStartParseAsyncArrowFromCallExpression;\n\n// Returns true if the expression was an arrow function.\n function tsParseMaybeAssign(noIn, isWithinParens) {\n  // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.\n  if (_base.isJSXEnabled) {\n    return tsParseMaybeAssignWithJSX(noIn, isWithinParens);\n  } else {\n    return tsParseMaybeAssignWithoutJSX(noIn, isWithinParens);\n  }\n} exports.tsParseMaybeAssign = tsParseMaybeAssign;\n\n function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {\n  if (!_index.match.call(void 0, _types.TokenType.lessThan)) {\n    return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);\n  }\n\n  // Prefer to parse JSX if possible. But may be an arrow fn.\n  const snapshot = _base.state.snapshot();\n  let wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);\n  if (_base.state.error) {\n    _base.state.restoreFromSnapshot(snapshot);\n  } else {\n    return wasArrow;\n  }\n\n  // Otherwise, try as type-parameterized arrow function.\n  _base.state.type = _types.TokenType.typeParameterStart;\n  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n  tsParseTypeParameters();\n  wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);\n  if (!wasArrow) {\n    _util.unexpected.call(void 0, );\n  }\n\n  return wasArrow;\n} exports.tsParseMaybeAssignWithJSX = tsParseMaybeAssignWithJSX;\n\n function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {\n  if (!_index.match.call(void 0, _types.TokenType.lessThan)) {\n    return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);\n  }\n\n  const snapshot = _base.state.snapshot();\n  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n  tsParseTypeParameters();\n  const wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);\n  if (!wasArrow) {\n    _util.unexpected.call(void 0, );\n  }\n  if (_base.state.error) {\n    _base.state.restoreFromSnapshot(snapshot);\n  } else {\n    return wasArrow;\n  }\n\n  // Try parsing a type cast instead of an arrow function.\n  // This will start with a type assertion (via parseMaybeUnary).\n  // But don't directly call `tsParseTypeAssertion` because we want to handle any binary after it.\n  return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);\n} exports.tsParseMaybeAssignWithoutJSX = tsParseMaybeAssignWithoutJSX;\n\n function tsParseArrow() {\n  if (_index.match.call(void 0, _types.TokenType.colon)) {\n    // This is different from how the TS parser does it.\n    // TS uses lookahead. Babylon parses it as a parenthesized expression and converts.\n    const snapshot = _base.state.snapshot();\n\n    tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);\n    if (_util.canInsertSemicolon.call(void 0, )) _util.unexpected.call(void 0, );\n    if (!_index.match.call(void 0, _types.TokenType.arrow)) _util.unexpected.call(void 0, );\n\n    if (_base.state.error) {\n      _base.state.restoreFromSnapshot(snapshot);\n    }\n  }\n  return _index.eat.call(void 0, _types.TokenType.arrow);\n} exports.tsParseArrow = tsParseArrow;\n\n// Allow type annotations inside of a parameter list.\n function tsParseAssignableListItemTypes() {\n  const oldIsType = _index.pushTypeContext.call(void 0, 0);\n  _index.eat.call(void 0, _types.TokenType.question);\n  tsTryParseTypeAnnotation();\n  _index.popTypeContext.call(void 0, oldIsType);\n} exports.tsParseAssignableListItemTypes = tsParseAssignableListItemTypes;\n\n function tsParseMaybeDecoratorArguments() {\n  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.bitShiftL)) {\n    tsParseTypeArgumentsWithPossibleBitshift();\n  }\n  _statement.baseParseMaybeDecoratorArguments.call(void 0, );\n} exports.tsParseMaybeDecoratorArguments = tsParseMaybeDecoratorArguments;\n"]}}