{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _index=require(\"../tokenizer/index\");var _keywords=require(\"../tokenizer/keywords\");var _types=require(\"../tokenizer/types\");var _base=require(\"../traverser/base\");var _expression=require(\"../traverser/expression\");var _statement=require(\"../traverser/statement\");var _util=require(\"../traverser/util\");function isMaybeDefaultImport(lookahead){return(lookahead.type===_types.TokenType.name||!!(lookahead.type&_types.TokenType.IS_KEYWORD))&&lookahead.contextualKeyword!==_keywords.ContextualKeyword._from}__name(isMaybeDefaultImport,\"isMaybeDefaultImport\");function flowParseTypeInitialiser(tok){const oldIsType=_index.pushTypeContext.call(void 0,0);_util.expect.call(void 0,tok||_types.TokenType.colon);flowParseType();_index.popTypeContext.call(void 0,oldIsType)}__name(flowParseTypeInitialiser,\"flowParseTypeInitialiser\");function flowParsePredicate(){_util.expect.call(void 0,_types.TokenType.modulo);_util.expectContextual.call(void 0,_keywords.ContextualKeyword._checks);if(_index.eat.call(void 0,_types.TokenType.parenL)){_expression.parseExpression.call(void 0);_util.expect.call(void 0,_types.TokenType.parenR)}}__name(flowParsePredicate,\"flowParsePredicate\");function flowParseTypeAndPredicateInitialiser(){const oldIsType=_index.pushTypeContext.call(void 0,0);_util.expect.call(void 0,_types.TokenType.colon);if(_index.match.call(void 0,_types.TokenType.modulo)){flowParsePredicate()}else{flowParseType();if(_index.match.call(void 0,_types.TokenType.modulo)){flowParsePredicate()}}_index.popTypeContext.call(void 0,oldIsType)}__name(flowParseTypeAndPredicateInitialiser,\"flowParseTypeAndPredicateInitialiser\");function flowParseDeclareClass(){_index.next.call(void 0);flowParseInterfaceish(true)}__name(flowParseDeclareClass,\"flowParseDeclareClass\");function flowParseDeclareFunction(){_index.next.call(void 0);_expression.parseIdentifier.call(void 0);if(_index.match.call(void 0,_types.TokenType.lessThan)){flowParseTypeParameterDeclaration()}_util.expect.call(void 0,_types.TokenType.parenL);flowParseFunctionTypeParams();_util.expect.call(void 0,_types.TokenType.parenR);flowParseTypeAndPredicateInitialiser();_util.semicolon.call(void 0)}__name(flowParseDeclareFunction,\"flowParseDeclareFunction\");function flowParseDeclare(){if(_index.match.call(void 0,_types.TokenType._class)){flowParseDeclareClass()}else if(_index.match.call(void 0,_types.TokenType._function)){flowParseDeclareFunction()}else if(_index.match.call(void 0,_types.TokenType._var)){flowParseDeclareVariable()}else if(_util.eatContextual.call(void 0,_keywords.ContextualKeyword._module)){if(_index.eat.call(void 0,_types.TokenType.dot)){flowParseDeclareModuleExports()}else{flowParseDeclareModule()}}else if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._type)){flowParseDeclareTypeAlias()}else if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._opaque)){flowParseDeclareOpaqueType()}else if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._interface)){flowParseDeclareInterface()}else if(_index.match.call(void 0,_types.TokenType._export)){flowParseDeclareExportDeclaration()}else{_util.unexpected.call(void 0)}}__name(flowParseDeclare,\"flowParseDeclare\");function flowParseDeclareVariable(){_index.next.call(void 0);flowParseTypeAnnotatableIdentifier();_util.semicolon.call(void 0)}__name(flowParseDeclareVariable,\"flowParseDeclareVariable\");function flowParseDeclareModule(){if(_index.match.call(void 0,_types.TokenType.string)){_expression.parseExprAtom.call(void 0)}else{_expression.parseIdentifier.call(void 0)}_util.expect.call(void 0,_types.TokenType.braceL);while(!_index.match.call(void 0,_types.TokenType.braceR)&&!_base.state.error){if(_index.match.call(void 0,_types.TokenType._import)){_index.next.call(void 0);_statement.parseImport.call(void 0)}else{_util.unexpected.call(void 0)}}_util.expect.call(void 0,_types.TokenType.braceR)}__name(flowParseDeclareModule,\"flowParseDeclareModule\");function flowParseDeclareExportDeclaration(){_util.expect.call(void 0,_types.TokenType._export);if(_index.eat.call(void 0,_types.TokenType._default)){if(_index.match.call(void 0,_types.TokenType._function)||_index.match.call(void 0,_types.TokenType._class)){flowParseDeclare()}else{flowParseType();_util.semicolon.call(void 0)}}else if(_index.match.call(void 0,_types.TokenType._var)||_index.match.call(void 0,_types.TokenType._function)||_index.match.call(void 0,_types.TokenType._class)||_util.isContextual.call(void 0,_keywords.ContextualKeyword._opaque)){flowParseDeclare()}else if(_index.match.call(void 0,_types.TokenType.star)||_index.match.call(void 0,_types.TokenType.braceL)||_util.isContextual.call(void 0,_keywords.ContextualKeyword._interface)||_util.isContextual.call(void 0,_keywords.ContextualKeyword._type)||_util.isContextual.call(void 0,_keywords.ContextualKeyword._opaque)){_statement.parseExport.call(void 0)}else{_util.unexpected.call(void 0)}}__name(flowParseDeclareExportDeclaration,\"flowParseDeclareExportDeclaration\");function flowParseDeclareModuleExports(){_util.expectContextual.call(void 0,_keywords.ContextualKeyword._exports);flowParseTypeAnnotation();_util.semicolon.call(void 0)}__name(flowParseDeclareModuleExports,\"flowParseDeclareModuleExports\");function flowParseDeclareTypeAlias(){_index.next.call(void 0);flowParseTypeAlias()}__name(flowParseDeclareTypeAlias,\"flowParseDeclareTypeAlias\");function flowParseDeclareOpaqueType(){_index.next.call(void 0);flowParseOpaqueType(true)}__name(flowParseDeclareOpaqueType,\"flowParseDeclareOpaqueType\");function flowParseDeclareInterface(){_index.next.call(void 0);flowParseInterfaceish()}__name(flowParseDeclareInterface,\"flowParseDeclareInterface\");function flowParseInterfaceish(isClass=false){flowParseRestrictedIdentifier();if(_index.match.call(void 0,_types.TokenType.lessThan)){flowParseTypeParameterDeclaration()}if(_index.eat.call(void 0,_types.TokenType._extends)){do{flowParseInterfaceExtends()}while(!isClass&&_index.eat.call(void 0,_types.TokenType.comma))}if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._mixins)){_index.next.call(void 0);do{flowParseInterfaceExtends()}while(_index.eat.call(void 0,_types.TokenType.comma))}if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._implements)){_index.next.call(void 0);do{flowParseInterfaceExtends()}while(_index.eat.call(void 0,_types.TokenType.comma))}flowParseObjectType(isClass,false,isClass)}__name(flowParseInterfaceish,\"flowParseInterfaceish\");function flowParseInterfaceExtends(){flowParseQualifiedTypeIdentifier(false);if(_index.match.call(void 0,_types.TokenType.lessThan)){flowParseTypeParameterInstantiation()}}__name(flowParseInterfaceExtends,\"flowParseInterfaceExtends\");function flowParseInterface(){flowParseInterfaceish()}__name(flowParseInterface,\"flowParseInterface\");function flowParseRestrictedIdentifier(){_expression.parseIdentifier.call(void 0)}__name(flowParseRestrictedIdentifier,\"flowParseRestrictedIdentifier\");function flowParseTypeAlias(){flowParseRestrictedIdentifier();if(_index.match.call(void 0,_types.TokenType.lessThan)){flowParseTypeParameterDeclaration()}flowParseTypeInitialiser(_types.TokenType.eq);_util.semicolon.call(void 0)}__name(flowParseTypeAlias,\"flowParseTypeAlias\");function flowParseOpaqueType(declare){_util.expectContextual.call(void 0,_keywords.ContextualKeyword._type);flowParseRestrictedIdentifier();if(_index.match.call(void 0,_types.TokenType.lessThan)){flowParseTypeParameterDeclaration()}if(_index.match.call(void 0,_types.TokenType.colon)){flowParseTypeInitialiser(_types.TokenType.colon)}if(!declare){flowParseTypeInitialiser(_types.TokenType.eq)}_util.semicolon.call(void 0)}__name(flowParseOpaqueType,\"flowParseOpaqueType\");function flowParseTypeParameter(){flowParseVariance();flowParseTypeAnnotatableIdentifier();if(_index.eat.call(void 0,_types.TokenType.eq)){flowParseType()}}__name(flowParseTypeParameter,\"flowParseTypeParameter\");function flowParseTypeParameterDeclaration(){const oldIsType=_index.pushTypeContext.call(void 0,0);if(_index.match.call(void 0,_types.TokenType.lessThan)||_index.match.call(void 0,_types.TokenType.typeParameterStart)){_index.next.call(void 0)}else{_util.unexpected.call(void 0)}do{flowParseTypeParameter();if(!_index.match.call(void 0,_types.TokenType.greaterThan)){_util.expect.call(void 0,_types.TokenType.comma)}}while(!_index.match.call(void 0,_types.TokenType.greaterThan)&&!_base.state.error);_util.expect.call(void 0,_types.TokenType.greaterThan);_index.popTypeContext.call(void 0,oldIsType)}__name(flowParseTypeParameterDeclaration,\"flowParseTypeParameterDeclaration\");exports.flowParseTypeParameterDeclaration=flowParseTypeParameterDeclaration;function flowParseTypeParameterInstantiation(){const oldIsType=_index.pushTypeContext.call(void 0,0);_util.expect.call(void 0,_types.TokenType.lessThan);while(!_index.match.call(void 0,_types.TokenType.greaterThan)&&!_base.state.error){flowParseType();if(!_index.match.call(void 0,_types.TokenType.greaterThan)){_util.expect.call(void 0,_types.TokenType.comma)}}_util.expect.call(void 0,_types.TokenType.greaterThan);_index.popTypeContext.call(void 0,oldIsType)}__name(flowParseTypeParameterInstantiation,\"flowParseTypeParameterInstantiation\");function flowParseInterfaceType(){_util.expectContextual.call(void 0,_keywords.ContextualKeyword._interface);if(_index.eat.call(void 0,_types.TokenType._extends)){do{flowParseInterfaceExtends()}while(_index.eat.call(void 0,_types.TokenType.comma))}flowParseObjectType(false,false,false)}__name(flowParseInterfaceType,\"flowParseInterfaceType\");function flowParseObjectPropertyKey(){if(_index.match.call(void 0,_types.TokenType.num)||_index.match.call(void 0,_types.TokenType.string)){_expression.parseExprAtom.call(void 0)}else{_expression.parseIdentifier.call(void 0)}}__name(flowParseObjectPropertyKey,\"flowParseObjectPropertyKey\");function flowParseObjectTypeIndexer(){if(_index.lookaheadType.call(void 0)===_types.TokenType.colon){flowParseObjectPropertyKey();flowParseTypeInitialiser()}else{flowParseType()}_util.expect.call(void 0,_types.TokenType.bracketR);flowParseTypeInitialiser()}__name(flowParseObjectTypeIndexer,\"flowParseObjectTypeIndexer\");function flowParseObjectTypeInternalSlot(){flowParseObjectPropertyKey();_util.expect.call(void 0,_types.TokenType.bracketR);_util.expect.call(void 0,_types.TokenType.bracketR);if(_index.match.call(void 0,_types.TokenType.lessThan)||_index.match.call(void 0,_types.TokenType.parenL)){flowParseObjectTypeMethodish()}else{_index.eat.call(void 0,_types.TokenType.question);flowParseTypeInitialiser()}}__name(flowParseObjectTypeInternalSlot,\"flowParseObjectTypeInternalSlot\");function flowParseObjectTypeMethodish(){if(_index.match.call(void 0,_types.TokenType.lessThan)){flowParseTypeParameterDeclaration()}_util.expect.call(void 0,_types.TokenType.parenL);while(!_index.match.call(void 0,_types.TokenType.parenR)&&!_index.match.call(void 0,_types.TokenType.ellipsis)&&!_base.state.error){flowParseFunctionTypeParam();if(!_index.match.call(void 0,_types.TokenType.parenR)){_util.expect.call(void 0,_types.TokenType.comma)}}if(_index.eat.call(void 0,_types.TokenType.ellipsis)){flowParseFunctionTypeParam()}_util.expect.call(void 0,_types.TokenType.parenR);flowParseTypeInitialiser()}__name(flowParseObjectTypeMethodish,\"flowParseObjectTypeMethodish\");function flowParseObjectTypeCallProperty(){flowParseObjectTypeMethodish()}__name(flowParseObjectTypeCallProperty,\"flowParseObjectTypeCallProperty\");function flowParseObjectType(allowStatic,allowExact,allowProto){let endDelim;if(allowExact&&_index.match.call(void 0,_types.TokenType.braceBarL)){_util.expect.call(void 0,_types.TokenType.braceBarL);endDelim=_types.TokenType.braceBarR}else{_util.expect.call(void 0,_types.TokenType.braceL);endDelim=_types.TokenType.braceR}while(!_index.match.call(void 0,endDelim)&&!_base.state.error){if(allowProto&&_util.isContextual.call(void 0,_keywords.ContextualKeyword._proto)){const lookahead=_index.lookaheadType.call(void 0);if(lookahead!==_types.TokenType.colon&&lookahead!==_types.TokenType.question){_index.next.call(void 0);allowStatic=false}}if(allowStatic&&_util.isContextual.call(void 0,_keywords.ContextualKeyword._static)){const lookahead=_index.lookaheadType.call(void 0);if(lookahead!==_types.TokenType.colon&&lookahead!==_types.TokenType.question){_index.next.call(void 0)}}flowParseVariance();if(_index.eat.call(void 0,_types.TokenType.bracketL)){if(_index.eat.call(void 0,_types.TokenType.bracketL)){flowParseObjectTypeInternalSlot()}else{flowParseObjectTypeIndexer()}}else if(_index.match.call(void 0,_types.TokenType.parenL)||_index.match.call(void 0,_types.TokenType.lessThan)){flowParseObjectTypeCallProperty()}else{if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._get)||_util.isContextual.call(void 0,_keywords.ContextualKeyword._set)){const lookahead=_index.lookaheadType.call(void 0);if(lookahead===_types.TokenType.name||lookahead===_types.TokenType.string||lookahead===_types.TokenType.num){_index.next.call(void 0)}}flowParseObjectTypeProperty()}flowObjectTypeSemicolon()}_util.expect.call(void 0,endDelim)}__name(flowParseObjectType,\"flowParseObjectType\");function flowParseObjectTypeProperty(){if(_index.match.call(void 0,_types.TokenType.ellipsis)){_util.expect.call(void 0,_types.TokenType.ellipsis);if(!_index.eat.call(void 0,_types.TokenType.comma)){_index.eat.call(void 0,_types.TokenType.semi)}if(_index.match.call(void 0,_types.TokenType.braceR)){return}flowParseType()}else{flowParseObjectPropertyKey();if(_index.match.call(void 0,_types.TokenType.lessThan)||_index.match.call(void 0,_types.TokenType.parenL)){flowParseObjectTypeMethodish()}else{_index.eat.call(void 0,_types.TokenType.question);flowParseTypeInitialiser()}}}__name(flowParseObjectTypeProperty,\"flowParseObjectTypeProperty\");function flowObjectTypeSemicolon(){if(!_index.eat.call(void 0,_types.TokenType.semi)&&!_index.eat.call(void 0,_types.TokenType.comma)&&!_index.match.call(void 0,_types.TokenType.braceR)&&!_index.match.call(void 0,_types.TokenType.braceBarR)){_util.unexpected.call(void 0)}}__name(flowObjectTypeSemicolon,\"flowObjectTypeSemicolon\");function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed){if(!initialIdAlreadyParsed){_expression.parseIdentifier.call(void 0)}while(_index.eat.call(void 0,_types.TokenType.dot)){_expression.parseIdentifier.call(void 0)}}__name(flowParseQualifiedTypeIdentifier,\"flowParseQualifiedTypeIdentifier\");function flowParseGenericType(){flowParseQualifiedTypeIdentifier(true);if(_index.match.call(void 0,_types.TokenType.lessThan)){flowParseTypeParameterInstantiation()}}__name(flowParseGenericType,\"flowParseGenericType\");function flowParseTypeofType(){_util.expect.call(void 0,_types.TokenType._typeof);flowParsePrimaryType()}__name(flowParseTypeofType,\"flowParseTypeofType\");function flowParseTupleType(){_util.expect.call(void 0,_types.TokenType.bracketL);while(_base.state.pos<_base.input.length&&!_index.match.call(void 0,_types.TokenType.bracketR)){flowParseType();if(_index.match.call(void 0,_types.TokenType.bracketR)){break}_util.expect.call(void 0,_types.TokenType.comma)}_util.expect.call(void 0,_types.TokenType.bracketR)}__name(flowParseTupleType,\"flowParseTupleType\");function flowParseFunctionTypeParam(){const lookahead=_index.lookaheadType.call(void 0);if(lookahead===_types.TokenType.colon||lookahead===_types.TokenType.question){_expression.parseIdentifier.call(void 0);_index.eat.call(void 0,_types.TokenType.question);flowParseTypeInitialiser()}else{flowParseType()}}__name(flowParseFunctionTypeParam,\"flowParseFunctionTypeParam\");function flowParseFunctionTypeParams(){while(!_index.match.call(void 0,_types.TokenType.parenR)&&!_index.match.call(void 0,_types.TokenType.ellipsis)&&!_base.state.error){flowParseFunctionTypeParam();if(!_index.match.call(void 0,_types.TokenType.parenR)){_util.expect.call(void 0,_types.TokenType.comma)}}if(_index.eat.call(void 0,_types.TokenType.ellipsis)){flowParseFunctionTypeParam()}}__name(flowParseFunctionTypeParams,\"flowParseFunctionTypeParams\");function flowParsePrimaryType(){let isGroupedType=false;const oldNoAnonFunctionType=_base.state.noAnonFunctionType;switch(_base.state.type){case _types.TokenType.name:{if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._interface)){flowParseInterfaceType();return}_expression.parseIdentifier.call(void 0);flowParseGenericType();return}case _types.TokenType.braceL:flowParseObjectType(false,false,false);return;case _types.TokenType.braceBarL:flowParseObjectType(false,true,false);return;case _types.TokenType.bracketL:flowParseTupleType();return;case _types.TokenType.lessThan:flowParseTypeParameterDeclaration();_util.expect.call(void 0,_types.TokenType.parenL);flowParseFunctionTypeParams();_util.expect.call(void 0,_types.TokenType.parenR);_util.expect.call(void 0,_types.TokenType.arrow);flowParseType();return;case _types.TokenType.parenL:_index.next.call(void 0);if(!_index.match.call(void 0,_types.TokenType.parenR)&&!_index.match.call(void 0,_types.TokenType.ellipsis)){if(_index.match.call(void 0,_types.TokenType.name)){const token=_index.lookaheadType.call(void 0);isGroupedType=token!==_types.TokenType.question&&token!==_types.TokenType.colon}else{isGroupedType=true}}if(isGroupedType){_base.state.noAnonFunctionType=false;flowParseType();_base.state.noAnonFunctionType=oldNoAnonFunctionType;if(_base.state.noAnonFunctionType||!(_index.match.call(void 0,_types.TokenType.comma)||_index.match.call(void 0,_types.TokenType.parenR)&&_index.lookaheadType.call(void 0)===_types.TokenType.arrow)){_util.expect.call(void 0,_types.TokenType.parenR);return}else{_index.eat.call(void 0,_types.TokenType.comma)}}flowParseFunctionTypeParams();_util.expect.call(void 0,_types.TokenType.parenR);_util.expect.call(void 0,_types.TokenType.arrow);flowParseType();return;case _types.TokenType.minus:_index.next.call(void 0);_expression.parseLiteral.call(void 0);return;case _types.TokenType.string:case _types.TokenType.num:case _types.TokenType._true:case _types.TokenType._false:case _types.TokenType._null:case _types.TokenType._this:case _types.TokenType._void:case _types.TokenType.star:_index.next.call(void 0);return;default:if(_base.state.type===_types.TokenType._typeof){flowParseTypeofType();return}else if(_base.state.type&_types.TokenType.IS_KEYWORD){_index.next.call(void 0);_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType.name;return}}_util.unexpected.call(void 0)}__name(flowParsePrimaryType,\"flowParsePrimaryType\");function flowParsePostfixType(){flowParsePrimaryType();while(!_util.canInsertSemicolon.call(void 0)&&(_index.match.call(void 0,_types.TokenType.bracketL)||_index.match.call(void 0,_types.TokenType.questionDot))){_index.eat.call(void 0,_types.TokenType.questionDot);_util.expect.call(void 0,_types.TokenType.bracketL);if(_index.eat.call(void 0,_types.TokenType.bracketR)){}else{flowParseType();_util.expect.call(void 0,_types.TokenType.bracketR)}}}__name(flowParsePostfixType,\"flowParsePostfixType\");function flowParsePrefixType(){if(_index.eat.call(void 0,_types.TokenType.question)){flowParsePrefixType()}else{flowParsePostfixType()}}__name(flowParsePrefixType,\"flowParsePrefixType\");function flowParseAnonFunctionWithoutParens(){flowParsePrefixType();if(!_base.state.noAnonFunctionType&&_index.eat.call(void 0,_types.TokenType.arrow)){flowParseType()}}__name(flowParseAnonFunctionWithoutParens,\"flowParseAnonFunctionWithoutParens\");function flowParseIntersectionType(){_index.eat.call(void 0,_types.TokenType.bitwiseAND);flowParseAnonFunctionWithoutParens();while(_index.eat.call(void 0,_types.TokenType.bitwiseAND)){flowParseAnonFunctionWithoutParens()}}__name(flowParseIntersectionType,\"flowParseIntersectionType\");function flowParseUnionType(){_index.eat.call(void 0,_types.TokenType.bitwiseOR);flowParseIntersectionType();while(_index.eat.call(void 0,_types.TokenType.bitwiseOR)){flowParseIntersectionType()}}__name(flowParseUnionType,\"flowParseUnionType\");function flowParseType(){flowParseUnionType()}__name(flowParseType,\"flowParseType\");function flowParseTypeAnnotation(){flowParseTypeInitialiser()}__name(flowParseTypeAnnotation,\"flowParseTypeAnnotation\");exports.flowParseTypeAnnotation=flowParseTypeAnnotation;function flowParseTypeAnnotatableIdentifier(){_expression.parseIdentifier.call(void 0);if(_index.match.call(void 0,_types.TokenType.colon)){flowParseTypeAnnotation()}}__name(flowParseTypeAnnotatableIdentifier,\"flowParseTypeAnnotatableIdentifier\");function flowParseVariance(){if(_index.match.call(void 0,_types.TokenType.plus)||_index.match.call(void 0,_types.TokenType.minus)){_index.next.call(void 0);_base.state.tokens[_base.state.tokens.length-1].isType=true}}__name(flowParseVariance,\"flowParseVariance\");exports.flowParseVariance=flowParseVariance;function flowParseFunctionBodyAndFinish(funcContextId){if(_index.match.call(void 0,_types.TokenType.colon)){flowParseTypeAndPredicateInitialiser()}_expression.parseFunctionBody.call(void 0,false,funcContextId)}__name(flowParseFunctionBodyAndFinish,\"flowParseFunctionBodyAndFinish\");exports.flowParseFunctionBodyAndFinish=flowParseFunctionBodyAndFinish;function flowParseSubscript(startTokenIndex,noCalls,stopState){if(_index.match.call(void 0,_types.TokenType.questionDot)&&_index.lookaheadType.call(void 0)===_types.TokenType.lessThan){if(noCalls){stopState.stop=true;return}_index.next.call(void 0);flowParseTypeParameterInstantiation();_util.expect.call(void 0,_types.TokenType.parenL);_expression.parseCallExpressionArguments.call(void 0);return}else if(!noCalls&&_index.match.call(void 0,_types.TokenType.lessThan)){const snapshot=_base.state.snapshot();flowParseTypeParameterInstantiation();_util.expect.call(void 0,_types.TokenType.parenL);_expression.parseCallExpressionArguments.call(void 0);if(_base.state.error){_base.state.restoreFromSnapshot(snapshot)}else{return}}_expression.baseParseSubscript.call(void 0,startTokenIndex,noCalls,stopState)}__name(flowParseSubscript,\"flowParseSubscript\");exports.flowParseSubscript=flowParseSubscript;function flowStartParseNewArguments(){if(_index.match.call(void 0,_types.TokenType.lessThan)){const snapshot=_base.state.snapshot();flowParseTypeParameterInstantiation();if(_base.state.error){_base.state.restoreFromSnapshot(snapshot)}}}__name(flowStartParseNewArguments,\"flowStartParseNewArguments\");exports.flowStartParseNewArguments=flowStartParseNewArguments;function flowTryParseStatement(){if(_index.match.call(void 0,_types.TokenType.name)&&_base.state.contextualKeyword===_keywords.ContextualKeyword._interface){const oldIsType=_index.pushTypeContext.call(void 0,0);_index.next.call(void 0);flowParseInterface();_index.popTypeContext.call(void 0,oldIsType);return true}else if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._enum)){flowParseEnumDeclaration();return true}return false}__name(flowTryParseStatement,\"flowTryParseStatement\");exports.flowTryParseStatement=flowTryParseStatement;function flowTryParseExportDefaultExpression(){if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._enum)){flowParseEnumDeclaration();return true}return false}__name(flowTryParseExportDefaultExpression,\"flowTryParseExportDefaultExpression\");exports.flowTryParseExportDefaultExpression=flowTryParseExportDefaultExpression;function flowParseIdentifierStatement(contextualKeyword){if(contextualKeyword===_keywords.ContextualKeyword._declare){if(_index.match.call(void 0,_types.TokenType._class)||_index.match.call(void 0,_types.TokenType.name)||_index.match.call(void 0,_types.TokenType._function)||_index.match.call(void 0,_types.TokenType._var)||_index.match.call(void 0,_types.TokenType._export)){const oldIsType=_index.pushTypeContext.call(void 0,1);flowParseDeclare();_index.popTypeContext.call(void 0,oldIsType)}}else if(_index.match.call(void 0,_types.TokenType.name)){if(contextualKeyword===_keywords.ContextualKeyword._interface){const oldIsType=_index.pushTypeContext.call(void 0,1);flowParseInterface();_index.popTypeContext.call(void 0,oldIsType)}else if(contextualKeyword===_keywords.ContextualKeyword._type){const oldIsType=_index.pushTypeContext.call(void 0,1);flowParseTypeAlias();_index.popTypeContext.call(void 0,oldIsType)}else if(contextualKeyword===_keywords.ContextualKeyword._opaque){const oldIsType=_index.pushTypeContext.call(void 0,1);flowParseOpaqueType(false);_index.popTypeContext.call(void 0,oldIsType)}}_util.semicolon.call(void 0)}__name(flowParseIdentifierStatement,\"flowParseIdentifierStatement\");exports.flowParseIdentifierStatement=flowParseIdentifierStatement;function flowShouldParseExportDeclaration(){return _util.isContextual.call(void 0,_keywords.ContextualKeyword._type)||_util.isContextual.call(void 0,_keywords.ContextualKeyword._interface)||_util.isContextual.call(void 0,_keywords.ContextualKeyword._opaque)||_util.isContextual.call(void 0,_keywords.ContextualKeyword._enum)}__name(flowShouldParseExportDeclaration,\"flowShouldParseExportDeclaration\");exports.flowShouldParseExportDeclaration=flowShouldParseExportDeclaration;function flowShouldDisallowExportDefaultSpecifier(){return _index.match.call(void 0,_types.TokenType.name)&&(_base.state.contextualKeyword===_keywords.ContextualKeyword._type||_base.state.contextualKeyword===_keywords.ContextualKeyword._interface||_base.state.contextualKeyword===_keywords.ContextualKeyword._opaque||_base.state.contextualKeyword===_keywords.ContextualKeyword._enum)}__name(flowShouldDisallowExportDefaultSpecifier,\"flowShouldDisallowExportDefaultSpecifier\");exports.flowShouldDisallowExportDefaultSpecifier=flowShouldDisallowExportDefaultSpecifier;function flowParseExportDeclaration(){if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._type)){const oldIsType=_index.pushTypeContext.call(void 0,1);_index.next.call(void 0);if(_index.match.call(void 0,_types.TokenType.braceL)){_statement.parseExportSpecifiers.call(void 0);_statement.parseExportFrom.call(void 0)}else{flowParseTypeAlias()}_index.popTypeContext.call(void 0,oldIsType)}else if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._opaque)){const oldIsType=_index.pushTypeContext.call(void 0,1);_index.next.call(void 0);flowParseOpaqueType(false);_index.popTypeContext.call(void 0,oldIsType)}else if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._interface)){const oldIsType=_index.pushTypeContext.call(void 0,1);_index.next.call(void 0);flowParseInterface();_index.popTypeContext.call(void 0,oldIsType)}else{_statement.parseStatement.call(void 0,true)}}__name(flowParseExportDeclaration,\"flowParseExportDeclaration\");exports.flowParseExportDeclaration=flowParseExportDeclaration;function flowShouldParseExportStar(){return _index.match.call(void 0,_types.TokenType.star)||_util.isContextual.call(void 0,_keywords.ContextualKeyword._type)&&_index.lookaheadType.call(void 0)===_types.TokenType.star}__name(flowShouldParseExportStar,\"flowShouldParseExportStar\");exports.flowShouldParseExportStar=flowShouldParseExportStar;function flowParseExportStar(){if(_util.eatContextual.call(void 0,_keywords.ContextualKeyword._type)){const oldIsType=_index.pushTypeContext.call(void 0,2);_statement.baseParseExportStar.call(void 0);_index.popTypeContext.call(void 0,oldIsType)}else{_statement.baseParseExportStar.call(void 0)}}__name(flowParseExportStar,\"flowParseExportStar\");exports.flowParseExportStar=flowParseExportStar;function flowAfterParseClassSuper(hasSuper){if(hasSuper&&_index.match.call(void 0,_types.TokenType.lessThan)){flowParseTypeParameterInstantiation()}if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._implements)){const oldIsType=_index.pushTypeContext.call(void 0,0);_index.next.call(void 0);_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._implements;do{flowParseRestrictedIdentifier();if(_index.match.call(void 0,_types.TokenType.lessThan)){flowParseTypeParameterInstantiation()}}while(_index.eat.call(void 0,_types.TokenType.comma));_index.popTypeContext.call(void 0,oldIsType)}}__name(flowAfterParseClassSuper,\"flowAfterParseClassSuper\");exports.flowAfterParseClassSuper=flowAfterParseClassSuper;function flowStartParseObjPropValue(){if(_index.match.call(void 0,_types.TokenType.lessThan)){flowParseTypeParameterDeclaration();if(!_index.match.call(void 0,_types.TokenType.parenL))_util.unexpected.call(void 0)}}__name(flowStartParseObjPropValue,\"flowStartParseObjPropValue\");exports.flowStartParseObjPropValue=flowStartParseObjPropValue;function flowParseAssignableListItemTypes(){const oldIsType=_index.pushTypeContext.call(void 0,0);_index.eat.call(void 0,_types.TokenType.question);if(_index.match.call(void 0,_types.TokenType.colon)){flowParseTypeAnnotation()}_index.popTypeContext.call(void 0,oldIsType)}__name(flowParseAssignableListItemTypes,\"flowParseAssignableListItemTypes\");exports.flowParseAssignableListItemTypes=flowParseAssignableListItemTypes;function flowStartParseImportSpecifiers(){if(_index.match.call(void 0,_types.TokenType._typeof)||_util.isContextual.call(void 0,_keywords.ContextualKeyword._type)){const lh=_index.lookaheadTypeAndKeyword.call(void 0);if(isMaybeDefaultImport(lh)||lh.type===_types.TokenType.braceL||lh.type===_types.TokenType.star){_index.next.call(void 0)}}}__name(flowStartParseImportSpecifiers,\"flowStartParseImportSpecifiers\");exports.flowStartParseImportSpecifiers=flowStartParseImportSpecifiers;function flowParseImportSpecifier(){const isTypeKeyword=_base.state.contextualKeyword===_keywords.ContextualKeyword._type||_base.state.type===_types.TokenType._typeof;if(isTypeKeyword){_index.next.call(void 0)}else{_expression.parseIdentifier.call(void 0)}if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._as)&&!_util.isLookaheadContextual.call(void 0,_keywords.ContextualKeyword._as)){_expression.parseIdentifier.call(void 0);if(isTypeKeyword&&!_index.match.call(void 0,_types.TokenType.name)&&!(_base.state.type&_types.TokenType.IS_KEYWORD)){}else{_expression.parseIdentifier.call(void 0)}}else{if(isTypeKeyword&&(_index.match.call(void 0,_types.TokenType.name)||!!(_base.state.type&_types.TokenType.IS_KEYWORD))){_expression.parseIdentifier.call(void 0)}if(_util.eatContextual.call(void 0,_keywords.ContextualKeyword._as)){_expression.parseIdentifier.call(void 0)}}}__name(flowParseImportSpecifier,\"flowParseImportSpecifier\");exports.flowParseImportSpecifier=flowParseImportSpecifier;function flowStartParseFunctionParams(){if(_index.match.call(void 0,_types.TokenType.lessThan)){const oldIsType=_index.pushTypeContext.call(void 0,0);flowParseTypeParameterDeclaration();_index.popTypeContext.call(void 0,oldIsType)}}__name(flowStartParseFunctionParams,\"flowStartParseFunctionParams\");exports.flowStartParseFunctionParams=flowStartParseFunctionParams;function flowAfterParseVarHead(){if(_index.match.call(void 0,_types.TokenType.colon)){flowParseTypeAnnotation()}}__name(flowAfterParseVarHead,\"flowAfterParseVarHead\");exports.flowAfterParseVarHead=flowAfterParseVarHead;function flowStartParseAsyncArrowFromCallExpression(){if(_index.match.call(void 0,_types.TokenType.colon)){const oldNoAnonFunctionType=_base.state.noAnonFunctionType;_base.state.noAnonFunctionType=true;flowParseTypeAnnotation();_base.state.noAnonFunctionType=oldNoAnonFunctionType}}__name(flowStartParseAsyncArrowFromCallExpression,\"flowStartParseAsyncArrowFromCallExpression\");exports.flowStartParseAsyncArrowFromCallExpression=flowStartParseAsyncArrowFromCallExpression;function flowParseMaybeAssign(noIn,isWithinParens){if(_index.match.call(void 0,_types.TokenType.lessThan)){const snapshot=_base.state.snapshot();let wasArrow=_expression.baseParseMaybeAssign.call(void 0,noIn,isWithinParens);if(_base.state.error){_base.state.restoreFromSnapshot(snapshot);_base.state.type=_types.TokenType.typeParameterStart}else{return wasArrow}const oldIsType=_index.pushTypeContext.call(void 0,0);flowParseTypeParameterDeclaration();_index.popTypeContext.call(void 0,oldIsType);wasArrow=_expression.baseParseMaybeAssign.call(void 0,noIn,isWithinParens);if(wasArrow){return true}_util.unexpected.call(void 0)}return _expression.baseParseMaybeAssign.call(void 0,noIn,isWithinParens)}__name(flowParseMaybeAssign,\"flowParseMaybeAssign\");exports.flowParseMaybeAssign=flowParseMaybeAssign;function flowParseArrow(){if(_index.match.call(void 0,_types.TokenType.colon)){const oldIsType=_index.pushTypeContext.call(void 0,0);const snapshot=_base.state.snapshot();const oldNoAnonFunctionType=_base.state.noAnonFunctionType;_base.state.noAnonFunctionType=true;flowParseTypeAndPredicateInitialiser();_base.state.noAnonFunctionType=oldNoAnonFunctionType;if(_util.canInsertSemicolon.call(void 0))_util.unexpected.call(void 0);if(!_index.match.call(void 0,_types.TokenType.arrow))_util.unexpected.call(void 0);if(_base.state.error){_base.state.restoreFromSnapshot(snapshot)}_index.popTypeContext.call(void 0,oldIsType)}return _index.eat.call(void 0,_types.TokenType.arrow)}__name(flowParseArrow,\"flowParseArrow\");exports.flowParseArrow=flowParseArrow;function flowParseSubscripts(startTokenIndex,noCalls=false){if(_base.state.tokens[_base.state.tokens.length-1].contextualKeyword===_keywords.ContextualKeyword._async&&_index.match.call(void 0,_types.TokenType.lessThan)){const snapshot=_base.state.snapshot();const wasArrow=parseAsyncArrowWithTypeParameters();if(wasArrow&&!_base.state.error){return}_base.state.restoreFromSnapshot(snapshot)}_expression.baseParseSubscripts.call(void 0,startTokenIndex,noCalls)}__name(flowParseSubscripts,\"flowParseSubscripts\");exports.flowParseSubscripts=flowParseSubscripts;function parseAsyncArrowWithTypeParameters(){_base.state.scopeDepth++;const startTokenIndex=_base.state.tokens.length;_statement.parseFunctionParams.call(void 0);if(!_expression.parseArrow.call(void 0)){return false}_expression.parseArrowExpression.call(void 0,startTokenIndex);return true}__name(parseAsyncArrowWithTypeParameters,\"parseAsyncArrowWithTypeParameters\");function flowParseEnumDeclaration(){_util.expectContextual.call(void 0,_keywords.ContextualKeyword._enum);_base.state.tokens[_base.state.tokens.length-1].type=_types.TokenType._enum;_expression.parseIdentifier.call(void 0);flowParseEnumBody()}__name(flowParseEnumDeclaration,\"flowParseEnumDeclaration\");function flowParseEnumBody(){if(_util.eatContextual.call(void 0,_keywords.ContextualKeyword._of)){_index.next.call(void 0)}_util.expect.call(void 0,_types.TokenType.braceL);flowParseEnumMembers();_util.expect.call(void 0,_types.TokenType.braceR)}__name(flowParseEnumBody,\"flowParseEnumBody\");function flowParseEnumMembers(){while(!_index.match.call(void 0,_types.TokenType.braceR)&&!_base.state.error){if(_index.eat.call(void 0,_types.TokenType.ellipsis)){break}flowParseEnumMember();if(!_index.match.call(void 0,_types.TokenType.braceR)){_util.expect.call(void 0,_types.TokenType.comma)}}}__name(flowParseEnumMembers,\"flowParseEnumMembers\");function flowParseEnumMember(){_expression.parseIdentifier.call(void 0);if(_index.eat.call(void 0,_types.TokenType.eq)){_index.next.call(void 0)}}__name(flowParseEnumMember,\"flowParseEnumMember\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/parser/plugins/flow.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});/* eslint max-len: 0 */\n\n\n\n\n\n\n\n\n\n\nvar _index = require('../tokenizer/index');\nvar _keywords = require('../tokenizer/keywords');\nvar _types = require('../tokenizer/types');\nvar _base = require('../traverser/base');\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar _expression = require('../traverser/expression');\n\n\n\n\n\n\n\n\nvar _statement = require('../traverser/statement');\n\n\n\n\n\n\n\n\n\nvar _util = require('../traverser/util');\n\nfunction isMaybeDefaultImport(lookahead) {\n  return (\n    (lookahead.type === _types.TokenType.name || !!(lookahead.type & _types.TokenType.IS_KEYWORD)) &&\n    lookahead.contextualKeyword !== _keywords.ContextualKeyword._from\n  );\n}\n\nfunction flowParseTypeInitialiser(tok) {\n  const oldIsType = _index.pushTypeContext.call(void 0, 0);\n  _util.expect.call(void 0, tok || _types.TokenType.colon);\n  flowParseType();\n  _index.popTypeContext.call(void 0, oldIsType);\n}\n\nfunction flowParsePredicate() {\n  _util.expect.call(void 0, _types.TokenType.modulo);\n  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._checks);\n  if (_index.eat.call(void 0, _types.TokenType.parenL)) {\n    _expression.parseExpression.call(void 0, );\n    _util.expect.call(void 0, _types.TokenType.parenR);\n  }\n}\n\nfunction flowParseTypeAndPredicateInitialiser() {\n  const oldIsType = _index.pushTypeContext.call(void 0, 0);\n  _util.expect.call(void 0, _types.TokenType.colon);\n  if (_index.match.call(void 0, _types.TokenType.modulo)) {\n    flowParsePredicate();\n  } else {\n    flowParseType();\n    if (_index.match.call(void 0, _types.TokenType.modulo)) {\n      flowParsePredicate();\n    }\n  }\n  _index.popTypeContext.call(void 0, oldIsType);\n}\n\nfunction flowParseDeclareClass() {\n  _index.next.call(void 0, );\n  flowParseInterfaceish(/* isClass */ true);\n}\n\nfunction flowParseDeclareFunction() {\n  _index.next.call(void 0, );\n  _expression.parseIdentifier.call(void 0, );\n\n  if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  _util.expect.call(void 0, _types.TokenType.parenL);\n  flowParseFunctionTypeParams();\n  _util.expect.call(void 0, _types.TokenType.parenR);\n\n  flowParseTypeAndPredicateInitialiser();\n\n  _util.semicolon.call(void 0, );\n}\n\nfunction flowParseDeclare() {\n  if (_index.match.call(void 0, _types.TokenType._class)) {\n    flowParseDeclareClass();\n  } else if (_index.match.call(void 0, _types.TokenType._function)) {\n    flowParseDeclareFunction();\n  } else if (_index.match.call(void 0, _types.TokenType._var)) {\n    flowParseDeclareVariable();\n  } else if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._module)) {\n    if (_index.eat.call(void 0, _types.TokenType.dot)) {\n      flowParseDeclareModuleExports();\n    } else {\n      flowParseDeclareModule();\n    }\n  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {\n    flowParseDeclareTypeAlias();\n  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque)) {\n    flowParseDeclareOpaqueType();\n  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {\n    flowParseDeclareInterface();\n  } else if (_index.match.call(void 0, _types.TokenType._export)) {\n    flowParseDeclareExportDeclaration();\n  } else {\n    _util.unexpected.call(void 0, );\n  }\n}\n\nfunction flowParseDeclareVariable() {\n  _index.next.call(void 0, );\n  flowParseTypeAnnotatableIdentifier();\n  _util.semicolon.call(void 0, );\n}\n\nfunction flowParseDeclareModule() {\n  if (_index.match.call(void 0, _types.TokenType.string)) {\n    _expression.parseExprAtom.call(void 0, );\n  } else {\n    _expression.parseIdentifier.call(void 0, );\n  }\n\n  _util.expect.call(void 0, _types.TokenType.braceL);\n  while (!_index.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {\n    if (_index.match.call(void 0, _types.TokenType._import)) {\n      _index.next.call(void 0, );\n      _statement.parseImport.call(void 0, );\n    } else {\n      _util.unexpected.call(void 0, );\n    }\n  }\n  _util.expect.call(void 0, _types.TokenType.braceR);\n}\n\nfunction flowParseDeclareExportDeclaration() {\n  _util.expect.call(void 0, _types.TokenType._export);\n\n  if (_index.eat.call(void 0, _types.TokenType._default)) {\n    if (_index.match.call(void 0, _types.TokenType._function) || _index.match.call(void 0, _types.TokenType._class)) {\n      // declare export default class ...\n      // declare export default function ...\n      flowParseDeclare();\n    } else {\n      // declare export default [type];\n      flowParseType();\n      _util.semicolon.call(void 0, );\n    }\n  } else if (\n    _index.match.call(void 0, _types.TokenType._var) || // declare export var ...\n    _index.match.call(void 0, _types.TokenType._function) || // declare export function ...\n    _index.match.call(void 0, _types.TokenType._class) || // declare export class ...\n    _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque) // declare export opaque ..\n  ) {\n    flowParseDeclare();\n  } else if (\n    _index.match.call(void 0, _types.TokenType.star) || // declare export * from ''\n    _index.match.call(void 0, _types.TokenType.braceL) || // declare export {} ...\n    _util.isContextual.call(void 0, _keywords.ContextualKeyword._interface) || // declare export interface ...\n    _util.isContextual.call(void 0, _keywords.ContextualKeyword._type) || // declare export type ...\n    _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque) // declare export opaque type ...\n  ) {\n    _statement.parseExport.call(void 0, );\n  } else {\n    _util.unexpected.call(void 0, );\n  }\n}\n\nfunction flowParseDeclareModuleExports() {\n  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._exports);\n  flowParseTypeAnnotation();\n  _util.semicolon.call(void 0, );\n}\n\nfunction flowParseDeclareTypeAlias() {\n  _index.next.call(void 0, );\n  flowParseTypeAlias();\n}\n\nfunction flowParseDeclareOpaqueType() {\n  _index.next.call(void 0, );\n  flowParseOpaqueType(true);\n}\n\nfunction flowParseDeclareInterface() {\n  _index.next.call(void 0, );\n  flowParseInterfaceish();\n}\n\n// Interfaces\n\nfunction flowParseInterfaceish(isClass = false) {\n  flowParseRestrictedIdentifier();\n\n  if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  if (_index.eat.call(void 0, _types.TokenType._extends)) {\n    do {\n      flowParseInterfaceExtends();\n    } while (!isClass && _index.eat.call(void 0, _types.TokenType.comma));\n  }\n\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._mixins)) {\n    _index.next.call(void 0, );\n    do {\n      flowParseInterfaceExtends();\n    } while (_index.eat.call(void 0, _types.TokenType.comma));\n  }\n\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._implements)) {\n    _index.next.call(void 0, );\n    do {\n      flowParseInterfaceExtends();\n    } while (_index.eat.call(void 0, _types.TokenType.comma));\n  }\n\n  flowParseObjectType(isClass, false, isClass);\n}\n\nfunction flowParseInterfaceExtends() {\n  flowParseQualifiedTypeIdentifier(false);\n  if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n}\n\nfunction flowParseInterface() {\n  flowParseInterfaceish();\n}\n\nfunction flowParseRestrictedIdentifier() {\n  _expression.parseIdentifier.call(void 0, );\n}\n\nfunction flowParseTypeAlias() {\n  flowParseRestrictedIdentifier();\n\n  if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  flowParseTypeInitialiser(_types.TokenType.eq);\n  _util.semicolon.call(void 0, );\n}\n\nfunction flowParseOpaqueType(declare) {\n  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);\n  flowParseRestrictedIdentifier();\n\n  if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  // Parse the supertype\n  if (_index.match.call(void 0, _types.TokenType.colon)) {\n    flowParseTypeInitialiser(_types.TokenType.colon);\n  }\n\n  if (!declare) {\n    flowParseTypeInitialiser(_types.TokenType.eq);\n  }\n  _util.semicolon.call(void 0, );\n}\n\nfunction flowParseTypeParameter() {\n  flowParseVariance();\n  flowParseTypeAnnotatableIdentifier();\n\n  if (_index.eat.call(void 0, _types.TokenType.eq)) {\n    flowParseType();\n  }\n}\n\n function flowParseTypeParameterDeclaration() {\n  const oldIsType = _index.pushTypeContext.call(void 0, 0);\n  // istanbul ignore else: this condition is already checked at all call sites\n  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.typeParameterStart)) {\n    _index.next.call(void 0, );\n  } else {\n    _util.unexpected.call(void 0, );\n  }\n\n  do {\n    flowParseTypeParameter();\n    if (!_index.match.call(void 0, _types.TokenType.greaterThan)) {\n      _util.expect.call(void 0, _types.TokenType.comma);\n    }\n  } while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error);\n  _util.expect.call(void 0, _types.TokenType.greaterThan);\n  _index.popTypeContext.call(void 0, oldIsType);\n} exports.flowParseTypeParameterDeclaration = flowParseTypeParameterDeclaration;\n\nfunction flowParseTypeParameterInstantiation() {\n  const oldIsType = _index.pushTypeContext.call(void 0, 0);\n  _util.expect.call(void 0, _types.TokenType.lessThan);\n  while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error) {\n    flowParseType();\n    if (!_index.match.call(void 0, _types.TokenType.greaterThan)) {\n      _util.expect.call(void 0, _types.TokenType.comma);\n    }\n  }\n  _util.expect.call(void 0, _types.TokenType.greaterThan);\n  _index.popTypeContext.call(void 0, oldIsType);\n}\n\nfunction flowParseInterfaceType() {\n  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._interface);\n  if (_index.eat.call(void 0, _types.TokenType._extends)) {\n    do {\n      flowParseInterfaceExtends();\n    } while (_index.eat.call(void 0, _types.TokenType.comma));\n  }\n  flowParseObjectType(false, false, false);\n}\n\nfunction flowParseObjectPropertyKey() {\n  if (_index.match.call(void 0, _types.TokenType.num) || _index.match.call(void 0, _types.TokenType.string)) {\n    _expression.parseExprAtom.call(void 0, );\n  } else {\n    _expression.parseIdentifier.call(void 0, );\n  }\n}\n\nfunction flowParseObjectTypeIndexer() {\n  // Note: bracketL has already been consumed\n  if (_index.lookaheadType.call(void 0, ) === _types.TokenType.colon) {\n    flowParseObjectPropertyKey();\n    flowParseTypeInitialiser();\n  } else {\n    flowParseType();\n  }\n  _util.expect.call(void 0, _types.TokenType.bracketR);\n  flowParseTypeInitialiser();\n}\n\nfunction flowParseObjectTypeInternalSlot() {\n  // Note: both bracketL have already been consumed\n  flowParseObjectPropertyKey();\n  _util.expect.call(void 0, _types.TokenType.bracketR);\n  _util.expect.call(void 0, _types.TokenType.bracketR);\n  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.parenL)) {\n    flowParseObjectTypeMethodish();\n  } else {\n    _index.eat.call(void 0, _types.TokenType.question);\n    flowParseTypeInitialiser();\n  }\n}\n\nfunction flowParseObjectTypeMethodish() {\n  if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  _util.expect.call(void 0, _types.TokenType.parenL);\n  while (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis) && !_base.state.error) {\n    flowParseFunctionTypeParam();\n    if (!_index.match.call(void 0, _types.TokenType.parenR)) {\n      _util.expect.call(void 0, _types.TokenType.comma);\n    }\n  }\n\n  if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {\n    flowParseFunctionTypeParam();\n  }\n  _util.expect.call(void 0, _types.TokenType.parenR);\n  flowParseTypeInitialiser();\n}\n\nfunction flowParseObjectTypeCallProperty() {\n  flowParseObjectTypeMethodish();\n}\n\nfunction flowParseObjectType(allowStatic, allowExact, allowProto) {\n  let endDelim;\n  if (allowExact && _index.match.call(void 0, _types.TokenType.braceBarL)) {\n    _util.expect.call(void 0, _types.TokenType.braceBarL);\n    endDelim = _types.TokenType.braceBarR;\n  } else {\n    _util.expect.call(void 0, _types.TokenType.braceL);\n    endDelim = _types.TokenType.braceR;\n  }\n\n  while (!_index.match.call(void 0, endDelim) && !_base.state.error) {\n    if (allowProto && _util.isContextual.call(void 0, _keywords.ContextualKeyword._proto)) {\n      const lookahead = _index.lookaheadType.call(void 0, );\n      if (lookahead !== _types.TokenType.colon && lookahead !== _types.TokenType.question) {\n        _index.next.call(void 0, );\n        allowStatic = false;\n      }\n    }\n    if (allowStatic && _util.isContextual.call(void 0, _keywords.ContextualKeyword._static)) {\n      const lookahead = _index.lookaheadType.call(void 0, );\n      if (lookahead !== _types.TokenType.colon && lookahead !== _types.TokenType.question) {\n        _index.next.call(void 0, );\n      }\n    }\n\n    flowParseVariance();\n\n    if (_index.eat.call(void 0, _types.TokenType.bracketL)) {\n      if (_index.eat.call(void 0, _types.TokenType.bracketL)) {\n        flowParseObjectTypeInternalSlot();\n      } else {\n        flowParseObjectTypeIndexer();\n      }\n    } else if (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan)) {\n      flowParseObjectTypeCallProperty();\n    } else {\n      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._get) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._set)) {\n        const lookahead = _index.lookaheadType.call(void 0, );\n        if (lookahead === _types.TokenType.name || lookahead === _types.TokenType.string || lookahead === _types.TokenType.num) {\n          _index.next.call(void 0, );\n        }\n      }\n\n      flowParseObjectTypeProperty();\n    }\n\n    flowObjectTypeSemicolon();\n  }\n\n  _util.expect.call(void 0, endDelim);\n}\n\nfunction flowParseObjectTypeProperty() {\n  if (_index.match.call(void 0, _types.TokenType.ellipsis)) {\n    _util.expect.call(void 0, _types.TokenType.ellipsis);\n    if (!_index.eat.call(void 0, _types.TokenType.comma)) {\n      _index.eat.call(void 0, _types.TokenType.semi);\n    }\n    // Explicit inexact object syntax.\n    if (_index.match.call(void 0, _types.TokenType.braceR)) {\n      return;\n    }\n    flowParseType();\n  } else {\n    flowParseObjectPropertyKey();\n    if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.parenL)) {\n      // This is a method property\n      flowParseObjectTypeMethodish();\n    } else {\n      _index.eat.call(void 0, _types.TokenType.question);\n      flowParseTypeInitialiser();\n    }\n  }\n}\n\nfunction flowObjectTypeSemicolon() {\n  if (!_index.eat.call(void 0, _types.TokenType.semi) && !_index.eat.call(void 0, _types.TokenType.comma) && !_index.match.call(void 0, _types.TokenType.braceR) && !_index.match.call(void 0, _types.TokenType.braceBarR)) {\n    _util.unexpected.call(void 0, );\n  }\n}\n\nfunction flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {\n  if (!initialIdAlreadyParsed) {\n    _expression.parseIdentifier.call(void 0, );\n  }\n  while (_index.eat.call(void 0, _types.TokenType.dot)) {\n    _expression.parseIdentifier.call(void 0, );\n  }\n}\n\nfunction flowParseGenericType() {\n  flowParseQualifiedTypeIdentifier(true);\n  if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n}\n\nfunction flowParseTypeofType() {\n  _util.expect.call(void 0, _types.TokenType._typeof);\n  flowParsePrimaryType();\n}\n\nfunction flowParseTupleType() {\n  _util.expect.call(void 0, _types.TokenType.bracketL);\n  // We allow trailing commas\n  while (_base.state.pos < _base.input.length && !_index.match.call(void 0, _types.TokenType.bracketR)) {\n    flowParseType();\n    if (_index.match.call(void 0, _types.TokenType.bracketR)) {\n      break;\n    }\n    _util.expect.call(void 0, _types.TokenType.comma);\n  }\n  _util.expect.call(void 0, _types.TokenType.bracketR);\n}\n\nfunction flowParseFunctionTypeParam() {\n  const lookahead = _index.lookaheadType.call(void 0, );\n  if (lookahead === _types.TokenType.colon || lookahead === _types.TokenType.question) {\n    _expression.parseIdentifier.call(void 0, );\n    _index.eat.call(void 0, _types.TokenType.question);\n    flowParseTypeInitialiser();\n  } else {\n    flowParseType();\n  }\n}\n\nfunction flowParseFunctionTypeParams() {\n  while (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis) && !_base.state.error) {\n    flowParseFunctionTypeParam();\n    if (!_index.match.call(void 0, _types.TokenType.parenR)) {\n      _util.expect.call(void 0, _types.TokenType.comma);\n    }\n  }\n  if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {\n    flowParseFunctionTypeParam();\n  }\n}\n\n// The parsing of types roughly parallels the parsing of expressions, and\n// primary types are kind of like primary expressions...they're the\n// primitives with which other types are constructed.\nfunction flowParsePrimaryType() {\n  let isGroupedType = false;\n  const oldNoAnonFunctionType = _base.state.noAnonFunctionType;\n\n  switch (_base.state.type) {\n    case _types.TokenType.name: {\n      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {\n        flowParseInterfaceType();\n        return;\n      }\n      _expression.parseIdentifier.call(void 0, );\n      flowParseGenericType();\n      return;\n    }\n\n    case _types.TokenType.braceL:\n      flowParseObjectType(false, false, false);\n      return;\n\n    case _types.TokenType.braceBarL:\n      flowParseObjectType(false, true, false);\n      return;\n\n    case _types.TokenType.bracketL:\n      flowParseTupleType();\n      return;\n\n    case _types.TokenType.lessThan:\n      flowParseTypeParameterDeclaration();\n      _util.expect.call(void 0, _types.TokenType.parenL);\n      flowParseFunctionTypeParams();\n      _util.expect.call(void 0, _types.TokenType.parenR);\n      _util.expect.call(void 0, _types.TokenType.arrow);\n      flowParseType();\n      return;\n\n    case _types.TokenType.parenL:\n      _index.next.call(void 0, );\n\n      // Check to see if this is actually a grouped type\n      if (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis)) {\n        if (_index.match.call(void 0, _types.TokenType.name)) {\n          const token = _index.lookaheadType.call(void 0, );\n          isGroupedType = token !== _types.TokenType.question && token !== _types.TokenType.colon;\n        } else {\n          isGroupedType = true;\n        }\n      }\n\n      if (isGroupedType) {\n        _base.state.noAnonFunctionType = false;\n        flowParseType();\n        _base.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n        // A `,` or a `) =>` means this is an anonymous function type\n        if (\n          _base.state.noAnonFunctionType ||\n          !(_index.match.call(void 0, _types.TokenType.comma) || (_index.match.call(void 0, _types.TokenType.parenR) && _index.lookaheadType.call(void 0, ) === _types.TokenType.arrow))\n        ) {\n          _util.expect.call(void 0, _types.TokenType.parenR);\n          return;\n        } else {\n          // Eat a comma if there is one\n          _index.eat.call(void 0, _types.TokenType.comma);\n        }\n      }\n\n      flowParseFunctionTypeParams();\n\n      _util.expect.call(void 0, _types.TokenType.parenR);\n      _util.expect.call(void 0, _types.TokenType.arrow);\n      flowParseType();\n      return;\n\n    case _types.TokenType.minus:\n      _index.next.call(void 0, );\n      _expression.parseLiteral.call(void 0, );\n      return;\n\n    case _types.TokenType.string:\n    case _types.TokenType.num:\n    case _types.TokenType._true:\n    case _types.TokenType._false:\n    case _types.TokenType._null:\n    case _types.TokenType._this:\n    case _types.TokenType._void:\n    case _types.TokenType.star:\n      _index.next.call(void 0, );\n      return;\n\n    default:\n      if (_base.state.type === _types.TokenType._typeof) {\n        flowParseTypeofType();\n        return;\n      } else if (_base.state.type & _types.TokenType.IS_KEYWORD) {\n        _index.next.call(void 0, );\n        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;\n        return;\n      }\n  }\n\n  _util.unexpected.call(void 0, );\n}\n\nfunction flowParsePostfixType() {\n  flowParsePrimaryType();\n  while (!_util.canInsertSemicolon.call(void 0, ) && (_index.match.call(void 0, _types.TokenType.bracketL) || _index.match.call(void 0, _types.TokenType.questionDot))) {\n    _index.eat.call(void 0, _types.TokenType.questionDot);\n    _util.expect.call(void 0, _types.TokenType.bracketL);\n    if (_index.eat.call(void 0, _types.TokenType.bracketR)) {\n      // Array type\n    } else {\n      // Indexed access type\n      flowParseType();\n      _util.expect.call(void 0, _types.TokenType.bracketR);\n    }\n  }\n}\n\nfunction flowParsePrefixType() {\n  if (_index.eat.call(void 0, _types.TokenType.question)) {\n    flowParsePrefixType();\n  } else {\n    flowParsePostfixType();\n  }\n}\n\nfunction flowParseAnonFunctionWithoutParens() {\n  flowParsePrefixType();\n  if (!_base.state.noAnonFunctionType && _index.eat.call(void 0, _types.TokenType.arrow)) {\n    flowParseType();\n  }\n}\n\nfunction flowParseIntersectionType() {\n  _index.eat.call(void 0, _types.TokenType.bitwiseAND);\n  flowParseAnonFunctionWithoutParens();\n  while (_index.eat.call(void 0, _types.TokenType.bitwiseAND)) {\n    flowParseAnonFunctionWithoutParens();\n  }\n}\n\nfunction flowParseUnionType() {\n  _index.eat.call(void 0, _types.TokenType.bitwiseOR);\n  flowParseIntersectionType();\n  while (_index.eat.call(void 0, _types.TokenType.bitwiseOR)) {\n    flowParseIntersectionType();\n  }\n}\n\nfunction flowParseType() {\n  flowParseUnionType();\n}\n\n function flowParseTypeAnnotation() {\n  flowParseTypeInitialiser();\n} exports.flowParseTypeAnnotation = flowParseTypeAnnotation;\n\nfunction flowParseTypeAnnotatableIdentifier() {\n  _expression.parseIdentifier.call(void 0, );\n  if (_index.match.call(void 0, _types.TokenType.colon)) {\n    flowParseTypeAnnotation();\n  }\n}\n\n function flowParseVariance() {\n  if (_index.match.call(void 0, _types.TokenType.plus) || _index.match.call(void 0, _types.TokenType.minus)) {\n    _index.next.call(void 0, );\n    _base.state.tokens[_base.state.tokens.length - 1].isType = true;\n  }\n} exports.flowParseVariance = flowParseVariance;\n\n// ==================================\n// Overrides\n// ==================================\n\n function flowParseFunctionBodyAndFinish(funcContextId) {\n  // For arrow functions, `parseArrow` handles the return type itself.\n  if (_index.match.call(void 0, _types.TokenType.colon)) {\n    flowParseTypeAndPredicateInitialiser();\n  }\n\n  _expression.parseFunctionBody.call(void 0, false, funcContextId);\n} exports.flowParseFunctionBodyAndFinish = flowParseFunctionBodyAndFinish;\n\n function flowParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (_index.match.call(void 0, _types.TokenType.questionDot) && _index.lookaheadType.call(void 0, ) === _types.TokenType.lessThan) {\n    if (noCalls) {\n      stopState.stop = true;\n      return;\n    }\n    _index.next.call(void 0, );\n    flowParseTypeParameterInstantiation();\n    _util.expect.call(void 0, _types.TokenType.parenL);\n    _expression.parseCallExpressionArguments.call(void 0, );\n    return;\n  } else if (!noCalls && _index.match.call(void 0, _types.TokenType.lessThan)) {\n    const snapshot = _base.state.snapshot();\n    flowParseTypeParameterInstantiation();\n    _util.expect.call(void 0, _types.TokenType.parenL);\n    _expression.parseCallExpressionArguments.call(void 0, );\n    if (_base.state.error) {\n      _base.state.restoreFromSnapshot(snapshot);\n    } else {\n      return;\n    }\n  }\n  _expression.baseParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);\n} exports.flowParseSubscript = flowParseSubscript;\n\n function flowStartParseNewArguments() {\n  if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n    const snapshot = _base.state.snapshot();\n    flowParseTypeParameterInstantiation();\n    if (_base.state.error) {\n      _base.state.restoreFromSnapshot(snapshot);\n    }\n  }\n} exports.flowStartParseNewArguments = flowStartParseNewArguments;\n\n// interfaces\n function flowTryParseStatement() {\n  if (_index.match.call(void 0, _types.TokenType.name) && _base.state.contextualKeyword === _keywords.ContextualKeyword._interface) {\n    const oldIsType = _index.pushTypeContext.call(void 0, 0);\n    _index.next.call(void 0, );\n    flowParseInterface();\n    _index.popTypeContext.call(void 0, oldIsType);\n    return true;\n  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._enum)) {\n    flowParseEnumDeclaration();\n    return true;\n  }\n  return false;\n} exports.flowTryParseStatement = flowTryParseStatement;\n\n function flowTryParseExportDefaultExpression() {\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._enum)) {\n    flowParseEnumDeclaration();\n    return true;\n  }\n  return false;\n} exports.flowTryParseExportDefaultExpression = flowTryParseExportDefaultExpression;\n\n// declares, interfaces and type aliases\n function flowParseIdentifierStatement(contextualKeyword) {\n  if (contextualKeyword === _keywords.ContextualKeyword._declare) {\n    if (\n      _index.match.call(void 0, _types.TokenType._class) ||\n      _index.match.call(void 0, _types.TokenType.name) ||\n      _index.match.call(void 0, _types.TokenType._function) ||\n      _index.match.call(void 0, _types.TokenType._var) ||\n      _index.match.call(void 0, _types.TokenType._export)\n    ) {\n      const oldIsType = _index.pushTypeContext.call(void 0, 1);\n      flowParseDeclare();\n      _index.popTypeContext.call(void 0, oldIsType);\n    }\n  } else if (_index.match.call(void 0, _types.TokenType.name)) {\n    if (contextualKeyword === _keywords.ContextualKeyword._interface) {\n      const oldIsType = _index.pushTypeContext.call(void 0, 1);\n      flowParseInterface();\n      _index.popTypeContext.call(void 0, oldIsType);\n    } else if (contextualKeyword === _keywords.ContextualKeyword._type) {\n      const oldIsType = _index.pushTypeContext.call(void 0, 1);\n      flowParseTypeAlias();\n      _index.popTypeContext.call(void 0, oldIsType);\n    } else if (contextualKeyword === _keywords.ContextualKeyword._opaque) {\n      const oldIsType = _index.pushTypeContext.call(void 0, 1);\n      flowParseOpaqueType(false);\n      _index.popTypeContext.call(void 0, oldIsType);\n    }\n  }\n  _util.semicolon.call(void 0, );\n} exports.flowParseIdentifierStatement = flowParseIdentifierStatement;\n\n// export type\n function flowShouldParseExportDeclaration() {\n  return (\n    _util.isContextual.call(void 0, _keywords.ContextualKeyword._type) ||\n    _util.isContextual.call(void 0, _keywords.ContextualKeyword._interface) ||\n    _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque) ||\n    _util.isContextual.call(void 0, _keywords.ContextualKeyword._enum)\n  );\n} exports.flowShouldParseExportDeclaration = flowShouldParseExportDeclaration;\n\n function flowShouldDisallowExportDefaultSpecifier() {\n  return (\n    _index.match.call(void 0, _types.TokenType.name) &&\n    (_base.state.contextualKeyword === _keywords.ContextualKeyword._type ||\n      _base.state.contextualKeyword === _keywords.ContextualKeyword._interface ||\n      _base.state.contextualKeyword === _keywords.ContextualKeyword._opaque ||\n      _base.state.contextualKeyword === _keywords.ContextualKeyword._enum)\n  );\n} exports.flowShouldDisallowExportDefaultSpecifier = flowShouldDisallowExportDefaultSpecifier;\n\n function flowParseExportDeclaration() {\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {\n    const oldIsType = _index.pushTypeContext.call(void 0, 1);\n    _index.next.call(void 0, );\n\n    if (_index.match.call(void 0, _types.TokenType.braceL)) {\n      // export type { foo, bar };\n      _statement.parseExportSpecifiers.call(void 0, );\n      _statement.parseExportFrom.call(void 0, );\n    } else {\n      // export type Foo = Bar;\n      flowParseTypeAlias();\n    }\n    _index.popTypeContext.call(void 0, oldIsType);\n  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque)) {\n    const oldIsType = _index.pushTypeContext.call(void 0, 1);\n    _index.next.call(void 0, );\n    // export opaque type Foo = Bar;\n    flowParseOpaqueType(false);\n    _index.popTypeContext.call(void 0, oldIsType);\n  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {\n    const oldIsType = _index.pushTypeContext.call(void 0, 1);\n    _index.next.call(void 0, );\n    flowParseInterface();\n    _index.popTypeContext.call(void 0, oldIsType);\n  } else {\n    _statement.parseStatement.call(void 0, true);\n  }\n} exports.flowParseExportDeclaration = flowParseExportDeclaration;\n\n function flowShouldParseExportStar() {\n  return _index.match.call(void 0, _types.TokenType.star) || (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type) && _index.lookaheadType.call(void 0, ) === _types.TokenType.star);\n} exports.flowShouldParseExportStar = flowShouldParseExportStar;\n\n function flowParseExportStar() {\n  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._type)) {\n    const oldIsType = _index.pushTypeContext.call(void 0, 2);\n    _statement.baseParseExportStar.call(void 0, );\n    _index.popTypeContext.call(void 0, oldIsType);\n  } else {\n    _statement.baseParseExportStar.call(void 0, );\n  }\n} exports.flowParseExportStar = flowParseExportStar;\n\n// parse a the super class type parameters and implements\n function flowAfterParseClassSuper(hasSuper) {\n  if (hasSuper && _index.match.call(void 0, _types.TokenType.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._implements)) {\n    const oldIsType = _index.pushTypeContext.call(void 0, 0);\n    _index.next.call(void 0, );\n    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._implements;\n    do {\n      flowParseRestrictedIdentifier();\n      if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n        flowParseTypeParameterInstantiation();\n      }\n    } while (_index.eat.call(void 0, _types.TokenType.comma));\n    _index.popTypeContext.call(void 0, oldIsType);\n  }\n} exports.flowAfterParseClassSuper = flowAfterParseClassSuper;\n\n// parse type parameters for object method shorthand\n function flowStartParseObjPropValue() {\n  // method shorthand\n  if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n    flowParseTypeParameterDeclaration();\n    if (!_index.match.call(void 0, _types.TokenType.parenL)) _util.unexpected.call(void 0, );\n  }\n} exports.flowStartParseObjPropValue = flowStartParseObjPropValue;\n\n function flowParseAssignableListItemTypes() {\n  const oldIsType = _index.pushTypeContext.call(void 0, 0);\n  _index.eat.call(void 0, _types.TokenType.question);\n  if (_index.match.call(void 0, _types.TokenType.colon)) {\n    flowParseTypeAnnotation();\n  }\n  _index.popTypeContext.call(void 0, oldIsType);\n} exports.flowParseAssignableListItemTypes = flowParseAssignableListItemTypes;\n\n// parse typeof and type imports\n function flowStartParseImportSpecifiers() {\n  if (_index.match.call(void 0, _types.TokenType._typeof) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {\n    const lh = _index.lookaheadTypeAndKeyword.call(void 0, );\n    if (isMaybeDefaultImport(lh) || lh.type === _types.TokenType.braceL || lh.type === _types.TokenType.star) {\n      _index.next.call(void 0, );\n    }\n  }\n} exports.flowStartParseImportSpecifiers = flowStartParseImportSpecifiers;\n\n// parse import-type/typeof shorthand\n function flowParseImportSpecifier() {\n  const isTypeKeyword =\n    _base.state.contextualKeyword === _keywords.ContextualKeyword._type || _base.state.type === _types.TokenType._typeof;\n  if (isTypeKeyword) {\n    _index.next.call(void 0, );\n  } else {\n    _expression.parseIdentifier.call(void 0, );\n  }\n\n  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._as) && !_util.isLookaheadContextual.call(void 0, _keywords.ContextualKeyword._as)) {\n    _expression.parseIdentifier.call(void 0, );\n    if (isTypeKeyword && !_index.match.call(void 0, _types.TokenType.name) && !(_base.state.type & _types.TokenType.IS_KEYWORD)) {\n      // `import {type as ,` or `import {type as }`\n    } else {\n      // `import {type as foo`\n      _expression.parseIdentifier.call(void 0, );\n    }\n  } else {\n    if (isTypeKeyword && (_index.match.call(void 0, _types.TokenType.name) || !!(_base.state.type & _types.TokenType.IS_KEYWORD))) {\n      // `import {type foo`\n      _expression.parseIdentifier.call(void 0, );\n    }\n    if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as)) {\n      _expression.parseIdentifier.call(void 0, );\n    }\n  }\n} exports.flowParseImportSpecifier = flowParseImportSpecifier;\n\n// parse function type parameters - function foo<T>() {}\n function flowStartParseFunctionParams() {\n  // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon\n  // anyway, so don't try to propagate that information.\n  if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n    const oldIsType = _index.pushTypeContext.call(void 0, 0);\n    flowParseTypeParameterDeclaration();\n    _index.popTypeContext.call(void 0, oldIsType);\n  }\n} exports.flowStartParseFunctionParams = flowStartParseFunctionParams;\n\n// parse flow type annotations on variable declarator heads - let foo: string = bar\n function flowAfterParseVarHead() {\n  if (_index.match.call(void 0, _types.TokenType.colon)) {\n    flowParseTypeAnnotation();\n  }\n} exports.flowAfterParseVarHead = flowAfterParseVarHead;\n\n// parse the return type of an async arrow function - let foo = (async (): number => {});\n function flowStartParseAsyncArrowFromCallExpression() {\n  if (_index.match.call(void 0, _types.TokenType.colon)) {\n    const oldNoAnonFunctionType = _base.state.noAnonFunctionType;\n    _base.state.noAnonFunctionType = true;\n    flowParseTypeAnnotation();\n    _base.state.noAnonFunctionType = oldNoAnonFunctionType;\n  }\n} exports.flowStartParseAsyncArrowFromCallExpression = flowStartParseAsyncArrowFromCallExpression;\n\n// We need to support type parameter declarations for arrow functions. This\n// is tricky. There are three situations we need to handle\n//\n// 1. This is either JSX or an arrow function. We'll try JSX first. If that\n//    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n//    error.\n// 2. This is an arrow function. We'll parse the type parameter declaration,\n//    parse the rest, make sure the rest is an arrow function, and go from\n//    there\n// 3. This is neither. Just call the super method\n function flowParseMaybeAssign(noIn, isWithinParens) {\n  if (_index.match.call(void 0, _types.TokenType.lessThan)) {\n    const snapshot = _base.state.snapshot();\n    let wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);\n    if (_base.state.error) {\n      _base.state.restoreFromSnapshot(snapshot);\n      _base.state.type = _types.TokenType.typeParameterStart;\n    } else {\n      return wasArrow;\n    }\n\n    const oldIsType = _index.pushTypeContext.call(void 0, 0);\n    flowParseTypeParameterDeclaration();\n    _index.popTypeContext.call(void 0, oldIsType);\n    wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);\n    if (wasArrow) {\n      return true;\n    }\n    _util.unexpected.call(void 0, );\n  }\n\n  return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);\n} exports.flowParseMaybeAssign = flowParseMaybeAssign;\n\n// handle return types for arrow functions\n function flowParseArrow() {\n  if (_index.match.call(void 0, _types.TokenType.colon)) {\n    const oldIsType = _index.pushTypeContext.call(void 0, 0);\n    const snapshot = _base.state.snapshot();\n\n    const oldNoAnonFunctionType = _base.state.noAnonFunctionType;\n    _base.state.noAnonFunctionType = true;\n    flowParseTypeAndPredicateInitialiser();\n    _base.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n    if (_util.canInsertSemicolon.call(void 0, )) _util.unexpected.call(void 0, );\n    if (!_index.match.call(void 0, _types.TokenType.arrow)) _util.unexpected.call(void 0, );\n\n    if (_base.state.error) {\n      _base.state.restoreFromSnapshot(snapshot);\n    }\n    _index.popTypeContext.call(void 0, oldIsType);\n  }\n  return _index.eat.call(void 0, _types.TokenType.arrow);\n} exports.flowParseArrow = flowParseArrow;\n\n function flowParseSubscripts(startTokenIndex, noCalls = false) {\n  if (\n    _base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _keywords.ContextualKeyword._async &&\n    _index.match.call(void 0, _types.TokenType.lessThan)\n  ) {\n    const snapshot = _base.state.snapshot();\n    const wasArrow = parseAsyncArrowWithTypeParameters();\n    if (wasArrow && !_base.state.error) {\n      return;\n    }\n    _base.state.restoreFromSnapshot(snapshot);\n  }\n\n  _expression.baseParseSubscripts.call(void 0, startTokenIndex, noCalls);\n} exports.flowParseSubscripts = flowParseSubscripts;\n\n// Returns true if there was an arrow function here.\nfunction parseAsyncArrowWithTypeParameters() {\n  _base.state.scopeDepth++;\n  const startTokenIndex = _base.state.tokens.length;\n  _statement.parseFunctionParams.call(void 0, );\n  if (!_expression.parseArrow.call(void 0, )) {\n    return false;\n  }\n  _expression.parseArrowExpression.call(void 0, startTokenIndex);\n  return true;\n}\n\nfunction flowParseEnumDeclaration() {\n  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._enum);\n  _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;\n  _expression.parseIdentifier.call(void 0, );\n  flowParseEnumBody();\n}\n\nfunction flowParseEnumBody() {\n  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._of)) {\n    _index.next.call(void 0, );\n  }\n  _util.expect.call(void 0, _types.TokenType.braceL);\n  flowParseEnumMembers();\n  _util.expect.call(void 0, _types.TokenType.braceR);\n}\n\nfunction flowParseEnumMembers() {\n  while (!_index.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {\n    if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {\n      break;\n    }\n    flowParseEnumMember();\n    if (!_index.match.call(void 0, _types.TokenType.braceR)) {\n      _util.expect.call(void 0, _types.TokenType.comma);\n    }\n  }\n}\n\nfunction flowParseEnumMember() {\n  _expression.parseIdentifier.call(void 0, );\n  if (_index.eat.call(void 0, _types.TokenType.eq)) {\n    // Flow enum values are always just one token (a string, number, or boolean literal).\n    _index.next.call(void 0, );\n  }\n}\n"]}}