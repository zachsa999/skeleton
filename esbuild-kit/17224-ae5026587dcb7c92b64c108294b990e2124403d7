{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:true,get:all[name]})}__name(_export,\"_export\");_export(exports,{formatVariantSelector:function(){return formatVariantSelector},eliminateIrrelevantSelectors:function(){return eliminateIrrelevantSelectors},finalizeSelector:function(){return finalizeSelector},handleMergePseudo:function(){return handleMergePseudo}});const _postcssselectorparser=_interop_require_default(require(\"postcss-selector-parser\"));const _unesc=_interop_require_default(require(\"postcss-selector-parser/dist/util/unesc\"));const _escapeClassName=_interop_require_default(require(\"../util/escapeClassName\"));const _prefixSelector=_interop_require_default(require(\"../util/prefixSelector\"));const _pseudoElements=require(\"./pseudoElements\");function _interop_require_default(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interop_require_default,\"_interop_require_default\");let MERGE=\":merge\";function formatVariantSelector(formats,{context,candidate}){var _context_tailwindConfig_prefix;let prefix=(_context_tailwindConfig_prefix=context===null||context===void 0?void 0:context.tailwindConfig.prefix)!==null&&_context_tailwindConfig_prefix!==void 0?_context_tailwindConfig_prefix:\"\";let parsedFormats=formats.map(format=>{let ast=(0,_postcssselectorparser.default)().astSync(format.format);return{...format,ast:format.isArbitraryVariant?ast:(0,_prefixSelector.default)(prefix,ast)}});let formatAst=_postcssselectorparser.default.root({nodes:[_postcssselectorparser.default.selector({nodes:[_postcssselectorparser.default.className({value:(0,_escapeClassName.default)(candidate)})]})]});for(let{ast}of parsedFormats){[formatAst,ast]=handleMergePseudo(formatAst,ast);ast.walkNesting(nesting=>nesting.replaceWith(...formatAst.nodes[0].nodes));formatAst=ast}return formatAst}__name(formatVariantSelector,\"formatVariantSelector\");function simpleSelectorForNode(node){let nodes=[];while(node.prev()&&node.prev().type!==\"combinator\"){node=node.prev()}while(node&&node.type!==\"combinator\"){nodes.push(node);node=node.next()}return nodes}__name(simpleSelectorForNode,\"simpleSelectorForNode\");function resortSelector(sel){sel.sort((a,b)=>{if(a.type===\"tag\"&&b.type===\"class\"){return-1}else if(a.type===\"class\"&&b.type===\"tag\"){return 1}else if(a.type===\"class\"&&b.type===\"pseudo\"&&b.value.startsWith(\"::\")){return-1}else if(a.type===\"pseudo\"&&a.value.startsWith(\"::\")&&b.type===\"class\"){return 1}return sel.index(a)-sel.index(b)});return sel}__name(resortSelector,\"resortSelector\");function eliminateIrrelevantSelectors(sel,base){let hasClassesMatchingCandidate=false;sel.walk(child=>{if(child.type===\"class\"&&child.value===base){hasClassesMatchingCandidate=true;return false}});if(!hasClassesMatchingCandidate){sel.remove()}}__name(eliminateIrrelevantSelectors,\"eliminateIrrelevantSelectors\");function finalizeSelector(current,formats,{context,candidate,base}){var _context_tailwindConfig;var _context_tailwindConfig_separator;let separator=(_context_tailwindConfig_separator=context===null||context===void 0?void 0:(_context_tailwindConfig=context.tailwindConfig)===null||_context_tailwindConfig===void 0?void 0:_context_tailwindConfig.separator)!==null&&_context_tailwindConfig_separator!==void 0?_context_tailwindConfig_separator:\":\";base=base!==null&&base!==void 0?base:candidate.split(new RegExp(`\\\\${separator}(?![^[]*\\\\])`)).pop();let selector=(0,_postcssselectorparser.default)().astSync(current);selector.walkClasses(node=>{if(node.raws&&node.value.includes(base)){node.raws.value=(0,_escapeClassName.default)((0,_unesc.default)(node.raws.value))}});selector.each(sel=>eliminateIrrelevantSelectors(sel,base));let formatAst=Array.isArray(formats)?formatVariantSelector(formats,{context,candidate}):formats;if(formatAst===null){return selector.toString()}let simpleStart=_postcssselectorparser.default.comment({value:\"/*__simple__*/\"});let simpleEnd=_postcssselectorparser.default.comment({value:\"/*__simple__*/\"});selector.walkClasses(node=>{if(node.value!==base){return}let parent=node.parent;let formatNodes=formatAst.nodes[0].nodes;if(parent.nodes.length===1){node.replaceWith(...formatNodes);return}let simpleSelector=simpleSelectorForNode(node);parent.insertBefore(simpleSelector[0],simpleStart);parent.insertAfter(simpleSelector[simpleSelector.length-1],simpleEnd);for(let child of formatNodes){parent.insertBefore(simpleSelector[0],child.clone())}node.remove();simpleSelector=simpleSelectorForNode(simpleStart);let firstNode=parent.index(simpleStart);parent.nodes.splice(firstNode,simpleSelector.length,...resortSelector(_postcssselectorparser.default.selector({nodes:simpleSelector})).nodes);simpleStart.remove();simpleEnd.remove()});selector.walkPseudos(p=>{if(p.value===MERGE){p.replaceWith(p.nodes)}});selector.each(sel=>(0,_pseudoElements.movePseudos)(sel));return selector.toString()}__name(finalizeSelector,\"finalizeSelector\");function handleMergePseudo(selector,format){let merges=[];selector.walkPseudos(pseudo=>{if(pseudo.value===MERGE){merges.push({pseudo,value:pseudo.nodes[0].toString()})}});format.walkPseudos(pseudo=>{if(pseudo.value!==MERGE){return}let value=pseudo.nodes[0].toString();let existing=merges.find(merge=>merge.value===value);if(!existing){return}let attachments=[];let next=pseudo.next();while(next&&next.type!==\"combinator\"){attachments.push(next);next=next.next()}let combinator=next;existing.pseudo.parent.insertAfter(existing.pseudo,_postcssselectorparser.default.selector({nodes:attachments.map(node=>node.clone())}));pseudo.remove();attachments.forEach(node=>node.remove());if(combinator&&combinator.type===\"combinator\"){combinator.remove()}});return[selector,format]}__name(handleMergePseudo,\"handleMergePseudo\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HACA,OAAO,eAAe,QAAS,aAAc,CACzC,MAAO,IACX,CAAC,EACD,SAAS,QAAQ,OAAQ,IAAK,CAC1B,QAAQ,QAAQ,IAAI,OAAO,eAAe,OAAQ,KAAM,CACpD,WAAY,KACZ,IAAK,IAAI,IAAI,CACjB,CAAC,CACL,CALS,0BAMT,QAAQ,QAAS,CACb,sBAAuB,UAAW,CAC9B,OAAO,qBACX,EACA,6BAA8B,UAAW,CACrC,OAAO,4BACX,EACA,iBAAkB,UAAW,CACzB,OAAO,gBACX,EACA,kBAAmB,UAAW,CAC1B,OAAO,iBACX,CACJ,CAAC,EACD,MAAM,uBAAuC,yBAAyB,QAAQ,yBAAyB,CAAC,EACxG,MAAM,OAAuB,yBAAyB,QAAQ,yCAAyC,CAAC,EACxG,MAAM,iBAAiC,yBAAyB,QAAQ,yBAAyB,CAAC,EAClG,MAAM,gBAAgC,yBAAyB,QAAQ,wBAAwB,CAAC,EAChG,MAAM,gBAAkB,QAAQ,kBAAkB,EAClD,SAAS,yBAAyB,IAAK,CACnC,OAAO,KAAO,IAAI,WAAa,IAAM,CACjC,QAAS,GACb,CACJ,CAJS,4DAK4c,IAAI,MAAQ,SACje,SAAS,sBAAsB,QAAS,CAAE,QAAU,SAAW,EAAG,CAC9D,IAAI,+BACJ,IAAI,QAAU,+BAAiC,UAAY,MAAQ,UAAY,OAAS,OAAS,QAAQ,eAAe,UAAY,MAAQ,iCAAmC,OAAS,+BAAiC,GAEzN,IAAI,cAAgB,QAAQ,IAAK,QAAS,CACtC,IAAI,KAAO,EAAG,uBAAuB,SAAS,EAAE,QAAQ,OAAO,MAAM,EACrE,MAAO,CACH,GAAG,OACH,IAAK,OAAO,mBAAqB,KAAO,EAAG,gBAAgB,SAAS,OAAQ,GAAG,CACnF,CACJ,CAAC,EAED,IAAI,UAAY,uBAAuB,QAAQ,KAAK,CAChD,MAAO,CACH,uBAAuB,QAAQ,SAAS,CACpC,MAAO,CACH,uBAAuB,QAAQ,UAAU,CACrC,OAAQ,EAAG,iBAAiB,SAAS,SAAS,CAClD,CAAC,CACL,CACJ,CAAC,CACL,CACJ,CAAC,EAED,OAAS,CAAE,GAAK,IAAK,cAAc,CAC/B,CAAC,UAAW,GAAG,EAAI,kBAAkB,UAAW,GAAG,EAEnD,IAAI,YAAa,SAAU,QAAQ,YAAY,GAAG,UAAU,MAAM,CAAC,EAAE,KAAK,CAAC,EAE3E,UAAY,GAChB,CACA,OAAO,SACX,CAhCS,sDAyCJ,SAAS,sBAAsB,KAAM,CAChB,IAAI,MAAQ,CAAC,EAEnC,MAAM,KAAK,KAAK,GAAK,KAAK,KAAK,EAAE,OAAS,aAAa,CACnD,KAAO,KAAK,KAAK,CACrB,CAEA,MAAM,MAAQ,KAAK,OAAS,aAAa,CACrC,MAAM,KAAK,IAAI,EACf,KAAO,KAAK,KAAK,CACrB,CACA,OAAO,KACX,CAZc,sDAmBT,SAAS,eAAe,IAAK,CAC9B,IAAI,KAAK,CAAC,EAAG,IAAI,CACb,GAAI,EAAE,OAAS,OAAS,EAAE,OAAS,QAAS,CACxC,MAAO,EACX,SAAW,EAAE,OAAS,SAAW,EAAE,OAAS,MAAO,CAC/C,MAAO,EACX,SAAW,EAAE,OAAS,SAAW,EAAE,OAAS,UAAY,EAAE,MAAM,WAAW,IAAI,EAAG,CAC9E,MAAO,EACX,SAAW,EAAE,OAAS,UAAY,EAAE,MAAM,WAAW,IAAI,GAAK,EAAE,OAAS,QAAS,CAC9E,MAAO,EACX,CACA,OAAO,IAAI,MAAM,CAAC,EAAI,IAAI,MAAM,CAAC,CACrC,CAAC,EACD,OAAO,GACX,CAdc,wCAed,SAAS,6BAA6B,IAAK,KAAM,CAC7C,IAAI,4BAA8B,MAClC,IAAI,KAAM,OAAQ,CACd,GAAI,MAAM,OAAS,SAAW,MAAM,QAAU,KAAM,CAChD,4BAA8B,KAC9B,MAAO,MAEX,CACJ,CAAC,EACD,GAAI,CAAC,4BAA6B,CAC9B,IAAI,OAAO,CACf,CAOJ,CAlBS,oEAmBT,SAAS,iBAAiB,QAAS,QAAS,CAAE,QAAU,UAAY,IAAM,EAAG,CACzE,IAAI,wBACJ,IAAI,kCACJ,IAAI,WAAa,kCAAoC,UAAY,MAAQ,UAAY,OAAS,QAAU,wBAA0B,QAAQ,kBAAoB,MAAQ,0BAA4B,OAAS,OAAS,wBAAwB,aAAe,MAAQ,oCAAsC,OAAS,kCAAoC,IAQtV,KAAO,OAAS,MAAQ,OAAS,OAAS,KAAO,UAAU,MAAM,IAAI,OAAO,KAAK,uBAAuB,CAAC,EAAE,IAAI,EAE/G,IAAI,UAAY,EAAG,uBAAuB,SAAS,EAAE,QAAQ,OAAO,EAYpE,SAAS,YAAa,MAAO,CACzB,GAAI,KAAK,MAAQ,KAAK,MAAM,SAAS,IAAI,EAAG,CACxC,KAAK,KAAK,OAAS,EAAG,iBAAiB,UAAU,EAAG,OAAO,SAAS,KAAK,KAAK,KAAK,CAAC,CACxF,CACJ,CAAC,EAED,SAAS,KAAM,KAAM,6BAA6B,IAAK,IAAI,CAAC,EAG5D,IAAI,UAAY,MAAM,QAAQ,OAAO,EAAI,sBAAsB,QAAS,CACpE,QACA,SACJ,CAAC,EAAI,QACL,GAAI,YAAc,KAAM,CACpB,OAAO,SAAS,SAAS,CAC7B,CACA,IAAI,YAAc,uBAAuB,QAAQ,QAAQ,CACrD,MAAO,gBACX,CAAC,EACD,IAAI,UAAY,uBAAuB,QAAQ,QAAQ,CACnD,MAAO,gBACX,CAAC,EAGD,SAAS,YAAa,MAAO,CACzB,GAAI,KAAK,QAAU,KAAM,CACrB,MACJ,CACA,IAAI,OAAS,KAAK,OAClB,IAAI,YAAc,UAAU,MAAM,CAAC,EAAE,MAErC,GAAI,OAAO,MAAM,SAAW,EAAG,CAC3B,KAAK,YAAY,GAAG,WAAW,EAC/B,MACJ,CACA,IAAI,eAAiB,sBAAsB,IAAI,EAC/C,OAAO,aAAa,eAAe,CAAC,EAAG,WAAW,EAClD,OAAO,YAAY,eAAe,eAAe,OAAS,CAAC,EAAG,SAAS,EACvE,QAAS,SAAS,YAAY,CAC1B,OAAO,aAAa,eAAe,CAAC,EAAG,MAAM,MAAM,CAAC,CACxD,CACA,KAAK,OAAO,EAEZ,eAAiB,sBAAsB,WAAW,EAClD,IAAI,UAAY,OAAO,MAAM,WAAW,EACxC,OAAO,MAAM,OAAO,UAAW,eAAe,OAAQ,GAAG,eAAe,uBAAuB,QAAQ,SAAS,CAC5G,MAAO,cACX,CAAC,CAAC,EAAE,KAAK,EACT,YAAY,OAAO,EACnB,UAAU,OAAO,CACrB,CAAC,EAED,SAAS,YAAa,GAAI,CACtB,GAAI,EAAE,QAAU,MAAO,CACnB,EAAE,YAAY,EAAE,KAAK,CACzB,CACJ,CAAC,EAED,SAAS,KAAM,MAAO,EAAG,gBAAgB,aAAa,GAAG,CAAC,EAC1D,OAAO,SAAS,SAAS,CAC7B,CArFS,4CAsFT,SAAS,kBAAkB,SAAU,OAAQ,CACQ,IAAI,OAAS,CAAC,EAE/D,SAAS,YAAa,QAAS,CAC3B,GAAI,OAAO,QAAU,MAAO,CACxB,OAAO,KAAK,CACR,OACA,MAAO,OAAO,MAAM,CAAC,EAAE,SAAS,CACpC,CAAC,CACL,CACJ,CAAC,EAED,OAAO,YAAa,QAAS,CACzB,GAAI,OAAO,QAAU,MAAO,CACxB,MACJ,CACA,IAAI,MAAQ,OAAO,MAAM,CAAC,EAAE,SAAS,EAErC,IAAI,SAAW,OAAO,KAAM,OAAQ,MAAM,QAAU,KAAK,EAEzD,GAAI,CAAC,SAAU,CACX,MACJ,CAEA,IAAI,YAAc,CAAC,EACnB,IAAI,KAAO,OAAO,KAAK,EACvB,MAAM,MAAQ,KAAK,OAAS,aAAa,CACrC,YAAY,KAAK,IAAI,EACrB,KAAO,KAAK,KAAK,CACrB,CACA,IAAI,WAAa,KACjB,SAAS,OAAO,OAAO,YAAY,SAAS,OAAQ,uBAAuB,QAAQ,SAAS,CACxF,MAAO,YAAY,IAAK,MAAO,KAAK,MAAM,CAAC,CAC/C,CAAC,CAAC,EACF,OAAO,OAAO,EACd,YAAY,QAAS,MAAO,KAAK,OAAO,CAAC,EAIzC,GAAI,YAAc,WAAW,OAAS,aAAc,CAChD,WAAW,OAAO,CACtB,CACJ,CAAC,EACD,MAAO,CACH,SACA,MACJ,CACJ,CA/CS","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/util/formatVariantSelector.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatVariantSelector: function() {\n        return formatVariantSelector;\n    },\n    eliminateIrrelevantSelectors: function() {\n        return eliminateIrrelevantSelectors;\n    },\n    finalizeSelector: function() {\n        return finalizeSelector;\n    },\n    handleMergePseudo: function() {\n        return handleMergePseudo;\n    }\n});\nconst _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require(\"postcss-selector-parser\"));\nconst _unesc = /*#__PURE__*/ _interop_require_default(require(\"postcss-selector-parser/dist/util/unesc\"));\nconst _escapeClassName = /*#__PURE__*/ _interop_require_default(require(\"../util/escapeClassName\"));\nconst _prefixSelector = /*#__PURE__*/ _interop_require_default(require(\"../util/prefixSelector\"));\nconst _pseudoElements = require(\"./pseudoElements\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n/** @typedef {import('postcss-selector-parser').Root} Root */ /** @typedef {import('postcss-selector-parser').Selector} Selector */ /** @typedef {import('postcss-selector-parser').Pseudo} Pseudo */ /** @typedef {import('postcss-selector-parser').Node} Node */ /** @typedef {{format: string, isArbitraryVariant: boolean}[]} RawFormats */ /** @typedef {import('postcss-selector-parser').Root} ParsedFormats */ /** @typedef {RawFormats | ParsedFormats} AcceptedFormats */ let MERGE = \":merge\";\nfunction formatVariantSelector(formats, { context , candidate  }) {\n    var _context_tailwindConfig_prefix;\n    let prefix = (_context_tailwindConfig_prefix = context === null || context === void 0 ? void 0 : context.tailwindConfig.prefix) !== null && _context_tailwindConfig_prefix !== void 0 ? _context_tailwindConfig_prefix : \"\";\n    // Parse the format selector into an AST\n    let parsedFormats = formats.map((format)=>{\n        let ast = (0, _postcssselectorparser.default)().astSync(format.format);\n        return {\n            ...format,\n            ast: format.isArbitraryVariant ? ast : (0, _prefixSelector.default)(prefix, ast)\n        };\n    });\n    // We start with the candidate selector\n    let formatAst = _postcssselectorparser.default.root({\n        nodes: [\n            _postcssselectorparser.default.selector({\n                nodes: [\n                    _postcssselectorparser.default.className({\n                        value: (0, _escapeClassName.default)(candidate)\n                    })\n                ]\n            })\n        ]\n    });\n    // And iteratively merge each format selector into the candidate selector\n    for (let { ast  } of parsedFormats){\n        [formatAst, ast] = handleMergePseudo(formatAst, ast);\n        // 2. Merge the format selector into the current selector AST\n        ast.walkNesting((nesting)=>nesting.replaceWith(...formatAst.nodes[0].nodes));\n        // 3. Keep going!\n        formatAst = ast;\n    }\n    return formatAst;\n}\n/**\n * Given any node in a selector this gets the \"simple\" selector it's a part of\n * A simple selector is just a list of nodes without any combinators\n * Technically :is(), :not(), :has(), etc… can have combinators but those are nested\n * inside the relevant node and won't be picked up so they're fine to ignore\n *\n * @param {Node} node\n * @returns {Node[]}\n **/ function simpleSelectorForNode(node) {\n    /** @type {Node[]} */ let nodes = [];\n    // Walk backwards until we hit a combinator node (or the start)\n    while(node.prev() && node.prev().type !== \"combinator\"){\n        node = node.prev();\n    }\n    // Now record all non-combinator nodes until we hit one (or the end)\n    while(node && node.type !== \"combinator\"){\n        nodes.push(node);\n        node = node.next();\n    }\n    return nodes;\n}\n/**\n * Resorts the nodes in a selector to ensure they're in the correct order\n * Tags go before classes, and pseudo classes go after classes\n *\n * @param {Selector} sel\n * @returns {Selector}\n **/ function resortSelector(sel) {\n    sel.sort((a, b)=>{\n        if (a.type === \"tag\" && b.type === \"class\") {\n            return -1;\n        } else if (a.type === \"class\" && b.type === \"tag\") {\n            return 1;\n        } else if (a.type === \"class\" && b.type === \"pseudo\" && b.value.startsWith(\"::\")) {\n            return -1;\n        } else if (a.type === \"pseudo\" && a.value.startsWith(\"::\") && b.type === \"class\") {\n            return 1;\n        }\n        return sel.index(a) - sel.index(b);\n    });\n    return sel;\n}\nfunction eliminateIrrelevantSelectors(sel, base) {\n    let hasClassesMatchingCandidate = false;\n    sel.walk((child)=>{\n        if (child.type === \"class\" && child.value === base) {\n            hasClassesMatchingCandidate = true;\n            return false // Stop walking\n            ;\n        }\n    });\n    if (!hasClassesMatchingCandidate) {\n        sel.remove();\n    }\n// We do NOT recursively eliminate sub selectors that don't have the base class\n// as this is NOT a safe operation. For example, if we have:\n// `.space-x-2 > :not([hidden]) ~ :not([hidden])`\n// We cannot remove the [hidden] from the :not() because it would change the\n// meaning of the selector.\n// TODO: Can we do this for :matches, :is, and :where?\n}\nfunction finalizeSelector(current, formats, { context , candidate , base  }) {\n    var _context_tailwindConfig;\n    var _context_tailwindConfig_separator;\n    let separator = (_context_tailwindConfig_separator = context === null || context === void 0 ? void 0 : (_context_tailwindConfig = context.tailwindConfig) === null || _context_tailwindConfig === void 0 ? void 0 : _context_tailwindConfig.separator) !== null && _context_tailwindConfig_separator !== void 0 ? _context_tailwindConfig_separator : \":\";\n    // Split by the separator, but ignore the separator inside square brackets:\n    //\n    // E.g.: dark:lg:hover:[paint-order:markers]\n    //           ┬  ┬     ┬            ┬\n    //           │  │     │            ╰── We will not split here\n    //           ╰──┴─────┴─────────────── We will split here\n    //\n    base = base !== null && base !== void 0 ? base : candidate.split(new RegExp(`\\\\${separator}(?![^[]*\\\\])`)).pop();\n    // Parse the selector into an AST\n    let selector = (0, _postcssselectorparser.default)().astSync(current);\n    // Normalize escaped classes, e.g.:\n    //\n    // The idea would be to replace the escaped `base` in the selector with the\n    // `format`. However, in css you can escape the same selector in a few\n    // different ways. This would result in different strings and therefore we\n    // can't replace it properly.\n    //\n    //               base: bg-[rgb(255,0,0)]\n    //   base in selector: bg-\\\\[rgb\\\\(255\\\\,0\\\\,0\\\\)\\\\]\n    //       escaped base: bg-\\\\[rgb\\\\(255\\\\2c 0\\\\2c 0\\\\)\\\\]\n    //\n    selector.walkClasses((node)=>{\n        if (node.raws && node.value.includes(base)) {\n            node.raws.value = (0, _escapeClassName.default)((0, _unesc.default)(node.raws.value));\n        }\n    });\n    // Remove extraneous selectors that do not include the base candidate\n    selector.each((sel)=>eliminateIrrelevantSelectors(sel, base));\n    // If there are no formats that means there were no variants added to the candidate\n    // so we can just return the selector as-is\n    let formatAst = Array.isArray(formats) ? formatVariantSelector(formats, {\n        context,\n        candidate\n    }) : formats;\n    if (formatAst === null) {\n        return selector.toString();\n    }\n    let simpleStart = _postcssselectorparser.default.comment({\n        value: \"/*__simple__*/\"\n    });\n    let simpleEnd = _postcssselectorparser.default.comment({\n        value: \"/*__simple__*/\"\n    });\n    // We can safely replace the escaped base now, since the `base` section is\n    // now in a normalized escaped value.\n    selector.walkClasses((node)=>{\n        if (node.value !== base) {\n            return;\n        }\n        let parent = node.parent;\n        let formatNodes = formatAst.nodes[0].nodes;\n        // Perf optimization: if the parent is a single class we can just replace it and be done\n        if (parent.nodes.length === 1) {\n            node.replaceWith(...formatNodes);\n            return;\n        }\n        let simpleSelector = simpleSelectorForNode(node);\n        parent.insertBefore(simpleSelector[0], simpleStart);\n        parent.insertAfter(simpleSelector[simpleSelector.length - 1], simpleEnd);\n        for (let child of formatNodes){\n            parent.insertBefore(simpleSelector[0], child.clone());\n        }\n        node.remove();\n        // Re-sort the simple selector to ensure it's in the correct order\n        simpleSelector = simpleSelectorForNode(simpleStart);\n        let firstNode = parent.index(simpleStart);\n        parent.nodes.splice(firstNode, simpleSelector.length, ...resortSelector(_postcssselectorparser.default.selector({\n            nodes: simpleSelector\n        })).nodes);\n        simpleStart.remove();\n        simpleEnd.remove();\n    });\n    // Remove unnecessary pseudo selectors that we used as placeholders\n    selector.walkPseudos((p)=>{\n        if (p.value === MERGE) {\n            p.replaceWith(p.nodes);\n        }\n    });\n    // Move pseudo elements to the end of the selector (if necessary)\n    selector.each((sel)=>(0, _pseudoElements.movePseudos)(sel));\n    return selector.toString();\n}\nfunction handleMergePseudo(selector, format) {\n    /** @type {{pseudo: Pseudo, value: string}[]} */ let merges = [];\n    // Find all :merge() pseudo-classes in `selector`\n    selector.walkPseudos((pseudo)=>{\n        if (pseudo.value === MERGE) {\n            merges.push({\n                pseudo,\n                value: pseudo.nodes[0].toString()\n            });\n        }\n    });\n    // Find all :merge() \"attachments\" in `format` and attach them to the matching selector in `selector`\n    format.walkPseudos((pseudo)=>{\n        if (pseudo.value !== MERGE) {\n            return;\n        }\n        let value = pseudo.nodes[0].toString();\n        // Does `selector` contain a :merge() pseudo-class with the same value?\n        let existing = merges.find((merge)=>merge.value === value);\n        // Nope so there's nothing to do\n        if (!existing) {\n            return;\n        }\n        // Everything after `:merge()` up to the next combinator is what is attached to the merged selector\n        let attachments = [];\n        let next = pseudo.next();\n        while(next && next.type !== \"combinator\"){\n            attachments.push(next);\n            next = next.next();\n        }\n        let combinator = next;\n        existing.pseudo.parent.insertAfter(existing.pseudo, _postcssselectorparser.default.selector({\n            nodes: attachments.map((node)=>node.clone())\n        }));\n        pseudo.remove();\n        attachments.forEach((node)=>node.remove());\n        // What about this case:\n        // :merge(.group):focus > &\n        // :merge(.group):hover &\n        if (combinator && combinator.type === \"combinator\") {\n            combinator.remove();\n        }\n    });\n    return [\n        selector,\n        format\n    ];\n}\n"]}}