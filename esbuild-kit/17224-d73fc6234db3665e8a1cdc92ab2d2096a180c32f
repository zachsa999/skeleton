{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});Object.defineProperty(exports,\"default\",{enumerable:true,get:function(){return expandTailwindAtRules}});const _fs=_interop_require_default(require(\"fs\"));const _quicklru=_interop_require_default(require(\"@alloc/quick-lru\"));const _sharedState=_interop_require_wildcard(require(\"./sharedState\"));const _generateRules=require(\"./generateRules\");const _log=_interop_require_default(require(\"../util/log\"));const _cloneNodes=_interop_require_default(require(\"../util/cloneNodes\"));const _defaultExtractor=require(\"./defaultExtractor\");function _interop_require_default(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interop_require_default,\"_interop_require_default\");function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!==\"function\")return null;var cacheBabelInterop=new WeakMap;var cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=__name(function(nodeInterop2){return nodeInterop2?cacheNodeInterop:cacheBabelInterop},\"_getRequireWildcardCache\"))(nodeInterop)}__name(_getRequireWildcardCache,\"_getRequireWildcardCache\");function _interop_require_wildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj}if(obj===null||typeof obj!==\"object\"&&typeof obj!==\"function\"){return{default:obj}}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj)}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!==\"default\"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}newObj.default=obj;if(cache){cache.set(obj,newObj)}return newObj}__name(_interop_require_wildcard,\"_interop_require_wildcard\");let env=_sharedState.env;const builtInExtractors={DEFAULT:_defaultExtractor.defaultExtractor};const builtInTransformers={DEFAULT:content=>content,svelte:content=>content.replace(/(?:^|\\s)class:/g,\" \")};function getExtractor(context,fileExtension){let extractors=context.tailwindConfig.content.extract;return extractors[fileExtension]||extractors.DEFAULT||builtInExtractors[fileExtension]||builtInExtractors.DEFAULT(context)}__name(getExtractor,\"getExtractor\");function getTransformer(tailwindConfig,fileExtension){let transformers=tailwindConfig.content.transform;return transformers[fileExtension]||transformers.DEFAULT||builtInTransformers[fileExtension]||builtInTransformers.DEFAULT}__name(getTransformer,\"getTransformer\");let extractorCache=new WeakMap;function getClassCandidates(content,extractor,candidates,seen){if(!extractorCache.has(extractor)){extractorCache.set(extractor,new _quicklru.default({maxSize:25e3}))}for(let line of content.split(\"\\n\")){line=line.trim();if(seen.has(line)){continue}seen.add(line);if(extractorCache.get(extractor).has(line)){for(let match of extractorCache.get(extractor).get(line)){candidates.add(match)}}else{let extractorMatches=extractor(line).filter(s=>s!==\"!*\");let lineMatchesSet=new Set(extractorMatches);for(let match of lineMatchesSet){candidates.add(match)}extractorCache.get(extractor).set(line,lineMatchesSet)}}}__name(getClassCandidates,\"getClassCandidates\");function buildStylesheet(rules,context){let sortedRules=context.offsets.sort(rules);let returnValue={base:new Set,defaults:new Set,components:new Set,utilities:new Set,variants:new Set};for(let[sort,rule]of sortedRules){returnValue[sort.layer].add(rule)}return returnValue}__name(buildStylesheet,\"buildStylesheet\");function expandTailwindAtRules(context){return root=>{let layerNodes={base:null,components:null,utilities:null,variants:null};root.walkAtRules(rule=>{if(rule.name===\"tailwind\"){if(Object.keys(layerNodes).includes(rule.params)){layerNodes[rule.params]=rule}}});if(Object.values(layerNodes).every(n=>n===null)){return root}var _context_candidates;let candidates=new Set([...(_context_candidates=context.candidates)!==null&&_context_candidates!==void 0?_context_candidates:[],_sharedState.NOT_ON_DEMAND]);let seen=new Set;env.DEBUG&&console.time(\"Reading changed files\");if(false){for(let candidate of null.parseCandidateStringsFromFiles(context.changedContent)){candidates.add(candidate)}}else{for(let{file,content,extension}of context.changedContent){let transformer=getTransformer(context.tailwindConfig,extension);let extractor=getExtractor(context,extension);content=file?_fs.default.readFileSync(file,\"utf8\"):content;getClassCandidates(transformer(content),extractor,candidates,seen)}}env.DEBUG&&console.timeEnd(\"Reading changed files\");let classCacheCount=context.classCache.size;env.DEBUG&&console.time(\"Generate rules\");env.DEBUG&&console.time(\"Sorting candidates\");let sortedCandidates=false?candidates:new Set([...candidates].sort((a,z)=>{if(a===z)return 0;if(a<z)return-1;return 1}));env.DEBUG&&console.timeEnd(\"Sorting candidates\");(0,_generateRules.generateRules)(sortedCandidates,context);env.DEBUG&&console.timeEnd(\"Generate rules\");env.DEBUG&&console.time(\"Build stylesheet\");if(context.stylesheetCache===null||context.classCache.size!==classCacheCount){context.stylesheetCache=buildStylesheet([...context.ruleCache],context)}env.DEBUG&&console.timeEnd(\"Build stylesheet\");let{defaults:defaultNodes,base:baseNodes,components:componentNodes,utilities:utilityNodes,variants:screenNodes}=context.stylesheetCache;if(layerNodes.base){layerNodes.base.before((0,_cloneNodes.default)([...baseNodes,...defaultNodes],layerNodes.base.source,{layer:\"base\"}));layerNodes.base.remove()}if(layerNodes.components){layerNodes.components.before((0,_cloneNodes.default)([...componentNodes],layerNodes.components.source,{layer:\"components\"}));layerNodes.components.remove()}if(layerNodes.utilities){layerNodes.utilities.before((0,_cloneNodes.default)([...utilityNodes],layerNodes.utilities.source,{layer:\"utilities\"}));layerNodes.utilities.remove()}const variantNodes=Array.from(screenNodes).filter(node=>{var _node_raws_tailwind;const parentLayer=(_node_raws_tailwind=node.raws.tailwind)===null||_node_raws_tailwind===void 0?void 0:_node_raws_tailwind.parentLayer;if(parentLayer===\"components\"){return layerNodes.components!==null}if(parentLayer===\"utilities\"){return layerNodes.utilities!==null}return true});if(layerNodes.variants){layerNodes.variants.before((0,_cloneNodes.default)(variantNodes,layerNodes.variants.source,{layer:\"variants\"}));layerNodes.variants.remove()}else if(variantNodes.length>0){root.append((0,_cloneNodes.default)(variantNodes,root.source,{layer:\"variants\"}))}const hasUtilityVariants=variantNodes.some(node=>{var _node_raws_tailwind;return((_node_raws_tailwind=node.raws.tailwind)===null||_node_raws_tailwind===void 0?void 0:_node_raws_tailwind.parentLayer)===\"utilities\"});if(layerNodes.utilities&&utilityNodes.size===0&&!hasUtilityVariants){_log.default.warn(\"content-problems\",[\"No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.\",\"https://tailwindcss.com/docs/content-configuration\"])}if(env.DEBUG){console.log(\"Potential classes: \",candidates.size);console.log(\"Active contexts: \",_sharedState.contextSourcesMap.size)}context.changedContent=[];root.walkAtRules(\"layer\",rule=>{if(Object.keys(layerNodes).includes(rule.params)){rule.remove()}})}}__name(expandTailwindAtRules,\"expandTailwindAtRules\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["nodeInterop"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/lib/expandTailwindAtRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return expandTailwindAtRules;\n    }\n});\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _quicklru = /*#__PURE__*/ _interop_require_default(require(\"@alloc/quick-lru\"));\nconst _sharedState = /*#__PURE__*/ _interop_require_wildcard(require(\"./sharedState\"));\nconst _generateRules = require(\"./generateRules\");\nconst _log = /*#__PURE__*/ _interop_require_default(require(\"../util/log\"));\nconst _cloneNodes = /*#__PURE__*/ _interop_require_default(require(\"../util/cloneNodes\"));\nconst _defaultExtractor = require(\"./defaultExtractor\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet env = _sharedState.env;\nconst builtInExtractors = {\n    DEFAULT: _defaultExtractor.defaultExtractor\n};\nconst builtInTransformers = {\n    DEFAULT: (content)=>content,\n    svelte: (content)=>content.replace(/(?:^|\\s)class:/g, \" \")\n};\nfunction getExtractor(context, fileExtension) {\n    let extractors = context.tailwindConfig.content.extract;\n    return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);\n}\nfunction getTransformer(tailwindConfig, fileExtension) {\n    let transformers = tailwindConfig.content.transform;\n    return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;\n}\nlet extractorCache = new WeakMap();\n// Scans template contents for possible classes. This is a hot path on initial build but\n// not too important for subsequent builds. The faster the better though — if we can speed\n// up these regexes by 50% that could cut initial build time by like 20%.\nfunction getClassCandidates(content, extractor, candidates, seen) {\n    if (!extractorCache.has(extractor)) {\n        extractorCache.set(extractor, new _quicklru.default({\n            maxSize: 25000\n        }));\n    }\n    for (let line of content.split(\"\\n\")){\n        line = line.trim();\n        if (seen.has(line)) {\n            continue;\n        }\n        seen.add(line);\n        if (extractorCache.get(extractor).has(line)) {\n            for (let match of extractorCache.get(extractor).get(line)){\n                candidates.add(match);\n            }\n        } else {\n            let extractorMatches = extractor(line).filter((s)=>s !== \"!*\");\n            let lineMatchesSet = new Set(extractorMatches);\n            for (let match of lineMatchesSet){\n                candidates.add(match);\n            }\n            extractorCache.get(extractor).set(line, lineMatchesSet);\n        }\n    }\n}\n/**\n *\n * @param {[import('./offsets.js').RuleOffset, import('postcss').Node][]} rules\n * @param {*} context\n */ function buildStylesheet(rules, context) {\n    let sortedRules = context.offsets.sort(rules);\n    let returnValue = {\n        base: new Set(),\n        defaults: new Set(),\n        components: new Set(),\n        utilities: new Set(),\n        variants: new Set()\n    };\n    for (let [sort, rule] of sortedRules){\n        returnValue[sort.layer].add(rule);\n    }\n    return returnValue;\n}\nfunction expandTailwindAtRules(context) {\n    return (root)=>{\n        let layerNodes = {\n            base: null,\n            components: null,\n            utilities: null,\n            variants: null\n        };\n        root.walkAtRules((rule)=>{\n            // Make sure this file contains Tailwind directives. If not, we can save\n            // a lot of work and bail early. Also we don't have to register our touch\n            // file as a dependency since the output of this CSS does not depend on\n            // the source of any templates. Think Vue <style> blocks for example.\n            if (rule.name === \"tailwind\") {\n                if (Object.keys(layerNodes).includes(rule.params)) {\n                    layerNodes[rule.params] = rule;\n                }\n            }\n        });\n        if (Object.values(layerNodes).every((n)=>n === null)) {\n            return root;\n        }\n        var _context_candidates;\n        // ---\n        // Find potential rules in changed files\n        let candidates = new Set([\n            ...(_context_candidates = context.candidates) !== null && _context_candidates !== void 0 ? _context_candidates : [],\n            _sharedState.NOT_ON_DEMAND\n        ]);\n        let seen = new Set();\n        env.DEBUG && console.time(\"Reading changed files\");\n        if (false) {\n            // TODO: Pass through or implement `extractor`\n            for (let candidate of require(\"@tailwindcss/oxide\").parseCandidateStringsFromFiles(context.changedContent)){\n                candidates.add(candidate);\n            }\n        // for (let { file, content, extension } of context.changedContent) {\n        //   let transformer = getTransformer(context.tailwindConfig, extension)\n        //   let extractor = getExtractor(context, extension)\n        //   getClassCandidatesOxide(file, transformer(content), extractor, candidates, seen)\n        // }\n        } else {\n            for (let { file , content , extension  } of context.changedContent){\n                let transformer = getTransformer(context.tailwindConfig, extension);\n                let extractor = getExtractor(context, extension);\n                content = file ? _fs.default.readFileSync(file, \"utf8\") : content;\n                getClassCandidates(transformer(content), extractor, candidates, seen);\n            }\n        }\n        env.DEBUG && console.timeEnd(\"Reading changed files\");\n        // ---\n        // Generate the actual CSS\n        let classCacheCount = context.classCache.size;\n        env.DEBUG && console.time(\"Generate rules\");\n        env.DEBUG && console.time(\"Sorting candidates\");\n        let sortedCandidates = false ? candidates : new Set([\n            ...candidates\n        ].sort((a, z)=>{\n            if (a === z) return 0;\n            if (a < z) return -1;\n            return 1;\n        }));\n        env.DEBUG && console.timeEnd(\"Sorting candidates\");\n        (0, _generateRules.generateRules)(sortedCandidates, context);\n        env.DEBUG && console.timeEnd(\"Generate rules\");\n        // We only ever add to the classCache, so if it didn't grow, there is nothing new.\n        env.DEBUG && console.time(\"Build stylesheet\");\n        if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {\n            context.stylesheetCache = buildStylesheet([\n                ...context.ruleCache\n            ], context);\n        }\n        env.DEBUG && console.timeEnd(\"Build stylesheet\");\n        let { defaults: defaultNodes , base: baseNodes , components: componentNodes , utilities: utilityNodes , variants: screenNodes  } = context.stylesheetCache;\n        // ---\n        // Replace any Tailwind directives with generated CSS\n        if (layerNodes.base) {\n            layerNodes.base.before((0, _cloneNodes.default)([\n                ...baseNodes,\n                ...defaultNodes\n            ], layerNodes.base.source, {\n                layer: \"base\"\n            }));\n            layerNodes.base.remove();\n        }\n        if (layerNodes.components) {\n            layerNodes.components.before((0, _cloneNodes.default)([\n                ...componentNodes\n            ], layerNodes.components.source, {\n                layer: \"components\"\n            }));\n            layerNodes.components.remove();\n        }\n        if (layerNodes.utilities) {\n            layerNodes.utilities.before((0, _cloneNodes.default)([\n                ...utilityNodes\n            ], layerNodes.utilities.source, {\n                layer: \"utilities\"\n            }));\n            layerNodes.utilities.remove();\n        }\n        // We do post-filtering to not alter the emitted order of the variants\n        const variantNodes = Array.from(screenNodes).filter((node)=>{\n            var _node_raws_tailwind;\n            const parentLayer = (_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer;\n            if (parentLayer === \"components\") {\n                return layerNodes.components !== null;\n            }\n            if (parentLayer === \"utilities\") {\n                return layerNodes.utilities !== null;\n            }\n            return true;\n        });\n        if (layerNodes.variants) {\n            layerNodes.variants.before((0, _cloneNodes.default)(variantNodes, layerNodes.variants.source, {\n                layer: \"variants\"\n            }));\n            layerNodes.variants.remove();\n        } else if (variantNodes.length > 0) {\n            root.append((0, _cloneNodes.default)(variantNodes, root.source, {\n                layer: \"variants\"\n            }));\n        }\n        // If we've got a utility layer and no utilities are generated there's likely something wrong\n        const hasUtilityVariants = variantNodes.some((node)=>{\n            var _node_raws_tailwind;\n            return ((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer) === \"utilities\";\n        });\n        if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {\n            _log.default.warn(\"content-problems\", [\n                \"No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.\",\n                \"https://tailwindcss.com/docs/content-configuration\"\n            ]);\n        }\n        // ---\n        if (env.DEBUG) {\n            console.log(\"Potential classes: \", candidates.size);\n            console.log(\"Active contexts: \", _sharedState.contextSourcesMap.size);\n        }\n        // Clear the cache for the changed files\n        context.changedContent = [];\n        // Cleanup any leftover @layer atrules\n        root.walkAtRules(\"layer\", (rule)=>{\n            if (Object.keys(layerNodes).includes(rule.params)) {\n                rule.remove();\n            }\n        });\n    };\n}\n"]}}