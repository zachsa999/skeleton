{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});Object.defineProperty(exports,\"defaultExtractor\",{enumerable:true,get:function(){return defaultExtractor}});const _featureFlags=require(\"../featureFlags\");const _regex=_interop_require_wildcard(require(\"./regex\"));function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!==\"function\")return null;var cacheBabelInterop=new WeakMap;var cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=__name(function(nodeInterop2){return nodeInterop2?cacheNodeInterop:cacheBabelInterop},\"_getRequireWildcardCache\"))(nodeInterop)}__name(_getRequireWildcardCache,\"_getRequireWildcardCache\");function _interop_require_wildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj}if(obj===null||typeof obj!==\"object\"&&typeof obj!==\"function\"){return{default:obj}}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj)}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!==\"default\"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}newObj.default=obj;if(cache){cache.set(obj,newObj)}return newObj}__name(_interop_require_wildcard,\"_interop_require_wildcard\");function defaultExtractor(context){let patterns=Array.from(buildRegExps(context));return content=>{let results=[];for(let pattern of patterns){var _content_match;results=[...results,...(_content_match=content.match(pattern))!==null&&_content_match!==void 0?_content_match:[]]}return results.filter(v=>v!==void 0).map(clipAtBalancedParens)}}__name(defaultExtractor,\"defaultExtractor\");function*buildRegExps(context){let separator=context.tailwindConfig.separator;let variantGroupingEnabled=(0,_featureFlags.flagEnabled)(context.tailwindConfig,\"variantGrouping\");let prefix=context.tailwindConfig.prefix!==\"\"?_regex.optional(_regex.pattern([/-?/,_regex.escape(context.tailwindConfig.prefix)])):\"\";let utility=_regex.any([/\\[[^\\s:'\"`]+:[^\\s\\[\\]]+\\]/,/\\[[^\\s:'\"`]+:[^\\s]+?\\[[^\\s]+\\][^\\s]+?\\]/,_regex.pattern([/-?(?:\\w+)/,_regex.optional(_regex.any([_regex.pattern([/-(?:\\w+-)*\\[[^\\s:]+\\]/,/(?![{([]])/,/(?:\\/[^\\s'\"`\\\\><$]*)?/]),_regex.pattern([/-(?:\\w+-)*\\[[^\\s]+\\]/,/(?![{([]])/,/(?:\\/[^\\s'\"`\\\\$]*)?/]),/[-\\/][^\\s'\"`\\\\$={><]*/]))])]);let variantPatterns=[_regex.any([_regex.pattern([/@\\[[^\\s\"'`]+\\](\\/[^\\s\"'`]+)?/,separator]),_regex.pattern([/([^\\s\"'`\\[\\\\]+-)?\\[[^\\s\"'`]+\\]/,separator]),_regex.pattern([/[^\\s\"'`\\[\\\\]+/,separator])]),_regex.any([_regex.pattern([/([^\\s\"'`\\[\\\\]+-)?\\[[^\\s`]+\\]/,separator]),_regex.pattern([/[^\\s`\\[\\\\]+/,separator])])];for(const variantPattern of variantPatterns){yield _regex.pattern([\"((?=((\",variantPattern,\")+))\\\\2)?\",/!?/,prefix,variantGroupingEnabled?_regex.any([_regex.pattern([/\\(/,utility,_regex.zeroOrMore([/,/,utility]),/\\)/]),utility]):utility])}yield/[^<>\"'`\\s.(){}[\\]#=%$]*[^<>\"'`\\s.(){}[\\]#=%:$]/g}__name(buildRegExps,\"buildRegExps\");let SPECIALS=/([\\[\\]'\"`])([^\\[\\]'\"`])?/g;let ALLOWED_CLASS_CHARACTERS=/[^\"'`\\s<>\\]]+/;function clipAtBalancedParens(input){if(!input.includes(\"-[\")){return input}let depth=0;let openStringTypes=[];let matches=input.matchAll(SPECIALS);matches=Array.from(matches).flatMap(match=>{const[,...groups]=match;return groups.map((group,idx)=>Object.assign([],match,{index:match.index+idx,0:group}))});for(let match of matches){let char=match[0];let inStringType=openStringTypes[openStringTypes.length-1];if(char===inStringType){openStringTypes.pop()}else if(char===\"'\"||char==='\"'||char===\"`\"){openStringTypes.push(char)}if(inStringType){continue}else if(char===\"[\"){depth++;continue}else if(char===\"]\"){depth--;continue}if(depth<0){return input.substring(0,match.index-1)}if(depth===0&&!ALLOWED_CLASS_CHARACTERS.test(char)){return input.substring(0,match.index)}}return input}__name(clipAtBalancedParens,\"clipAtBalancedParens\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":["nodeInterop"],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/tailwindcss@3.3.2/node_modules/tailwindcss/lib/lib/defaultExtractor.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"defaultExtractor\", {\n    enumerable: true,\n    get: function() {\n        return defaultExtractor;\n    }\n});\nconst _featureFlags = require(\"../featureFlags\");\nconst _regex = /*#__PURE__*/ _interop_require_wildcard(require(\"./regex\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction defaultExtractor(context) {\n    let patterns = Array.from(buildRegExps(context));\n    /**\n   * @param {string} content\n   */ return (content)=>{\n        /** @type {(string|string)[]} */ let results = [];\n        for (let pattern of patterns){\n            var _content_match;\n            results = [\n                ...results,\n                ...(_content_match = content.match(pattern)) !== null && _content_match !== void 0 ? _content_match : []\n            ];\n        }\n        return results.filter((v)=>v !== undefined).map(clipAtBalancedParens);\n    };\n}\nfunction* buildRegExps(context) {\n    let separator = context.tailwindConfig.separator;\n    let variantGroupingEnabled = (0, _featureFlags.flagEnabled)(context.tailwindConfig, \"variantGrouping\");\n    let prefix = context.tailwindConfig.prefix !== \"\" ? _regex.optional(_regex.pattern([\n        /-?/,\n        _regex.escape(context.tailwindConfig.prefix)\n    ])) : \"\";\n    let utility = _regex.any([\n        // Arbitrary properties (without square brackets)\n        /\\[[^\\s:'\"`]+:[^\\s\\[\\]]+\\]/,\n        // Arbitrary properties with balanced square brackets\n        // This is a targeted fix to continue to allow theme()\n        // with square brackets to work in arbitrary properties\n        // while fixing a problem with the regex matching too much\n        /\\[[^\\s:'\"`]+:[^\\s]+?\\[[^\\s]+\\][^\\s]+?\\]/,\n        // Utilities\n        _regex.pattern([\n            // Utility Name / Group Name\n            /-?(?:\\w+)/,\n            // Normal/Arbitrary values\n            _regex.optional(_regex.any([\n                _regex.pattern([\n                    // Arbitrary values\n                    /-(?:\\w+-)*\\[[^\\s:]+\\]/,\n                    // Not immediately followed by an `{[(`\n                    /(?![{([]])/,\n                    // optionally followed by an opacity modifier\n                    /(?:\\/[^\\s'\"`\\\\><$]*)?/\n                ]),\n                _regex.pattern([\n                    // Arbitrary values\n                    /-(?:\\w+-)*\\[[^\\s]+\\]/,\n                    // Not immediately followed by an `{[(`\n                    /(?![{([]])/,\n                    // optionally followed by an opacity modifier\n                    /(?:\\/[^\\s'\"`\\\\$]*)?/\n                ]),\n                // Normal values w/o quotes — may include an opacity modifier\n                /[-\\/][^\\s'\"`\\\\$={><]*/\n            ]))\n        ])\n    ]);\n    let variantPatterns = [\n        // Without quotes\n        _regex.any([\n            // This is here to provide special support for the `@` variant\n            _regex.pattern([\n                /@\\[[^\\s\"'`]+\\](\\/[^\\s\"'`]+)?/,\n                separator\n            ]),\n            _regex.pattern([\n                /([^\\s\"'`\\[\\\\]+-)?\\[[^\\s\"'`]+\\]/,\n                separator\n            ]),\n            _regex.pattern([\n                /[^\\s\"'`\\[\\\\]+/,\n                separator\n            ])\n        ]),\n        // With quotes allowed\n        _regex.any([\n            _regex.pattern([\n                /([^\\s\"'`\\[\\\\]+-)?\\[[^\\s`]+\\]/,\n                separator\n            ]),\n            _regex.pattern([\n                /[^\\s`\\[\\\\]+/,\n                separator\n            ])\n        ])\n    ];\n    for (const variantPattern of variantPatterns){\n        yield _regex.pattern([\n            // Variants\n            \"((?=((\",\n            variantPattern,\n            \")+))\\\\2)?\",\n            // Important (optional)\n            /!?/,\n            prefix,\n            variantGroupingEnabled ? _regex.any([\n                // Or any of those things but grouped separated by commas\n                _regex.pattern([\n                    /\\(/,\n                    utility,\n                    _regex.zeroOrMore([\n                        /,/,\n                        utility\n                    ]),\n                    /\\)/\n                ]),\n                // Arbitrary properties, constrained utilities, arbitrary values, etc…\n                utility\n            ]) : utility\n        ]);\n    }\n    // 5. Inner matches\n    yield /[^<>\"'`\\s.(){}[\\]#=%$]*[^<>\"'`\\s.(){}[\\]#=%:$]/g;\n}\n// We want to capture any \"special\" characters\n// AND the characters immediately following them (if there is one)\nlet SPECIALS = /([\\[\\]'\"`])([^\\[\\]'\"`])?/g;\nlet ALLOWED_CLASS_CHARACTERS = /[^\"'`\\s<>\\]]+/;\n/**\n * Clips a string ensuring that parentheses, quotes, etc… are balanced\n * Used for arbitrary values only\n *\n * We will go past the end of the balanced parens until we find a non-class character\n *\n * Depth matching behavior:\n * w-[calc(100%-theme('spacing[some_key][1.5]'))]']\n *   ┬    ┬          ┬┬       ┬        ┬┬   ┬┬┬┬┬┬┬\n *   1    2          3        4        34   3 210 END\n *   ╰────┴──────────┴────────┴────────┴┴───┴─┴┴┴\n *\n * @param {string} input\n */ function clipAtBalancedParens(input) {\n    // We are care about this for arbitrary values\n    if (!input.includes(\"-[\")) {\n        return input;\n    }\n    let depth = 0;\n    let openStringTypes = [];\n    // Find all parens, brackets, quotes, etc\n    // Stop when we end at a balanced pair\n    // This is naive and will treat mismatched parens as balanced\n    // This shouldn't be a problem in practice though\n    let matches = input.matchAll(SPECIALS);\n    // We can't use lookbehind assertions because we have to support Safari\n    // So, instead, we've emulated it using capture groups and we'll re-work the matches to accommodate\n    matches = Array.from(matches).flatMap((match)=>{\n        const [, ...groups] = match;\n        return groups.map((group, idx)=>Object.assign([], match, {\n                index: match.index + idx,\n                0: group\n            }));\n    });\n    for (let match of matches){\n        let char = match[0];\n        let inStringType = openStringTypes[openStringTypes.length - 1];\n        if (char === inStringType) {\n            openStringTypes.pop();\n        } else if (char === \"'\" || char === '\"' || char === \"`\") {\n            openStringTypes.push(char);\n        }\n        if (inStringType) {\n            continue;\n        } else if (char === \"[\") {\n            depth++;\n            continue;\n        } else if (char === \"]\") {\n            depth--;\n            continue;\n        }\n        // We've gone one character past the point where we should stop\n        // This means that there was an extra closing `]`\n        // We'll clip to just before it\n        if (depth < 0) {\n            return input.substring(0, match.index - 1);\n        }\n        // We've finished balancing the brackets but there still may be characters that can be included\n        // For example in the class `text-[#336699]/[.35]`\n        // The depth goes to `0` at the closing `]` but goes up again at the `[`\n        // If we're at zero and encounter a non-class character then we clip the class there\n        if (depth === 0 && !ALLOWED_CLASS_CHARACTERS.test(char)) {\n            return input.substring(0, match.index);\n        }\n    }\n    return input;\n} // Regular utilities\n // {{modifier}:}*{namespace}{-{suffix}}*{/{opacityModifier}}?\n // Arbitrary values\n // {{modifier}:}*{namespace}-[{arbitraryValue}]{/{opacityModifier}}?\n // arbitraryValue: no whitespace, balanced quotes unless within quotes, balanced brackets unless within quotes\n // Arbitrary properties\n // {{modifier}:}*[{validCssPropertyName}:{arbitraryValue}]\n"]}}