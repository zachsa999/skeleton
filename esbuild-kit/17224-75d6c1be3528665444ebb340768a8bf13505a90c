{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _flow=require(\"../plugins/flow\");var _index=require(\"../plugins/jsx/index\");var _types=require(\"../plugins/types\");var _typescript=require(\"../plugins/typescript\");var _index3=require(\"../tokenizer/index\");var _keywords=require(\"../tokenizer/keywords\");var _state=require(\"../tokenizer/state\");var _types3=require(\"../tokenizer/types\");var _charcodes=require(\"../util/charcodes\");var _identifier=require(\"../util/identifier\");var _base=require(\"./base\");var _lval=require(\"./lval\");var _statement=require(\"./statement\");var _util=require(\"./util\");class StopState{constructor(stop){this.stop=stop}}__name(StopState,\"StopState\");exports.StopState=StopState;function parseExpression(noIn=false){parseMaybeAssign(noIn);if(_index3.match.call(void 0,_types3.TokenType.comma)){while(_index3.eat.call(void 0,_types3.TokenType.comma)){parseMaybeAssign(noIn)}}}__name(parseExpression,\"parseExpression\");exports.parseExpression=parseExpression;function parseMaybeAssign(noIn=false,isWithinParens=false){if(_base.isTypeScriptEnabled){return _typescript.tsParseMaybeAssign.call(void 0,noIn,isWithinParens)}else if(_base.isFlowEnabled){return _flow.flowParseMaybeAssign.call(void 0,noIn,isWithinParens)}else{return baseParseMaybeAssign(noIn,isWithinParens)}}__name(parseMaybeAssign,\"parseMaybeAssign\");exports.parseMaybeAssign=parseMaybeAssign;function baseParseMaybeAssign(noIn,isWithinParens){if(_index3.match.call(void 0,_types3.TokenType._yield)){parseYield();return false}if(_index3.match.call(void 0,_types3.TokenType.parenL)||_index3.match.call(void 0,_types3.TokenType.name)||_index3.match.call(void 0,_types3.TokenType._yield)){_base.state.potentialArrowAt=_base.state.start}const wasArrow=parseMaybeConditional(noIn);if(isWithinParens){parseParenItem()}if(_base.state.type&_types3.TokenType.IS_ASSIGN){_index3.next.call(void 0);parseMaybeAssign(noIn);return false}return wasArrow}__name(baseParseMaybeAssign,\"baseParseMaybeAssign\");exports.baseParseMaybeAssign=baseParseMaybeAssign;function parseMaybeConditional(noIn){const wasArrow=parseExprOps(noIn);if(wasArrow){return true}parseConditional(noIn);return false}__name(parseMaybeConditional,\"parseMaybeConditional\");function parseConditional(noIn){if(_base.isTypeScriptEnabled||_base.isFlowEnabled){_types.typedParseConditional.call(void 0,noIn)}else{baseParseConditional(noIn)}}__name(parseConditional,\"parseConditional\");function baseParseConditional(noIn){if(_index3.eat.call(void 0,_types3.TokenType.question)){parseMaybeAssign();_util.expect.call(void 0,_types3.TokenType.colon);parseMaybeAssign(noIn)}}__name(baseParseConditional,\"baseParseConditional\");exports.baseParseConditional=baseParseConditional;function parseExprOps(noIn){const startTokenIndex=_base.state.tokens.length;const wasArrow=parseMaybeUnary();if(wasArrow){return true}parseExprOp(startTokenIndex,-1,noIn);return false}__name(parseExprOps,\"parseExprOps\");function parseExprOp(startTokenIndex,minPrec,noIn){if(_base.isTypeScriptEnabled&&(_types3.TokenType._in&_types3.TokenType.PRECEDENCE_MASK)>minPrec&&!_util.hasPrecedingLineBreak.call(void 0)&&(_util.eatContextual.call(void 0,_keywords.ContextualKeyword._as)||_util.eatContextual.call(void 0,_keywords.ContextualKeyword._satisfies))){const oldIsType=_index3.pushTypeContext.call(void 0,1);_typescript.tsParseType.call(void 0);_index3.popTypeContext.call(void 0,oldIsType);_index3.rescan_gt.call(void 0);parseExprOp(startTokenIndex,minPrec,noIn);return}const prec=_base.state.type&_types3.TokenType.PRECEDENCE_MASK;if(prec>0&&(!noIn||!_index3.match.call(void 0,_types3.TokenType._in))){if(prec>minPrec){const op=_base.state.type;_index3.next.call(void 0);if(op===_types3.TokenType.nullishCoalescing){_base.state.tokens[_base.state.tokens.length-1].nullishStartIndex=startTokenIndex}const rhsStartTokenIndex=_base.state.tokens.length;parseMaybeUnary();parseExprOp(rhsStartTokenIndex,op&_types3.TokenType.IS_RIGHT_ASSOCIATIVE?prec-1:prec,noIn);if(op===_types3.TokenType.nullishCoalescing){_base.state.tokens[startTokenIndex].numNullishCoalesceStarts++;_base.state.tokens[_base.state.tokens.length-1].numNullishCoalesceEnds++}parseExprOp(startTokenIndex,minPrec,noIn)}}}__name(parseExprOp,\"parseExprOp\");function parseMaybeUnary(){if(_base.isTypeScriptEnabled&&!_base.isJSXEnabled&&_index3.eat.call(void 0,_types3.TokenType.lessThan)){_typescript.tsParseTypeAssertion.call(void 0);return false}if(_util.isContextual.call(void 0,_keywords.ContextualKeyword._module)&&_index3.lookaheadCharCode.call(void 0)===_charcodes.charCodes.leftCurlyBrace&&!_util.hasFollowingLineBreak.call(void 0)){parseModuleExpression();return false}if(_base.state.type&_types3.TokenType.IS_PREFIX){_index3.next.call(void 0);parseMaybeUnary();return false}const wasArrow=parseExprSubscripts();if(wasArrow){return true}while(_base.state.type&_types3.TokenType.IS_POSTFIX&&!_util.canInsertSemicolon.call(void 0)){if(_base.state.type===_types3.TokenType.preIncDec){_base.state.type=_types3.TokenType.postIncDec}_index3.next.call(void 0)}return false}__name(parseMaybeUnary,\"parseMaybeUnary\");exports.parseMaybeUnary=parseMaybeUnary;function parseExprSubscripts(){const startTokenIndex=_base.state.tokens.length;const wasArrow=parseExprAtom();if(wasArrow){return true}parseSubscripts(startTokenIndex);if(_base.state.tokens.length>startTokenIndex&&_base.state.tokens[startTokenIndex].isOptionalChainStart){_base.state.tokens[_base.state.tokens.length-1].isOptionalChainEnd=true}return false}__name(parseExprSubscripts,\"parseExprSubscripts\");exports.parseExprSubscripts=parseExprSubscripts;function parseSubscripts(startTokenIndex,noCalls=false){if(_base.isFlowEnabled){_flow.flowParseSubscripts.call(void 0,startTokenIndex,noCalls)}else{baseParseSubscripts(startTokenIndex,noCalls)}}__name(parseSubscripts,\"parseSubscripts\");function baseParseSubscripts(startTokenIndex,noCalls=false){const stopState=new StopState(false);do{parseSubscript(startTokenIndex,noCalls,stopState)}while(!stopState.stop&&!_base.state.error)}__name(baseParseSubscripts,\"baseParseSubscripts\");exports.baseParseSubscripts=baseParseSubscripts;function parseSubscript(startTokenIndex,noCalls,stopState){if(_base.isTypeScriptEnabled){_typescript.tsParseSubscript.call(void 0,startTokenIndex,noCalls,stopState)}else if(_base.isFlowEnabled){_flow.flowParseSubscript.call(void 0,startTokenIndex,noCalls,stopState)}else{baseParseSubscript(startTokenIndex,noCalls,stopState)}}__name(parseSubscript,\"parseSubscript\");function baseParseSubscript(startTokenIndex,noCalls,stopState){if(!noCalls&&_index3.eat.call(void 0,_types3.TokenType.doubleColon)){parseNoCallExpr();stopState.stop=true;parseSubscripts(startTokenIndex,noCalls)}else if(_index3.match.call(void 0,_types3.TokenType.questionDot)){_base.state.tokens[startTokenIndex].isOptionalChainStart=true;if(noCalls&&_index3.lookaheadType.call(void 0)===_types3.TokenType.parenL){stopState.stop=true;return}_index3.next.call(void 0);_base.state.tokens[_base.state.tokens.length-1].subscriptStartIndex=startTokenIndex;if(_index3.eat.call(void 0,_types3.TokenType.bracketL)){parseExpression();_util.expect.call(void 0,_types3.TokenType.bracketR)}else if(_index3.eat.call(void 0,_types3.TokenType.parenL)){parseCallExpressionArguments()}else{parseMaybePrivateName()}}else if(_index3.eat.call(void 0,_types3.TokenType.dot)){_base.state.tokens[_base.state.tokens.length-1].subscriptStartIndex=startTokenIndex;parseMaybePrivateName()}else if(_index3.eat.call(void 0,_types3.TokenType.bracketL)){_base.state.tokens[_base.state.tokens.length-1].subscriptStartIndex=startTokenIndex;parseExpression();_util.expect.call(void 0,_types3.TokenType.bracketR)}else if(!noCalls&&_index3.match.call(void 0,_types3.TokenType.parenL)){if(atPossibleAsync()){const snapshot=_base.state.snapshot();const asyncStartTokenIndex=_base.state.tokens.length;_index3.next.call(void 0);_base.state.tokens[_base.state.tokens.length-1].subscriptStartIndex=startTokenIndex;const callContextId=_base.getNextContextId.call(void 0);_base.state.tokens[_base.state.tokens.length-1].contextId=callContextId;parseCallExpressionArguments();_base.state.tokens[_base.state.tokens.length-1].contextId=callContextId;if(shouldParseAsyncArrow()){_base.state.restoreFromSnapshot(snapshot);stopState.stop=true;_base.state.scopeDepth++;_statement.parseFunctionParams.call(void 0);parseAsyncArrowFromCallExpression(asyncStartTokenIndex)}}else{_index3.next.call(void 0);_base.state.tokens[_base.state.tokens.length-1].subscriptStartIndex=startTokenIndex;const callContextId=_base.getNextContextId.call(void 0);_base.state.tokens[_base.state.tokens.length-1].contextId=callContextId;parseCallExpressionArguments();_base.state.tokens[_base.state.tokens.length-1].contextId=callContextId}}else if(_index3.match.call(void 0,_types3.TokenType.backQuote)){parseTemplate()}else{stopState.stop=true}}__name(baseParseSubscript,\"baseParseSubscript\");exports.baseParseSubscript=baseParseSubscript;function atPossibleAsync(){return _base.state.tokens[_base.state.tokens.length-1].contextualKeyword===_keywords.ContextualKeyword._async&&!_util.canInsertSemicolon.call(void 0)}__name(atPossibleAsync,\"atPossibleAsync\");exports.atPossibleAsync=atPossibleAsync;function parseCallExpressionArguments(){let first=true;while(!_index3.eat.call(void 0,_types3.TokenType.parenR)&&!_base.state.error){if(first){first=false}else{_util.expect.call(void 0,_types3.TokenType.comma);if(_index3.eat.call(void 0,_types3.TokenType.parenR)){break}}parseExprListItem(false)}}__name(parseCallExpressionArguments,\"parseCallExpressionArguments\");exports.parseCallExpressionArguments=parseCallExpressionArguments;function shouldParseAsyncArrow(){return _index3.match.call(void 0,_types3.TokenType.colon)||_index3.match.call(void 0,_types3.TokenType.arrow)}__name(shouldParseAsyncArrow,\"shouldParseAsyncArrow\");function parseAsyncArrowFromCallExpression(startTokenIndex){if(_base.isTypeScriptEnabled){_typescript.tsStartParseAsyncArrowFromCallExpression.call(void 0)}else if(_base.isFlowEnabled){_flow.flowStartParseAsyncArrowFromCallExpression.call(void 0)}_util.expect.call(void 0,_types3.TokenType.arrow);parseArrowExpression(startTokenIndex)}__name(parseAsyncArrowFromCallExpression,\"parseAsyncArrowFromCallExpression\");function parseNoCallExpr(){const startTokenIndex=_base.state.tokens.length;parseExprAtom();parseSubscripts(startTokenIndex,true)}__name(parseNoCallExpr,\"parseNoCallExpr\");function parseExprAtom(){if(_index3.eat.call(void 0,_types3.TokenType.modulo)){parseIdentifier();return false}if(_index3.match.call(void 0,_types3.TokenType.jsxText)||_index3.match.call(void 0,_types3.TokenType.jsxEmptyText)){parseLiteral();return false}else if(_index3.match.call(void 0,_types3.TokenType.lessThan)&&_base.isJSXEnabled){_base.state.type=_types3.TokenType.jsxTagStart;_index.jsxParseElement.call(void 0);_index3.next.call(void 0);return false}const canBeArrow=_base.state.potentialArrowAt===_base.state.start;switch(_base.state.type){case _types3.TokenType.slash:case _types3.TokenType.assign:_index3.retokenizeSlashAsRegex.call(void 0);case _types3.TokenType._super:case _types3.TokenType._this:case _types3.TokenType.regexp:case _types3.TokenType.num:case _types3.TokenType.bigint:case _types3.TokenType.decimal:case _types3.TokenType.string:case _types3.TokenType._null:case _types3.TokenType._true:case _types3.TokenType._false:_index3.next.call(void 0);return false;case _types3.TokenType._import:_index3.next.call(void 0);if(_index3.match.call(void 0,_types3.TokenType.dot)){_base.state.tokens[_base.state.tokens.length-1].type=_types3.TokenType.name;_index3.next.call(void 0);parseIdentifier()}return false;case _types3.TokenType.name:{const startTokenIndex=_base.state.tokens.length;const functionStart=_base.state.start;const contextualKeyword=_base.state.contextualKeyword;parseIdentifier();if(contextualKeyword===_keywords.ContextualKeyword._await){parseAwait();return false}else if(contextualKeyword===_keywords.ContextualKeyword._async&&_index3.match.call(void 0,_types3.TokenType._function)&&!_util.canInsertSemicolon.call(void 0)){_index3.next.call(void 0);_statement.parseFunction.call(void 0,functionStart,false);return false}else if(canBeArrow&&contextualKeyword===_keywords.ContextualKeyword._async&&!_util.canInsertSemicolon.call(void 0)&&_index3.match.call(void 0,_types3.TokenType.name)){_base.state.scopeDepth++;_lval.parseBindingIdentifier.call(void 0,false);_util.expect.call(void 0,_types3.TokenType.arrow);parseArrowExpression(startTokenIndex);return true}else if(_index3.match.call(void 0,_types3.TokenType._do)&&!_util.canInsertSemicolon.call(void 0)){_index3.next.call(void 0);_statement.parseBlock.call(void 0);return false}if(canBeArrow&&!_util.canInsertSemicolon.call(void 0)&&_index3.match.call(void 0,_types3.TokenType.arrow)){_base.state.scopeDepth++;_lval.markPriorBindingIdentifier.call(void 0,false);_util.expect.call(void 0,_types3.TokenType.arrow);parseArrowExpression(startTokenIndex);return true}_base.state.tokens[_base.state.tokens.length-1].identifierRole=_index3.IdentifierRole.Access;return false}case _types3.TokenType._do:{_index3.next.call(void 0);_statement.parseBlock.call(void 0);return false}case _types3.TokenType.parenL:{const wasArrow=parseParenAndDistinguishExpression(canBeArrow);return wasArrow}case _types3.TokenType.bracketL:_index3.next.call(void 0);parseExprList(_types3.TokenType.bracketR,true);return false;case _types3.TokenType.braceL:parseObj(false,false);return false;case _types3.TokenType._function:parseFunctionExpression();return false;case _types3.TokenType.at:_statement.parseDecorators.call(void 0);case _types3.TokenType._class:_statement.parseClass.call(void 0,false);return false;case _types3.TokenType._new:parseNew();return false;case _types3.TokenType.backQuote:parseTemplate();return false;case _types3.TokenType.doubleColon:{_index3.next.call(void 0);parseNoCallExpr();return false}case _types3.TokenType.hash:{const code=_index3.lookaheadCharCode.call(void 0);if(_identifier.IS_IDENTIFIER_START[code]||code===_charcodes.charCodes.backslash){parseMaybePrivateName()}else{_index3.next.call(void 0)}return false}default:_util.unexpected.call(void 0);return false}}__name(parseExprAtom,\"parseExprAtom\");exports.parseExprAtom=parseExprAtom;function parseMaybePrivateName(){_index3.eat.call(void 0,_types3.TokenType.hash);parseIdentifier()}__name(parseMaybePrivateName,\"parseMaybePrivateName\");function parseFunctionExpression(){const functionStart=_base.state.start;parseIdentifier();if(_index3.eat.call(void 0,_types3.TokenType.dot)){parseIdentifier()}_statement.parseFunction.call(void 0,functionStart,false)}__name(parseFunctionExpression,\"parseFunctionExpression\");function parseLiteral(){_index3.next.call(void 0)}__name(parseLiteral,\"parseLiteral\");exports.parseLiteral=parseLiteral;function parseParenExpression(){_util.expect.call(void 0,_types3.TokenType.parenL);parseExpression();_util.expect.call(void 0,_types3.TokenType.parenR)}__name(parseParenExpression,\"parseParenExpression\");exports.parseParenExpression=parseParenExpression;function parseParenAndDistinguishExpression(canBeArrow){const snapshot=_base.state.snapshot();const startTokenIndex=_base.state.tokens.length;_util.expect.call(void 0,_types3.TokenType.parenL);let first=true;while(!_index3.match.call(void 0,_types3.TokenType.parenR)&&!_base.state.error){if(first){first=false}else{_util.expect.call(void 0,_types3.TokenType.comma);if(_index3.match.call(void 0,_types3.TokenType.parenR)){break}}if(_index3.match.call(void 0,_types3.TokenType.ellipsis)){_lval.parseRest.call(void 0,false);parseParenItem();break}else{parseMaybeAssign(false,true)}}_util.expect.call(void 0,_types3.TokenType.parenR);if(canBeArrow&&shouldParseArrow()){const wasArrow=parseArrow();if(wasArrow){_base.state.restoreFromSnapshot(snapshot);_base.state.scopeDepth++;_statement.parseFunctionParams.call(void 0);parseArrow();parseArrowExpression(startTokenIndex);if(_base.state.error){_base.state.restoreFromSnapshot(snapshot);parseParenAndDistinguishExpression(false);return false}return true}}return false}__name(parseParenAndDistinguishExpression,\"parseParenAndDistinguishExpression\");function shouldParseArrow(){return _index3.match.call(void 0,_types3.TokenType.colon)||!_util.canInsertSemicolon.call(void 0)}__name(shouldParseArrow,\"shouldParseArrow\");function parseArrow(){if(_base.isTypeScriptEnabled){return _typescript.tsParseArrow.call(void 0)}else if(_base.isFlowEnabled){return _flow.flowParseArrow.call(void 0)}else{return _index3.eat.call(void 0,_types3.TokenType.arrow)}}__name(parseArrow,\"parseArrow\");exports.parseArrow=parseArrow;function parseParenItem(){if(_base.isTypeScriptEnabled||_base.isFlowEnabled){_types.typedParseParenItem.call(void 0)}}__name(parseParenItem,\"parseParenItem\");function parseNew(){_util.expect.call(void 0,_types3.TokenType._new);if(_index3.eat.call(void 0,_types3.TokenType.dot)){parseIdentifier();return}parseNewCallee();if(_base.isFlowEnabled){_flow.flowStartParseNewArguments.call(void 0)}if(_index3.eat.call(void 0,_types3.TokenType.parenL)){parseExprList(_types3.TokenType.parenR)}}__name(parseNew,\"parseNew\");function parseNewCallee(){parseNoCallExpr();_index3.eat.call(void 0,_types3.TokenType.questionDot)}__name(parseNewCallee,\"parseNewCallee\");function parseTemplate(){_index3.nextTemplateToken.call(void 0);_index3.nextTemplateToken.call(void 0);while(!_index3.match.call(void 0,_types3.TokenType.backQuote)&&!_base.state.error){_util.expect.call(void 0,_types3.TokenType.dollarBraceL);parseExpression();_index3.nextTemplateToken.call(void 0);_index3.nextTemplateToken.call(void 0)}_index3.next.call(void 0)}__name(parseTemplate,\"parseTemplate\");exports.parseTemplate=parseTemplate;function parseObj(isPattern,isBlockScope){const contextId=_base.getNextContextId.call(void 0);let first=true;_index3.next.call(void 0);_base.state.tokens[_base.state.tokens.length-1].contextId=contextId;while(!_index3.eat.call(void 0,_types3.TokenType.braceR)&&!_base.state.error){if(first){first=false}else{_util.expect.call(void 0,_types3.TokenType.comma);if(_index3.eat.call(void 0,_types3.TokenType.braceR)){break}}let isGenerator=false;if(_index3.match.call(void 0,_types3.TokenType.ellipsis)){const previousIndex=_base.state.tokens.length;_lval.parseSpread.call(void 0);if(isPattern){if(_base.state.tokens.length===previousIndex+2){_lval.markPriorBindingIdentifier.call(void 0,isBlockScope)}if(_index3.eat.call(void 0,_types3.TokenType.braceR)){break}}continue}if(!isPattern){isGenerator=_index3.eat.call(void 0,_types3.TokenType.star)}if(!isPattern&&_util.isContextual.call(void 0,_keywords.ContextualKeyword._async)){if(isGenerator)_util.unexpected.call(void 0);parseIdentifier();if(_index3.match.call(void 0,_types3.TokenType.colon)||_index3.match.call(void 0,_types3.TokenType.parenL)||_index3.match.call(void 0,_types3.TokenType.braceR)||_index3.match.call(void 0,_types3.TokenType.eq)||_index3.match.call(void 0,_types3.TokenType.comma)){}else{if(_index3.match.call(void 0,_types3.TokenType.star)){_index3.next.call(void 0);isGenerator=true}parsePropertyName(contextId)}}else{parsePropertyName(contextId)}parseObjPropValue(isPattern,isBlockScope,contextId)}_base.state.tokens[_base.state.tokens.length-1].contextId=contextId}__name(parseObj,\"parseObj\");exports.parseObj=parseObj;function isGetterOrSetterMethod(isPattern){return!isPattern&&(_index3.match.call(void 0,_types3.TokenType.string)||_index3.match.call(void 0,_types3.TokenType.num)||_index3.match.call(void 0,_types3.TokenType.bracketL)||_index3.match.call(void 0,_types3.TokenType.name)||!!(_base.state.type&_types3.TokenType.IS_KEYWORD))}__name(isGetterOrSetterMethod,\"isGetterOrSetterMethod\");function parseObjectMethod(isPattern,objectContextId){const functionStart=_base.state.start;if(_index3.match.call(void 0,_types3.TokenType.parenL)){if(isPattern)_util.unexpected.call(void 0);parseMethod(functionStart,false);return true}if(isGetterOrSetterMethod(isPattern)){parsePropertyName(objectContextId);parseMethod(functionStart,false);return true}return false}__name(parseObjectMethod,\"parseObjectMethod\");function parseObjectProperty(isPattern,isBlockScope){if(_index3.eat.call(void 0,_types3.TokenType.colon)){if(isPattern){_lval.parseMaybeDefault.call(void 0,isBlockScope)}else{parseMaybeAssign(false)}return}let identifierRole;if(isPattern){if(_base.state.scopeDepth===0){identifierRole=_index3.IdentifierRole.ObjectShorthandTopLevelDeclaration}else if(isBlockScope){identifierRole=_index3.IdentifierRole.ObjectShorthandBlockScopedDeclaration}else{identifierRole=_index3.IdentifierRole.ObjectShorthandFunctionScopedDeclaration}}else{identifierRole=_index3.IdentifierRole.ObjectShorthand}_base.state.tokens[_base.state.tokens.length-1].identifierRole=identifierRole;_lval.parseMaybeDefault.call(void 0,isBlockScope,true)}__name(parseObjectProperty,\"parseObjectProperty\");function parseObjPropValue(isPattern,isBlockScope,objectContextId){if(_base.isTypeScriptEnabled){_typescript.tsStartParseObjPropValue.call(void 0)}else if(_base.isFlowEnabled){_flow.flowStartParseObjPropValue.call(void 0)}const wasMethod=parseObjectMethod(isPattern,objectContextId);if(!wasMethod){parseObjectProperty(isPattern,isBlockScope)}}__name(parseObjPropValue,\"parseObjPropValue\");function parsePropertyName(objectContextId){if(_base.isFlowEnabled){_flow.flowParseVariance.call(void 0)}if(_index3.eat.call(void 0,_types3.TokenType.bracketL)){_base.state.tokens[_base.state.tokens.length-1].contextId=objectContextId;parseMaybeAssign();_util.expect.call(void 0,_types3.TokenType.bracketR);_base.state.tokens[_base.state.tokens.length-1].contextId=objectContextId}else{if(_index3.match.call(void 0,_types3.TokenType.num)||_index3.match.call(void 0,_types3.TokenType.string)||_index3.match.call(void 0,_types3.TokenType.bigint)||_index3.match.call(void 0,_types3.TokenType.decimal)){parseExprAtom()}else{parseMaybePrivateName()}_base.state.tokens[_base.state.tokens.length-1].identifierRole=_index3.IdentifierRole.ObjectKey;_base.state.tokens[_base.state.tokens.length-1].contextId=objectContextId}}__name(parsePropertyName,\"parsePropertyName\");exports.parsePropertyName=parsePropertyName;function parseMethod(functionStart,isConstructor){const funcContextId=_base.getNextContextId.call(void 0);_base.state.scopeDepth++;const startTokenIndex=_base.state.tokens.length;const allowModifiers=isConstructor;_statement.parseFunctionParams.call(void 0,allowModifiers,funcContextId);parseFunctionBodyAndFinish(functionStart,funcContextId);const endTokenIndex=_base.state.tokens.length;_base.state.scopes.push(new(0,_state.Scope)(startTokenIndex,endTokenIndex,true));_base.state.scopeDepth--}__name(parseMethod,\"parseMethod\");exports.parseMethod=parseMethod;function parseArrowExpression(startTokenIndex){parseFunctionBody(true);const endTokenIndex=_base.state.tokens.length;_base.state.scopes.push(new(0,_state.Scope)(startTokenIndex,endTokenIndex,true));_base.state.scopeDepth--}__name(parseArrowExpression,\"parseArrowExpression\");exports.parseArrowExpression=parseArrowExpression;function parseFunctionBodyAndFinish(functionStart,funcContextId=0){if(_base.isTypeScriptEnabled){_typescript.tsParseFunctionBodyAndFinish.call(void 0,functionStart,funcContextId)}else if(_base.isFlowEnabled){_flow.flowParseFunctionBodyAndFinish.call(void 0,funcContextId)}else{parseFunctionBody(false,funcContextId)}}__name(parseFunctionBodyAndFinish,\"parseFunctionBodyAndFinish\");exports.parseFunctionBodyAndFinish=parseFunctionBodyAndFinish;function parseFunctionBody(allowExpression,funcContextId=0){const isExpression=allowExpression&&!_index3.match.call(void 0,_types3.TokenType.braceL);if(isExpression){parseMaybeAssign()}else{_statement.parseBlock.call(void 0,true,funcContextId)}}__name(parseFunctionBody,\"parseFunctionBody\");exports.parseFunctionBody=parseFunctionBody;function parseExprList(close,allowEmpty=false){let first=true;while(!_index3.eat.call(void 0,close)&&!_base.state.error){if(first){first=false}else{_util.expect.call(void 0,_types3.TokenType.comma);if(_index3.eat.call(void 0,close))break}parseExprListItem(allowEmpty)}}__name(parseExprList,\"parseExprList\");function parseExprListItem(allowEmpty){if(allowEmpty&&_index3.match.call(void 0,_types3.TokenType.comma)){}else if(_index3.match.call(void 0,_types3.TokenType.ellipsis)){_lval.parseSpread.call(void 0);parseParenItem()}else if(_index3.match.call(void 0,_types3.TokenType.question)){_index3.next.call(void 0)}else{parseMaybeAssign(false,true)}}__name(parseExprListItem,\"parseExprListItem\");function parseIdentifier(){_index3.next.call(void 0);_base.state.tokens[_base.state.tokens.length-1].type=_types3.TokenType.name}__name(parseIdentifier,\"parseIdentifier\");exports.parseIdentifier=parseIdentifier;function parseAwait(){parseMaybeUnary()}__name(parseAwait,\"parseAwait\");function parseYield(){_index3.next.call(void 0);if(!_index3.match.call(void 0,_types3.TokenType.semi)&&!_util.canInsertSemicolon.call(void 0)){_index3.eat.call(void 0,_types3.TokenType.star);parseMaybeAssign()}}__name(parseYield,\"parseYield\");function parseModuleExpression(){_util.expectContextual.call(void 0,_keywords.ContextualKeyword._module);_util.expect.call(void 0,_types3.TokenType.braceL);_statement.parseBlockBody.call(void 0,_types3.TokenType.braceR)}__name(parseModuleExpression,\"parseModuleExpression\");\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/parser/traverser/expression.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});/* eslint max-len: 0 */\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts â€” that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n\n\n\n\n\n\n\n\n\n\nvar _flow = require('../plugins/flow');\nvar _index = require('../plugins/jsx/index');\nvar _types = require('../plugins/types');\n\n\n\n\n\n\n\n\n\nvar _typescript = require('../plugins/typescript');\n\n\n\n\n\n\n\n\n\n\n\n\nvar _index3 = require('../tokenizer/index');\nvar _keywords = require('../tokenizer/keywords');\nvar _state = require('../tokenizer/state');\nvar _types3 = require('../tokenizer/types');\nvar _charcodes = require('../util/charcodes');\nvar _identifier = require('../util/identifier');\nvar _base = require('./base');\n\n\n\n\n\n\nvar _lval = require('./lval');\n\n\n\n\n\n\n\nvar _statement = require('./statement');\n\n\n\n\n\n\n\n\n\nvar _util = require('./util');\n\n class StopState {\n  \n  constructor(stop) {\n    this.stop = stop;\n  }\n} exports.StopState = StopState;\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function (s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n function parseExpression(noIn = false) {\n  parseMaybeAssign(noIn);\n  if (_index3.match.call(void 0, _types3.TokenType.comma)) {\n    while (_index3.eat.call(void 0, _types3.TokenType.comma)) {\n      parseMaybeAssign(noIn);\n    }\n  }\n} exports.parseExpression = parseExpression;\n\n/**\n * noIn is used when parsing a for loop so that we don't interpret a following \"in\" as the binary\n * operatior.\n * isWithinParens is used to indicate that we're parsing something that might be a comma expression\n * or might be an arrow function or might be a Flow type assertion (which requires explicit parens).\n * In these cases, we should allow : and ?: after the initial \"left\" part.\n */\n function parseMaybeAssign(noIn = false, isWithinParens = false) {\n  if (_base.isTypeScriptEnabled) {\n    return _typescript.tsParseMaybeAssign.call(void 0, noIn, isWithinParens);\n  } else if (_base.isFlowEnabled) {\n    return _flow.flowParseMaybeAssign.call(void 0, noIn, isWithinParens);\n  } else {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n} exports.parseMaybeAssign = parseMaybeAssign;\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n// Returns true if the expression was an arrow function.\n function baseParseMaybeAssign(noIn, isWithinParens) {\n  if (_index3.match.call(void 0, _types3.TokenType._yield)) {\n    parseYield();\n    return false;\n  }\n\n  if (_index3.match.call(void 0, _types3.TokenType.parenL) || _index3.match.call(void 0, _types3.TokenType.name) || _index3.match.call(void 0, _types3.TokenType._yield)) {\n    _base.state.potentialArrowAt = _base.state.start;\n  }\n\n  const wasArrow = parseMaybeConditional(noIn);\n  if (isWithinParens) {\n    parseParenItem();\n  }\n  if (_base.state.type & _types3.TokenType.IS_ASSIGN) {\n    _index3.next.call(void 0, );\n    parseMaybeAssign(noIn);\n    return false;\n  }\n  return wasArrow;\n} exports.baseParseMaybeAssign = baseParseMaybeAssign;\n\n// Parse a ternary conditional (`?:`) operator.\n// Returns true if the expression was an arrow function.\nfunction parseMaybeConditional(noIn) {\n  const wasArrow = parseExprOps(noIn);\n  if (wasArrow) {\n    return true;\n  }\n  parseConditional(noIn);\n  return false;\n}\n\nfunction parseConditional(noIn) {\n  if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {\n    _types.typedParseConditional.call(void 0, noIn);\n  } else {\n    baseParseConditional(noIn);\n  }\n}\n\n function baseParseConditional(noIn) {\n  if (_index3.eat.call(void 0, _types3.TokenType.question)) {\n    parseMaybeAssign();\n    _util.expect.call(void 0, _types3.TokenType.colon);\n    parseMaybeAssign(noIn);\n  }\n} exports.baseParseConditional = baseParseConditional;\n\n// Start the precedence parser.\n// Returns true if this was an arrow function\nfunction parseExprOps(noIn) {\n  const startTokenIndex = _base.state.tokens.length;\n  const wasArrow = parseMaybeUnary();\n  if (wasArrow) {\n    return true;\n  }\n  parseExprOp(startTokenIndex, -1, noIn);\n  return false;\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\nfunction parseExprOp(startTokenIndex, minPrec, noIn) {\n  if (\n    _base.isTypeScriptEnabled &&\n    (_types3.TokenType._in & _types3.TokenType.PRECEDENCE_MASK) > minPrec &&\n    !_util.hasPrecedingLineBreak.call(void 0, ) &&\n    (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as) || _util.eatContextual.call(void 0, _keywords.ContextualKeyword._satisfies))\n  ) {\n    const oldIsType = _index3.pushTypeContext.call(void 0, 1);\n    _typescript.tsParseType.call(void 0, );\n    _index3.popTypeContext.call(void 0, oldIsType);\n    _index3.rescan_gt.call(void 0, );\n    parseExprOp(startTokenIndex, minPrec, noIn);\n    return;\n  }\n\n  const prec = _base.state.type & _types3.TokenType.PRECEDENCE_MASK;\n  if (prec > 0 && (!noIn || !_index3.match.call(void 0, _types3.TokenType._in))) {\n    if (prec > minPrec) {\n      const op = _base.state.type;\n      _index3.next.call(void 0, );\n      if (op === _types3.TokenType.nullishCoalescing) {\n        _base.state.tokens[_base.state.tokens.length - 1].nullishStartIndex = startTokenIndex;\n      }\n\n      const rhsStartTokenIndex = _base.state.tokens.length;\n      parseMaybeUnary();\n      // Extend the right operand of this operator if possible.\n      parseExprOp(rhsStartTokenIndex, op & _types3.TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);\n      if (op === _types3.TokenType.nullishCoalescing) {\n        _base.state.tokens[startTokenIndex].numNullishCoalesceStarts++;\n        _base.state.tokens[_base.state.tokens.length - 1].numNullishCoalesceEnds++;\n      }\n      // Continue with any future operator holding this expression as the left operand.\n      parseExprOp(startTokenIndex, minPrec, noIn);\n    }\n  }\n}\n\n// Parse unary operators, both prefix and postfix.\n// Returns true if this was an arrow function.\n function parseMaybeUnary() {\n  if (_base.isTypeScriptEnabled && !_base.isJSXEnabled && _index3.eat.call(void 0, _types3.TokenType.lessThan)) {\n    _typescript.tsParseTypeAssertion.call(void 0, );\n    return false;\n  }\n  if (\n    _util.isContextual.call(void 0, _keywords.ContextualKeyword._module) &&\n    _index3.lookaheadCharCode.call(void 0, ) === _charcodes.charCodes.leftCurlyBrace &&\n    !_util.hasFollowingLineBreak.call(void 0, )\n  ) {\n    parseModuleExpression();\n    return false;\n  }\n  if (_base.state.type & _types3.TokenType.IS_PREFIX) {\n    _index3.next.call(void 0, );\n    parseMaybeUnary();\n    return false;\n  }\n\n  const wasArrow = parseExprSubscripts();\n  if (wasArrow) {\n    return true;\n  }\n  while (_base.state.type & _types3.TokenType.IS_POSTFIX && !_util.canInsertSemicolon.call(void 0, )) {\n    // The tokenizer calls everything a preincrement, so make it a postincrement when\n    // we see it in that context.\n    if (_base.state.type === _types3.TokenType.preIncDec) {\n      _base.state.type = _types3.TokenType.postIncDec;\n    }\n    _index3.next.call(void 0, );\n  }\n  return false;\n} exports.parseMaybeUnary = parseMaybeUnary;\n\n// Parse call, dot, and `[]`-subscript expressions.\n// Returns true if this was an arrow function.\n function parseExprSubscripts() {\n  const startTokenIndex = _base.state.tokens.length;\n  const wasArrow = parseExprAtom();\n  if (wasArrow) {\n    return true;\n  }\n  parseSubscripts(startTokenIndex);\n  // If there was any optional chain operation, the start token would be marked\n  // as such, so also mark the end now.\n  if (_base.state.tokens.length > startTokenIndex && _base.state.tokens[startTokenIndex].isOptionalChainStart) {\n    _base.state.tokens[_base.state.tokens.length - 1].isOptionalChainEnd = true;\n  }\n  return false;\n} exports.parseExprSubscripts = parseExprSubscripts;\n\nfunction parseSubscripts(startTokenIndex, noCalls = false) {\n  if (_base.isFlowEnabled) {\n    _flow.flowParseSubscripts.call(void 0, startTokenIndex, noCalls);\n  } else {\n    baseParseSubscripts(startTokenIndex, noCalls);\n  }\n}\n\n function baseParseSubscripts(startTokenIndex, noCalls = false) {\n  const stopState = new StopState(false);\n  do {\n    parseSubscript(startTokenIndex, noCalls, stopState);\n  } while (!stopState.stop && !_base.state.error);\n} exports.baseParseSubscripts = baseParseSubscripts;\n\nfunction parseSubscript(startTokenIndex, noCalls, stopState) {\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);\n  } else if (_base.isFlowEnabled) {\n    _flow.flowParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);\n  } else {\n    baseParseSubscript(startTokenIndex, noCalls, stopState);\n  }\n}\n\n/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */\n function baseParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (!noCalls && _index3.eat.call(void 0, _types3.TokenType.doubleColon)) {\n    parseNoCallExpr();\n    stopState.stop = true;\n    // Propagate startTokenIndex so that `a::b?.()` will keep `a` as the first token. We may want\n    // to revisit this in the future when fully supporting bind syntax.\n    parseSubscripts(startTokenIndex, noCalls);\n  } else if (_index3.match.call(void 0, _types3.TokenType.questionDot)) {\n    _base.state.tokens[startTokenIndex].isOptionalChainStart = true;\n    if (noCalls && _index3.lookaheadType.call(void 0, ) === _types3.TokenType.parenL) {\n      stopState.stop = true;\n      return;\n    }\n    _index3.next.call(void 0, );\n    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n    if (_index3.eat.call(void 0, _types3.TokenType.bracketL)) {\n      parseExpression();\n      _util.expect.call(void 0, _types3.TokenType.bracketR);\n    } else if (_index3.eat.call(void 0, _types3.TokenType.parenL)) {\n      parseCallExpressionArguments();\n    } else {\n      parseMaybePrivateName();\n    }\n  } else if (_index3.eat.call(void 0, _types3.TokenType.dot)) {\n    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseMaybePrivateName();\n  } else if (_index3.eat.call(void 0, _types3.TokenType.bracketL)) {\n    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseExpression();\n    _util.expect.call(void 0, _types3.TokenType.bracketR);\n  } else if (!noCalls && _index3.match.call(void 0, _types3.TokenType.parenL)) {\n    if (atPossibleAsync()) {\n      // We see \"async\", but it's possible it's a usage of the name \"async\". Parse as if it's a\n      // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.\n      const snapshot = _base.state.snapshot();\n      const asyncStartTokenIndex = _base.state.tokens.length;\n      _index3.next.call(void 0, );\n      _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n      const callContextId = _base.getNextContextId.call(void 0, );\n\n      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;\n\n      if (shouldParseAsyncArrow()) {\n        // We hit an arrow, so backtrack and start again parsing function parameters.\n        _base.state.restoreFromSnapshot(snapshot);\n        stopState.stop = true;\n        _base.state.scopeDepth++;\n\n        _statement.parseFunctionParams.call(void 0, );\n        parseAsyncArrowFromCallExpression(asyncStartTokenIndex);\n      }\n    } else {\n      _index3.next.call(void 0, );\n      _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      const callContextId = _base.getNextContextId.call(void 0, );\n      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;\n    }\n  } else if (_index3.match.call(void 0, _types3.TokenType.backQuote)) {\n    // Tagged template expression.\n    parseTemplate();\n  } else {\n    stopState.stop = true;\n  }\n} exports.baseParseSubscript = baseParseSubscript;\n\n function atPossibleAsync() {\n  // This was made less strict than the original version to avoid passing around nodes, but it\n  // should be safe to have rare false positives here.\n  return (\n    _base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _keywords.ContextualKeyword._async &&\n    !_util.canInsertSemicolon.call(void 0, )\n  );\n} exports.atPossibleAsync = atPossibleAsync;\n\n function parseCallExpressionArguments() {\n  let first = true;\n  while (!_index3.eat.call(void 0, _types3.TokenType.parenR) && !_base.state.error) {\n    if (first) {\n      first = false;\n    } else {\n      _util.expect.call(void 0, _types3.TokenType.comma);\n      if (_index3.eat.call(void 0, _types3.TokenType.parenR)) {\n        break;\n      }\n    }\n\n    parseExprListItem(false);\n  }\n} exports.parseCallExpressionArguments = parseCallExpressionArguments;\n\nfunction shouldParseAsyncArrow() {\n  return _index3.match.call(void 0, _types3.TokenType.colon) || _index3.match.call(void 0, _types3.TokenType.arrow);\n}\n\nfunction parseAsyncArrowFromCallExpression(startTokenIndex) {\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsStartParseAsyncArrowFromCallExpression.call(void 0, );\n  } else if (_base.isFlowEnabled) {\n    _flow.flowStartParseAsyncArrowFromCallExpression.call(void 0, );\n  }\n  _util.expect.call(void 0, _types3.TokenType.arrow);\n  parseArrowExpression(startTokenIndex);\n}\n\n// Parse a no-call expression (like argument of `new` or `::` operators).\n\nfunction parseNoCallExpr() {\n  const startTokenIndex = _base.state.tokens.length;\n  parseExprAtom();\n  parseSubscripts(startTokenIndex, true);\n}\n\n// Parse an atomic expression â€” either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n// Returns true if the parsed expression was an arrow function.\n function parseExprAtom() {\n  if (_index3.eat.call(void 0, _types3.TokenType.modulo)) {\n    // V8 intrinsic expression. Just parse the identifier, and the function invocation is parsed\n    // naturally.\n    parseIdentifier();\n    return false;\n  }\n\n  if (_index3.match.call(void 0, _types3.TokenType.jsxText) || _index3.match.call(void 0, _types3.TokenType.jsxEmptyText)) {\n    parseLiteral();\n    return false;\n  } else if (_index3.match.call(void 0, _types3.TokenType.lessThan) && _base.isJSXEnabled) {\n    _base.state.type = _types3.TokenType.jsxTagStart;\n    _index.jsxParseElement.call(void 0, );\n    _index3.next.call(void 0, );\n    return false;\n  }\n\n  const canBeArrow = _base.state.potentialArrowAt === _base.state.start;\n  switch (_base.state.type) {\n    case _types3.TokenType.slash:\n    case _types3.TokenType.assign:\n      _index3.retokenizeSlashAsRegex.call(void 0, );\n    // Fall through.\n\n    case _types3.TokenType._super:\n    case _types3.TokenType._this:\n    case _types3.TokenType.regexp:\n    case _types3.TokenType.num:\n    case _types3.TokenType.bigint:\n    case _types3.TokenType.decimal:\n    case _types3.TokenType.string:\n    case _types3.TokenType._null:\n    case _types3.TokenType._true:\n    case _types3.TokenType._false:\n      _index3.next.call(void 0, );\n      return false;\n\n    case _types3.TokenType._import:\n      _index3.next.call(void 0, );\n      if (_index3.match.call(void 0, _types3.TokenType.dot)) {\n        // import.meta\n        _base.state.tokens[_base.state.tokens.length - 1].type = _types3.TokenType.name;\n        _index3.next.call(void 0, );\n        parseIdentifier();\n      }\n      return false;\n\n    case _types3.TokenType.name: {\n      const startTokenIndex = _base.state.tokens.length;\n      const functionStart = _base.state.start;\n      const contextualKeyword = _base.state.contextualKeyword;\n      parseIdentifier();\n      if (contextualKeyword === _keywords.ContextualKeyword._await) {\n        parseAwait();\n        return false;\n      } else if (\n        contextualKeyword === _keywords.ContextualKeyword._async &&\n        _index3.match.call(void 0, _types3.TokenType._function) &&\n        !_util.canInsertSemicolon.call(void 0, )\n      ) {\n        _index3.next.call(void 0, );\n        _statement.parseFunction.call(void 0, functionStart, false);\n        return false;\n      } else if (\n        canBeArrow &&\n        contextualKeyword === _keywords.ContextualKeyword._async &&\n        !_util.canInsertSemicolon.call(void 0, ) &&\n        _index3.match.call(void 0, _types3.TokenType.name)\n      ) {\n        _base.state.scopeDepth++;\n        _lval.parseBindingIdentifier.call(void 0, false);\n        _util.expect.call(void 0, _types3.TokenType.arrow);\n        // let foo = async bar => {};\n        parseArrowExpression(startTokenIndex);\n        return true;\n      } else if (_index3.match.call(void 0, _types3.TokenType._do) && !_util.canInsertSemicolon.call(void 0, )) {\n        _index3.next.call(void 0, );\n        _statement.parseBlock.call(void 0, );\n        return false;\n      }\n\n      if (canBeArrow && !_util.canInsertSemicolon.call(void 0, ) && _index3.match.call(void 0, _types3.TokenType.arrow)) {\n        _base.state.scopeDepth++;\n        _lval.markPriorBindingIdentifier.call(void 0, false);\n        _util.expect.call(void 0, _types3.TokenType.arrow);\n        parseArrowExpression(startTokenIndex);\n        return true;\n      }\n\n      _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index3.IdentifierRole.Access;\n      return false;\n    }\n\n    case _types3.TokenType._do: {\n      _index3.next.call(void 0, );\n      _statement.parseBlock.call(void 0, );\n      return false;\n    }\n\n    case _types3.TokenType.parenL: {\n      const wasArrow = parseParenAndDistinguishExpression(canBeArrow);\n      return wasArrow;\n    }\n\n    case _types3.TokenType.bracketL:\n      _index3.next.call(void 0, );\n      parseExprList(_types3.TokenType.bracketR, true);\n      return false;\n\n    case _types3.TokenType.braceL:\n      parseObj(false, false);\n      return false;\n\n    case _types3.TokenType._function:\n      parseFunctionExpression();\n      return false;\n\n    case _types3.TokenType.at:\n      _statement.parseDecorators.call(void 0, );\n    // Fall through.\n\n    case _types3.TokenType._class:\n      _statement.parseClass.call(void 0, false);\n      return false;\n\n    case _types3.TokenType._new:\n      parseNew();\n      return false;\n\n    case _types3.TokenType.backQuote:\n      parseTemplate();\n      return false;\n\n    case _types3.TokenType.doubleColon: {\n      _index3.next.call(void 0, );\n      parseNoCallExpr();\n      return false;\n    }\n\n    case _types3.TokenType.hash: {\n      const code = _index3.lookaheadCharCode.call(void 0, );\n      if (_identifier.IS_IDENTIFIER_START[code] || code === _charcodes.charCodes.backslash) {\n        parseMaybePrivateName();\n      } else {\n        _index3.next.call(void 0, );\n      }\n      // Smart pipeline topic reference.\n      return false;\n    }\n\n    default:\n      _util.unexpected.call(void 0, );\n      return false;\n  }\n} exports.parseExprAtom = parseExprAtom;\n\nfunction parseMaybePrivateName() {\n  _index3.eat.call(void 0, _types3.TokenType.hash);\n  parseIdentifier();\n}\n\nfunction parseFunctionExpression() {\n  const functionStart = _base.state.start;\n  parseIdentifier();\n  if (_index3.eat.call(void 0, _types3.TokenType.dot)) {\n    // function.sent\n    parseIdentifier();\n  }\n  _statement.parseFunction.call(void 0, functionStart, false);\n}\n\n function parseLiteral() {\n  _index3.next.call(void 0, );\n} exports.parseLiteral = parseLiteral;\n\n function parseParenExpression() {\n  _util.expect.call(void 0, _types3.TokenType.parenL);\n  parseExpression();\n  _util.expect.call(void 0, _types3.TokenType.parenR);\n} exports.parseParenExpression = parseParenExpression;\n\n// Returns true if this was an arrow expression.\nfunction parseParenAndDistinguishExpression(canBeArrow) {\n  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and\n  // start over as a parameter list.\n  const snapshot = _base.state.snapshot();\n\n  const startTokenIndex = _base.state.tokens.length;\n  _util.expect.call(void 0, _types3.TokenType.parenL);\n\n  let first = true;\n\n  while (!_index3.match.call(void 0, _types3.TokenType.parenR) && !_base.state.error) {\n    if (first) {\n      first = false;\n    } else {\n      _util.expect.call(void 0, _types3.TokenType.comma);\n      if (_index3.match.call(void 0, _types3.TokenType.parenR)) {\n        break;\n      }\n    }\n\n    if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {\n      _lval.parseRest.call(void 0, false /* isBlockScope */);\n      parseParenItem();\n      break;\n    } else {\n      parseMaybeAssign(false, true);\n    }\n  }\n\n  _util.expect.call(void 0, _types3.TokenType.parenR);\n\n  if (canBeArrow && shouldParseArrow()) {\n    const wasArrow = parseArrow();\n    if (wasArrow) {\n      // It was an arrow function this whole time, so start over and parse it as params so that we\n      // get proper token annotations.\n      _base.state.restoreFromSnapshot(snapshot);\n      _base.state.scopeDepth++;\n      // Don't specify a context ID because arrow functions don't need a context ID.\n      _statement.parseFunctionParams.call(void 0, );\n      parseArrow();\n      parseArrowExpression(startTokenIndex);\n      if (_base.state.error) {\n        // Nevermind! This must have been something that looks very much like an\n        // arrow function but where its \"parameter list\" isn't actually a valid\n        // parameter list. Force non-arrow parsing.\n        // See https://github.com/alangpierce/sucrase/issues/666 for an example.\n        _base.state.restoreFromSnapshot(snapshot);\n        parseParenAndDistinguishExpression(false);\n        return false;\n      }\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldParseArrow() {\n  return _index3.match.call(void 0, _types3.TokenType.colon) || !_util.canInsertSemicolon.call(void 0, );\n}\n\n// Returns whether there was an arrow token.\n function parseArrow() {\n  if (_base.isTypeScriptEnabled) {\n    return _typescript.tsParseArrow.call(void 0, );\n  } else if (_base.isFlowEnabled) {\n    return _flow.flowParseArrow.call(void 0, );\n  } else {\n    return _index3.eat.call(void 0, _types3.TokenType.arrow);\n  }\n} exports.parseArrow = parseArrow;\n\nfunction parseParenItem() {\n  if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {\n    _types.typedParseParenItem.call(void 0, );\n  }\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call â€” at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\nfunction parseNew() {\n  _util.expect.call(void 0, _types3.TokenType._new);\n  if (_index3.eat.call(void 0, _types3.TokenType.dot)) {\n    // new.target\n    parseIdentifier();\n    return;\n  }\n  parseNewCallee();\n  if (_base.isFlowEnabled) {\n    _flow.flowStartParseNewArguments.call(void 0, );\n  }\n  if (_index3.eat.call(void 0, _types3.TokenType.parenL)) {\n    parseExprList(_types3.TokenType.parenR);\n  }\n}\n\nfunction parseNewCallee() {\n  parseNoCallExpr();\n  _index3.eat.call(void 0, _types3.TokenType.questionDot);\n}\n\n function parseTemplate() {\n  // Finish `, read quasi\n  _index3.nextTemplateToken.call(void 0, );\n  // Finish quasi, read ${\n  _index3.nextTemplateToken.call(void 0, );\n  while (!_index3.match.call(void 0, _types3.TokenType.backQuote) && !_base.state.error) {\n    _util.expect.call(void 0, _types3.TokenType.dollarBraceL);\n    parseExpression();\n    // Finish }, read quasi\n    _index3.nextTemplateToken.call(void 0, );\n    // Finish quasi, read either ${ or `\n    _index3.nextTemplateToken.call(void 0, );\n  }\n  _index3.next.call(void 0, );\n} exports.parseTemplate = parseTemplate;\n\n// Parse an object literal or binding pattern.\n function parseObj(isPattern, isBlockScope) {\n  // Attach a context ID to the object open and close brace and each object key.\n  const contextId = _base.getNextContextId.call(void 0, );\n  let first = true;\n\n  _index3.next.call(void 0, );\n  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;\n\n  while (!_index3.eat.call(void 0, _types3.TokenType.braceR) && !_base.state.error) {\n    if (first) {\n      first = false;\n    } else {\n      _util.expect.call(void 0, _types3.TokenType.comma);\n      if (_index3.eat.call(void 0, _types3.TokenType.braceR)) {\n        break;\n      }\n    }\n\n    let isGenerator = false;\n    if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {\n      const previousIndex = _base.state.tokens.length;\n      _lval.parseSpread.call(void 0, );\n      if (isPattern) {\n        // Mark role when the only thing being spread over is an identifier.\n        if (_base.state.tokens.length === previousIndex + 2) {\n          _lval.markPriorBindingIdentifier.call(void 0, isBlockScope);\n        }\n        if (_index3.eat.call(void 0, _types3.TokenType.braceR)) {\n          break;\n        }\n      }\n      continue;\n    }\n\n    if (!isPattern) {\n      isGenerator = _index3.eat.call(void 0, _types3.TokenType.star);\n    }\n\n    if (!isPattern && _util.isContextual.call(void 0, _keywords.ContextualKeyword._async)) {\n      if (isGenerator) _util.unexpected.call(void 0, );\n\n      parseIdentifier();\n      if (\n        _index3.match.call(void 0, _types3.TokenType.colon) ||\n        _index3.match.call(void 0, _types3.TokenType.parenL) ||\n        _index3.match.call(void 0, _types3.TokenType.braceR) ||\n        _index3.match.call(void 0, _types3.TokenType.eq) ||\n        _index3.match.call(void 0, _types3.TokenType.comma)\n      ) {\n        // This is a key called \"async\" rather than an async function.\n      } else {\n        if (_index3.match.call(void 0, _types3.TokenType.star)) {\n          _index3.next.call(void 0, );\n          isGenerator = true;\n        }\n        parsePropertyName(contextId);\n      }\n    } else {\n      parsePropertyName(contextId);\n    }\n\n    parseObjPropValue(isPattern, isBlockScope, contextId);\n  }\n\n  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;\n} exports.parseObj = parseObj;\n\nfunction isGetterOrSetterMethod(isPattern) {\n  // We go off of the next and don't bother checking if the node key is actually \"get\" or \"set\".\n  // This lets us avoid generating a node, and should only make the validation worse.\n  return (\n    !isPattern &&\n    (_index3.match.call(void 0, _types3.TokenType.string) || // get \"string\"() {}\n      _index3.match.call(void 0, _types3.TokenType.num) || // get 1() {}\n      _index3.match.call(void 0, _types3.TokenType.bracketL) || // get [\"string\"]() {}\n      _index3.match.call(void 0, _types3.TokenType.name) || // get foo() {}\n      !!(_base.state.type & _types3.TokenType.IS_KEYWORD)) // get debugger() {}\n  );\n}\n\n// Returns true if this was a method.\nfunction parseObjectMethod(isPattern, objectContextId) {\n  // We don't need to worry about modifiers because object methods can't have optional bodies, so\n  // the start will never be used.\n  const functionStart = _base.state.start;\n  if (_index3.match.call(void 0, _types3.TokenType.parenL)) {\n    if (isPattern) _util.unexpected.call(void 0, );\n    parseMethod(functionStart, /* isConstructor */ false);\n    return true;\n  }\n\n  if (isGetterOrSetterMethod(isPattern)) {\n    parsePropertyName(objectContextId);\n    parseMethod(functionStart, /* isConstructor */ false);\n    return true;\n  }\n  return false;\n}\n\nfunction parseObjectProperty(isPattern, isBlockScope) {\n  if (_index3.eat.call(void 0, _types3.TokenType.colon)) {\n    if (isPattern) {\n      _lval.parseMaybeDefault.call(void 0, isBlockScope);\n    } else {\n      parseMaybeAssign(false);\n    }\n    return;\n  }\n\n  // Since there's no colon, we assume this is an object shorthand.\n\n  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so\n  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to\n  // transform it on access, so mark it as a normal object shorthand.\n  let identifierRole;\n  if (isPattern) {\n    if (_base.state.scopeDepth === 0) {\n      identifierRole = _index3.IdentifierRole.ObjectShorthandTopLevelDeclaration;\n    } else if (isBlockScope) {\n      identifierRole = _index3.IdentifierRole.ObjectShorthandBlockScopedDeclaration;\n    } else {\n      identifierRole = _index3.IdentifierRole.ObjectShorthandFunctionScopedDeclaration;\n    }\n  } else {\n    identifierRole = _index3.IdentifierRole.ObjectShorthand;\n  }\n  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;\n\n  // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow\n  // parsing as if there's a default value.\n  _lval.parseMaybeDefault.call(void 0, isBlockScope, true);\n}\n\nfunction parseObjPropValue(\n  isPattern,\n  isBlockScope,\n  objectContextId,\n) {\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsStartParseObjPropValue.call(void 0, );\n  } else if (_base.isFlowEnabled) {\n    _flow.flowStartParseObjPropValue.call(void 0, );\n  }\n  const wasMethod = parseObjectMethod(isPattern, objectContextId);\n  if (!wasMethod) {\n    parseObjectProperty(isPattern, isBlockScope);\n  }\n}\n\n function parsePropertyName(objectContextId) {\n  if (_base.isFlowEnabled) {\n    _flow.flowParseVariance.call(void 0, );\n  }\n  if (_index3.eat.call(void 0, _types3.TokenType.bracketL)) {\n    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;\n    parseMaybeAssign();\n    _util.expect.call(void 0, _types3.TokenType.bracketR);\n    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;\n  } else {\n    if (_index3.match.call(void 0, _types3.TokenType.num) || _index3.match.call(void 0, _types3.TokenType.string) || _index3.match.call(void 0, _types3.TokenType.bigint) || _index3.match.call(void 0, _types3.TokenType.decimal)) {\n      parseExprAtom();\n    } else {\n      parseMaybePrivateName();\n    }\n\n    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index3.IdentifierRole.ObjectKey;\n    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;\n  }\n} exports.parsePropertyName = parsePropertyName;\n\n// Parse object or class method.\n function parseMethod(functionStart, isConstructor) {\n  const funcContextId = _base.getNextContextId.call(void 0, );\n\n  _base.state.scopeDepth++;\n  const startTokenIndex = _base.state.tokens.length;\n  const allowModifiers = isConstructor; // For TypeScript parameter properties\n  _statement.parseFunctionParams.call(void 0, allowModifiers, funcContextId);\n  parseFunctionBodyAndFinish(functionStart, funcContextId);\n  const endTokenIndex = _base.state.tokens.length;\n  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));\n  _base.state.scopeDepth--;\n} exports.parseMethod = parseMethod;\n\n// Parse arrow function expression.\n// If the parameters are provided, they will be converted to an\n// assignable list.\n function parseArrowExpression(startTokenIndex) {\n  parseFunctionBody(true);\n  const endTokenIndex = _base.state.tokens.length;\n  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));\n  _base.state.scopeDepth--;\n} exports.parseArrowExpression = parseArrowExpression;\n\n function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {\n  if (_base.isTypeScriptEnabled) {\n    _typescript.tsParseFunctionBodyAndFinish.call(void 0, functionStart, funcContextId);\n  } else if (_base.isFlowEnabled) {\n    _flow.flowParseFunctionBodyAndFinish.call(void 0, funcContextId);\n  } else {\n    parseFunctionBody(false, funcContextId);\n  }\n} exports.parseFunctionBodyAndFinish = parseFunctionBodyAndFinish;\n\n function parseFunctionBody(allowExpression, funcContextId = 0) {\n  const isExpression = allowExpression && !_index3.match.call(void 0, _types3.TokenType.braceL);\n\n  if (isExpression) {\n    parseMaybeAssign();\n  } else {\n    _statement.parseBlock.call(void 0, true /* isFunctionScope */, funcContextId);\n  }\n} exports.parseFunctionBody = parseFunctionBody;\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\nfunction parseExprList(close, allowEmpty = false) {\n  let first = true;\n  while (!_index3.eat.call(void 0, close) && !_base.state.error) {\n    if (first) {\n      first = false;\n    } else {\n      _util.expect.call(void 0, _types3.TokenType.comma);\n      if (_index3.eat.call(void 0, close)) break;\n    }\n    parseExprListItem(allowEmpty);\n  }\n}\n\nfunction parseExprListItem(allowEmpty) {\n  if (allowEmpty && _index3.match.call(void 0, _types3.TokenType.comma)) {\n    // Empty item; nothing more to parse for this item.\n  } else if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {\n    _lval.parseSpread.call(void 0, );\n    parseParenItem();\n  } else if (_index3.match.call(void 0, _types3.TokenType.question)) {\n    // Partial function application proposal.\n    _index3.next.call(void 0, );\n  } else {\n    parseMaybeAssign(false, true);\n  }\n}\n\n// Parse the next token as an identifier.\n function parseIdentifier() {\n  _index3.next.call(void 0, );\n  _base.state.tokens[_base.state.tokens.length - 1].type = _types3.TokenType.name;\n} exports.parseIdentifier = parseIdentifier;\n\n// Parses await expression inside async function.\nfunction parseAwait() {\n  parseMaybeUnary();\n}\n\n// Parses yield expression inside generator.\nfunction parseYield() {\n  _index3.next.call(void 0, );\n  if (!_index3.match.call(void 0, _types3.TokenType.semi) && !_util.canInsertSemicolon.call(void 0, )) {\n    _index3.eat.call(void 0, _types3.TokenType.star);\n    parseMaybeAssign();\n  }\n}\n\n// https://github.com/tc39/proposal-js-module-blocks\nfunction parseModuleExpression() {\n  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._module);\n  _util.expect.call(void 0, _types3.TokenType.braceL);\n  // For now, just call parseBlockBody to parse the block. In the future when we\n  // implement full support, we'll want to emit scopes and possibly other\n  // information.\n  _statement.parseBlockBody.call(void 0, _types3.TokenType.braceR);\n}\n"]}}