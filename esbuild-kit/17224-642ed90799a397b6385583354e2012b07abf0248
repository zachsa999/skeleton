{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}__name(_interopRequireDefault,\"_interopRequireDefault\");var _tokenizer=require(\"./parser/tokenizer\");var _keywords=require(\"./parser/tokenizer/keywords\");var _types=require(\"./parser/tokenizer/types\");var _getImportExportSpecifierInfo=require(\"./util/getImportExportSpecifierInfo\");var _getImportExportSpecifierInfo2=_interopRequireDefault(_getImportExportSpecifierInfo);var _getNonTypeIdentifiers=require(\"./util/getNonTypeIdentifiers\");class CJSImportProcessor{__init(){this.nonTypeIdentifiers=new Set}__init2(){this.importInfoByPath=new Map}__init3(){this.importsToReplace=new Map}__init4(){this.identifierReplacements=new Map}__init5(){this.exportBindingsByLocalName=new Map}constructor(nameManager,tokens,enableLegacyTypeScriptModuleInterop,options,isTypeScriptTransformEnabled,helperManager){;this.nameManager=nameManager;this.tokens=tokens;this.enableLegacyTypeScriptModuleInterop=enableLegacyTypeScriptModuleInterop;this.options=options;this.isTypeScriptTransformEnabled=isTypeScriptTransformEnabled;this.helperManager=helperManager;CJSImportProcessor.prototype.__init.call(this);CJSImportProcessor.prototype.__init2.call(this);CJSImportProcessor.prototype.__init3.call(this);CJSImportProcessor.prototype.__init4.call(this);CJSImportProcessor.prototype.__init5.call(this)}preprocessTokens(){for(let i=0;i<this.tokens.tokens.length;i++){if(this.tokens.matches1AtIndex(i,_types.TokenType._import)&&!this.tokens.matches3AtIndex(i,_types.TokenType._import,_types.TokenType.name,_types.TokenType.eq)){this.preprocessImportAtIndex(i)}if(this.tokens.matches1AtIndex(i,_types.TokenType._export)&&!this.tokens.matches2AtIndex(i,_types.TokenType._export,_types.TokenType.eq)){this.preprocessExportAtIndex(i)}}this.generateImportReplacements()}pruneTypeOnlyImports(){this.nonTypeIdentifiers=_getNonTypeIdentifiers.getNonTypeIdentifiers.call(void 0,this.tokens,this.options);for(const[path,importInfo]of this.importInfoByPath.entries()){if(importInfo.hasBareImport||importInfo.hasStarExport||importInfo.exportStarNames.length>0||importInfo.namedExports.length>0){continue}const names=[...importInfo.defaultNames,...importInfo.wildcardNames,...importInfo.namedImports.map(({localName})=>localName)];if(names.every(name=>this.isTypeName(name))){this.importsToReplace.set(path,\"\")}}}isTypeName(name){return this.isTypeScriptTransformEnabled&&!this.nonTypeIdentifiers.has(name)}generateImportReplacements(){for(const[path,importInfo]of this.importInfoByPath.entries()){const{defaultNames,wildcardNames,namedImports,namedExports,exportStarNames,hasStarExport}=importInfo;if(defaultNames.length===0&&wildcardNames.length===0&&namedImports.length===0&&namedExports.length===0&&exportStarNames.length===0&&!hasStarExport){this.importsToReplace.set(path,`require('${path}');`);continue}const primaryImportName=this.getFreeIdentifierForPath(path);let secondaryImportName;if(this.enableLegacyTypeScriptModuleInterop){secondaryImportName=primaryImportName}else{secondaryImportName=wildcardNames.length>0?wildcardNames[0]:this.getFreeIdentifierForPath(path)}let requireCode=`var ${primaryImportName} = require('${path}');`;if(wildcardNames.length>0){for(const wildcardName of wildcardNames){const moduleExpr=this.enableLegacyTypeScriptModuleInterop?primaryImportName:`${this.helperManager.getHelperName(\"interopRequireWildcard\")}(${primaryImportName})`;requireCode+=` var ${wildcardName} = ${moduleExpr};`}}else if(exportStarNames.length>0&&secondaryImportName!==primaryImportName){requireCode+=` var ${secondaryImportName} = ${this.helperManager.getHelperName(\"interopRequireWildcard\")}(${primaryImportName});`}else if(defaultNames.length>0&&secondaryImportName!==primaryImportName){requireCode+=` var ${secondaryImportName} = ${this.helperManager.getHelperName(\"interopRequireDefault\")}(${primaryImportName});`}for(const{importedName,localName}of namedExports){requireCode+=` ${this.helperManager.getHelperName(\"createNamedExportFrom\")}(${primaryImportName}, '${localName}', '${importedName}');`}for(const exportStarName of exportStarNames){requireCode+=` exports.${exportStarName} = ${secondaryImportName};`}if(hasStarExport){requireCode+=` ${this.helperManager.getHelperName(\"createStarExport\")}(${primaryImportName});`}this.importsToReplace.set(path,requireCode);for(const defaultName of defaultNames){this.identifierReplacements.set(defaultName,`${secondaryImportName}.default`)}for(const{importedName,localName}of namedImports){this.identifierReplacements.set(localName,`${primaryImportName}.${importedName}`)}}}getFreeIdentifierForPath(path){const components=path.split(\"/\");const lastComponent=components[components.length-1];const baseName=lastComponent.replace(/\\W/g,\"\");return this.nameManager.claimFreeName(`_${baseName}`)}preprocessImportAtIndex(index){const defaultNames=[];const wildcardNames=[];const namedImports=[];index++;if((this.tokens.matchesContextualAtIndex(index,_keywords.ContextualKeyword._type)||this.tokens.matches1AtIndex(index,_types.TokenType._typeof))&&!this.tokens.matches1AtIndex(index+1,_types.TokenType.comma)&&!this.tokens.matchesContextualAtIndex(index+1,_keywords.ContextualKeyword._from)){return}if(this.tokens.matches1AtIndex(index,_types.TokenType.parenL)){return}if(this.tokens.matches1AtIndex(index,_types.TokenType.name)){defaultNames.push(this.tokens.identifierNameAtIndex(index));index++;if(this.tokens.matches1AtIndex(index,_types.TokenType.comma)){index++}}if(this.tokens.matches1AtIndex(index,_types.TokenType.star)){index+=2;wildcardNames.push(this.tokens.identifierNameAtIndex(index));index++}if(this.tokens.matches1AtIndex(index,_types.TokenType.braceL)){const result=this.getNamedImports(index+1);index=result.newIndex;for(const namedImport of result.namedImports){if(namedImport.importedName===\"default\"){defaultNames.push(namedImport.localName)}else{namedImports.push(namedImport)}}}if(this.tokens.matchesContextualAtIndex(index,_keywords.ContextualKeyword._from)){index++}if(!this.tokens.matches1AtIndex(index,_types.TokenType.string)){throw new Error(\"Expected string token at the end of import statement.\")}const path=this.tokens.stringValueAtIndex(index);const importInfo=this.getImportInfo(path);importInfo.defaultNames.push(...defaultNames);importInfo.wildcardNames.push(...wildcardNames);importInfo.namedImports.push(...namedImports);if(defaultNames.length===0&&wildcardNames.length===0&&namedImports.length===0){importInfo.hasBareImport=true}}preprocessExportAtIndex(index){if(this.tokens.matches2AtIndex(index,_types.TokenType._export,_types.TokenType._var)||this.tokens.matches2AtIndex(index,_types.TokenType._export,_types.TokenType._let)||this.tokens.matches2AtIndex(index,_types.TokenType._export,_types.TokenType._const)){this.preprocessVarExportAtIndex(index)}else if(this.tokens.matches2AtIndex(index,_types.TokenType._export,_types.TokenType._function)||this.tokens.matches2AtIndex(index,_types.TokenType._export,_types.TokenType._class)){const exportName=this.tokens.identifierNameAtIndex(index+2);this.addExportBinding(exportName,exportName)}else if(this.tokens.matches3AtIndex(index,_types.TokenType._export,_types.TokenType.name,_types.TokenType._function)){const exportName=this.tokens.identifierNameAtIndex(index+3);this.addExportBinding(exportName,exportName)}else if(this.tokens.matches2AtIndex(index,_types.TokenType._export,_types.TokenType.braceL)){this.preprocessNamedExportAtIndex(index)}else if(this.tokens.matches2AtIndex(index,_types.TokenType._export,_types.TokenType.star)){this.preprocessExportStarAtIndex(index)}}preprocessVarExportAtIndex(index){let depth=0;for(let i=index+2;;i++){if(this.tokens.matches1AtIndex(i,_types.TokenType.braceL)||this.tokens.matches1AtIndex(i,_types.TokenType.dollarBraceL)||this.tokens.matches1AtIndex(i,_types.TokenType.bracketL)){depth++}else if(this.tokens.matches1AtIndex(i,_types.TokenType.braceR)||this.tokens.matches1AtIndex(i,_types.TokenType.bracketR)){depth--}else if(depth===0&&!this.tokens.matches1AtIndex(i,_types.TokenType.name)){break}else if(this.tokens.matches1AtIndex(1,_types.TokenType.eq)){const endIndex=this.tokens.currentToken().rhsEndIndex;if(endIndex==null){throw new Error(\"Expected = token with an end index.\")}i=endIndex-1}else{const token=this.tokens.tokens[i];if(_tokenizer.isDeclaration.call(void 0,token)){const exportName=this.tokens.identifierNameAtIndex(i);this.identifierReplacements.set(exportName,`exports.${exportName}`)}}}}preprocessNamedExportAtIndex(index){index+=2;const{newIndex,namedImports}=this.getNamedImports(index);index=newIndex;if(this.tokens.matchesContextualAtIndex(index,_keywords.ContextualKeyword._from)){index++}else{for(const{importedName:localName,localName:exportedName}of namedImports){this.addExportBinding(localName,exportedName)}return}if(!this.tokens.matches1AtIndex(index,_types.TokenType.string)){throw new Error(\"Expected string token at the end of import statement.\")}const path=this.tokens.stringValueAtIndex(index);const importInfo=this.getImportInfo(path);importInfo.namedExports.push(...namedImports)}preprocessExportStarAtIndex(index){let exportedName=null;if(this.tokens.matches3AtIndex(index,_types.TokenType._export,_types.TokenType.star,_types.TokenType._as)){index+=3;exportedName=this.tokens.identifierNameAtIndex(index);index+=2}else{index+=3}if(!this.tokens.matches1AtIndex(index,_types.TokenType.string)){throw new Error(\"Expected string token at the end of star export statement.\")}const path=this.tokens.stringValueAtIndex(index);const importInfo=this.getImportInfo(path);if(exportedName!==null){importInfo.exportStarNames.push(exportedName)}else{importInfo.hasStarExport=true}}getNamedImports(index){const namedImports=[];while(true){if(this.tokens.matches1AtIndex(index,_types.TokenType.braceR)){index++;break}const specifierInfo=_getImportExportSpecifierInfo2.default.call(void 0,this.tokens,index);index=specifierInfo.endIndex;if(!specifierInfo.isType){namedImports.push({importedName:specifierInfo.leftName,localName:specifierInfo.rightName})}if(this.tokens.matches2AtIndex(index,_types.TokenType.comma,_types.TokenType.braceR)){index+=2;break}else if(this.tokens.matches1AtIndex(index,_types.TokenType.braceR)){index++;break}else if(this.tokens.matches1AtIndex(index,_types.TokenType.comma)){index++}else{throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index])}`)}}return{newIndex:index,namedImports}}getImportInfo(path){const existingInfo=this.importInfoByPath.get(path);if(existingInfo){return existingInfo}const newInfo={defaultNames:[],wildcardNames:[],namedImports:[],namedExports:[],hasBareImport:false,exportStarNames:[],hasStarExport:false};this.importInfoByPath.set(path,newInfo);return newInfo}addExportBinding(localName,exportedName){if(!this.exportBindingsByLocalName.has(localName)){this.exportBindingsByLocalName.set(localName,[])}this.exportBindingsByLocalName.get(localName).push(exportedName)}claimImportCode(importPath){const result=this.importsToReplace.get(importPath);this.importsToReplace.set(importPath,\"\");return result||\"\"}getIdentifierReplacement(identifierName){return this.identifierReplacements.get(identifierName)||null}resolveExportBinding(assignedName){const exportedNames=this.exportBindingsByLocalName.get(assignedName);if(!exportedNames||exportedNames.length===0){return null}return exportedNames.map(exportedName=>`exports.${exportedName}`).join(\" = \")}getGlobalNames(){return new Set([...this.identifierReplacements.keys(),...this.exportBindingsByLocalName.keys()])}}__name(CJSImportProcessor,\"CJSImportProcessor\");exports.default=CJSImportProcessor;\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/CJSImportProcessor.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\nvar _tokenizer = require('./parser/tokenizer');\nvar _keywords = require('./parser/tokenizer/keywords');\nvar _types = require('./parser/tokenizer/types');\n\nvar _getImportExportSpecifierInfo = require('./util/getImportExportSpecifierInfo'); var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);\nvar _getNonTypeIdentifiers = require('./util/getNonTypeIdentifiers');\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Class responsible for preprocessing and bookkeeping import and export declarations within the\n * file.\n *\n * TypeScript uses a simpler mechanism that does not use functions like interopRequireDefault and\n * interopRequireWildcard, so we also allow that mode for compatibility.\n */\n class CJSImportProcessor {\n   __init() {this.nonTypeIdentifiers = new Set()}\n   __init2() {this.importInfoByPath = new Map()}\n   __init3() {this.importsToReplace = new Map()}\n   __init4() {this.identifierReplacements = new Map()}\n   __init5() {this.exportBindingsByLocalName = new Map()}\n\n  constructor(\n     nameManager,\n     tokens,\n     enableLegacyTypeScriptModuleInterop,\n     options,\n     isTypeScriptTransformEnabled,\n     helperManager,\n  ) {;this.nameManager = nameManager;this.tokens = tokens;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.options = options;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.helperManager = helperManager;CJSImportProcessor.prototype.__init.call(this);CJSImportProcessor.prototype.__init2.call(this);CJSImportProcessor.prototype.__init3.call(this);CJSImportProcessor.prototype.__init4.call(this);CJSImportProcessor.prototype.__init5.call(this);}\n\n  preprocessTokens() {\n    for (let i = 0; i < this.tokens.tokens.length; i++) {\n      if (\n        this.tokens.matches1AtIndex(i, _types.TokenType._import) &&\n        !this.tokens.matches3AtIndex(i, _types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)\n      ) {\n        this.preprocessImportAtIndex(i);\n      }\n      if (\n        this.tokens.matches1AtIndex(i, _types.TokenType._export) &&\n        !this.tokens.matches2AtIndex(i, _types.TokenType._export, _types.TokenType.eq)\n      ) {\n        this.preprocessExportAtIndex(i);\n      }\n    }\n    this.generateImportReplacements();\n  }\n\n  /**\n   * In TypeScript, import statements that only import types should be removed. This does not count\n   * bare imports.\n   */\n  pruneTypeOnlyImports() {\n    this.nonTypeIdentifiers = _getNonTypeIdentifiers.getNonTypeIdentifiers.call(void 0, this.tokens, this.options);\n    for (const [path, importInfo] of this.importInfoByPath.entries()) {\n      if (\n        importInfo.hasBareImport ||\n        importInfo.hasStarExport ||\n        importInfo.exportStarNames.length > 0 ||\n        importInfo.namedExports.length > 0\n      ) {\n        continue;\n      }\n      const names = [\n        ...importInfo.defaultNames,\n        ...importInfo.wildcardNames,\n        ...importInfo.namedImports.map(({localName}) => localName),\n      ];\n      if (names.every((name) => this.isTypeName(name))) {\n        this.importsToReplace.set(path, \"\");\n      }\n    }\n  }\n\n  isTypeName(name) {\n    return this.isTypeScriptTransformEnabled && !this.nonTypeIdentifiers.has(name);\n  }\n\n   generateImportReplacements() {\n    for (const [path, importInfo] of this.importInfoByPath.entries()) {\n      const {\n        defaultNames,\n        wildcardNames,\n        namedImports,\n        namedExports,\n        exportStarNames,\n        hasStarExport,\n      } = importInfo;\n\n      if (\n        defaultNames.length === 0 &&\n        wildcardNames.length === 0 &&\n        namedImports.length === 0 &&\n        namedExports.length === 0 &&\n        exportStarNames.length === 0 &&\n        !hasStarExport\n      ) {\n        // Import is never used, so don't even assign a name.\n        this.importsToReplace.set(path, `require('${path}');`);\n        continue;\n      }\n\n      const primaryImportName = this.getFreeIdentifierForPath(path);\n      let secondaryImportName;\n      if (this.enableLegacyTypeScriptModuleInterop) {\n        secondaryImportName = primaryImportName;\n      } else {\n        secondaryImportName =\n          wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);\n      }\n      let requireCode = `var ${primaryImportName} = require('${path}');`;\n      if (wildcardNames.length > 0) {\n        for (const wildcardName of wildcardNames) {\n          const moduleExpr = this.enableLegacyTypeScriptModuleInterop\n            ? primaryImportName\n            : `${this.helperManager.getHelperName(\"interopRequireWildcard\")}(${primaryImportName})`;\n          requireCode += ` var ${wildcardName} = ${moduleExpr};`;\n        }\n      } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {\n        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(\n          \"interopRequireWildcard\",\n        )}(${primaryImportName});`;\n      } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {\n        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(\n          \"interopRequireDefault\",\n        )}(${primaryImportName});`;\n      }\n\n      for (const {importedName, localName} of namedExports) {\n        requireCode += ` ${this.helperManager.getHelperName(\n          \"createNamedExportFrom\",\n        )}(${primaryImportName}, '${localName}', '${importedName}');`;\n      }\n      for (const exportStarName of exportStarNames) {\n        requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;\n      }\n      if (hasStarExport) {\n        requireCode += ` ${this.helperManager.getHelperName(\n          \"createStarExport\",\n        )}(${primaryImportName});`;\n      }\n\n      this.importsToReplace.set(path, requireCode);\n\n      for (const defaultName of defaultNames) {\n        this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);\n      }\n      for (const {importedName, localName} of namedImports) {\n        this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);\n      }\n    }\n  }\n\n  getFreeIdentifierForPath(path) {\n    const components = path.split(\"/\");\n    const lastComponent = components[components.length - 1];\n    const baseName = lastComponent.replace(/\\W/g, \"\");\n    return this.nameManager.claimFreeName(`_${baseName}`);\n  }\n\n   preprocessImportAtIndex(index) {\n    const defaultNames = [];\n    const wildcardNames = [];\n    const namedImports = [];\n\n    index++;\n    if (\n      (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._type) ||\n        this.tokens.matches1AtIndex(index, _types.TokenType._typeof)) &&\n      !this.tokens.matches1AtIndex(index + 1, _types.TokenType.comma) &&\n      !this.tokens.matchesContextualAtIndex(index + 1, _keywords.ContextualKeyword._from)\n    ) {\n      // import type declaration, so no need to process anything.\n      return;\n    }\n\n    if (this.tokens.matches1AtIndex(index, _types.TokenType.parenL)) {\n      // Dynamic import, so nothing to do\n      return;\n    }\n\n    if (this.tokens.matches1AtIndex(index, _types.TokenType.name)) {\n      defaultNames.push(this.tokens.identifierNameAtIndex(index));\n      index++;\n      if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) {\n        index++;\n      }\n    }\n\n    if (this.tokens.matches1AtIndex(index, _types.TokenType.star)) {\n      // * as\n      index += 2;\n      wildcardNames.push(this.tokens.identifierNameAtIndex(index));\n      index++;\n    }\n\n    if (this.tokens.matches1AtIndex(index, _types.TokenType.braceL)) {\n      const result = this.getNamedImports(index + 1);\n      index = result.newIndex;\n\n      for (const namedImport of result.namedImports) {\n        // Treat {default as X} as a default import to ensure usage of require interop helper\n        if (namedImport.importedName === \"default\") {\n          defaultNames.push(namedImport.localName);\n        } else {\n          namedImports.push(namedImport);\n        }\n      }\n    }\n\n    if (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._from)) {\n      index++;\n    }\n\n    if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {\n      throw new Error(\"Expected string token at the end of import statement.\");\n    }\n    const path = this.tokens.stringValueAtIndex(index);\n    const importInfo = this.getImportInfo(path);\n    importInfo.defaultNames.push(...defaultNames);\n    importInfo.wildcardNames.push(...wildcardNames);\n    importInfo.namedImports.push(...namedImports);\n    if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0) {\n      importInfo.hasBareImport = true;\n    }\n  }\n\n   preprocessExportAtIndex(index) {\n    if (\n      this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._var) ||\n      this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._let) ||\n      this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._const)\n    ) {\n      this.preprocessVarExportAtIndex(index);\n    } else if (\n      this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._function) ||\n      this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._class)\n    ) {\n      const exportName = this.tokens.identifierNameAtIndex(index + 2);\n      this.addExportBinding(exportName, exportName);\n    } else if (this.tokens.matches3AtIndex(index, _types.TokenType._export, _types.TokenType.name, _types.TokenType._function)) {\n      const exportName = this.tokens.identifierNameAtIndex(index + 3);\n      this.addExportBinding(exportName, exportName);\n    } else if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType.braceL)) {\n      this.preprocessNamedExportAtIndex(index);\n    } else if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType.star)) {\n      this.preprocessExportStarAtIndex(index);\n    }\n  }\n\n   preprocessVarExportAtIndex(index) {\n    let depth = 0;\n    // Handle cases like `export let {x} = y;`, starting at the open-brace in that case.\n    for (let i = index + 2; ; i++) {\n      if (\n        this.tokens.matches1AtIndex(i, _types.TokenType.braceL) ||\n        this.tokens.matches1AtIndex(i, _types.TokenType.dollarBraceL) ||\n        this.tokens.matches1AtIndex(i, _types.TokenType.bracketL)\n      ) {\n        depth++;\n      } else if (\n        this.tokens.matches1AtIndex(i, _types.TokenType.braceR) ||\n        this.tokens.matches1AtIndex(i, _types.TokenType.bracketR)\n      ) {\n        depth--;\n      } else if (depth === 0 && !this.tokens.matches1AtIndex(i, _types.TokenType.name)) {\n        break;\n      } else if (this.tokens.matches1AtIndex(1, _types.TokenType.eq)) {\n        const endIndex = this.tokens.currentToken().rhsEndIndex;\n        if (endIndex == null) {\n          throw new Error(\"Expected = token with an end index.\");\n        }\n        i = endIndex - 1;\n      } else {\n        const token = this.tokens.tokens[i];\n        if (_tokenizer.isDeclaration.call(void 0, token)) {\n          const exportName = this.tokens.identifierNameAtIndex(i);\n          this.identifierReplacements.set(exportName, `exports.${exportName}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Walk this export statement just in case it's an export...from statement.\n   * If it is, combine it into the import info for that path. Otherwise, just\n   * bail out; it'll be handled later.\n   */\n   preprocessNamedExportAtIndex(index) {\n    // export {\n    index += 2;\n    const {newIndex, namedImports} = this.getNamedImports(index);\n    index = newIndex;\n\n    if (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._from)) {\n      index++;\n    } else {\n      // Reinterpret \"a as b\" to be local/exported rather than imported/local.\n      for (const {importedName: localName, localName: exportedName} of namedImports) {\n        this.addExportBinding(localName, exportedName);\n      }\n      return;\n    }\n\n    if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {\n      throw new Error(\"Expected string token at the end of import statement.\");\n    }\n    const path = this.tokens.stringValueAtIndex(index);\n    const importInfo = this.getImportInfo(path);\n    importInfo.namedExports.push(...namedImports);\n  }\n\n   preprocessExportStarAtIndex(index) {\n    let exportedName = null;\n    if (this.tokens.matches3AtIndex(index, _types.TokenType._export, _types.TokenType.star, _types.TokenType._as)) {\n      // export * as\n      index += 3;\n      exportedName = this.tokens.identifierNameAtIndex(index);\n      // foo from\n      index += 2;\n    } else {\n      // export * from\n      index += 3;\n    }\n    if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {\n      throw new Error(\"Expected string token at the end of star export statement.\");\n    }\n    const path = this.tokens.stringValueAtIndex(index);\n    const importInfo = this.getImportInfo(path);\n    if (exportedName !== null) {\n      importInfo.exportStarNames.push(exportedName);\n    } else {\n      importInfo.hasStarExport = true;\n    }\n  }\n\n   getNamedImports(index) {\n    const namedImports = [];\n    while (true) {\n      if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {\n        index++;\n        break;\n      }\n\n      const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, this.tokens, index);\n      index = specifierInfo.endIndex;\n      if (!specifierInfo.isType) {\n        namedImports.push({\n          importedName: specifierInfo.leftName,\n          localName: specifierInfo.rightName,\n        });\n      }\n\n      if (this.tokens.matches2AtIndex(index, _types.TokenType.comma, _types.TokenType.braceR)) {\n        index += 2;\n        break;\n      } else if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {\n        index++;\n        break;\n      } else if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) {\n        index++;\n      } else {\n        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index])}`);\n      }\n    }\n    return {newIndex: index, namedImports};\n  }\n\n  /**\n   * Get a mutable import info object for this path, creating one if it doesn't\n   * exist yet.\n   */\n   getImportInfo(path) {\n    const existingInfo = this.importInfoByPath.get(path);\n    if (existingInfo) {\n      return existingInfo;\n    }\n    const newInfo = {\n      defaultNames: [],\n      wildcardNames: [],\n      namedImports: [],\n      namedExports: [],\n      hasBareImport: false,\n      exportStarNames: [],\n      hasStarExport: false,\n    };\n    this.importInfoByPath.set(path, newInfo);\n    return newInfo;\n  }\n\n   addExportBinding(localName, exportedName) {\n    if (!this.exportBindingsByLocalName.has(localName)) {\n      this.exportBindingsByLocalName.set(localName, []);\n    }\n    this.exportBindingsByLocalName.get(localName).push(exportedName);\n  }\n\n  /**\n   * Return the code to use for the import for this path, or the empty string if\n   * the code has already been \"claimed\" by a previous import.\n   */\n  claimImportCode(importPath) {\n    const result = this.importsToReplace.get(importPath);\n    this.importsToReplace.set(importPath, \"\");\n    return result || \"\";\n  }\n\n  getIdentifierReplacement(identifierName) {\n    return this.identifierReplacements.get(identifierName) || null;\n  }\n\n  /**\n   * Return a string like `exports.foo = exports.bar`.\n   */\n  resolveExportBinding(assignedName) {\n    const exportedNames = this.exportBindingsByLocalName.get(assignedName);\n    if (!exportedNames || exportedNames.length === 0) {\n      return null;\n    }\n    return exportedNames.map((exportedName) => `exports.${exportedName}`).join(\" = \");\n  }\n\n  /**\n   * Return all imported/exported names where we might be interested in whether usages of those\n   * names are shadowed.\n   */\n  getGlobalNames() {\n    return new Set([\n      ...this.identifierReplacements.keys(),\n      ...this.exportBindingsByLocalName.keys(),\n    ]);\n  }\n} exports.default = CJSImportProcessor;\n"]}}