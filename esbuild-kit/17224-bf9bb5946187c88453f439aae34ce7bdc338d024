{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});Object.defineProperty(exports,\"__esModule\",{value:true});var _tokenizer=require(\"./parser/tokenizer\");var _types=require(\"./parser/tokenizer/types\");function identifyShadowedGlobals(tokens,scopes,globalNames){if(!hasShadowedGlobals(tokens,globalNames)){return}markShadowedGlobals(tokens,scopes,globalNames)}__name(identifyShadowedGlobals,\"identifyShadowedGlobals\");exports.default=identifyShadowedGlobals;function hasShadowedGlobals(tokens,globalNames){for(const token of tokens.tokens){if(token.type===_types.TokenType.name&&_tokenizer.isNonTopLevelDeclaration.call(void 0,token)&&globalNames.has(tokens.identifierNameForToken(token))){return true}}return false}__name(hasShadowedGlobals,\"hasShadowedGlobals\");exports.hasShadowedGlobals=hasShadowedGlobals;function markShadowedGlobals(tokens,scopes,globalNames){const scopeStack=[];let scopeIndex=scopes.length-1;for(let i=tokens.tokens.length-1;;i--){while(scopeStack.length>0&&scopeStack[scopeStack.length-1].startTokenIndex===i+1){scopeStack.pop()}while(scopeIndex>=0&&scopes[scopeIndex].endTokenIndex===i+1){scopeStack.push(scopes[scopeIndex]);scopeIndex--}if(i<0){break}const token=tokens.tokens[i];const name=tokens.identifierNameForToken(token);if(scopeStack.length>1&&token.type===_types.TokenType.name&&globalNames.has(name)){if(_tokenizer.isBlockScopedDeclaration.call(void 0,token)){markShadowedForScope(scopeStack[scopeStack.length-1],tokens,name)}else if(_tokenizer.isFunctionScopedDeclaration.call(void 0,token)){let stackIndex=scopeStack.length-1;while(stackIndex>0&&!scopeStack[stackIndex].isFunctionScope){stackIndex--}if(stackIndex<0){throw new Error(\"Did not find parent function scope.\")}markShadowedForScope(scopeStack[stackIndex],tokens,name)}}}if(scopeStack.length>0){throw new Error(\"Expected empty scope stack after processing file.\")}}__name(markShadowedGlobals,\"markShadowedGlobals\");function markShadowedForScope(scope,tokens,name){for(let i=scope.startTokenIndex;i<scope.endTokenIndex;i++){const token=tokens.tokens[i];if((token.type===_types.TokenType.name||token.type===_types.TokenType.jsxName)&&tokens.identifierNameForToken(token)===name){token.shadowsGlobal=true}}}__name(markShadowedForScope,\"markShadowedForScope\");\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAa,OAAO,eAAe,QAAS,aAAc,CAAC,MAAO,IAAI,CAAC,EAIvE,IAAI,WAAa,QAAQ,oBAAoB,EAE7C,IAAI,OAAS,QAAQ,0BAA0B,EAO9C,SAAS,wBACR,OACA,OACA,YACA,CACA,GAAI,CAAC,mBAAmB,OAAQ,WAAW,EAAG,CAC5C,MACF,CACA,oBAAoB,OAAQ,OAAQ,WAAW,CACjD,CATU,0DASR,QAAQ,QAAU,wBAOnB,SAAS,mBAAmB,OAAQ,YAAa,CAChD,UAAW,SAAS,OAAO,OAAQ,CACjC,GACE,MAAM,OAAS,OAAO,UAAU,MAChC,WAAW,yBAAyB,KAAK,OAAQ,KAAK,GACtD,YAAY,IAAI,OAAO,uBAAuB,KAAK,CAAC,EACpD,CACA,MAAO,KACT,CACF,CACA,MAAO,MACT,CAXU,gDAWR,QAAQ,mBAAqB,mBAE/B,SAAS,oBACP,OACA,OACA,YACA,CACA,MAAM,WAAa,CAAC,EACpB,IAAI,WAAa,OAAO,OAAS,EAGjC,QAAS,EAAI,OAAO,OAAO,OAAS,GAAK,IAAK,CAC5C,MAAO,WAAW,OAAS,GAAK,WAAW,WAAW,OAAS,CAAC,EAAE,kBAAoB,EAAI,EAAG,CAC3F,WAAW,IAAI,CACjB,CACA,MAAO,YAAc,GAAK,OAAO,UAAU,EAAE,gBAAkB,EAAI,EAAG,CACpE,WAAW,KAAK,OAAO,UAAU,CAAC,EAClC,YACF,CAEA,GAAI,EAAI,EAAG,CACT,KACF,CAEA,MAAM,MAAQ,OAAO,OAAO,CAAC,EAC7B,MAAM,KAAO,OAAO,uBAAuB,KAAK,EAChD,GAAI,WAAW,OAAS,GAAK,MAAM,OAAS,OAAO,UAAU,MAAQ,YAAY,IAAI,IAAI,EAAG,CAC1F,GAAI,WAAW,yBAAyB,KAAK,OAAQ,KAAK,EAAG,CAC3D,qBAAqB,WAAW,WAAW,OAAS,CAAC,EAAG,OAAQ,IAAI,CACtE,SAAW,WAAW,4BAA4B,KAAK,OAAQ,KAAK,EAAG,CACrE,IAAI,WAAa,WAAW,OAAS,EACrC,MAAO,WAAa,GAAK,CAAC,WAAW,UAAU,EAAE,gBAAiB,CAChE,YACF,CACA,GAAI,WAAa,EAAG,CAClB,MAAM,IAAI,MAAM,qCAAqC,CACvD,CACA,qBAAqB,WAAW,UAAU,EAAG,OAAQ,IAAI,CAC3D,CACF,CACF,CACA,GAAI,WAAW,OAAS,EAAG,CACzB,MAAM,IAAI,MAAM,mDAAmD,CACrE,CACF,CA1CS,kDA4CT,SAAS,qBAAqB,MAAO,OAAQ,KAAM,CACjD,QAAS,EAAI,MAAM,gBAAiB,EAAI,MAAM,cAAe,IAAK,CAChE,MAAM,MAAQ,OAAO,OAAO,CAAC,EAC7B,IACG,MAAM,OAAS,OAAO,UAAU,MAAQ,MAAM,OAAS,OAAO,UAAU,UACzE,OAAO,uBAAuB,KAAK,IAAM,KACzC,CACA,MAAM,cAAgB,IACxB,CACF,CACF,CAVS","names":[],"sources":["/root/projects/zachw-i/packages/plugin/node_modules/.pnpm/sucrase@3.32.0/node_modules/sucrase/dist/identifyShadowedGlobals.js"],"sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});\n\n\n\nvar _tokenizer = require('./parser/tokenizer');\n\nvar _types = require('./parser/tokenizer/types');\n\n\n/**\n * Traverse the given tokens and modify them if necessary to indicate that some names shadow global\n * variables.\n */\n function identifyShadowedGlobals(\n  tokens,\n  scopes,\n  globalNames,\n) {\n  if (!hasShadowedGlobals(tokens, globalNames)) {\n    return;\n  }\n  markShadowedGlobals(tokens, scopes, globalNames);\n} exports.default = identifyShadowedGlobals;\n\n/**\n * We can do a fast up-front check to see if there are any declarations to global names. If not,\n * then there's no point in computing scope assignments.\n */\n// Exported for testing.\n function hasShadowedGlobals(tokens, globalNames) {\n  for (const token of tokens.tokens) {\n    if (\n      token.type === _types.TokenType.name &&\n      _tokenizer.isNonTopLevelDeclaration.call(void 0, token) &&\n      globalNames.has(tokens.identifierNameForToken(token))\n    ) {\n      return true;\n    }\n  }\n  return false;\n} exports.hasShadowedGlobals = hasShadowedGlobals;\n\nfunction markShadowedGlobals(\n  tokens,\n  scopes,\n  globalNames,\n) {\n  const scopeStack = [];\n  let scopeIndex = scopes.length - 1;\n  // Scopes were generated at completion time, so they're sorted by end index, so we can maintain a\n  // good stack by going backwards through them.\n  for (let i = tokens.tokens.length - 1; ; i--) {\n    while (scopeStack.length > 0 && scopeStack[scopeStack.length - 1].startTokenIndex === i + 1) {\n      scopeStack.pop();\n    }\n    while (scopeIndex >= 0 && scopes[scopeIndex].endTokenIndex === i + 1) {\n      scopeStack.push(scopes[scopeIndex]);\n      scopeIndex--;\n    }\n    // Process scopes after the last iteration so we can make sure we pop all of them.\n    if (i < 0) {\n      break;\n    }\n\n    const token = tokens.tokens[i];\n    const name = tokens.identifierNameForToken(token);\n    if (scopeStack.length > 1 && token.type === _types.TokenType.name && globalNames.has(name)) {\n      if (_tokenizer.isBlockScopedDeclaration.call(void 0, token)) {\n        markShadowedForScope(scopeStack[scopeStack.length - 1], tokens, name);\n      } else if (_tokenizer.isFunctionScopedDeclaration.call(void 0, token)) {\n        let stackIndex = scopeStack.length - 1;\n        while (stackIndex > 0 && !scopeStack[stackIndex].isFunctionScope) {\n          stackIndex--;\n        }\n        if (stackIndex < 0) {\n          throw new Error(\"Did not find parent function scope.\");\n        }\n        markShadowedForScope(scopeStack[stackIndex], tokens, name);\n      }\n    }\n  }\n  if (scopeStack.length > 0) {\n    throw new Error(\"Expected empty scope stack after processing file.\");\n  }\n}\n\nfunction markShadowedForScope(scope, tokens, name) {\n  for (let i = scope.startTokenIndex; i < scope.endTokenIndex; i++) {\n    const token = tokens.tokens[i];\n    if (\n      (token.type === _types.TokenType.name || token.type === _types.TokenType.jsxName) &&\n      tokens.identifierNameForToken(token) === name\n    ) {\n      token.shadowsGlobal = true;\n    }\n  }\n}\n"]}}